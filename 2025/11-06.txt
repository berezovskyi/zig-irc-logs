1762453439
grayhatter!~grayhatte@user/grayhatter
I'm just now realizing that std.Io.File doesn't have a Writer interface yet

1762457452
bblack!~bblack@wikimedia/bblack-WMF
grayhatter: yeah I got halfway done converting some fs.File -> Io.File before I realized that too.  (also Io.Dir doesn't do iteration yet)

1762457479
bblack!~bblack@wikimedia/bblack-WMF
it's just-baked-enough to start getting a feel for things, but there's plenty of TODO left :)

1762457827
grayhatter!~grayhatte@user/grayhatter
bblack: extract common into it's own function (so the inline code stays pretty) `.adaptFromNewApi()`

1762457871
grayhatter!~grayhatte@user/grayhatter
I would probably have waited longer if I realized there was a Reader, but no Writer... but I'm already in too deep now :D

1762457966
sjohnson!~sjohnson@user/sjohnson
Zig!

1762458606
braewoods!~braewoods@user/braewoods
Zag

1762462435
ledx_!~thomas@user/ledx
just playing around with std.net.Server here, and I get ".BADF => unreachable, // always a race condition" as soon as I try to write with a io.Writer. any advice is must welcome: https://hastebin.com/share/cojecivote.php

1762462492
ledx_!~thomas@user/ledx
it's a mess, but I just don't see/understand the problem. the commented out line using the deprecated method work

1762467353
squeek502!~squeek502@user/squeek502
ledx_, you are copying the interface field of the writer, don't do that: https://ziggit.dev/t/zig-0-15-1-reader-writer-dont-make-copies-of-fieldparentptr-based-interfaces/11719

1762470385
rvrb!~rvrb@156.146.51.228
is there anything wrong with taking an arbitrary slice ([]u32, whatever), and splitting it into two separately owned data structures, and deallocating them separately? the only reason I can think of this would be bad is if the allocators expect to store their own metadata before the pointer or something

1762470498
rvrb!~rvrb@156.146.51.228
the context for what I am thinking through is a 'compact' operation on type with an allocated buffer.. it would be nice if I did not need to allocate in the compaction, by using the saved space from compacting to store a report on what was compacted

1762470511
rvrb!~rvrb@156.146.51.228
then the report can deinit()

1762471535
rvrb!~rvrb@156.146.51.228
oh, I am thinking about this incorrectly and I think I found a way to approach it

1762471579
rvrb!~rvrb@156.146.51.228
but to answer my own question, I think yes, allocators expect to only receive pointers they have given out and to deallocate a pointer it did not allocate would be IB

1762473494
RavenJoad!~user@168.91.208.173
I am packaging ghostty for Guix right now and have hit some roadblocks. Ghostty is the first major zig packaging effort in Guix so far. I am worried about hitting an issue with pulling in dependencies. The build.zig.zon.json file specifies a few crazy paths for C/C++/asset dependencies. For example, zig fetch (and build?) expects imgui to be in $ZIG_GLOBAL_CACHE_DIR/p/N-V-__8AAH0GaQC8a52s6vfIxg88OZgFgEW6DFxfSK4lX_l3.

1762473548
RavenJoad!~user@168.91.208.173
My first concern is that path name. Is there any way to override that or make it more sensible?

