1763945095
grayhatter!~grayhatte@user/grayhatter
I can't concat a union similar to errors, right? It'd be really useful for labeled switch

1763971085
Travelan!~travelan@user/travelan
grayhatter, how would you expect that to work under the hood? The compiler would have to keep track of unions and their mathematical unions (unironically named the same). Including possible permutations and overlapping backing types. I'm not saying that it's impossible, it's far from, but it's a lot of bookkeeping for a concept that is questionable

1763971085
Travelan!~travelan@user/travelan
at best. What is the use case where this might be useful? Are Zig's unexhaustive enums possibly a solution to that problem?

1763996900
grayhatter!~grayhatte@user/grayhatter
Travelan: the same way I expect everything to work magic :P trolling aside I don't know why I wrote union there, I meant enum

1763997067
grayhatter!~grayhatte@user/grayhatter
I'd assume you could also do it for tagged unions, I can't imagine it would be a hard thing to implement given I could just copy and paste the source code to create said union

1763997597
grayhatter!~grayhatte@user/grayhatter
the reason I wanted it was for a parser where the valid tokens are a subset of different parser states

1763999010
p00f!ad2b9023b7@2a03:6000:1812:100::d93
grayhatter: thanks

1763999373
Travelan!~travelan@user/travelan
Or misuse error sets for this purpose. I think it might work. It's nasty, but probably works :P But I'd probably implement it as a tagged union indeed.

1764023934
rvrb!~rvrb@156.146.51.230
hi #zig. I've been messing with adding span/tracing support to std.log with support for std.Io. this would be my first Zig contribution. it's not currently tested, but I am hoping someone who knows things about multithreading can take a look and maybe tell me if I am completely off base on what I am trying here

1764023948
rvrb!~rvrb@156.146.51.230
https://github.com/tristanpemble/zig/commit/d55e95919d7070dc815c38f363f693fb1b42dd85

1764024054
rvrb!~rvrb@156.146.51.230
the general idea is a theadlocal span and a threadlocal context id. std.Io implementations manage context IDs, end users manage spans. spans form a linked list as they are created, and the Io implementations swap out the context/head span pointer

1764024146
rvrb!~rvrb@156.146.51.230
I wanted to try this as a library but I couldn't see any way to do it without implementing support directly in std.Io

1764024318
grayhatter!~grayhatte@user/grayhatter
rvrb: you could implement your own Io

1764024352
grayhatter!~grayhatte@user/grayhatter
Io.ThreadedTraceable

1764025384
rvrb!~rvrb@156.146.51.230
Well the hope was to support the built in Ios 

1764025447
rvrb!~rvrb@156.146.51.230
Tracking context switching is an implementation level detail afaict that a wrapper wouldn’t be able to do. You’re right I could POC it with a copy of them though

1764026373
grayhatter!~grayhatte@user/grayhatter
if I'm reading this correctly, this as is doesn't touch the public Io interface at all, it only alters Threaded? and Threaded is what provides Io, so why wouldn't a library provided Io work?

1764026698
rvrb!~rvrb@156.146.51.230
Space away from computer is giving me some perspective and I already have some things I want to improve here

