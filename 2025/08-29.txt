1756428862
smlavine!~smlavine@sourcehut/user/smlavine
Hello. What would be the best analogue for the Java StringBuilder class in Zig?

1756429116
squeek502!~squeek502@user/squeek502
smlavine, std.ArrayList(u8)

1756429343
andrewrk!~andrewrk@mail.ziglang.org
indeed, that or std.Io.Writer.Allocating

1756464593
chmod222!~chmod222@user/chmod222
Or you could try to be fancy and implement a rope structure

1756464606
chmod222!~chmod222@user/chmod222
(are people still doing ropes?)

1756464719
chmod222!~chmod222@user/chmod222
I think they've fallen off a bit in popularity since we learned about the horror that is cache misses, but I guess they're neat

1756464806
tranzystorekk!86175ff574@voidlinux/maintainer/tranzystorekk
i thought they were still a pretty good choice for text editors

1756492167
txdv!~txdv@cl-78-158-16-107.fastlink.lt
hello

1756492311
lemons!~doggie@user/doggie-:49517
hello

1756492449
andrewrk!~andrewrk@mail.ziglang.org
hello

1756500967
przmk!~przmk@user/przmk
hello

1756502601
rvrb!~rvrb@156.146.51.229
hello

1756502747
bblack!~bblack@wikimedia/bblack-WMF
hi :)

1756502762
rvrb!~rvrb@156.146.51.229
is my understanding of restricted function types correct? that, once implemented, any library author exposing a vtable like interface similar to Io can also benefit from de-virtualizing when there is only one implementation in use?

1756502828
bblack!~bblack@wikimedia/bblack-WMF
I've become confuzzled.  I thought I knew what was going on with "builtin.link_libc".  If I print its value at runtime, it correctly tells me "true" if I am in fact linking libc.  And thus I suspect posix.system == std.c and all that implies.

1756502859
ifreund!2940d10f8b@user/ifreund
rvrb: yes, it's all in zig "userland" and there's no special casing of the standard library interfaces in the compiler

1756502884
rvrb!~rvrb@156.146.51.229
neato

1756502894
bblack!~bblack@wikimedia/bblack-WMF
but I'm building on linux, and I guess during comptime, link_libc is false? it makes me question a lot of things, about how some of these conditionals like posix.use_libc really work...

1756502917
bblack!~bblack@wikimedia/bblack-WMF
does link_libc switch between false at comptime and true at runtime, when building a module that links libc?

1756502939
ifreund!2940d10f8b@user/ifreund
bblack: that doesn't make sense to me, how are you determining that it is false at comptime?

1756502941
bblack!~bblack@wikimedia/bblack-WMF
(and I guess, perhaps true at link time as well, or some other intermediate stage)

1756502973
bblack!~bblack@wikimedia/bblack-WMF
ifreund: I stuck @compileLog("use_libc in std.posix is ", use_libc); into posix.zig and re-ran my libc-linking build, and it says false.

1756502989
bblack!~bblack@wikimedia/bblack-WMF
but if I leave that off and print it at runtime, it's true

1756503037
ifreund!2940d10f8b@user/ifreund
bblack: are you sure that the compilation of the standard library which is hitting the @compileLog() is the compilation for building your program?

1756503040
andrewrk!~andrewrk@mail.ziglang.org
rvrb: devirt is a nice side benefit, but it's worth remembering the main motivation for restricted function pointers is to make stack upper bound size known, and enable stackless coroutines to be used in combination with function pointers

1756503051
ifreund!2940d10f8b@user/ifreund
and not e.g. the compilation of the standard library that is done for building your build.zig?

1756503062
bblack!~bblack@wikimedia/bblack-WMF
this all started because I was working on a patch to a std.posix function... and I had an argument to system.foo() that was of the correct type for std.c.foo(), but wrong type for std.os.linux.foo(), and I found it odd it was even looking there since I was linking libc

1756503104
bblack!~bblack@wikimedia/bblack-WMF
ifreund: oh good point about build.zig, hmmm

1756503129
jpk68!~jpk68@user/jpk68
Does anyone know when the 0.15 Arch Linux package might release

1756503145
jpk68!~jpk68@user/jpk68
I started in 0.14.1 so I'm not sure how long it usually takes

1756503150
ifreund!2940d10f8b@user/ifreund
jpk68: they are probably waiting for me to tag a river release lol

1756503159
rvrb!~rvrb@156.146.51.229
well I am exploring writing a graphics abstraction library, studying Mach's sysgpu, and they're doing comptime generic interfaces â€“ assume to avoid virtual dispatch. I was just thinking it would be nice to not have to deal with all that and do plain vtables and optimize it out if you're just targeting one backend

1756503161
triallax!~triallax@lacerte/triallax
this seems like a question to ask the package maintainer

1756503164
ifreund!2940d10f8b@user/ifreund
I should do that tomorrow morining when I'm not sleepy

1756503205
jpk68!~jpk68@user/jpk68
ifreund: Do you know if the ncdu package is the Zig one

1756503223
ifreund!2940d10f8b@user/ifreund
jpk68: no, I don't use arch. You could look at the version number?

1756503230
rvrb!~rvrb@156.146.51.229
come to think of it, I think what you said means that in that case the library can be used with stackless coroutines

1756503258
jpk68!~jpk68@user/jpk68
ifreund: thanks, didn't think of that

1756503292
ifreund!2940d10f8b@user/ifreund
:)

1756503301
ifreund!2940d10f8b@user/ifreund
goodnight all!

1756503366
bblack!~bblack@wikimedia/bblack-WMF
ah maybe this all makes sense now.  it's all build.zig confusion.  when I edit posix.zig and create a type error for the !link_libc case, it's going to bomb while re-building build.zig before it tries building my link_libc software, and I'm interpreting things wrong.

1756503382
rvrb!~rvrb@156.146.51.229
I would love to just `io.async(interface.requestAdapter, .{ &request })`

1756503402
bblack!~bblack@wikimedia/bblack-WMF
it just was jarring, to see a compiler type error about std.os.linux.foo() when I was patching posix.zig and rebuilding my libc-linking software.

1756503497
bblack!~bblack@wikimedia/bblack-WMF
the "Compile Build Script" part vanishes by the time I'm staring at the error :P

1756503727
bblack!~bblack@wikimedia/bblack-WMF
anyways, the whole "de-virtualizing when only one implementation is in use" thing caught my eye.  What does that mean? e.g. only one kind of Writer in the whole compilation unit across all the call sites? or just one kind at a given callsite?

1756504045
rvrb!~rvrb@156.146.51.229
when you are only using one Io implementation in your application, it would be de-virtualized, aka the virtual dispatch via the vtable is optimized away (as I understand it)

1756504067
rvrb!~rvrb@156.146.51.229
so I think, the compilation unit

1756504090
bblack!~bblack@wikimedia/bblack-WMF
ah I see

1756504092
rvrb!~rvrb@156.146.51.229
compiler would have no way of knowing which implementation is in use at a call site given that is runtime known

1756504158
bblack!~bblack@wikimedia/bblack-WMF
so if, for example, I had a multi-threaded app and chose to use io.async() in some thread and io.uringeventloop() or whatever in another, still virtualized.

1756504202
rvrb!~rvrb@156.146.51.229
see the "Optimality" header https://kristoff.it/blog/zig-new-async-io/

1756504383
andrewrk!~andrewrk@mail.ziglang.org
goodnight ifreund

1756504385
bblack!~bblack@wikimedia/bblack-WMF
yeah.  I guess I'm using bad examples, maybe it's all io.async(), but still somewhere there's a question of which asynchronizing implementation you're using (threadpool, coroutines, eventloop, whatever)

1756504473
bblack!~bblack@wikimedia/bblack-WMF
I should poke more at the WIP branch and get a better idea

1756504488
andrewrk!~andrewrk@mail.ziglang.org
it's very unlikely there will only be 1 kind of Writer in the whole compilation unit. already with hello world we have a file Writer for stdout, and probably an Allocating Writer somewhere in debug info parsing

1756504598
rvrb!~rvrb@156.146.51.229
but in the case of a GPU library - highly likely a Linux build only wants Vulkan, or a macOS only wants Metal, etc

1756504662
rvrb!~rvrb@156.146.51.229
I doubt virtual dispatch is anything but negligible amount of time there, but it's nice to know

1756505234
jpk68!~jpk68@user/jpk68
I'm trying to write a JIT compiler for an emulator, what would be the best way to detect CPU features/extensions for the machine it's running on?

1756505259
jpk68!~jpk68@user/jpk68
std.Target and std.Builtin (might have capitalized that incorrectly) seem to be similar but the documentation is a bit unclear

1756505596
rvrb!~rvrb@156.146.51.229
`std.Target` is a type, the current target is available on the "builtin" module: @import("builtin").target

1756505616
rvrb!~rvrb@156.146.51.229
I myself have wondered where I can see what is in that module

1756505649
jpk68!~jpk68@user/jpk68
Yeah, it's confusing

1756505665
rvrb!~rvrb@156.146.51.229
thanks to your question, I was bothered enough to figure it out; run `zig build-exe --show-builtin`

1756505709
jpk68!~jpk68@user/jpk68
So basically, the CPU's supported extensions would have to be determined at compile time and not runtime?

1756505770
jpk68!~jpk68@user/jpk68
Would there be some way to make it so that I can build binaries for each architecture/platform, but the software can still detect at runtime which assembly instructions to compile depending on the CPU features

1756505772
rvrb!~rvrb@156.146.51.229
oh; I misunderstood the question. I am certain you can do that, I don't know how

1756505792
bblack!~bblack@wikimedia/bblack-WMF
it might not be something that's ready-to-go in std, though.

1756505852
rvrb!~rvrb@156.146.51.229
I would guess if it's not directly available that you can use the OS APIs like std.posix or whatever

1756505855
bblack!~bblack@wikimedia/bblack-WMF
builtin.cpu is whatever target was compiled for

1756505893
jpk68!~jpk68@user/jpk68
I tried to use environment variables to determine the architecture at one point

1756505896
jpk68!~jpk68@user/jpk68
But that didn't work

1756505912
jpk68!~jpk68@user/jpk68
I'm on Linux; there was no environment variable for that (??)

1756505922
jpk68!~jpk68@user/jpk68
I could have easily messed something up though

1756505937
bblack!~bblack@wikimedia/bblack-WMF
if this is linux, you could try getting runtime CPU features from getauxval(AT_HWCAP)

1756505958
jpk68!~jpk68@user/jpk68
Thanks, I didn't know about that

1756506001
rvrb!~rvrb@156.146.51.229
https://ziglang.org/documentation/master/std/#std.os.linux

1756507787
JailBird!jailbird@user/jailbird
I'm sorry if this is a known issue. On FreeBSD/amd64, I have no problems with Zig 0.14.1, but when trying to use 0.15.1 (either self-compiled or the precompiled version), I keep getting: error: not an ELF file    note: while parsing /usr/lib/libc_nonshared.a

1756508253
torque!~tachyon@user/torque
the error is correct in that static libraries are not usually elf files

1756508327
JailBird!jailbird@user/jailbird
Yes, I understand that. I just don't understand WHY it's trying to load it as an ELF

1756508373
torque!~tachyon@user/torque
yeah, sorry for the useless response. I thought I recalled seeing something similar on the issue tracker but I am not finding it right now so I may have been misremembering

1756508388
JailBird!jailbird@user/jailbird
just using the simple index.zig from the home page:

1756508389
JailBird!jailbird@user/jailbird
$ zig test index.zig

1756508389
JailBird!jailbird@user/jailbird
error: not an ELF file

1756508389
JailBird!jailbird@user/jailbird
    note: while parsing /usr/lib/libc_nonshared.a

1756508398
JailBird!jailbird@user/jailbird
gotcha, thanks

1756508425
andrewrk!~andrewrk@mail.ziglang.org
JailBird: sorry for the regression. would you mind opening an issue? I suspect alexrp will be interested to take a peek 

1756508439
JailBird!jailbird@user/jailbird
Yes, sir! I just didn't want to open a dupe if it was already known about :)

1756508442
torque!~tachyon@user/torque
this might be a self-hosted x86 backend thing?

1756508451
torque!~tachyon@user/torque
does it work if you do -fllvm -flld?

1756508452
andrewrk!~andrewrk@mail.ziglang.org
well it might be, try searching first pretty please :)

1756508607
JailBird!jailbird@user/jailbird
torque: sure enough, it seems to work

1756508617
JailBird!jailbird@user/jailbird
is there a way to specify that in a build.zig?

1756508883
torque!~tachyon@user/torque
I believe it's `.use_llvm = true` or something similar

1756508920
JailBird!jailbird@user/jailbird
awesome, thanks, I'll figure it out from there (and look for an issue and/or open one)

1756508937
JailBird!jailbird@user/jailbird
yay for crosscompiling for now!

1756508963
torque!~tachyon@user/torque
https://ziglang.org/documentation/master/std/#std.Build.LibraryOptions

