1760288452
grayhatter!~grayhatte@user/grayhatter
would you accept a PR to rename Thread.sleep into Thread.yield?

1760288538
grayhatter!~grayhatte@user/grayhatter
I assume it was just moved from std.time into std.Thread, because arguably it does fit there better, but the semantics of sleep and yield are different

1760288591
grayhatter!~grayhatte@user/grayhatter
I'd also like to change the resolution because ns don't make sense in the context of "system threads"

1760289006
rockorager!~rockorage@2600:3c06::f03c:94ff:fea6:1f08
sleep makes more sense to me

1760289025
rockorager!~rockorage@2600:3c06::f03c:94ff:fea6:1f08
yield(1_000) means....yield the thread for 1 second?

1760289059
grayhatter!~grayhatte@user/grayhatter
if I just renamed it, yield(1_000) would be sleep for 1 microsecond

1760289096
grayhatter!~grayhatte@user/grayhatter
if I renamed it, and changed the resolution, yield(1_000) would be yield for 1 millisecond

1760289149
grayhatter!~grayhatte@user/grayhatter
rockorager: `sleep(0)` makes no sense, `yield(0)` does

1760289173
grayhatter!~grayhatte@user/grayhatter
I would expect sleep(0) to be a nop, but I would be angry if yield(0) was a nop

1760289173
rockorager!~rockorage@2600:3c06::f03c:94ff:fea6:1f08
units aside, "yield for <time>" makes less sense than "sleep for <time>"

1760289185
rockorager!~rockorage@2600:3c06::f03c:94ff:fea6:1f08
I would expect sleep(0) to be effectively a yield

1760289224
grayhatter!~grayhatte@user/grayhatter
I know, but that's how it's "always" implemented

1760289311
grayhatter!~grayhatte@user/grayhatter
names mean things, and (to me) it's a lot more obvious that yield([time]) might return before time has elapsed, but (to me) it's unexpected that sleep would return before [time]

1760289455
grayhatter!~grayhatte@user/grayhatter
IMO, e.g. it's reasonable for a program to sleep for 10 seconds, but trying to "sleep" a thread is a less specific, and less valuable abstraction than telling a thread to yield, and giving the hint about how long the yield should take place.

1760289672
grayhatter!~grayhatte@user/grayhatter
are semantics of build.zig.zon fingerprint documented anywhere?

1760291317
bwbuhse!~The_Buhs@user/The-Buhs/x-5080862
KK

1760291323
bwbuhse!~The_Buhs@user/The-Buhs/x-5080862
oops

1760291333
bwbuhse!~The_Buhs@user/The-Buhs/x-5080862
KKKKK

1760306620
longlonglongint!~longlongl@user/longlonglongint
if i have a function that takes a type and returns that type initialized with arbitrary bytes

1760306642
longlonglongint!~longlongl@user/longlonglongint
is it "proper" zig to pass an array type to that

1760306672
longlonglongint!~longlongl@user/longlonglongint
and if so is it "proper" zig to do writer.writeAll(&f([n]u8))

1760306687
longlonglongint!~longlongl@user/longlonglongint
seems to run fine but i dont know if its discouraged or not

1760312294
rockorager!~rockorage@2600:3c06::f03c:94ff:fea6:1f08
You mean the function modifies the array and returns it?

1760313249
longlonglongint!~longlongl@user/longlonglongint
no

1760313273
longlonglongint!~longlongl@user/longlonglongint
the function returns T initializes with random bytes and takes T: type as a parameter

1760313383
longlonglongint!~longlongl@user/longlonglongint
initialized*

