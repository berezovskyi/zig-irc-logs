1765153875
tranzystorekk!86175ff574@voidlinux/maintainer/tranzystorekk
its also a workaround for zig giving you trouble if you named a method and a field the same like snake_case langs do

1765172489
akiva!~Akiva@user/Akiva
I find myself in this awkward position of looking for work and really wanting to pivot to something involving Zig but coming from Web-based software engineering, there isn't much overlap.

1765173582
andrewrk!~andrewrk@mail.ziglang.org
akiva: it's tough, whatever you have in your resume, that's what people will want you to keep doing

1765173595
andrewrk!~andrewrk@mail.ziglang.org
if it makes you feel any better, I was stuck in a web development career trap before creating zig

1765174074
torque!~tachyon@user/torque
if you have some time to learn or become literate in non-web software engineering (which is broad and usually would have a more focused goal) if you aren't already, in my experience one of the key things in interviews is just being able to know what you're talking about (or at least sound like it)

1765174133
torque!~tachyon@user/torque
though zig, being "alpha" software is probably not going to see much use at all outside of startups who are willing to take big tooling risks

1765174149
torque!~tachyon@user/torque
i suppose instead of "alpha" I should say pre-1.0

1765174268
torque!~tachyon@user/torque
my current job is writing C++ (unfortunately) which I got despite never really having written C++ before (though I have a non-web background)

1765174448
torque!~tachyon@user/torque
anyway, I guess my point is, if you have the luxury of time between jobs, it may make sense for you to brush up on your skills and apply for the type of job you want to have, even if you're not completely confident

1765175838
akiva!~Akiva@user/Akiva
andrewrk: Exactly. It's like you seal your own fate. 

1765175859
akiva!~Akiva@user/Akiva
torque: Thanks, I appreciate the input and this is very much where my thoughts are on the matter. 

1765175941
akiva!~Akiva@user/Akiva
andrewrk: Ironically, I had been in the Ruby world from around 2009-2011, only to get out and decide to go full-stack JS for a few years (I know) and then ended up back in RoR land. However, the last several years were very generalist and also used Python, Go, etc.

1765193581
bw!sid2730@user/betawaffle
torque: I mean the way zig is doing camelCase is the most correct (anything else is ambiguous), itâ€™s just visually annoying to my brain, and I want to change that

1765194068
bw!sid2730@user/betawaffle
Completely unrelated: I wish there was tooling out there that could take an object file, and validate call signatures against the behavior of the native code, like to ensure that your extern declarations are correct. Like obviously there are testing techniques that could identify those issues, but I feel like it should be possible. But maybe itâ€™s just really impractical

1765194255
ifreund!2940d10f8b@user/ifreund
bw: an object file doesn't necessarily contain enough information to perform that validation afaik

1765194285
ifreund!2940d10f8b@user/ifreund
dwarf debug info for example should be sufficient for most cases though I believe

1765194289
ifreund!2940d10f8b@user/ifreund
and such tools do exist

1765194298
bw!sid2730@user/betawaffle
I mean the tool would have to understand the assembly

1765194360
bw!sid2730@user/betawaffle
I guess specifically what I mean is validating a call signature against the assembly code that gets jumped to

1765194383
bw!sid2730@user/betawaffle
Which is probably a halting problem issue in general

1765194392
ifreund!2940d10f8b@user/ifreund
I don't think "understand the assembly" is a thing that can be done without extra info about how the assembly corresponds to the source code

1765194395
bw!sid2730@user/betawaffle
But probably not in the common case

1765194399
ifreund!2940d10f8b@user/ifreund
which is exactly what debug info is

1765194431
bw!sid2730@user/betawaffle
ifreund: humans can look at assembly and figure out what it does

1765194560
bw!sid2730@user/betawaffle
It should be possible to figure out what registers and stack locations are read and written

1765194656
bw!sid2730@user/betawaffle
And then given a call signature, you ask â€œdoes the assembly read or write anything it shouldnâ€™t

1765194808
bw!sid2730@user/betawaffle
Likeâ€¦ you can declare a function with one signature, link it just fine to a library, and then when you call it, the implementation could be completely different

1765194955
bw!sid2730@user/betawaffle
AFAIK thereâ€™s no good way to catch that in general, even with tests you probably just have to hope you get a segfault or misbehavior

1765195037
bw!sid2730@user/betawaffle
That makes it really scary to write manual library bindings, imo

1765195078
bw!sid2730@user/betawaffle
Or even to modify generated ones, since you might typo something

1765195094
ifreund!2940d10f8b@user/ifreund
indeed, the question is how do you obtain the "correct" ABI to compare your code to?

1765195113
ifreund!2940d10f8b@user/ifreund
my claim is that the dwarf info in the shared library you are linking has the info you need

1765195134
bw!sid2730@user/betawaffle
Well the abi is essentially baked into the behavior of the assembled machine code

1765195138
ifreund!2940d10f8b@user/ifreund
otherwise your tool has to understand the header files of all languages that can produce a C ABI shared library

1765195144
bw!sid2730@user/betawaffle
And yeah dwarf would, if you have it

1765195186
bw!sid2730@user/betawaffle
Right Iâ€™m saying donâ€™t use the header files to validate, as technically even those could be subtly wrong

1765195190
ifreund!2940d10f8b@user/ifreund
Related: https://abi-laboratory.pro/index.php?view=open-source

1765195258
bw!sid2730@user/betawaffle
Yeah thatâ€™s basically what I want

1765195439
bw!sid2730@user/betawaffle
I guess what I want is like: take this assembly, and produce a report of what assumptions it makes

1765195523
bw!sid2730@user/betawaffle
And then to be able too compare those assumptions against a call signature (which may not even be able to express all of those assumptions in most languages)

1765195538
bw!sid2730@user/betawaffle
to*

1765195607
bw!sid2730@user/betawaffle
Stuff like sentinel terminators is a good example of something that would be really hard to extract from assembly

1765195676
bw!sid2730@user/betawaffle
This is like what someoneâ€™s PHD thesis should be on probably

1765195732
ifreund!2940d10f8b@user/ifreund
this is the relevant zig issue by the way: https://github.com/ziglang/zig/issues/20654

1765195934
bw!sid2730@user/betawaffle
Yeah exactly

1765196016
bw!sid2730@user/betawaffle
But even C could have this problem if youâ€™re using a pre-existing object (e.g. a shared library) and you have the wrong header file

1765196070
bw!sid2730@user/betawaffle
I just find it kinda wild that this isnâ€™t a solved problem in computer science

1765196108
bw!sid2730@user/betawaffle
Itâ€™s like duct taped

1765196192
ifreund!2940d10f8b@user/ifreund
kinda crazy right?

1765196243
ifreund!2940d10f8b@user/ifreund
I mean the ideal would be linkers understanding enough about the shared objects being linked to give a hard error on abi incompatibility

1765196265
ifreund!2940d10f8b@user/ifreund
but linkers don't have sufficient information to do that because that's how we've always done things

1765197395
clevor!sid649024@id-649024.hampstead.irccloud.com
https://github.com/ziglang/zig/issues/26033 can be closed as it was just a bug in my program itself ðŸ¤¦

1765197643
cephei8!b8652603d7@user/cephei8
is linking to libc required to have threads working on linux? I read somewhere that it's not required, but my multithreading code didn't work without libc. I wonder if I do something wrong, or there a known limitation/issue

1765198184
bw!sid2730@user/betawaffle
I really like the new Io.Reader design. Why does zig keep doing such a great job?

1765205407
gastus_!~gastus@185.6.123.221
I want to debug nvidia and openxr. While khronos says there should be dubgging/logging layers when I tried using them they didn't work. So I want to use zig to read the C types and and pass some functions and return a new version which logs the results and argumenst. Some arguments are linked lists. So comptime should be able to achieve this easily eg expose new debuggivg versions of the 50 - 100 functions I 

1765205413
gastus_!~gastus@185.6.123.221
care ? Has somebody already done something similar ?

1765229944
clevor!sid649024@id-649024.hampstead.irccloud.com
Either I've found a perfect repro for std.Io.Queue deadlocking with std.Io.Threaded that I can't seem to fix, or there is some UB in my program making it deadlock somehow.

1765230972
andrewrk!~andrewrk@mail.ziglang.org
clevor: did you see this related issue? https://codeberg.org/ziglang/zig/issues/30141

1765232587
clevor!sid649024@id-649024.hampstead.irccloud.com
Oh, it's that.

1765236783
gastus!~gastus@185.6.123.221
I have a hard time finding information about how to use comptime to generate functions and configure eg arguments and return types. What guide should I read ? My goal is to wrap OpenXR/Vulkan functions log the parameters and call the original functions

1765236846
andrewrk!~andrewrk@mail.ziglang.org
gastus: I'm not aware of a guide that exactly fits that description. If you have any questions about the official language reference (or the language in general) I'm happy to help

1765237046
gastus!~gastus@185.6.123.221
I want a function wrap(XrInit)(arg1, arg2) where wrap actually logs "XrInit" the logs arg1, arg2 then calls the original XrInit same for 20-50 functions. Cause C++ works but Rust code doesn't So I want to log the parameter and diff then find out why it fails.

1765237112
gastus!~gastus@185.6.123.221
So the idea is to create a shared library and expose DebugXInti = wrap ( ..) and then uset he DEbug versions. Now its very hard for me to understand how to make wrap create a function doing the logging. I am struggling with finding information about how to make comptime code build arguments of the function to be returned for example.

1765237233
gastus!~gastus@185.6.123.221
Something like return struct { fn call ( $$[ [arg, type] for arg, type in fun.params ] )  where $$[..] is python like syntax and fun is the type of the function passed as comp arg at compile time.

1765237247
andrewrk!~andrewrk@mail.ziglang.org
have a look at @typeInfo and @call

1765237276
gastus!~gastus@185.6.123.221
That's how I can query the data. I know about @log @err something I found that information with .Fn @"Fn" whatever depending on zig version.

1765237449
gastus!~gastus@185.6.123.221
Other macro like systems Haskell/HAxe wahtever have abstract syntax trees. So you can just assemble that and be done. Like Fun("name", [ ["arg1", "int"], ["arg2", "int"]], "ret-type") and that's it.

1765237732
andrewrk!~andrewrk@mail.ziglang.org
well that's not how it works in zig

1765237772
andrewrk!~andrewrk@mail.ziglang.org
it's based on partial execution

1765237833
gastus!~gastus@185.6.123.221
WEll or full execution. THe examples show comptime fib() examples telling after comptime code is run at compilation time.

1765237846
gastus!~gastus@185.6.123.221
So the only thing which is missing is run code .. return AST .. inject then compile.

1765237850
gastus!~gastus@185.6.123.221
Like all the others do. :-)

1765237874
andrewrk!~andrewrk@mail.ziglang.org
it's not missing, it's intentionally omitted

1765237876
gastus!~gastus@185.6.123.221
So if it works differently it kinda means I have to generate text and compile that. So Zig at least can tranverse the types easily.

1765237888
andrewrk!~andrewrk@mail.ziglang.org
you don't have to generate text

1765237904
andrewrk!~andrewrk@mail.ziglang.org
learn a new skill, it's fun

