1755044617
torque!~tachyon@user/torque
 <AmandaC> Hrm. with std.json can I specify in my struct that it's okay if a field is missing? Making it nullable doesn't seem to have worked for that

1755044626
torque!~tachyon@user/torque
you can do this by setting a default value on the field

1755044643
torque!~tachyon@user/torque
so `myfield: ?T = null,` should work

1755044706
torque!~tachyon@user/torque
you can see this here: https://github.com/ziglang/zig/blob/master/lib/std/json/static.zig#L384. `fillDefaultStructValues` is what actually returns the missing field error

1755044784
AmandaC!~m-yt727s@cloud.camnet.site
ahhh

1755044856
AmandaC!~m-yt727s@cloud.camnet.site
Danke, Will do some refactoring tomorrow around my code then

1755045959
AmandaC!~m-yt727s@cloud.camnet.site
Actually can you detect if a variable is "undefined"? Cause if so that'll make this much easier. This is what creates the struct I'm deserializing into: https://git.camnet.site/amandac/oc2-zig-fuckery/src/branch/main/src/lib/hlapi.zig#L59

1755045999
AmandaC!~m-yt727s@cloud.camnet.site
Or is by chance an undefined ?T null

1755059939
torque!~tachyon@user/torque
no

1755059955
torque!~tachyon@user/torque
undefined is not a detectable bit pattern. if you need to know if a value is set or not, use an optional

1755075545
dutchie!~dutchie@user/dutchie
or another flag somewhere else

1755076652
tsujp!497e1f7b6a@sourcehut/user/tsujp
bblack: emacs is nice, used neovim, vscode, sublime text, helix, IDEs by jetbrains and while it has it‘s quriks (as they all do) I‘ve found emacs for me to be the best 

1755076717
hadronized!~hadronize@2001:41d0:a:fe76::1
I would probably be on emacs if it was as good at editing text as Kakoune is

1755076740
hadronized!~hadronize@2001:41d0:a:fe76::1
on the other side, I love the orthogonality of Kakoune, and even though I think the terminal is a tool of the past, it has stood the test of time

1755076745
hadronized!~hadronize@2001:41d0:a:fe76::1
(so does emacs, btw)

1755076753
hadronized!~hadronize@2001:41d0:a:fe76::1
s/does/has

1755076776
hadronized!~hadronize@2001:41d0:a:fe76::1
probably offtopic though :|

1755077346
flower_!~archie@83-81-123-193.cable.dynamic.v4.ziggo.nl
sorry to ask, but for when is the release of 0.15 planned? 

1755077410
flower_!~archie@83-81-123-193.cable.dynamic.v4.ziggo.nl
There are so many changes in the pipeline, that I might wait until 0.15 for further work

1755077436
hadronized!~hadronize@2001:41d0:a:fe76::1
https://github.com/ziglang/zig/milestone/28

1755077454
hadronized!~hadronize@2001:41d0:a:fe76::1
the due date disappeared, no? :D

1755077464
hadronized!~hadronize@2001:41d0:a:fe76::1
I think it was due on the 12th last time I checked

1755077468
tranzystorekk!86175ff574@voidlinux/maintainer/tranzystorekk
"planned" is such a big word

1755077502
flower_!~archie@83-81-123-193.cable.dynamic.v4.ziggo.nl
90% done, ok

1755077622
tranzystorekk!86175ff574@voidlinux/maintainer/tranzystorekk
id hazard to say that date was there just as a placeholder or simply someone forgot to delete it

1755077662
flower_!~archie@83-81-123-193.cable.dynamic.v4.ziggo.nl
given the amount of changes, it's reasonable to expect the release will be prosponed a few times maybe

1755077737
hadronized!~hadronize@2001:41d0:a:fe76::1
I’m waiting for the IO interface thing to land to start actually using Zig for more than experimenting

1755077760
flower_!~archie@83-81-123-193.cable.dynamic.v4.ziggo.nl
planning fallacy

1755077772
flower_!~archie@83-81-123-193.cable.dynamic.v4.ziggo.nl
IO interface is planned for 0.15 right?

1755077776
flower_!~archie@83-81-123-193.cable.dynamic.v4.ziggo.nl
or at least partly

1755077784
flower_!~archie@83-81-123-193.cable.dynamic.v4.ziggo.nl
same here

1755077851
hadronized!~hadronize@2001:41d0:a:fe76::1
flower_: I thought it was not?

1755078202
flower_!~archie@83-81-123-193.cable.dynamic.v4.ziggo.nl
"This is part of a series of changes leading up to "I/O as an Interface" and Async/Await Resurrection. However, this branch does not do any of that"

1755078210
flower_!~archie@83-81-123-193.cable.dynamic.v4.ziggo.nl
https://github.com/ziglang/zig/pull/24329

1755082043
hadronized!~hadronize@2001:41d0:a:fe76::1
is there a way for zig init to use a template or put less stuff in the project?

1755082056
hadronized!~hadronize@2001:41d0:a:fe76::1
I usually have to strip down the content of the build.zig by a huge margin

1755083839
bblack!~bblack@wikimedia/bblack-WMF
re the planning fallacy and waiting for 0.15: I've been developing against master branch and pulling new changes ~1-2x a week while working on a new project.  I think it's actually easier this way.  When things get broken, you can easily find an immediate cause in recent commit history and dig into how to adapt, and there haven't been all that many of them.

1755083862
bblack!~bblack@wikimedia/bblack-WMF
I'd feel differently if I was working on released software, or even had an imminent release plan of my own :)

1755086099
flower_!~archie@83-81-123-193.cable.dynamic.v4.ziggo.nl
bblack: it might be even a learning experience to fix breaking changes

1755096375
kassiopeia!~kassiopei@user/Kassiopeia
hey guys, how do you debug your Zig programs? I know of LLDB but i couldnt get that to work, maybe someone has a good article or tutorial on that? In most posts i found they were using a visual studio extension

1755096728
bblack!~bblack@wikimedia/bblack-WMF
kassiopeia: one of the gotchas on lldb last I checked, is if you want to be able to dig into printing values and such, you need to build with llvm/lld, and currently the default .Debug builds use the native compiler rather than llvm.

1755096735
dutchie!~dutchie@user/dutchie
if it comes down to it, gdb

1755096796
dutchie!~dutchie@user/dutchie
there are some tools in the zig repo to pretty-print things: https://github.com/ziglang/zig/blob/master/tools/std_gdb_pretty_printers.py

1755097672
kassiopeia!~kassiopei@user/Kassiopeia
dutchie i understand, but the workflow to debug a zig program with gdb is the same as with a program written in C for example? i dont know GDB either, but i think its easier to learn because there more resources available to learn it

1755097710
kassiopeia!~kassiopei@user/Kassiopeia
and yes i could use print statements to debug, but i want to learn how debug the "proper" way, and also look a little deeper into how the program works

1755098389
dutchie!~dutchie@user/dutchie
yeah, it's much the same as debugging a C program

1755098404
dutchie!~dutchie@user/dutchie
set breakpoints, print expressions, step through code

1755098435
dutchie!~dutchie@user/dutchie
sometimes you have to work a little bit to figure out what your functions ended up being called if they are inside structs etc 

1755103852
tsujp!497e1f7b6a@sourcehut/user/tsujp
should one use std.testing.allocator in tests always? Perhaps even as the backing allocator for DebugAllocator?

1755105965
aktina!94c41af484@user/voidskull
i wish to learn zig, but i haven't learnt any programming languages (i have tried to learn c, but i always give up halfway, and i don't learn a cs degree as i am from another stream, what should i do

1755105969
aktina!94c41af484@user/voidskull
)

1755106047
aktina!94c41af484@user/voidskull
when i looked at zig website for tutorial, they had told that it would be better if i had already known some other oop language, and i don't know which resource to actually use to learn which programming language, i would like to have guidance of any kind

1755106056
aktina!94c41af484@user/voidskull
thanks in advance

1755118864
squeek502!~squeek502@user/squeek502
tsujp, testing.allocator is an instance of DebugAllocator

1755127425
rvrb!~rvrb@156.146.51.228
a while back I wanted to write a recursive descent parser using generator functions, so since Zig doesn't have them, I did a hand-written, unrolled state machine. I guess it might be called a pushdown automaton? I don't know, but it was a stack of state machines, and the idea was to be able to `for (parser.next()) |event|` to parse with zero

1755127425
rvrb!~rvrb@156.146.51.228
allocations and spit out events (start_node, add_token, finish_node) that can be used to assemble a concrete syntax tree

1755127459
rvrb!~rvrb@156.146.51.228
it worked, but it was a lot, and obviously lost the readability of a hand written recursive descent pratt parser

1755127559
rvrb!~rvrb@156.146.51.228
the main thing was that you have to manage the stack yourself. which sucks, you can set a reasonable upper bound but it still is dumb. I have learned a lot since then. I am wondering if such a thing can be achieved but leaning on the compiler to determine the stack size by using maybe a continuation passing style comptime function pointers and

1755127559
rvrb!~rvrb@156.146.51.228
@call?

1755127684
rvrb!~rvrb@156.146.51.228
the goal being a streaming, zero allocation parser; the original approach using a generator-function style

1755128188
andrewrk!~andrewrk@mail.ziglang.org
rvrb: are you trying to use tail calls for this?

1755128277
rvrb!~rvrb@156.146.51.228
yeah, I think so

1755128331
andrewrk!~andrewrk@mail.ziglang.org
it works, but be warned that tail calls are slightly less portable than not using them

1755128349
andrewrk!~andrewrk@mail.ziglang.org
unfortunately for reusable code you kind of have to treat tail calls as only an optimization

1755128358
rvrb!~rvrb@156.146.51.228
I am thinking about a comment I saw you make a while back, that I am probably misinterpreting, about disallowing recursive function calls, and forcing use of @call(.always_tail)

1755128366
rvrb!~rvrb@156.146.51.228
or something along those lines

1755128404
rvrb!~rvrb@156.146.51.228
I believe related to the IO work

1755128558
andrewrk!~andrewrk@mail.ziglang.org
tail calls are one possible way to lower stackless coroutines

1755128558
rvrb!~rvrb@156.146.51.228
nevermind, I think it was this https://news.ycombinator.com/item?id=44697787

