1755734482
ovf!sid19068@id-19068.hampstead.irccloud.com
s/right not/right now/

1755734925
andrewrk!~andrewrk@mail.ziglang.org
ovf: https://ziglang.org/download/#release-0.15.1

1755735117
ovf!sid19068@id-19068.hampstead.irccloud.com
andrewrk: sure, but that's only latest for now. :-) i meant a permalink to whichever is the latest release (i.e. an additional anchor right after the 'master' section). perhaps that'd make more sense after 1.0.0? 

1755736731
andrewrk!~andrewrk@mail.ziglang.org
I see

1755737036
rvrb!~rvrb@156.146.51.229
when writing a Reader that wraps another one, it feels wrong to do anything with the wrapped Reader's buffer. am I right about that?

1755737081
rvrb!~rvrb@156.146.51.229
follow up if I am right about that: if the Reader I am writing requires its own buffer, does that mean the user needs to basically make two?

1755737167
andrewrk!~andrewrk@mail.ziglang.org
rvrb: the "user" owns the `seek` position, the stream implementation owns the `end` position

1755737219
andrewrk!~andrewrk@mail.ziglang.org
a key design consideration is that no stream implementation should require additional internal buffering

1755737232
andrewrk!~andrewrk@mail.ziglang.org
it should be able to either keep data buffered on one side, or the other

1755738161
rvrb!~rvrb@156.146.51.229
I think I might be starting to understand. generalizing, the wrapper Reader I am writing needs N bytes kept around after reading. so I think the wrapper's seek is always ahead of the inner's seek, and the wrapper manages the inner ensuring those bytes are always available (I think with functions like fill)

1755738180
rvrb!~rvrb@156.146.51.229
and I would assert the buffer is sized appropriately

1755739218
andrewrk!~andrewrk@mail.ziglang.org
yeah you can either assert and document that assertion or make the buffer decide runtime limitations and return an error

1755746460
grayhatter!~grayhatte@user/grayhatter
chmod222: I was more upset about that when I first heard of it, then I started writing my mix code differently expecting it. And, subjectively, I feel like it results in better code. There's very little you can't do by passing a type to a function const Thing = makeNewFn(@This()); \n pub const newFunction = thing.newFunction; is a superior pattern (IMO; (because less magic))

1755746589
grayhatter!~grayhatte@user/grayhatter
I **am** sad about BoundedArray... I'm pretty sure I'll eventually agree that less is ~~more~~ better, e.g. ArrayList -> ArrayListManaged (eventually) but... I liked all my toys, and *someone* keeps taking away the ones' I'm currently using

1755746591
grayhatter!~grayhatte@user/grayhatter
:P

1755746635
grayhatter!~grayhatte@user/grayhatter
that would hurt less if ArrayListUnmanaged was renamed as well (because I care about line length way too much)

1755755167
andrewrk!~andrewrk@mail.ziglang.org
grayhatter: it was

1755755184
andrewrk!~andrewrk@mail.ziglang.org
it's std.ArrayList now

1755755252
LAC-Tech!~lewis@granite-phrase.bnr.la
I had been doing const ArrayList = std.ArrayListUnamanged; in anticipation of this. they laughed me. who's laughing now?

1755755383
neothechosen!~neothecho@user/neothechosen
Could someone please clarify the usage of

1755755383
neothechosen!~neothecho@user/neothechosen
`const SomeName = @This();`

1755755383
neothechosen!~neothecho@user/neothechosen
in the outermost scope (e. g. https://github.com/ghostty-org/ghostty/blob/main/pkg%2Fopengl%2FVertexArray.zig#L1)?

1755755383
neothechosen!~neothecho@user/neothechosen
As reference page says, `This()` returns type of the innermost struct which it is being called from and that's completely fine. But what does this expression mean when not called from some anonymous struct or any struct at all? Is every Zig module being implicitly registered as some kind of struct?

1755755408
grayhatter!~grayhatte@user/grayhatter
andrewrk: huh, I looked for that in patch notes but didn't see it, was it omitted, or am I just completely blind?

1755755449
grayhatter!~grayhatte@user/grayhatter
I am completely blind... I only looked in the list of deletions/deprecations

1755755487
grayhatter!~grayhatte@user/grayhatter
that was an easy one for me to miss because the boundedarray example uses the older name 

1755755598
andrewrk!~andrewrk@mail.ziglang.org
neothechosen: https://ziglang.org/documentation/0.15.1/#Source-File-Structs

1755755651
grayhatter!~grayhatte@user/grayhatter
neothechosen: yes-ish, almost everything in Zig is a container 

1755755738
agent314!~agent314@static-68-235-46-217.cust.tzulo.com
i appreciate that zig has a build system that's also programmable in zig

1755755760
neothechosen!~neothecho@user/neothechosen
andrewrk: for some reason reference page is down for me, will check it out later, but thanks nevertheless

1755755785
grayhatter!~grayhatte@user/grayhatter
huh, that's strange... the link worked for me

1755755824
agent314!~agent314@static-68-235-46-217.cust.tzulo.com
works for me too

1755755852
agent314!~agent314@static-68-235-46-217.cust.tzulo.com
change to a different vpn server neothechosen ?

1755756016
agent314!~agent314@static-68-235-46-217.cust.tzulo.com
or run "zig std" and have a local web-server with documentation

1755761079
tranzystorekk!86175ff574@voidlinux/maintainer/tranzystorekk
hm, im wondering how to add modules from a dependency into build.zig now that usingnamespace mixins are out of the question

1755761846
tranzystorekk!86175ff574@voidlinux/maintainer/tranzystorekk
the musings from here https://zig.news/liyu1981/how-to-use-your-fav-pkg-in-buildzig-3ni8 don't seem to work on 0.15.1

1755762614
ifreund!2940d10f8b@user/ifreund
bblack: I've been using this doubly linked list everywhere myself: https://codeberg.org/ifreund/zig-wayland/src/commit/65b01fb69148013eea882c8222a82a1d96a6241b/src/common_core.zig#L18

1755762641
ifreund!2940d10f8b@user/ifreund
I originally wrote it for compat with libwayland, but it's actually just really comfy

1755762678
ifreund!2940d10f8b@user/ifreund
apparently the linux kernel also uses this style of circular doubly linked list quite a bit

1755762851
ifreund!2940d10f8b@user/ifreund
tranzystorekk: I'm confused about how usingnamespace is related to that... are you looking for @import("module_name")?

1755762939
triallax!~triallax@lacerte/triallax
the feature i'm most impressed by in zig 0.15.0 is the new {t} format specifier

1755762941
triallax!~triallax@lacerte/triallax
/hj

1755762978
tranzystorekk!86175ff574@voidlinux/maintainer/tranzystorekk
im looking at https://github.com/rockorager/zzdoc/blob/57e86eb4e621bc4a96fbe0dd89ad0986db6d0483/build.zig#L3-L4 (the mixin adds all functions into bild.zig, but now im realizing that probably shouldn't be necessary)

1755763049
tranzystorekk!86175ff574@voidlinux/maintainer/tranzystorekk
still, when im trying to import zzdoc (my rewritten version that supports 0.15) in a test project build.zig, it complains that there's no zzdoc module in root.@build

1755764120
tranzystorekk!86175ff574@voidlinux/maintainer/tranzystorekk
okay nevermind, i had the incorrect path in build.zig.zon

1755765173
hadronized!~hadronize@2001:41d0:a:fe76::1
andrewrk: so, about the noalias godbolt link? you mentioned something else I didn’t try?

1755765575
tranzystorekk!86175ff574@voidlinux/maintainer/tranzystorekk
one question about Io, can I get a file writer/reader that is unbuffered simply by doing `File.writer(&.{})` ?

1755765707
hadronized!~hadronize@2001:41d0:a:fe76::1
tranzystorekk: I think that’s the design they mentioned, yeah; if the buffer has size 0, it’s unbuffered

1755765946
tranzystorekk!86175ff574@voidlinux/maintainer/tranzystorekk
asking because im getting weird errors in unbuffered file reader, like assert(r.buffer.len - r.seek >= capacity)

1755765957
tranzystorekk!86175ff574@voidlinux/maintainer/tranzystorekk
probably reader cant be unbuffered?

1755765971
tranzystorekk!86175ff574@voidlinux/maintainer/tranzystorekk
or an impl bug, hard to say

1755766042
hadronized!~hadronize@2001:41d0:a:fe76::1
hm, if a reader cannot be unbuffered, it should be quite easy to check for the length of the buffer at compile-time and ensure it’s > 0, emitting a compileError in the case it’s 0, so it’s surprising it would fail on that line

1755766107
triallax!~triallax@lacerte/triallax
buffers are dynamic though

1755766124
hadronized!~hadronize@2001:41d0:a:fe76::1
then check when creating the reader?

1755766125
triallax!~triallax@lacerte/triallax
so their lengths may be runtime-known

1755766127
hadronized!~hadronize@2001:41d0:a:fe76::1
I mean it’s a trivial check

1755766133
triallax!~triallax@lacerte/triallax
sure

1755766166
hadronized!~hadronize@2001:41d0:a:fe76::1
however, it’s likely it’s not possible to have a reader without a buffer for internal reasons?

1755766179
hadronized!~hadronize@2001:41d0:a:fe76::1
like, reading from a TCP stream without an internal buffer is probably super inefficient

1755766202
triallax!~triallax@lacerte/triallax
you might need to have a "buffer" of length 1

1755766231
ifreund!2940d10f8b@user/ifreund
tranzystorekk: some APIs require a non-zero buffer

1755766243
tranzystorekk!86175ff574@voidlinux/maintainer/tranzystorekk
ah

1755766251
ifreund!2940d10f8b@user/ifreund
they should state "Asserts non-zero buffer" or similar in their doc comments

1755766256
tranzystorekk!86175ff574@voidlinux/maintainer/tranzystorekk
oh well, [1024]u8 for everyone!

1755766269
hadronized!~hadronize@2001:41d0:a:fe76::1
ifreund: why isn’t that checked in the implementation? at least in debug

1755766272
triallax!~triallax@lacerte/triallax
i mean if you want it to be "unbuffered" 1 does the job

1755766287
triallax!~triallax@lacerte/triallax
but also i'm curious why you'd want an unbuffered reader

1755766291
ifreund!2940d10f8b@user/ifreund
hadronized: the assert is that?

1755766305
hadronized!~hadronize@2001:41d0:a:fe76::1
ifreund: you said doc comments

1755766329
ifreund!2940d10f8b@user/ifreund
... "Asserts non-zero buffer"

1755766338
tranzystorekk!86175ff574@voidlinux/maintainer/tranzystorekk
i was just trying to keep as close to original code as possible

1755766350
tranzystorekk!86175ff574@voidlinux/maintainer/tranzystorekk
but slapping a 1kb buffer is trivial to do

1755766363
triallax!~triallax@lacerte/triallax
i use 4kb personally

1755766390
hadronized!~hadronize@2001:41d0:a:fe76::1
ifreund: ah, I parsed your sentence wrong I guess, as in, « Asserts non-zero buffer in their doc comments »

1755766476
tranzystorekk!86175ff574@voidlinux/maintainer/tranzystorekk
this is bound to start a Writergate war, why isnt there a recommended default buffer size as a constant that I can quote and completely misuse without any consideration :D

1755766504
triallax!~triallax@lacerte/triallax
c's BUFSIZ :D

1755766531
triallax!~triallax@lacerte/triallax
i did do some benchmarking and found 4K to be the sweet spot, ymmv of course

1755766602
hadronized!~hadronize@2001:41d0:a:fe76::1
btw, I was thinking about something I guess comptime cannot do: given a type that I pass to a function, check that the type is a struct and if so, create another type with the same field names, but with all the fields optional

1755766617
hadronized!~hadronize@2001:41d0:a:fe76::1
is there a known trick to actually do that?

1755766622
triallax!~triallax@lacerte/triallax
pretty sure that's possible

1755766634
hadronized!~hadronize@2001:41d0:a:fe76::1
IIRC, you cannot use comptime var in place of identifiers

1755766654
hadronized!~hadronize@2001:41d0:a:fe76::1
return struct { field1.name: ?field1.type, … }

1755766738
hadronized!~hadronize@2001:41d0:a:fe76::1
in Rust, because you either use macro_rules and have a completely different syntax for « macro variables » (i.e. { $field1_name: $field1_type }) it’s possible, and procedural macro is basically you rewriting an AST, so fin etoo

1755766743
hadronized!~hadronize@2001:41d0:a:fe76::1
but in Zig I’m a bit out of clues

1755766768
hadronized!~hadronize@2001:41d0:a:fe76::1
I was thinking about making a builder-like type for constructing some values

1755766776
triallax!~triallax@lacerte/triallax
i imagine it'd be something more like, make a slice of `StructField`s, copied from the type, make them optional, construct a new struct type with these fields

1755766793
triallax!~triallax@lacerte/triallax
taking a look at std.meta.FieldEnum might help 

1755766802
triallax!~triallax@lacerte/triallax
it does something different but a simitar overall idea

1755766805
triallax!~triallax@lacerte/triallax
similar even

1755766866
hadronized!~hadronize@2001:41d0:a:fe76::1
ah I see the idea

1755766887
hadronized!~hadronize@2001:41d0:a:fe76::1
so there’s a function that can build a type from the Field set description

1755767107
hadronized!~hadronize@2001:41d0:a:fe76::1
hm, I don’t find it

1755767169
hadronized!~hadronize@2001:41d0:a:fe76::1
the closet thing I find is @import()

1755767181
hadronized!~hadronize@2001:41d0:a:fe76::1
but it takes in a path, not the actual information about the type

1755767186
hadronized!~hadronize@2001:41d0:a:fe76::1
so I don’t think we can do that?

1755767196
triallax!~triallax@lacerte/triallax
@Type

1755767231
hadronized!~hadronize@2001:41d0:a:fe76::1
ah indeed

1755767240
triallax!~triallax@lacerte/triallax
it's used it FieldEnum

1755767244
hadronized!~hadronize@2001:41d0:a:fe76::1
nice! I guess it’s my next exercise to do :)

1755767249
hadronized!~hadronize@2001:41d0:a:fe76::1
thanks triallax :)

1755767751
triallax!~triallax@lacerte/triallax
anytime

1755769400
hadronized!~hadronize@2001:41d0:a:fe76::1
https://zigbin.io/6a3a76 not too bad :)

1755769742
hadronized!~hadronize@2001:41d0:a:fe76::1
I’m not entirely sure about line 22

1755769749
hadronized!~hadronize@2001:41d0:a:fe76::1
because I guess the value should have a static lifetime

1755769753
hadronized!~hadronize@2001:41d0:a:fe76::1
but I’m not 100% sure

1755769786
dutchie!~dutchie@user/dutchie
eh, it's comptime, all is good

1755774790
bblack!~bblack@wikimedia/bblack-WMF
ifreund: ah that's a nice design too, and even more flexible and succinct :)

1755774905
triallax!~triallax@lacerte/triallax
the debug allocator is _slow_ but it only makes me feel better that implementing small-string optimisation gives a 97%(!!!) speed improvement on one benchmark that's very heavy on small strings

1755774924
triallax!~triallax@lacerte/triallax
of course with a reasonable allocator the difference is nowhere near as large but still

1755787392
militarycoder!~militaryc@user/neothechosen
I've stumbled upon Zig & C interoperation. I'm writing custom Zig wrapper around GLFW and I'm trying to get error description retrieval working (https://www.glfw.org/docs/latest/group__init.html, see `glfwGetError(const char **description)`). When importing glfw3.h via `@cImport(@cInclude())`, the aforementioned function has the following type: `pub extern fn glfwGetError(description: [*c][*c]const

1755787394
militarycoder!~militaryc@user/neothechosen
u8) c_int`. I'm concerned that C->Zig translation is wrong because, obviously, glfwGetError() wants a pointer to the first item of `const char *` array, but Zig recognizes it as a "multidimensional array of u8". Am I understanding it correctly?

1755788292
bblack!~bblack@wikimedia/bblack-WMF
militarycoder: I think basically glfwGetError wants a pointer to somewhere it can store its own const point into.  So you can basically do something like:

1755788434
bblack!~bblack@wikimedia/bblack-WMF
var glfwerr: ?[*:0]u8 = null; glfwGetError(&glfwerr); std.debug.print("glfw error was {?s}\n", .{ glfwerr });

1755788517
bblack!~bblack@wikimedia/bblack-WMF
oh I misconstrued something there along the way

1755788518
grayhatter!~grayhatte@user/grayhatter
huh, I didn't know {s} would accept [*:0], that's good to know

1755788581
bblack!~bblack@wikimedia/bblack-WMF
oh maybe I didn

1755788594
bblack!~bblack@wikimedia/bblack-WMF
't, I think maybe my snippet is ~correct

1755788633
bblack!~bblack@wikimedia/bblack-WMF
you can also turn that into a slice if it makes things more-convenient, and apparently it can set NULL to indicate no error

1755788657
grayhatter!~grayhatte@user/grayhatter
bblack: I think you got it right, the only thing I'd add, is that technically a pointer to a c-string is a multidimensional array of u8 (with extra rules)

1755788713
militarycoder!~militaryc@user/neothechosen
bblack: it's a bit trickier

1755788718
bblack!~bblack@wikimedia/bblack-WMF
yeah and whatever the context is, you may want to interpret a stored null there as "no error"

1755788741
grayhatter!~grayhatte@user/grayhatter
[1][*:0]u8 is a smaller version of [5][*:0]u8

1755788745
militarycoder!~militaryc@user/neothechosen
bblack: compiler says the following: src/main.zig:31:44: error: expected type '[*c][*c]const u8', found '*?[*:0]u8'

1755788768
bblack!~bblack@wikimedia/bblack-WMF
militarycoder: then just wrap it in @ptrCast()

1755788782
militarycoder!~militaryc@user/neothechosen
huh, that's interesting

1755788784
bblack!~bblack@wikimedia/bblack-WMF
glfwGetError(@ptrCast(&glfwerr));

1755788813
bblack!~bblack@wikimedia/bblack-WMF
sometimes you have to get ugly when crossing the C barrier :)

1755788882
militarycoder!~militaryc@user/neothechosen
bblack: yeah, @ptrCast() did the trick, thank you

1755788932
bblack!~bblack@wikimedia/bblack-WMF
where I'm still using libev as the eventloop driving my Zig code (that was ported from C), I have some terribly ugly lines like this to unwrap a context pointer to a zig object that came through a C callback :)

1755788936
bblack!~bblack@wikimedia/bblack-WMF
const self: *Self = @ptrCast(@alignCast(w.data.?));

1755788967
bblack!~bblack@wikimedia/bblack-WMF
where "w" is a libev watcher from the C side, and data is its void* context pointer.

1755789030
grayhatter!~grayhatte@user/grayhatter
I think it's complaining that you're dropping the const part

1755789042
militarycoder!~militaryc@user/neothechosen
bblack: well, imho it doesn't look all that bad

1755789045
bblack!~bblack@wikimedia/bblack-WMF
hmmm yeah might be

1755789063
bblack!~bblack@wikimedia/bblack-WMF
"var glfwerr: ?[*:0]const u8 = null;" might not need the @ptrCast?

1755789072
grayhatter!~grayhatte@user/grayhatter
you'll get a string that's const u8,  but you've told zig it's mutable, that's a bug

1755789312
bblack!~bblack@wikimedia/bblack-WMF
every day I'm getting slightly-closer to removing all @cImport dependencies from my code.  swapping libev for some fancy std.Io eventloop will be one of the big ones.  The only others I really have left now are reimplementing libc's glob() and fnmatch() stuff (ewww), and some missing network-related constants/macros from libc headers (for CMSG stuff, and various IP_* socket options, etc)

1755789344
torque!~tachyon@user/torque
<militarycoder> I've stumbled upon Zig & C interoperation. I'm writing custom Zig wrapper around GLFW

1755789365
torque!~tachyon@user/torque
to be clear here, zig cannot autogenerate better bindings because C doesn't include any information about pointers

1755789382
torque!~tachyon@user/torque
all pointers in C may be a single item pointer or a pointer to many and there is no distinction

1755789413
torque!~tachyon@user/torque
when writing bindings, it is up to you to use your knowledge of the C codebase to provide better bindings than zig translate-c can autogenerate, if you're actually writing a custom wrapper

1755789427
bblack!~bblack@wikimedia/bblack-WMF
torque: it could do slightly-better about some aspects than it does.  some modern-ish (hah) C code has attribute specifiers on functions args are retvals about whether they're nullable or not.

1755789453
torque!~tachyon@user/torque
there's nothing magical about zig translate-c, so you can put the output in a file, and then modify that to improve it

1755789482
militarycoder!~militaryc@user/neothechosen
grayhatter: I don't quite understand your take about bug thing with variable mutability

1755789555
bblack!~bblack@wikimedia/bblack-WMF
militarycoder: what he means is that glfw really is returning a pointer to some constant string storage from the library, to some fixed error string like: "the foo failed to bar", which can't be modified.

1755789557
torque!~tachyon@user/torque
bblack, there's no type in zig that can represent "single or many item pointer but hell it's not going to be null", and it doesn't make sense to introduce additional types besides [*c]

1755789589
torque!~tachyon@user/torque
specifically for autotranslating c

1755789591
bblack!~bblack@wikimedia/bblack-WMF
militarycoder: but my original "var glfwerr: ?[*:0]u8 = null" declares that the string's storage can be modified by zig code

1755789613
bblack!~bblack@wikimedia/bblack-WMF
which would probably segfault or whatever if you tried to do so.  declaring it const prevents that bug.

1755789620
militarycoder!~militaryc@user/neothechosen
bblack: then I could use some explanation on how `const glfwerr: ?[*:0]u8` should be translated

1755789643
militarycoder!~militaryc@user/neothechosen
bblack: but declaring glfwerr as const disables me from passing it as an argument to glfwGetError :-/

1755789665
bblack!~bblack@wikimedia/bblack-WMF
don't make it const, make the bytes const

1755789677
bblack!~bblack@wikimedia/bblack-WMF
var glfwerr: ?[*:0]const u8 = null;

1755789704
bblack!~bblack@wikimedia/bblack-WMF
now the pointer can be assigned to, but the bytes cannot

1755789751
militarycoder!~militaryc@user/neothechosen
bblack: thank you, know that makes sense

1755789756
militarycoder!~militaryc@user/neothechosen
now*

1755793071
reykjalin!7e28cf3a41@user/reykjalin
sorry if I missed this somewhere in the scrollback, but I’m really curious: what’s the reason version 0.15.0 was skipped and instead the version went straight to 0.15.1?

1755793264
dutchie!~dutchie@user/dutchie
reykjalin: https://github.com/ziglang/www.ziglang.org/commit/1be0f80b15d256d42411a21f10e208f9b269a5e2

1755793280
dutchie!~dutchie@user/dutchie
i.e. https://github.com/ziglang/zig/issues/24911

1755796435
netvor!~netvor@2a00:ca8:a1f:cd0:b2de:c866:be10:f582
kind of OT but...:  is it just me?  for second time i tried to connect to tigerbeetle stream but it's broken, says player cannot load and i cannot even get to chat to let them know

1755796470
netvor!~netvor@2a00:ca8:a1f:cd0:b2de:c866:be10:f582
if someone is there can you let matklad know?

1755796502
netvor!~netvor@2a00:ca8:a1f:cd0:b2de:c866:be10:f582
there's just 2 viewers now, i wanted to increase the viewership by 50%! :D

1755796529
Gliptic!~glip@2a01:4f8:c012:91f3::1
on twitch?

1755796534
Gliptic!~glip@2a01:4f8:c012:91f3::1
I get "The video download was cancelled. Please try again. (Error #1000)"

1755796597
netvor!~netvor@2a00:ca8:a1f:cd0:b2de:c866:be10:f582
yeah me too, same as last week

1755796616
netvor!~netvor@2a00:ca8:a1f:cd0:b2de:c866:be10:f582
but some weeks ago i could totally connect

1755797079
netvor!~netvor@2a00:ca8:a1f:cd0:b2de:c866:be10:f582
i sent email directly to matklad so we'll see

1755797097
netvor!~netvor@2a00:ca8:a1f:cd0:b2de:c866:be10:f582
hope they don't just think that nobody wants to watch :D

1755797509
netvor!~netvor@2a00:ca8:a1f:cd0:b2de:c866:be10:f582
turns out the chat works, so i let them know there as well

1755802938
chmod222!~chmod222@user/chmod222
Twitch has been kind of on the fritz recently, and by recently I mean "the last few years"

1755806889
bwbuhse!~The_Buhs@user/The-Buhs/x-5080862
Twitch wouldn't work on LibreWolf on Linux for a year or so >:( 

1755807067
dutchie!~dutchie@user/dutchie
mpv/ytdlp work well for me these days

1755807472
chmod222!~chmod222@user/chmod222
Oh yeah, mpv is the much superior twitch experience, if you can live without the chat being right there. For me that's arguably a bonus, chat is the worst part of twitch

1755809868
andrewrk!~andrewrk@mail.ziglang.org
oh I didn't know mpv supported twitch

1755810506
chmod222!~chmod222@user/chmod222
mpv mostly shells out to yt-dlp, but yes, it's very good

1755812281
andrewrk!~andrewrk@mail.ziglang.org
ah

1755813111
netvor!~netvor@2a00:ca8:a1f:cd0:b2de:c866:be10:f582
i also had no idea it would support it.   gotta try it next time

1755814668
GreaseMonkey!greaser@user/greasemonkey
0.15.1 came out and somehow i didn't notice, congratulations

1755814800
gbrlsnchs!d584fe5421@2a03:6000:1812:100::10b4
chmod222: I remember doing that in the past and at that time I had the chat working in my IRC client

1755816866
reykjalin!7e28cf3a41@user/reykjalin
ah got it, thank you dutchie!

1755817245
andrewrk!~andrewrk@mail.ziglang.org
GreaseMonkey: cheers

1755817265
triallax!~triallax@lacerte/triallax
the migration was mildly painful but not as painful as i'd expected

1755817271
triallax!~triallax@lacerte/triallax
only took me an hour or two

1755817371
andrewrk!~andrewrk@mail.ziglang.org
nice that's a lot less time than it took me

1755817381
triallax!~triallax@lacerte/triallax
my codebase is not very big

1755817393
triallax!~triallax@lacerte/triallax
~10k lines of code (excluding comments and blanks)

1755817414
triallax!~triallax@lacerte/triallax
and most of it doesn't deal with writers and readers

1755817463
triallax!~triallax@lacerte/triallax
was pleasantly surprised to see performance wasn't regressed too much and the binary size also decreased quite a bit

1755817526
triallax!~triallax@lacerte/triallax
by ~0.4MiB (before stripping)

1755817537
triallax!~triallax@lacerte/triallax
not entirely sure why

1755817650
mortmann!~mortmann@p57b29c98.dip0.t-ipconnect.de
i have same/better performance after migration of sum fun stuff, but binary size (stripped) +30%. so thanks trilallax for reporting, guess the error is on my side then.

1755817672
triallax!~triallax@lacerte/triallax
i mean lemme see stripped first

1755817713
triallax!~triallax@lacerte/triallax
ok still smaller but difference is not as big

1755817725
triallax!~triallax@lacerte/triallax
30% is a lot though

1755817729
triallax!~triallax@lacerte/triallax
from your side

1755817737
mortmann!~mortmann@p57b29c98.dip0.t-ipconnect.de
ive got 23k bin size -> 30k with 0.15.1. hope i find the bug...

1755817752
triallax!~triallax@lacerte/triallax
ah at these sizes that's not super surprising

1755817780
triallax!~triallax@lacerte/triallax
my stripped 0.15.1 exectuable is 0.76 MiB

1755818024
mortmann!~mortmann@p57b29c98.dip0.t-ipconnect.de
i guess its more crt/startup/one/time increase, that would not be noticed with bigger binaries, still courious where it comes from

