1763519592
torque!~tachyon@user/torque
https://github.com/zigbook/zigbook/issues/30 lol

1763519610
torque!~tachyon@user/torque
unsurprisingly this guy dug in his heels and insists no ai

1763522940
clevor!sid649024@id-649024.hampstead.irccloud.com
I'm pretty sure the same person owns https://github.com/zigglang

1763522998
clevor!sid649024@id-649024.hampstead.irccloud.com
Lo and behold, the 3 dislikes in https://github.com/zigbook/zigbook/issues/25 were zigbook, zig-vm, and zigglang.

1763523048
torque!~tachyon@user/torque
weird

1763523140
clevor!sid649024@id-649024.hampstead.irccloud.com
I believe they have at least 4 accounts.

1763523233
torque!~tachyon@user/torque
sticking with my initial impression of "bizarre psyop"

1763523271
clevor!sid649024@id-649024.hampstead.irccloud.com
I'll type up an issue tomorrow when I'm on my laptop so I can use archive.org and such to prevent them from removing said reactions and calling me a liar.

1763523323
clevor!sid649024@id-649024.hampstead.irccloud.com
The important thing is that this shouldn't be shared anywhere until I submit the issue.

1763523483
clevor!sid649024@id-649024.hampstead.irccloud.com
I wonder who is running this in the first place.

1763523651
torque!~tachyon@user/torque
lets have a good old fashioned witch hunt

1763523735
torque!~tachyon@user/torque
I don't really care who does it but it feels like it's a setup for someone to make a blog post about how all the zig ai haters were tricked into loving ai generated content

1763525661
clevor!sid649024@id-649024.hampstead.irccloud.com
I did one better and typed up a report to Github, also accusing them of impersonation and fraud in the process.

1763525976
clevor!sid649024@id-649024.hampstead.irccloud.com
Remind me to share it on Ziggit on Friday.

1763526458
torque!~tachyon@user/torque
eh, not sure who's being impersonated or defrauded exactly, though "zigglang" does seem to be close to typosquatting

1763526468
torque!~tachyon@user/torque
it's not like it's being used for anything nefarious

1763526819
squeek502!~squeek502@user/squeek502
torque, not related to zig, but this is definitely fraud adjacent by the same person: https://buymeacoffee.com/cursor (not actually affiliated with cursor, linked from https://github.com/zig-vm and likely other places controlled by the same person)

1763526852
torque!~tachyon@user/torque
lol indeed

1763526873
torque!~tachyon@user/torque
though i hesitate to feel sorry for the type of credulous rube who would fall for such a scam

1763527070
torque!~tachyon@user/torque
on review of the documents, https://github.com/zig-vm has a certification for "ethical hacker" right there on their github profile readme. ipso facto it is not possible for them to engage in fraud. I rest my case

1763557091
bblack!~bblack@wikimedia/bblack-WMF
grayhatter: re: " zig want to have one obvious way to do things. If Io works most of the time [...]".  I mean... yes? but not necessarily? for any given situation there might be 3 different std.foo data structures you could reasonably choose to solve your problem as well.  I don't think it's necessarily true that std.Io has to perfectly cover every possible edge case for anything under the sun that could be 

1763557097
bblack!~bblack@wikimedia/bblack-WMF
considered "io".  It's kind of hard to do that with an abstraction anyways, the law of leaky abstractions and all that.  My not-yet-cogent argument is that even once the current direction of std.Io is more-fully-completed, there will probably always be edge cases where a systems programmer will prefer just making direct calls to the system's API for some things that don't quite fit the abstraction model, 

1763557103
bblack!~bblack@wikimedia/bblack-WMF
probably nice things.

1763557157
bblack!~bblack@wikimedia/bblack-WMF
I think of it more like the stdlib / std.Io equivalent of what's going on at the language level when sometimes, you're just gonna have to drop down to asm.  Or sometimes, you might have such special needs for a hashtable implementation that you roll your own instead of using an std.HashMap, or whatever.

1763557229
bblack!~bblack@wikimedia/bblack-WMF
I think there will always be cases where someone will want to bypass std.Io and do some things directly interfacing the low-level system "io" calls.  And if we have some working abstractions that are a little easier for some cases (e.g. abstracting basic recvmsg over the posixy platforms with reasonable errno interpretation, etc), we shouldn't kill that just because std.Io exists now.

1763557275
bblack!~bblack@wikimedia/bblack-WMF
s/nice things/niche things/ :)

1763557876
bblack!~bblack@wikimedia/bblack-WMF
[I'm reasonably-confident in the "there will always be an uncovered edge case" part of the above.  I'm opinionated about the last bit re: keeping the std.posix abstractions, but if it goes the other way, it's not the end of the world.  It just means those niche users will have to do that for themselves, calling into std.os.foo and/or std.c with their own target-switching and/or errno-handling stuff]

1763557985
ifreund!2940d10f8b@user/ifreund
I think it's a fundamental property of abstraction that any useful abstraction comes at the cost of some level of loss of control/simplification

1763558025
ifreund!2940d10f8b@user/ifreund
an abstraction that exposes exactly the same amount of complexity and control as the interface it is built on is not an abstraction

1763558037
bblack!~bblack@wikimedia/bblack-WMF
yes :)

1763558085
bblack!~bblack@wikimedia/bblack-WMF
for those not so ancient as to remember this ancient link: https://www.joelonsoftware.com/2002/11/11/the-law-of-leaky-abstractions/

1763558393
bblack!~bblack@wikimedia/bblack-WMF
it might even be reasonable at some stage to push something like std.posix out to just be a 3rd party dependency for those that want/need it, too.

1763558483
bblack!~bblack@wikimedia/bblack-WMF
that kinda auto-solves the "one canonical way to do things" argument.  there can be other ways, they just don't ship with Zig itself :)

1763571811
grayhatter!~grayhatte@user/grayhatter
bblack: I'd like to nudge your argument (I think it's the shared argument we're both converging on, because you haven't yet said anything I disagree with out right) in what I hope is more cogent; because I want to suggest it's not just ok, but desired for the stdlib to be immature. The idea I'm pondering is zig would be better served by *not* trying to make Io cover all uses? e.g. I have `net.Stream =

1763571813
grayhatter!~grayhatte@user/grayhatter
try addr.connect(io, .{ .mode = .dgram, .protocol = .udp });` in my code right now... It's really weird to me that my packet based protocol exposes a streaming API; IMO this is worse than not having an Io interface over udp. 

1763571924
grayhatter!~grayhatte@user/grayhatter
a linux socket doesn't care if you give it a unix file, or an ip address, or etc, but Io does

1763572194
grayhatter!~grayhatte@user/grayhatter
admittedly, this is partially my recency bias slipping in; because I want to suggest instead of trying to pick the "ideal" API for Io, the time would be better spent "updating" the various system APIs and getting them in a state that's compatible with the Io interface. std.os.linux.bind() shouldn't take sockaddr and .connect() shouldn't take anyopaque

1763572225
grayhatter!~grayhatte@user/grayhatter
you don't have to choose one or the other if they're intercompatable 

1763572418
bblack!~bblack@wikimedia/bblack-WMF
grayhatter: by that you mean, I'm assuming, that std.os.linux network calls should take arguments like std.Io.net.{Socket, IpAddress, etc} and deal with the linux-specific aspects of that on the inside?

1763572482
grayhatter!~grayhatte@user/grayhatter
exactly, took me a few minutes to realize that my dnsd wasn't working because I didn't have to byteswap the port number anymore when I upgraded to std.Io.Ip4Address

1763572545
grayhatter!~grayhatte@user/grayhatter
unlike udp being becoming a stream, that was a pleasant change

1763572600
grayhatter!~grayhatte@user/grayhatter
there's no reason creating a raw linux socket shouldn't be exactly that easy (yes, I know I can get a socket, but it doesn't plug directly into linux.connect nor linux.listen the way I'd want it to

1763572626
bblack!~bblack@wikimedia/bblack-WMF
yeah, I mean, that feels like a solid idea at first glance.  I do worry this might lead to some implementation detail that would turn some off, though (e.g. if the only canonical way now to call certain os.linux network syscalls ends up needing to allocate a stack buffer and translate a thing in some expensive way, just to deal with the abstraction -> sockaddr bits or whatever)

1763572665
bblack!~bblack@wikimedia/bblack-WMF
(and then it happens over and over for 10 socket calls in a row, because the std.Io.net representation is what's being passed around at a higher level)

1763572667
grayhatter!~grayhatte@user/grayhatter
yeah, I'm trying to resolve the conflict between suggesting that, and my objections on my timed wait pr

1763572718
grayhatter!~grayhatte@user/grayhatter
bblack: I'd argue that repeated expensive translation is the job of the compiler

1763572744
grayhatter!~grayhatte@user/grayhatter
argue that optimizing* that

1763572748
bblack!~bblack@wikimedia/bblack-WMF
yes, if it's tractable for the compiler.  the details of this all really looks and compiles will matter

1763572992
bblack!~bblack@wikimedia/bblack-WMF
but if it ends up being the case that your pre-std.Io (more C-like) code had, say, an array or hashmap or whatever of thousands of application-layer client "connection" structs, which were being stored with efficient address/fd info in them and passed directly to std.posix network calls or whatever...  and now your applayer client connection struct is storing std.Io.net equivalents and passing those down into 

1763572998
bblack!~bblack@wikimedia/bblack-WMF
either actul std.Io interfaces or to std.os.linux.foo() in that form, and that results in some un-optimizable expensive thing happening on every operation now that didn't have to happen before...

1763573054
bblack!~bblack@wikimedia/bblack-WMF
that's the primal fear in my head: that this ends up having unavoidable abstraction costs that matter, and it's now baked all the way down through std.posix (or even past that into std.os.linux) and there's no other way to do it.

1763573194
bblack!~bblack@wikimedia/bblack-WMF
but maybe my fears are unfounded :)

1763573224
grayhatter!~grayhatte@user/grayhatter
I wouldn't call them unfounded, just, insignificant?

1763573236
bblack!~bblack@wikimedia/bblack-WMF
yeah, maybe

1763573237
clevor!sid649024@id-649024.hampstead.irccloud.com
I think std.os.* should only contain raw wrappers around syscalls anyway.

1763573247
grayhatter!~grayhatte@user/grayhatter
that is 100% a mistake that a **lot** of people make, and it ruins a library

1763573261
bblack!~bblack@wikimedia/bblack-WMF
but note that currently, IpAddress and Unix addresses are separate things in std.Io land

1763573264
grayhatter!~grayhatte@user/grayhatter
but I haven't seen that mistake happen in stdlib yet

1763573290
bblack!~bblack@wikimedia/bblack-WMF
I'm sure that's in part because unix addresses need way more storage.  that may have to be resolved by some bloated union for cases where it's never a unix address

1763573294
bblack!~bblack@wikimedia/bblack-WMF
there are things like that to sort out

1763573317
grayhatter!~grayhatte@user/grayhatter
clevor: I used to think that it should behave closer to that, but after implementing my 3rd `std.os.linux.syscall4` I would rather stdlib be easy to use

1763573381
clevor!sid649024@id-649024.hampstead.irccloud.com
Were you using a syscall not in std.os.linux?

1763573397
grayhatter!~grayhatte@user/grayhatter
I'm not afraid to @intFromPtr() if I don't like how some `std.os.linux.func` works... it would annoy me if I had to do that for all of them... but I think zig's translation layer between "std lib functions" and "os syscalls" is far to thick

1763573489
bblack!~bblack@wikimedia/bblack-WMF
[bbl to resume this]

1763573516
grayhatter!~grayhatte@user/grayhatter
https://srctree.gr.ht/repo/benevolence/blob/src/signals.zig#L8

1763573521
grayhatter!~grayhatte@user/grayhatter
clevor: ^

1763573658
clevor!sid649024@id-649024.hampstead.irccloud.com
I'd expect std.os.linux to have every syscall :p

1763573750
grayhatter!~grayhatte@user/grayhatter
depending on how you define every syscall, they do... std.os.linux.syscall* exists :P

1763573807
JetpackJackson!739e7f3d14@user/JetpackJackson
Kinda random but I'm really glad that zig and zvm are supported on freebsd, I'm tinkering with it now and it's nice that it works on it :3

1763573908
JetpackJackson!739e7f3d14@user/JetpackJackson
Now to write one of my programs to be portable to it lol

1763573991
grayhatter!~grayhatte@user/grayhatter
why does std.os.linux.wrapped exist?

1763574155
grayhatter!~grayhatte@user/grayhatter
not; why was it created? but why is it better than making thoes functions the default and let anything that needs the raw API call `std.os.linux.c.func` instead?

1763575893
bblack!~bblack@wikimedia/bblack-WMF
I think part of where I disconnect with some view of related things, is I really have a hope that Zig will make C itself obsolete eventually.  That there will be no really good excuse for any C project not to port itself to Zig for the obvious wins.  I think already, the language is primed for BYOS and for writing real OS kernels in and such.  And at the other end of the spectrum, I can totally see someone 

1763575898
erock!8a023a9e4a@pico/erock
does using posix.fork or posix.forkpty cause issues with the debug allocator?

1763575899
bblack!~bblack@wikimedia/bblack-WMF
writing a production-grade, scalable HTTP server in Zig using std.Io instead of doing it in C like most of them we know and love/hate today.

1763575962
bblack!~bblack@wikimedia/bblack-WMF
but I feel like there will be this grey area, too.  of people who want to port low-level systems software that would've otherwise been in C.  It's not OS code, it rides on Linux or FreeBSD or whatever, but it doesn't want all the magic.  It wants the OS syscalls directly, and it wants them to be as ~"easy" to use as they were in C-land, too

1763575995
bblack!~bblack@wikimedia/bblack-WMF
without reorganizing their code and their brain into all the better abstractions which may or may not apply to all cases.

1763576061
grayhatter!~grayhatte@user/grayhatter
I disagee with that end goal... I've yet to hear a compelling argument for rewriting from language X into New_Version_Of_Y

1763576072
grayhatter!~grayhatte@user/grayhatter
what if, instead, it was easy to use both together?

1763576381
bblack!~bblack@wikimedia/bblack-WMF
well I guess here we get into all the debates about rewrites vs ports, and rewrites vs legacy baggage vs legacy important-lessons-learned-that-get-lost-in-greenfield-rewrites, stability for users of the project in question, etc...

1763576486
bblack!~bblack@wikimedia/bblack-WMF
I mean, it's all well-trod ground.  I think there's a solid case for taking some important legacy C codebases and language-porting them to Zig for gains in reliability and code clarity, and a modern path forward for that legacy codebase.

1763576487
grayhatter!~grayhatte@user/grayhatter
I'd rather not? (I know you're not suggesting it) because actionable diffs don't come from thoes discussions. I think most people agree with some part of posix is the wrong abstraction layer for zig

1763576514
grayhatter!~grayhatte@user/grayhatter
posix is very C

1763576519
bblack!~bblack@wikimedia/bblack-WMF
(without breaking things for their users, or losing all the lessons those codebases gained over the years, etc)

1763576606
bblack!~bblack@wikimedia/bblack-WMF
it is very C.  but if their first baby step has to be from C -> std.Io, it's a tough bridge to cross perhaps.

1763576742
bblack!~bblack@wikimedia/bblack-WMF
but as I mentioned earlier, even a non-std 3rd party dep that looks a lot like today's std.posix would suffice for helping people across that bridge.  it doesn't necessarily have to be in Zig's std.

1763576869
bblack!~bblack@wikimedia/bblack-WMF
at least for me, this is the pathway I went down with my crufty legacy C project.  I started with porting the build system from autotools -> build.zig.  Then I started porting one little piece of C code at a time to Zig code that looked a lot like the C code, and compiling Zig+C bits together and still passing my old tests.  I kept at that until there were no C files left.  Then I started eliminating deps on 

1763576875
bblack!~bblack@wikimedia/bblack-WMF
C-based shlibs, and deps on libc itself, and refactoring and rewriting increasingly-large parts to look more Zig-like, etc...

1763576923
bblack!~bblack@wikimedia/bblack-WMF
I mean, I'm still going through that process, but the light at the end of the tunnel is getting closer.  I don't know how realistic it would be in the world you're imagining.

1763577028
grayhatter!~grayhatte@user/grayhatter
the world I'm imagining, that's optional, you could stop half way through and be happy... and while the "unmerged" sections  wouldn't be "zig" it wouldn't be painful to interact with them

1763577072
grayhatter!~grayhatte@user/grayhatter
I want the zig api's to be easier to using the zig flavor, but I don't want it to be *very* painful to use both (just ugly)

1763577090
bblack!~bblack@wikimedia/bblack-WMF
for me at least, though, getting rid of my C code was an explicit goal.  I had tried for years to stay on top of code quality and such in the C world, and the more you learn the more painful the problems get.  I wanted a better C than C, and I found one :)

1763577230
grayhatter!~grayhatte@user/grayhatter
zig isn't a better C

1763577277
bblack!~bblack@wikimedia/bblack-WMF
well, it's certainly much more than that.  but it also happens to be a better C than C (the language itself)

1763577303
grayhatter!~grayhatte@user/grayhatter
it's a language that matches it power, but C is a toy compared to even v0 zig

1763577559
bblack!~bblack@wikimedia/bblack-WMF
well, to be fair, C is a toy compared to a lot of languages.  But for some projects, I didn't want those other languages because they lacked in being low-level enough to do fancy high-performance things, where you really want to carefully and manually manage memory and syscall costs, etc.

1763577628
bblack!~bblack@wikimedia/bblack-WMF
but even when you've made the (definitely questionable) decision to do something C in the pre-Zig world, you're also accepting all of this pointless painful baggage that comes with it.  And Zig just happens to have all of that same level of control, but with a lot less scary/painful baggage.  it's in that sense that I consider it a better C than C.

1763577800
bblack!~bblack@wikimedia/bblack-WMF
but I don't expect anyone to want to stop at "I language-ported my C to Zig just barely and gained a little".  I think once you cross that bridge, that whole world of power is open to you, and you're gonna keep refactoring into better shapes.

1763577918
bblack!~bblack@wikimedia/bblack-WMF
the alternative world (which is totally plausible) is that it's difficult to take those baby steps with legacy code, and C projects just get slowly replaced with greenfield native-Zig equivalents, I guess, and they take some time to mature into proper replacments.

1763578793
bblack!~bblack@wikimedia/bblack-WMF
or another way to say the same things: it's one thing to say "I wrote a Zig-based HTTP server/proxy that looks a lot like nginx or haproxy" (which probably means you're ~years away from being as mature and performant and capable and featureful as projects like those), vs "I ported nginx or haproxy to Zig and it is definitely, at bare-minimum a drop-in replacement for the old one in every way, and now it's 

1763578799
bblack!~bblack@wikimedia/bblack-WMF
only going to get better faster thanks to the new language foundation"

1763578837
grayhatter!~grayhatte@user/grayhatter
bblack: I like that framing much better

1763580587
bblack!~bblack@wikimedia/bblack-WMF
[and, to be clear, I'm not suggesting I want people to go aggressively fork major projects like those.  I want to grease the wheels for authors of projects like those, to want to do this themselves, because they love their projects and want to move forward to a better language]

1763581065
grayhatter!~grayhatte@user/grayhatter
I remain optimistic that zig will never develop a "you should rewrite it in zig" meme

1763581206
bblack!~bblack@wikimedia/bblack-WMF
yeah, I hope not.  I wouldn't want it meme-forced on me.

1763581232
bblack!~bblack@wikimedia/bblack-WMF
but I came around to it on my own, on the strengths of what I saw in Zig, as a scarred C developer.  I think others will too.

1763581240
grayhatter!~grayhatte@user/grayhatter
s/meme/meme, group, subculture/

1763591357
grayhatter!~grayhatte@user/grayhatter
I very much enjoy that I'm not able to delete a lot of code from DNSd because it's in std.Io now 

1763592768
bblack!~bblack@wikimedia/bblack-WMF
yeah I'm looking forward to those parts when I get there

1763592777
bblack!~bblack@wikimedia/bblack-WMF
deleting a lot of my old code, I mean

1763592888
bblack!~bblack@wikimedia/bblack-WMF
even just the basic Zig porting and some light refactoring, if I count the whole repo up in git stats (so this includes things like autotools -> build.zig, not entirely fair), the repo has lost ~31% line count since the last C version it was based off of.

1763593614
grayhatter!~grayhatte@user/grayhatter
"not fair" I mean... less code, is less code. build.zig is part of the compiler, you wouldn't discount the power of C macros

