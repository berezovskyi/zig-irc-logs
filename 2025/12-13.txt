1765593712
p00f!ad2b9023b7@2a03:6000:1812:100::d93
when does a file get a PascalCase name?

1765593763
p00f!ad2b9023b7@2a03:6000:1812:100::d93
whenever it's a struct like file?

1765593992
Affliction!affliction@idlerpg/player/affliction
Pretty much. The filename reflects the name you'll generally import it under

1765594093
Affliction!affliction@idlerpg/player/affliction
so if Thing.zig contains fields directly, you'd generally use it as: const Thing = @import("Thing.zig");

1765594153
p00f!ad2b9023b7@2a03:6000:1812:100::d93
thank you

1765604622
rvrb!~rvrb@156.146.51.229
I want `allocator.dupe()` for single items so I don't have to do `self = allocator.create(T); self.* = .{}`, am I missing it

1765604729
rvrb!~rvrb@156.146.51.229
something like return try allocator.createCopy(T, .{ .foo = bar });

1765604821
torque!~tachyon@user/torque
I agree that would be nice as a standard api but also it's trivial to write that function 

1765605253
rvrb!~rvrb@156.146.51.229
yeah, but the same can be said of dupe

1765605292
rvrb!~rvrb@156.146.51.229
and I think there's an argument of safety, I remember a guy being surprised he had uninitialized memory cause he was initializing field by field and then later added a new field to the struct

1765605302
rvrb!~rvrb@156.146.51.229
oh god I said the word. but you know what I mean

1765657037
mimivalsi!~mimivalsi@user/MimiValsi
bblack: I see. My project is a library. The initialization is made by the user. But at the same time, there's some parameters which is the lib who will handle it. Atm, the only allocator I'm using inside the lib, coz seems the simple, is 'page_allocator'. Exemple: std.StringArrayHashMapUnmanaged which will need an allocator. So the only pertinent idea I had was storing an allocator in a struct so I

1765657039
mimivalsi!~mimivalsi@user/MimiValsi
can resize and/or free when needed

1765657121
mimivalsi!~mimivalsi@user/MimiValsi
That way I don't need to create infinity functions with an allocator.

