1758159380
JailBird!jailbird@user/jailbird
Is there a local version of the Language Reference, like their is for the stdlib? Eg, a langref version of "zig std"?

1758160925
clevor!sid649024@id-649024.hampstead.irccloud.com
JailBird: It's located in the doc/ subfolder of the Zig installation and is enabled by default unless you build with `-Dno-lib` or `-Dno-langref`.

1758160936
clevor!sid649024@id-649024.hampstead.irccloud.com
built it*

1758160943
JailBird!jailbird@user/jailbird
awesome, thanks

1758160949
clevor!sid649024@id-649024.hampstead.irccloud.com
np

1758161461
ezzieyguywuf!~Unknown@user/ezzieyguywuf
noam: oh I use gentoo too! also, what does it mean that my type is "backed by an integer"? how would I know?

1758170694
noam!81879d1ffa@2a03:6000:1812:100::dfc
I actually kinda hate Gentoo

1758170703
noam!81879d1ffa@2a03:6000:1812:100::dfc
I just dislike LInux in general, and it's the one that has pissed me off the least, so far xD

1758170716
noam!81879d1ffa@2a03:6000:1812:100::dfc
...well. Alpine's higher up the list, tbh, it's just less usable.

1758176734
andrewrk!~andrewrk@mail.ziglang.org
back from vacation

1758176773
realguy!~realguy@user/realguy
andrewrk: hope you're well rested :-)

1758176798
andrewrk!~andrewrk@mail.ziglang.org
thanks!

1758176948
tranzystorekk!86175ff574@voidlinux/maintainer/tranzystorekk
welcome back!

1758181366
netvor!~netvor@2a00:ca8:a1f:cd0:2b85:8de7:55b:170c
yay

1758191245
clevor!sid649024@id-649024.hampstead.irccloud.com
andrewrk: Where'd you vacation to?

1758191263
clevor!sid649024@id-649024.hampstead.irccloud.com
Where did*

1758197289
clevor!sid649024@id-649024.hampstead.irccloud.com
I have a proposal for `std.mem.Allocator`: do what `std.Io.Writer` did and include the interface as part of the data structure and use @fieldParentPtr instead of dereferencing a context pointer. I haven't created an implementation to test and benchmark the idea yet, but here is what it would look like: https://usercontent.irccloud-cdn.com/file/vBdiWBGb/allocgate_v2.zig

1758198752
nicefries!~nicefries@user/nicefries
hi, iam trying to build zig-bootstrap but iam getting following error: https://pastebin.com/ipJSSJQU

1758199079
clevor!sid649024@id-649024.hampstead.irccloud.com
Run `echo $LD ; which ld`

1758200047
nicefries!~nicefries@user/nicefries
i dont have a linker, can i just use zig?

1758202355
clevor!sid649024@id-649024.hampstead.irccloud.com
See how the script sets it in the second stage of building LLVM.

1758203475
netvor!~netvor@2a00:ca8:a1f:cd0:2b85:8de7:55b:170c
is there a sorting function in std that helps with index remapping?  ie. i have slice a, and slice b, and structs in slice b contain indices into a.  now, i need to sort a and then rewrite the indices in b such that they still point to the same elements

1758203610
netvor!~netvor@2a00:ca8:a1f:cd0:2b85:8de7:55b:170c
i guess i could kind of do it with usual std.mem.sort by wrapping the items into tuples like .{old_idx, item}...  not sure if that will be optimal

1758204043
netvor!~netvor@2a00:ca8:a1f:cd0:2b85:8de7:55b:170c
umm, maybe the wrapping (maybe "decoration" is better term) strategy will work just fine; i can already produce the items decorated with the original index.

1758204118
netvor!~netvor@2a00:ca8:a1f:cd0:2b85:8de7:55b:170c
(maybe i can even get some extra safety for free if i use separate types for the orig index and the final index)

1758204883
JetpackJackson!739e7f3d14@user/JetpackJackson
hi, im having issues getting umlaut/special characters read from a file to print correctly in a loop, but they print ok in a test, so im not sure whats going on. ive attached my code, a sample output, and a sample quote. https://zigbin.io/401cae

1758205593
nicefries!~nicefries@user/nicefries
JetpackJackson Ich bekomme Ausschlag, wenn ich das lese. Sprich doch einfach mal eine Frau an

1758206343
JetpackJackson!739e7f3d14@user/JetpackJackson
...what? i just want to figure out whats up with the code..?

1758207592
Pistahh!~Pistahh@user/pistahh
JetpackJackson: non-ascii chars like ü take up more than 1 byte, and it messes up your length calculation (length increases by 2, but physically it is 1 char wide)

1758207615
JetpackJackson!739e7f3d14@user/JetpackJackson
how can i fix it?

1758207686
clevor!sid649024@id-649024.hampstead.irccloud.com
You could count the number of unicode code points, but that doesn't work either due to emoji and such. Instead, use a specialized Unicode library.

1758207799
clevor!sid649024@id-649024.hampstead.irccloud.com
https://www.joelonsoftware.com/2003/10/08/the-absolute-minimum-every-software-developer-absolutely-positively-must-know-about-unicode-and-character-sets-no-excuses/

1758207872
Pistahh!~Pistahh@user/pistahh
JetpackJackson: https://zig.news/dude_the_builder/unicode-basics-in-zig-dj3 is also a good start

1758207905
JetpackJackson!739e7f3d14@user/JetpackJackson
thanks!

1758207917
JetpackJackson!739e7f3d14@user/JetpackJackson
i have that library already, forgot it had more stuff

1758208359
donpdonp!~donp@donp.org
Pistahh: interesting link, thx

1758208395
donpdonp!~donp@donp.org
"Note that codePointWidth returns an i3 because code points like backspace have width -1." a width of -1. /me slaps forehead

1758208478
JetpackJackson!739e7f3d14@user/JetpackJackson
hmm i added code that should return the right length but its not changing even though i have that same code in my test that works

1758208523
JetpackJackson!739e7f3d14@user/JetpackJackson
https://zigbin.io/cc3f6c

1758208846
JetpackJackson!739e7f3d14@user/JetpackJackson
Am I using the wrong set of code?

1758209639
JetpackJackson!739e7f3d14@user/JetpackJackson
Oh maybe I need to do displaywidth padright

1758217822
andrewrk!~andrewrk@mail.ziglang.org
clevor: re: Allocator interface - are you aware that it used to work like that (with @feldParentPtr)?

1758217838
clevor!sid649024@id-649024.hampstead.irccloud.com
I wasn't aware.

1758218175
ezzieyguywuf!~Unknown@user/ezzieyguywuf
I wrote this small program for messing around with ethernet stuff https://pastebin.com/raw/hxT8k8fG - I'm curious if anyone could provide like a mini code review. I'm certain there's things in here that are non-ideal or non-idiomatic, and I'd like to learn whatever best practices I'm missing

1758218474
grayhatter!~grayhatte@user/grayhatter
ezzieyguywuf: std.print.debug is for debugging, if it's something you're hoping will be reuseable, you should print to stdout. std.mem.zeros warns you not to use it, so if you have a reason, you should add that reason as a comment... (weird stuff is always a bug unless otherwise documented). Why are you doing  @cImport() and then not using it?

1758218574
grayhatter!~grayhatte@user/grayhatter
this (ioctl) is also the old way to write this code, you're "supposed" to use netlink these days. And once I figured out the communication packet api, I have to say, I do like netlink a lot better

1758219230
ezzieyguywuf!~Unknown@user/ezzieyguywuf
ah I didn't see a warning for std.mem.zeroes, I'll look closer

1758219237
grayhatter!~grayhatte@user/grayhatter
it's more idiomatic to write `@splat(0xff)` instead of `.{0xff} ** 6`. If you treat types like something helpful, and use them to explain to the compiler how you want your code to work, it's much easier to 1) find bugs, and 2) write/refactor the code. E.g. I'd write `const HwAddr = [6]u8;` && `const mac: HwAddr = ifreq.ifru.hwaddr.data[0..6].*;` then later `.dst_addr = mac,` the compiler will be your

1758219239
grayhatter!~grayhatte@user/grayhatter
friend if/when you have to change that code later

1758219246
ezzieyguywuf!~Unknown@user/ezzieyguywuf
and good call out, I can def use stdout, I was using std.print.debug just for starters

1758219277
ezzieyguywuf!~Unknown@user/ezzieyguywuf
grayhatter: I haven't heard of netlink, I will take a look at that too. I'm just trying to do 'low level ethernet stuff', so whatever the best right way to do that I'm down

1758219279
grayhatter!~grayhatte@user/grayhatter
ezzieyguywuf: that's the only reason I mentioned, I forget to replace them all myself once I have something working

1758219301
ezzieyguywuf!~Unknown@user/ezzieyguywuf
ahh I figured there was a better way than .{0xff} ** 6

1758219312
grayhatter!~grayhatte@user/grayhatter
I'm sure my network lib code has some debug.print() that I should have changed to stdout.print, lol

1758219356
ezzieyguywuf!~Unknown@user/ezzieyguywuf
lol

1758219401
grayhatter!~grayhatte@user/grayhatter
if you wanted to be really fancy, you could write `const HardwareMac = enum (u48) { _, };`

1758219508
grayhatter!~grayhatte@user/grayhatter
I was not an advocate of this syntax, until decl literals showed up

1758219556
ezzieyguywuf!~Unknown@user/ezzieyguywuf
hm, is this "fancy" or "idiomatic"?

1758219625
grayhatter!~grayhatte@user/grayhatter
it's both

1758219702
grayhatter!~grayhatte@user/grayhatter
it's fancy when you use @intFromEnum()/@enumFromInt(), but it's idiomatic when you exposed a function to express the idea very cleanly. E.g. std.Io.Limit

1758219899
grayhatter!~grayhatte@user/grayhatter
`reader.allocRemaining(allocator, .limited(max_alloc_size))` vs `reader.allocRemaining(allocator, .unlimited);` is still a new enough pattern that I've yet to see it used in the wild (outside of stdlib obviously), so, maybe I shouldn't call it idiomatic yet... but it's **so** nice to use that it's only a matter of time now

1758220297
grayhatter!~grayhatte@user/grayhatter
fits well as a TTL number too https://srctree.gr.ht/repo/dns/commit/410f3c93?inline=false

1758220363
grayhatter!~grayhatte@user/grayhatter
though I probably should add a minutes() function too

1758221860
netvor!~netvor@2a00:ca8:a1f:cd0:2b85:8de7:55b:170c
what, `Limit = enum(usize)` ?  that's really interesting

1758222253
grayhatter!~grayhatte@user/grayhatter
netvor: if this doesn't answer it, ask your question again with more context

1758222285
grayhatter!~grayhatte@user/grayhatter
it's an enum (which to the CPU is just a number)  the size of a usize

1758222351
grayhatter!~grayhatte@user/grayhatter
oh, or completely ignore that if you meant what as an exclimation, instead of "what is" as a question

1758222353
netvor!~netvor@2a00:ca8:a1f:cd0:2b85:8de7:55b:170c
well that was not meant as a question, that was just me being surprised :) and kind of nerd-sniped

1758222407
grayhatter!~grayhatte@user/grayhatter
lol, yeah I was pretty sure you knew sized enums sorry, my brain inserted the "s", sorry about that

1758222450
netvor!~netvor@2a00:ca8:a1f:cd0:2b85:8de7:55b:170c
i can envision something like `const Char = enum(u8) { nul = 0, lf = 0x0a ... }` being useful when parsing bytes

1758222520
Gliptic!~glip@2a01:4f8:c012:91f3::1
it's useful for type safety

1758222557
netvor!~netvor@2a00:ca8:a1f:cd0:2b85:8de7:55b:170c
yeah i was also thinking of things like currency or inches vs cm, etc.

1758222594
Gliptic!~glip@2a01:4f8:c012:91f3::1
the annoyance with that is arithmetic ops no longer work

1758222604
grayhatter!~grayhatte@user/grayhatter
I basically do that for chars, etc in a few projects, if the token is a valid ascii char, you can cast the enum to the u8, otherwise it's something like .left_arrow

1758222620
netvor!~netvor@2a00:ca8:a1f:cd0:2b85:8de7:55b:170c
oh, that's certainly "too much safety" i guess :D

1758222658
netvor!~netvor@2a00:ca8:a1f:cd0:2b85:8de7:55b:170c
the ops not working, that is

1758222702
grayhatter!~grayhatte@user/grayhatter
in cases where I'd use it, I think I'd rather them not work

1758222705
bblack!~bblack@wikimedia/bblack-WMF
yeah but you could use them at the interface edge of something, and then unwrap to uwhatever for internal operations.

1758222724
bblack!~bblack@wikimedia/bblack-WMF
then at least for callers, they're not mixing up different kinds of usizes in various interfaces

1758222726
grayhatter!~grayhatte@user/grayhatter
something_in_meters += something_in_centermeters

1758222743
Gliptic!~glip@2a01:4f8:c012:91f3::1
but meters + meters doesn't work either

1758222776
Gliptic!~glip@2a01:4f8:c012:91f3::1
one reason I'm not really fully on-board with the "operator overloading bad" stuff

1758222783
bblack!~bblack@wikimedia/bblack-WMF
you could define an "fn add()"

1758222788
netvor!~netvor@2a00:ca8:a1f:cd0:2b85:8de7:55b:170c
on a second thought, i think for unit safety a simple struct `Cm = { value: f32};` still wins, as it works for any primitive type

1758222808
grayhatter!~grayhatte@user/grayhatter
`something_in_meters.add(something_in_cm)` <- compile error `something_in_meters.addCm(something_in_cm)` <- will be reduced to the mov,add instructions by the compiler, so who cares?

1758222817
netvor!~netvor@2a00:ca8:a1f:cd0:2b85:8de7:55b:170c
but heay you would want separate fn's for arithmetic ops in both cases

1758222821
Gliptic!~glip@2a01:4f8:c012:91f3::1
now you've broken generics

1758222834
bblack!~bblack@wikimedia/bblack-WMF
I'm not a fan of operator overloading though.  even if the alternative is painful.  operator overloading hides deep things that matter.

1758222886
Gliptic!~glip@2a01:4f8:c012:91f3::1
in this things it hides no deep things that matter

1758222888
grayhatter!~grayhatte@user/grayhatter
Gliptic: I didn't specify the types, but you could always meters.add(CentimeterType, something_cm)

1758222890
Gliptic!~glip@2a01:4f8:c012:91f3::1
*in this case

1758222950
bblack!~bblack@wikimedia/bblack-WMF
mostly I find myself liking the enum-based types when math doesn't make a ton of sense anyways, so far.  places in my code where I have, for example, 5 different "u32" indices running around, that index different kinds of things that I don't want to mix up.

1758222967
grayhatter!~grayhatte@user/grayhatter
Gliptic: for this theroitical case, I agree, but I assume I could imagine a real world care where there's something deep that does matter where it's better not to try to hide that under some abstration

1758223039
grayhatter!~grayhatte@user/grayhatter
yeah, I agree with bblack, it's much nicer to use when any math is rare. If you have something that's gonna take a lot of operations, then you should leave it as it's int type.

1758223064
Gliptic!~glip@2a01:4f8:c012:91f3::1
but that's because it sucks for math things :P, if it didn't you could use it for that in a nice way

1758223086
bblack!~bblack@wikimedia/bblack-WMF
if I read "const x = a + b;", I don't want it hidden from me that "+" in fact might mean "invoke a giant function that instantiates a page_allocator inside itself and writes stuff to stderr along the way for fun"

1758223099
Gliptic!~glip@2a01:4f8:c012:91f3::1
there is no giant function

1758223105
grayhatter!~grayhatte@user/grayhatter
TTL.expires() is a good example where the math is kinda rare" but the code is much harder to mess up now.... I can't count the number of times I've reverse the gt,lt comparision on some date based thing

1758223106
bblack!~bblack@wikimedia/bblack-WMF
but if I read "const x = a.add(b);", I know I might need to look and see :)

1758223170
netvor!~netvor@2a00:ca8:a1f:cd0:2b85:8de7:55b:170c
if i read `cons x = a + b` in c++ i know i might need to look and see as well.  (except i have no idea where)

1758223208
Gliptic!~glip@2a01:4f8:c012:91f3::1
if there was a way to enable the arithmetic ops for enums or equivalent way to define typed integers, that'd be half-way there

1758223216
bblack!~bblack@wikimedia/bblack-WMF
yeah maybe

1758223261
bblack!~bblack@wikimedia/bblack-WMF
I think maybe (and I haven't thought this through fully!) it might be a reasonable proposal to say that math ops should work on enum types like these, iff both are of the same exact wrapper-type.

1758223269
Gliptic!~glip@2a01:4f8:c012:91f3::1
I've tried implementing generics that works for both + and .add, but it's very horrible

1758223270
bblack!~bblack@wikimedia/bblack-WMF
I just don't know if it's realistic or efficient to support that.

1758223337
Gliptic!~glip@2a01:4f8:c012:91f3::1
bblack: I don't think you'd want that in general, if the enum is not in fact "numeric", which isn't necessarily the case just because you specify the integer type

1758223353
bblack!~bblack@wikimedia/bblack-WMF
hmmm true

1758223381
netvor!~netvor@2a00:ca8:a1f:cd0:2b85:8de7:55b:170c
i heard somewhere that if you keep finding yourself wanting op overloading, having a simple math language where you can express your calculations in strings might be a feasible solution that's still better than overloading

1758223406
bblack!~bblack@wikimedia/bblack-WMF
(because I also have cases like that: enum types which are really just identifiers that shouldn't be math'd.  like a list of DNS RR-types"

1758223407
Gliptic!~glip@2a01:4f8:c012:91f3::1
I hate dsls

1758223407
netvor!~netvor@2a00:ca8:a1f:cd0:2b85:8de7:55b:170c
haven't seen that idea applied, though

1758223431
Gliptic!~glip@2a01:4f8:c012:91f3::1
unless the domain is actually very isolated from the rest of the code

1758223457
bblack!~bblack@wikimedia/bblack-WMF
pub const Type = enum(u16) { Zero = 0, A = 1, ... };

1758223460
Gliptic!~glip@2a01:4f8:c012:91f3::1
for one, zls has no idea how it works

1758223472
bblack!~bblack@wikimedia/bblack-WMF
^ is what my rrtypes things looks like for DNS.  it never makes sense to add those numbers together.

1758223523
netvor!~netvor@2a00:ca8:a1f:cd0:2b85:8de7:55b:170c
i mean if you have a domain where non-programmers have to check your calculations,  then i suppose DSL is still better for both sides than op overloading

1758223542
bblack!~bblack@wikimedia/bblack-WMF
maybe some new keyword or syntax for the case of a mathable enum?

1758223633
bblack!~bblack@wikimedia/bblack-WMF
const Meter = enum_mathy(usize) { _, ... }; // allows e.g. "Meter + Meter", but not "Meter + usize", nor "Meter + Centimeter"

1758223642
Gliptic!~glip@2a01:4f8:c012:91f3::1
perhaps

1758223691
netvor!~netvor@2a00:ca8:a1f:cd0:2b85:8de7:55b:170c
you have domains where arithmetic matters, and domains where other principles matter, such as inheritance.  so if you let the domain needs spill to language, you end up with c++

1758223719
bblack!~bblack@wikimedia/bblack-WMF
I don't want to end up with c++ :)

1758223916
Gliptic!~glip@2a01:4f8:c012:91f3::1
if the domain is type safety and arithmetic, I don't think it's spilling anything anywhere

1758224103
bblack!~bblack@wikimedia/bblack-WMF
for the sneaky awful syntax award: mathy non-exhaustive enums are specified by replacing the usual "_" with "+" :)

1758224112
Gliptic!~glip@2a01:4f8:c012:91f3::1
in fact C++ already has more math stuff in the language than C++ (vectors)

1758224119
Gliptic!~glip@2a01:4f8:c012:91f3::1
ehm

1758224123
Gliptic!~glip@2a01:4f8:c012:91f3::1
*zig already has

1758225647
grayhatter!~grayhatte@user/grayhatter
Gliptic: do you write code professionally, or mostly because it's cool?

1758225656
Gliptic!~glip@2a01:4f8:c012:91f3::1
both

1758225663
Gliptic!~glip@2a01:4f8:c012:91f3::1
well, not zig professionally (yet)

1758225681
grayhatter!~grayhatte@user/grayhatter
I meant more than just zig... how many years have you fixing other peoples code?

1758225717
Gliptic!~glip@2a01:4f8:c012:91f3::1
like >15 years

1758225732
Gliptic!~glip@2a01:4f8:c012:91f3::1
before that it was mostly fixing my own code

1758225736
clevor!sid649024@id-649024.hampstead.irccloud.com
lol

1758225752
grayhatter!~grayhatte@user/grayhatter
this isn't "you'll understand when you're older" thing either; I wanted to say: you know, the really nice thing about zig not having op overloading, is that `const c = a + b;` will never segv

1758225825
grayhatter!~grayhatte@user/grayhatter
but in thinking about if that observation would make sense, you'd have to have a very low opinion about the compentency of other developers.... which isn't an awareness when you write code for fun, because the people that you work with who enjoy writing code, often are never **that** bad

1758225841
Gliptic!~glip@2a01:4f8:c012:91f3::1
I don't care that much whether + specifically will segv as much as _any_ code will segv

1758225923
grayhatter!~grayhatte@user/grayhatter
I think the problem statment is more; I don't want *you* to be in control over what my code does

1758226077
grayhatter!~grayhatte@user/grayhatter
if you're library does something stupid, then I have to know about every stupid thing it does. This isn't a problem when I'm reading my code, because I don't import libs written by stupid people (or I try very very hard not to), but more when I'm working on someone elses code, because then I have to know if + is special, where I don't have to know if .add() is special, beacuse I can already see it's a

1758226079
grayhatter!~grayhatte@user/grayhatter
function call without thinking, and without needing to remember, "ok, this a + b is actually dangerous, because the library they're using was written by a gopher 3 bottles of smirnoff deep

1758226129
Gliptic!~glip@2a01:4f8:c012:91f3::1
I know the reasoning

1758226242
grayhatter!~grayhatte@user/grayhatter
> but not "Meter + usize", nor "Meter + Centimeter"

1758226400
grayhatter!~grayhatte@user/grayhatter
I would actually love this! Some case where you have `const Something = usize; const Other = usize;`  then `const c = @as(Something, 5) + @as(Other, 5);` would be a compile error. Yes, enums work that way, but `@enumFromint(@intFromEnum(.five) + @intFromEnum(.five));` is ugly

1758226410
grayhatter!~grayhatte@user/grayhatter
I want my code to loop pretty damnit :D

1758228591
noam!81879d1ffa@2a03:6000:1812:100::dfc
grayhatter: horrible idea: a mechanism that allows operator overloading and similar dangerous features but only by people whose public keys you've signed XD

1758228608
noam!81879d1ffa@2a03:6000:1812:100::dfc
It's a web-of-trust, but instead of 'trustworthiness', it's about establishing _basic competency!_

1758228631
noam!81879d1ffa@2a03:6000:1812:100::dfc
"You need a special license to use operator overloading"

1758233311
Xellophane!~weechat@208.184.105.69
exit

1758234744
bblack!~bblack@wikimedia/bblack-WMF
noam: the difference is that in the Meter+Meter examples, nobody gets to write a custom "fn +()".  the compiler still treats it as usize+usize if that's the underlying type of Meter's enum.  It just doesn't let you mix math with kinds of usizes.

1758234993
noam!81879d1ffa@2a03:6000:1812:100::dfc
Ah, yeah

1758235094
bblack!~bblack@wikimedia/bblack-WMF
I'm digging through existing proposals now, surely someone's proposed this before

1758235106
clevor!sid649024@id-649024.hampstead.irccloud.com
`fn @"+"(lhs: Meter, rhs: anytype) Meter {return switch (@TypeOf(rhs)) {…};}`

1758235447
noam!81879d1ffa@2a03:6000:1812:100::dfc
Don't be clever, it's one of the first rules of good engineering

1758235540
bblack!~bblack@wikimedia/bblack-WMF
it's a paradox though, because interesting engineers love to be clever even though it's terrible to be too-clever :P

1758235603
grayhatter!~grayhatte@user/grayhatter
no

1758235615
grayhatter!~grayhatte@user/grayhatter
cleverness is plain good engineering

1758235737
andrewrk!~andrewrk@mail.ziglang.org
`plus` is easier to input than `@"+"` (including external tools such as grep)

1758235776
grayhatter!~grayhatte@user/grayhatter
I can cite so many more examples of clever engineering that's good than I can cite for generic "good engineering"... ignoring the inherent sample bias in said claim, instead I'll point out cleverness that respects "least surprise" is the kinda that tends to withstand the test of time

1758235872
grayhatter!~grayhatte@user/grayhatter
wow, I'm disapointed in myself I've only used add() and have never considered `pub fn plus(self: Self, other: Self)`

1758236848
clevor!sid649024@id-649024.hampstead.irccloud.com
noam: but imclevor

1758237414
bblack!~bblack@wikimedia/bblack-WMF
hmmm I couldn't find an existing proposal for this idea about allowing math on some enums.  even assuming it makes some kind of logical sense in the big picture of things, I have a sneaking suspicion it might be too-costly to implement it well.  What do you do with two matching enum definitions with different names? what about aliased names for the same type? etc.

1758237465
bblack!~bblack@wikimedia/bblack-WMF
but it's bugging my brain enough, maybe I'll poke around in the zig code and see how quickly it becomes infeasible or not.

1758237518
bblack!~bblack@wikimedia/bblack-WMF
there's a lot I don't know in there.  poking around will be informative anyways, and then I'd already know the answer to that kind of question in the future :)

