1761869081
karhunkynsi!~user@user/karhunkynsi
Hello everyone! Noob here. I'm attempting to get the second/proper fibonacci program running from this comment by mlugg, https://github.com/ziglang/zig/pull/25592#issuecomment-3419917850

1761869100
karhunkynsi!~user@user/karhunkynsi
But i'm failing to create the Io instance i think. Here's my attempt, https://godbolt.org/z/jM1v4hEYr

1761869104
karhunkynsi!~user@user/karhunkynsi
Anyone can help?

1761871440
torque!~tachyon@user/torque
well, it's not going to work on 0.15.1

1761871525
torque!~tachyon@user/torque
there's also no "juicy main" currently as far as I know so you can't just specify Io as a parameter to main, you need to construct it yourself

1761871719
torque!~tachyon@user/torque
hmm, even zig trunk on godbolt might be a bit old for this

1761872156
torque!~tachyon@user/torque
in fact the most recently published master build on nightly seem to not have the new io in the stdlib either?

1761872259
karhunkynsi!~user@user/karhunkynsi
Oh!

1761872318
karhunkynsi!~user@user/karhunkynsi
How would you construct the Io though?

1761872559
torque!~tachyon@user/torque
https://andrewkelley.me/post/zig-new-async-io-text-version.html

1761872582
torque!~tachyon@user/torque
you can look at the examples here which are hopefully not out of date given they were posted yesterday

1761872789
karhunkynsi!~user@user/karhunkynsi
Great, thank you!

1761874840
GreaseMonkey!greaser@user/greasemonkey
`zig std` is borked in latest Git due to it still using `std.net.Address` and some other things, having a look into how one would fix this

1761874894
GreaseMonkey!greaser@user/greasemonkey
...maybe it'll be better if i do a bug report and leave this part as an educational exercise as i suspect there will still be a bit of API breakage

1761875357
GreaseMonkey!greaser@user/greasemonkey
ok, report made as GH-25770, i'll continue learning std.Io the hard way

1761881701
clevor!sid649024@id-649024.hampstead.irccloud.com
When compiling a naked function with an input register using the C backend and compiling it with `zig cc`, I get the error "non-ASM statement in naked function is not supported"

1761887273
clevor!sid649024@id-649024.hampstead.irccloud.com
When I saw "jp <blah>" in the assembly of my f32 question, I confused it with Z80's `jp` and didn't realize it was a conditional jump.

1761887924
mortmann!~mortmann@p5dcb2ca4.dip0.t-ipconnect.de
from z80 to zig - nice journey

1761903372
netvor!~netvor@2a00:ca8:a1f:cd0:5881:d6e1:8586:8bde
are there no release notes for 0.15.2 ? do i want to upgrade from 0.15.1?

1761903558
netvor!~netvor@2a00:ca8:a1f:cd0:5881:d6e1:8586:8bde
ah i missed the milestone link in the "released" news item.   https://ziggit.dev/t/zig-0-15-2-released/12466  proper human-to-human RN would be nice but nevermind .. :)

1761921631
yabobay!~pizza@2a02:85f:fcd5:1601:439e:d9b3:6a5d:d567
what's the recommended way to return an error with additional information? like a FileNotFound but with a string saying *what* file wasn't found

1761926937
reykjalin!7e28cf3a41@user/reykjalin
yabobay: to the best of my knowledge it’s not something you can do by retuning an error, but you might be able to hack it together using something like a struct { error: error.FileNotFound, file_name: []const u8 }. not sure if it’s allowed to include errors in a struct like that though 

1761926952
reykjalin!7e28cf3a41@user/reykjalin
is there a reason the caller won’t know which file failed to open?

1761926988
reykjalin!7e28cf3a41@user/reykjalin
I’d strongly suggest trying to work with the way zig errors work instead of against them with a struct like the one I proposed 

1761927330
yabobay!~pizza@2a02:85f:fcd5:1601:439e:d9b3:6a5d:d567
well i'm passing a list of multiple filenames to my function

1761927352
yabobay!~pizza@2a02:85f:fcd5:1601:439e:d9b3:6a5d:d567
i don't think it makes sense to check them before calling since i can find out inside the function

1761927397
torque!~tachyon@user/torque
the typical technique is to use a diagnostics out-parameter

1761927404
torque!~tachyon@user/torque
this is how std.json does it, I believe

1761927475
torque!~tachyon@user/torque
I do think this is one of the most unfortunate limitations of zig's otherwise great error handling, but designing errors differently would certainly make a different set of tradeoffs

1761927795
yabobay!~pizza@2a02:85f:fcd5:1601:439e:d9b3:6a5d:d567
hm, i think i'll do the out parameter

1761931871
src!~src@user/src
am I stupid here shouldn't this work? https://dpaste.com/3VMVFJJK5 tried w/ master and zig-0.15.2

1761931930
src!~src@user/src
haven't changed a single thing after `zig init`, `main.zig` is https://dpaste.com/AFQ8TBR97

1761931935
palanix!~palanix@2a02:3100:5e57:4e00:e65f:1ff:fe56:5b8
src: no this shouldn't work. What exactly are you even trying to do?

1761931995
src!~src@user/src
follow the book 'introduction to zig', why wouldn't the sample code you have after `zig init` compile?!

1761932054
palanix!~palanix@2a02:3100:5e57:4e00:e65f:1ff:fe56:5b8
Oh i see now. the module is defined in the zig build system. just run it with `zig build` and it will work

1761932081
src!~src@user/src
but then main isn't executable

1761932082
src!~src@user/src
bash: ./main: cannot execute binary file: Exec format error

1761932104
Gliptic!~glip@2a01:4f8:c012:91f3::1
what's your build.zig

1761932126
palanix!~palanix@2a02:3100:5e57:4e00:e65f:1ff:fe56:5b8
the executable should be inside `zig-out/bin/aa_helloWorld`

1761932126
torque!~tachyon@user/torque
`zig build` will output executables to `./zig-out/bin` by default, is that where you're looking?

1761932191
src!~src@user/src
nope I didn't I thought `main` in root was it, but that was from the failed `zig build-exe` command

1761932201
src!~src@user/src
after `zig build` the one in `./zig-out/bin` works 

1761932230
Gliptic!~glip@2a01:4f8:c012:91f3::1
hm, strange that it would create anything in the root after build fails

1761932231
src!~src@user/src
Gliptic: not relevant anymore but also the default after `zig init` https://dpaste.com/2NTKCMQLK

1761932339
src!~src@user/src
Gliptic: yeah thought the same, but it does https://dpaste.com/6QKPE7BYX

1761932365
src!~src@user/src
anywho, solved to the point where I can keep going, thanks

1761932376
src!~src@user/src
:)

1761932697
grayhatter!~grayhatte@user/grayhatter
netvor: yeah, reading that made me sad too... But to be fair, patch version increments shouldn't need to inculde release notes above `git shortlog` This case is an unfortunate case where an API change was made to fix an existing bug. 

1761934472
tlewin!~tlewin@user/tlewin
Hi, I have this callback in my prototype: comptime callback: fn (*ContextType, *const ChequersPlay, bool) callconv(.@"inline") Allocator.Error!bool

1761934498
tlewin!~tlewin@user/tlewin
The fact I added callconv(.@"inline") does affect anything?

1761934550
tlewin!~tlewin@user/tlewin
I mean, does it tell to the compiler to inline the callback in the function?

1761935150
Gliptic!~glip@2a01:4f8:c012:91f3::1
I assume it only allows inline functions to be passed

1761935167
Gliptic!~glip@2a01:4f8:c012:91f3::1
`inline fn` in zig means more than just the function being inlined

1761935257
Gliptic!~glip@2a01:4f8:c012:91f3::1
https://ziglang.org/documentation/0.15.2/#inline-fn

1761935613
tlewin!~tlewin@user/tlewin
Gliptic: Thanks for the link! And indeed tthe compiler forces the callbacks to be declared as inline, but do you think, in this scenario, does it have any implication?

1761936004
Gliptic!~glip@2a01:4f8:c012:91f3::1
I think it will work exactly the same as if you called an inline fn directly

1761936014
Gliptic!~glip@2a01:4f8:c012:91f3::1
but have not verified this hypothesis

1761936175
Gliptic!~glip@2a01:4f8:c012:91f3::1
I assume it's not going to compile if `callback` isn't comptime

1761936223
tlewin!~tlewin@user/tlewin
Gliptic: All the callbacks are static

1761936291
tlewin!~tlewin@user/tlewin
And my intention is they will inlined, but I could verify this hypothesis. I created a toy example to check the assembly, but I am not so good at it

1761936301
tlewin!~tlewin@user/tlewin
*couldn't

1761936579
grayhatter!~grayhatte@user/grayhatter
...an inline callback 

1761936698
tlewin!~tlewin@user/tlewin
grayhatter: Any insight? :-)

1761936726
grayhatter!~grayhatte@user/grayhatter
I feel like callback is the wrong pattern here, but I'm unsure how to best explain it

1761936778
tlewin!~tlewin@user/tlewin
I have the following use case: I am creating a backgammon engine and I have function to generate all the possible moves for a given position

1761936780
Gliptic!~glip@2a01:4f8:c012:91f3::1
hard to tell without knowing more details

1761936812
Gliptic!~glip@2a01:4f8:c012:91f3::1
yet your callback has a Chequers parameter, curious...

1761936813
grayhatter!~grayhatte@user/grayhatter
the compiler has to know the function at comptime to make it an inline function, so given the complexity introduces using callbacks, if you could know enough about the call stack to inline it, you'd also be able to avoid using a callback

1761936826
tlewin!~tlewin@user/tlewin
Then I need to specialize this function for 2 other use cases: to check whether a given move is valid or if there is any valid move available

1761936899
tlewin!~tlewin@user/tlewin
grayhatter: That's why I defined the callback as comptime

1761936924
grayhatter!~grayhatte@user/grayhatter
if you know all valid moves, you can check if move in valid_moves or valid_moves.len == 0 

1761936964
tlewin!~tlewin@user/tlewin
grayhatter: But I didn't want to allocate memory for these 2 use cases, only when I need to list all the moves

1761936976
Gliptic!~glip@2a01:4f8:c012:91f3::1
you probably want a way to immediately check if it's a valid move, as well as have a way to generate valid moves

1761937026
grayhatter!~grayhatte@user/grayhatter
you don't wanna allocate for the theoritical challenge, or because you're concerned about perf?

1761937026
tlewin!~tlewin@user/tlewin
To list all the moves, I don't mind to allocate memory, but for the other 2 use cases, I would prefer not to

1761937066
tlewin!~tlewin@user/tlewin
grayhatter: Kind of both

1761937106
tlewin!~tlewin@user/tlewin
If it's really need to allocate then it's okay, but I thought by defining the callbacks as comptime the compiler is able to specialize in 3 different functions

1761937119
tlewin!~tlewin@user/tlewin
But I am not sure if I am being too optimistic

1761937146
grayhatter!~grayhatte@user/grayhatter
I wouldn't use callbacks here, I'd just use a normal fn call, and a switch

1761937164
grayhatter!~grayhatte@user/grayhatter
you know the functions at comptime, don't use runtime callbacks

1761937174
Gliptic!~glip@2a01:4f8:c012:91f3::1
I usually pass a struct with a method in these cases

1761937196
Gliptic!~glip@2a01:4f8:c012:91f3::1
grayhatter: it's comptime and callconv(.@"inline") though, won't it be semantically inlined

1761937214
grayhatter!~grayhatte@user/grayhatter
^ or that.... which also gives the advantage of all the compiler optimizations to figure out which will actually be faster

1761937218
Gliptic!~glip@2a01:4f8:c012:91f3::1
otherwise I don't see the point of callconv(.@"inline")'s existence

1761937225
Gliptic!~glip@2a01:4f8:c012:91f3::1
grayhatter: well, that's what he was doing already :P

1761937265
grayhatter!~grayhatte@user/grayhatter
Gliptic: unless I'm missing something (likely) a comptime callback is a comptime static vtable with extra steps, it's only adding code complexity

1761937303
Gliptic!~glip@2a01:4f8:c012:91f3::1
well

1761937319
Gliptic!~glip@2a01:4f8:c012:91f3::1
except it's not really extra steps, is it

1761937345
Gliptic!~glip@2a01:4f8:c012:91f3::1
the only other way I can think of is passing a struct { pub fn run() { ... } } thing

1761937354
grayhatter!~grayhatte@user/grayhatter
callback + inline feels to me like saying, I want my 18wheel trailer truck to run nitrous so it can be faster

1761937366
Gliptic!~glip@2a01:4f8:c012:91f3::1
as a "callback: type", and callback.run(...)

1761937386
Gliptic!~glip@2a01:4f8:c012:91f3::1
plus `inline`

1761937404
tlewin!~tlewin@user/tlewin
Gliptic: inline the function run?

1761937407
Gliptic!~glip@2a01:4f8:c012:91f3::1
yeah

1761937413
Gliptic!~glip@2a01:4f8:c012:91f3::1
pub fn inline run() { ... }

1761937416
Gliptic!~glip@2a01:4f8:c012:91f3::1
but it's not less code

1761937430
Gliptic!~glip@2a01:4f8:c012:91f3::1
afaik

1761937438
tlewin!~tlewin@user/tlewin
The amount of code doesn't bother me

1761937453
Gliptic!~glip@2a01:4f8:c012:91f3::1
it seemed to bother grayhatter, or code complexity

1761937467
Gliptic!~glip@2a01:4f8:c012:91f3::1
but I'm not seeing how the fn() parameter is more complex

1761937519
tlewin!~tlewin@user/tlewin
To be honest, I didn't understand the comptime static vtable 

1761937526
tlewin!~tlewin@user/tlewin
I am new to the language

1761937532
grayhatter!~grayhatte@user/grayhatter
complexity makes both code and development slower

1761937546
Gliptic!~glip@2a01:4f8:c012:91f3::1
but what's complex about it

1761937569
Gliptic!~glip@2a01:4f8:c012:91f3::1
tlewin: it's not really a vtable, just one function

1761937637
grayhatter!~grayhatte@user/grayhatter
Gliptic: switch (generate_moves_kind) { .all_moves => some_inline_fn(), ..., } vs if (thing) generated_moves_kind.inline_callback(); 

1761937665
grayhatter!~grayhatte@user/grayhatter
Gliptic: if it's just one function, (and not different functions) why callback? why not call with a simple return?

1761937667
tlewin!~tlewin@user/tlewin
This is the module: https://dpaste.com/7JNA2PLN2

1761937693
tlewin!~tlewin@user/tlewin
I am still improving the code

1761937741
grayhatter!~grayhatte@user/grayhatter
tlewin: welcome to the langauge :) some maybe helpful context Gliptic and I like to argue about code because it's interesting to learn the different perspectives, it's not a right or wrong thing

1761937757
grayhatter!~grayhatte@user/grayhatter
just in case it wasn't obvious

1761937765
tlewin!~tlewin@user/tlewin
grayhatter: Don't worry! I appreciate the discussion :-) 

1761937776
tlewin!~tlewin@user/tlewin
It's a good opportunity for me to learn more

1761937860
Gliptic!~glip@2a01:4f8:c012:91f3::1
grayhatter: well, for one, callback is called in a bunch of places

1761937921
tlewin!~tlewin@user/tlewin
Gliptic: Backgammon has a bunch of excpetions and to generate all the moves is a bit annoying

1761937925
Gliptic!~glip@2a01:4f8:c012:91f3::1
so it makes to put the logic in the chose of callback than copying a switch all over

1761937936
Gliptic!~glip@2a01:4f8:c012:91f3::1
*makes sense

1761937941
Gliptic!~glip@2a01:4f8:c012:91f3::1
*choice

1761937948
grayhatter!~grayhatte@user/grayhatter
this doesn't need to be a callback, this can just return to the callers

1761938020
Gliptic!~glip@2a01:4f8:c012:91f3::1
return to the caller when?

1761938024
Gliptic!~glip@2a01:4f8:c012:91f3::1
that depends on what you want to do

1761938047
Gliptic!~glip@2a01:4f8:c012:91f3::1
it's used both for listing all moves and for checking if a move is valid

1761938077
Gliptic!~glip@2a01:4f8:c012:91f3::1
or for checking whether there's any move at all

1761938087
Gliptic!~glip@2a01:4f8:c012:91f3::1
so at least three purposes

1761938105
Gliptic!~glip@2a01:4f8:c012:91f3::1
two of those can be short-circuited

1761938112
Gliptic!~glip@2a01:4f8:c012:91f3::1
and don't need to allocate extra memory

1761938180
tlewin!~tlewin@user/tlewin
Gliptic: indeed. I would like to halt the computation once I find any move or when I find the played move

1761938202
Gliptic!~glip@2a01:4f8:c012:91f3::1
sure, you could have an function that contains a switch with these three cases that you call everywhere the callback is called, but how is that actually simpler

1761938206
Gliptic!~glip@2a01:4f8:c012:91f3::1
*a function

1761938221
Gliptic!~glip@2a01:4f8:c012:91f3::1
(sorry for the typos, I'm a pit tipsy)

1761938273
tlewin!~tlewin@user/tlewin
Gliptic: It's Friday

1761938283
Gliptic!~glip@2a01:4f8:c012:91f3::1
indeed it is

1761938359
Gliptic!~glip@2a01:4f8:c012:91f3::1
s/pit/bit

1761938362
Gliptic!~glip@2a01:4f8:c012:91f3::1
case in point

1761938366
grayhatter!~grayhatte@user/grayhatter
the more ziggy way to express this, would be to turn generate_all_chequers_plays from a function, into an iterator struct, and instead of using a callback, callers can iterate over it, clone/append the result into the list, compare equality, or return false if iter.first() returns false

1761938386
Gliptic!~glip@2a01:4f8:c012:91f3::1
iterators can be much more annoying to write

1761938400
Gliptic!~glip@2a01:4f8:c012:91f3::1
in zig anyway

1761938405
grayhatter!~grayhatte@user/grayhatter
that way generate_all_chequers_plays depends on no external context and can be written much simpler (and thus faster)

1761938440
Gliptic!~glip@2a01:4f8:c012:91f3::1
press X to doubt

1761938448
grayhatter!~grayhatte@user/grayhatter
Gliptic: I disagree, an iterator is easier for me to reason about than a callback... but that's IMHO, I could totally be convinced another pattern would be easier to write

1761938464
Gliptic!~glip@2a01:4f8:c012:91f3::1
that doesn't mean it's easier to write

1761938483
grayhatter!~grayhatte@user/grayhatter
well, doing it my way, is_cancelable wouldn't need to be a param

1761938497
grayhatter!~grayhatte@user/grayhatter
that's a detail the move generation could wouldn't need to know about

1761938532
Gliptic!~glip@2a01:4f8:c012:91f3::1
I don't know why it's a parameter anyway

1761938561
tlewin!~tlewin@user/tlewin
One constraint that I have is  that generate_all_moves has to be very efficient. On top of the engine, I am training an AI to play the game and I have to generate millions of scenarions

1761938603
grayhatter!~grayhatte@user/grayhatter
callbacks, generally, prevent the compiler from optimizing that code

1761938604
Gliptic!~glip@2a01:4f8:c012:91f3::1
in rust I would definitely go for the iterator as there's `yield`

1761938615
Gliptic!~glip@2a01:4f8:c012:91f3::1
grayhatter: except it's inline fn :)

1761938615
grayhatter!~grayhatte@user/grayhatter
ditto with inline, using it might result in worse code

1761938616
tlewin!~tlewin@user/tlewin
Another thing, in backgammon there is the rollouts, so when one wants to be certain which move to play, then you play the same position thounsands of times 

1761938629
tlewin!~tlewin@user/tlewin
In a tight loop

1761938640
grayhatter!~grayhatte@user/grayhatter
I have no idea what the implications for an inline callback would be...

1761938641
Gliptic!~glip@2a01:4f8:c012:91f3::1
an iterator is harder to optimize in other ways

1761938648
Gliptic!~glip@2a01:4f8:c012:91f3::1
because it depends on extra state

1761938681
Gliptic!~glip@2a01:4f8:c012:91f3::1
you may hope that the compiler optimizes to the same thing as the inline callback version

1761938701
grayhatter!~grayhatte@user/grayhatter
Gliptic: not nearly as much when it's in a tight loop

1761938734
Gliptic!~glip@2a01:4f8:c012:91f3::1
that might be the case if there were only one callback call in the function

1761938743
Gliptic!~glip@2a01:4f8:c012:91f3::1
but now the callback is called in different places

1761938767
grayhatter!~grayhatte@user/grayhatter
intuition based on nothing but wild speculation, would have me assuming you'd ruin the cacheline using a callback more often than an iterator

1761938785
grayhatter!~grayhatte@user/grayhatter
I would write both versions, and test it with poop

1761938814
tlewin!~tlewin@user/tlewin
grayhatter: But my hope is that the compiler would generate 3 versions of the function given the callbacks are comptime defined

1761938824
tlewin!~tlewin@user/tlewin
And inlined as well

1761938825
Gliptic!~glip@2a01:4f8:c012:91f3::1
I agree due to instruction cache the iterator may be better, but it's far from obvious

1761938834
Gliptic!~glip@2a01:4f8:c012:91f3::1
it'll be more annoying to write for sure

1761938843
Gliptic!~glip@2a01:4f8:c012:91f3::1
as you have to manually write the state machine

1761938874
tlewin!~tlewin@user/tlewin
If my assumption is right, then there would be no cache invalidation 

1761938880
grayhatter!~grayhatte@user/grayhatter
tlewin: having three versions of the same function that do exactly the same thing, but exit at points where the compiler can't predict, is likely to be suboptimal for speed

1761938918
Gliptic!~glip@2a01:4f8:c012:91f3::1
but they aren't doing the same thing

1761938925
tlewin!~tlewin@user/tlewin
grayhatter: But then we assume that the compiler is not specializing the functions

1761938938
Gliptic!~glip@2a01:4f8:c012:91f3::1
and it's better that they are separate because they behave differently

1761938954
grayhatter!~grayhatte@user/grayhatter
append to list, check equality and discard, return if first result is zero, everything else is the same, no?

1761938964
Gliptic!~glip@2a01:4f8:c012:91f3::1
only one of them appends to a list

1761938970
Gliptic!~glip@2a01:4f8:c012:91f3::1
the one that's generating all moves

1761938980
grayhatter!~grayhatte@user/grayhatter
*shrug*

1761939021
Gliptic!~glip@2a01:4f8:c012:91f3::1
it's of course more performant to make a fully custom "is valid" checker

1761939032
Gliptic!~glip@2a01:4f8:c012:91f3::1
but sounds like it's annoying

1761939038
grayhatter!~grayhatte@user/grayhatter
I've never seen performance optimized code written using callbacks, perhaps that heuristic doesn't apply, but at this point, I'm still unconvinced, so I'd say write both and test it instead of speculating

1761939040
Gliptic!~glip@2a01:4f8:c012:91f3::1
I never bothered to learn backgammon

1761939097
tlewin!~tlewin@user/tlewin
grayhatter: I will benchmark for sure. Do you have any reference on how to write an iterator in Zig? Just for me to see the challenge

1761939132
tlewin!~tlewin@user/tlewin
Gliptic: It's a fun game. Easy to learn, but hard to master

1761939141
grayhatter!~grayhatte@user/grayhatter
std.mem.split or std.mem.tokenize

1761939151
tlewin!~tlewin@user/tlewin
grayhatter: Thanks

1761939177
Gliptic!~glip@2a01:4f8:c012:91f3::1
an iterator is just a thing with a `fn next(self: *Iterator) ?T`

1761939201
Gliptic!~glip@2a01:4f8:c012:91f3::1
problem is you need to keep track of where you were so you can continue when next is called again

1761939216
grayhatter!~grayhatte@user/grayhatter
searching for `Iterator` in the stdlib docs webpage will give plenty of examples 

1761939222
Gliptic!~glip@2a01:4f8:c012:91f3::1
so here you need to keep track of which `if` the callback was called from

1761939242
Gliptic!~glip@2a01:4f8:c012:91f3::1
and what iteration you're on in the while loops

1761939248
Gliptic!~glip@2a01:4f8:c012:91f3::1
and probably a bunch of more state

1761939269
grayhatter!~grayhatte@user/grayhatter
std.fs.Dir.Iterator is a more complicated example with some extra state and logic 

1761939280
Gliptic!~glip@2a01:4f8:c012:91f3::1
this looks more complicated than the typical Iterator I would manually write

1761939394
tlewin!~tlewin@user/tlewin
It will be an interesting exercise

1761943865
lemons!~doggie@user/doggie-:49517
hm.. trying to get lldb_pretty_printers.py to work, having some issues

1761943954
lemons!~doggie@user/doggie-:49517
it seems to import just fine (typing the "type category enable" shows the autocompletes listed in header but hashmaps f.e keep showing up as they were before import

1761944006
Gliptic!~glip@2a01:4f8:c012:91f3::1
... .py?

1761944098
Gliptic!~glip@2a01:4f8:c012:91f3::1
right, that's what you have to do in lldb

1761944164
lemons!~doggie@user/doggie-:49517
Gliptic: https://bpa.st/GJPA

1761944175
lemons!~doggie@user/doggie-:49517
is how i have it set up currently

1761944220
lemons!~doggie@user/doggie-:49517
debug symbols work just fine so it doesnt feel like a case of not picking up std

1761944227
lemons!~doggie@user/doggie-:49517
..maybe it is, unsure

1761944271
lemons!~doggie@user/doggie-:49517
much of the lldb stuff is still a novelty to me

1761945555
lemons!~doggie@user/doggie-:49517
works now

1761951824
src!~src@user/src
https://dpaste.com/8ZCDXL4QX why can't I name an array u008array and iterate over it but d064array is fine?

1761951842
src!~src@user/src
see error at bottom, if I change the name to `uarray` for example then it works, this a bug?

1761951845
src!~src@user/src
not sure I understand

1761953429
torque!~tachyon@user/torque
arguably a bug in the parser, it's trying to parse it as like `u8` but `u08` isn't valid

1761953463
torque!~tachyon@user/torque
i would strongly recommend not giving your variables names that are redundant with their types but rather describe their semantic purpose

1761953519
torque!~tachyon@user/torque
for code that serves no purpose the classic `foo`, `bar`, `baz` etc are always a good chocie

1761953860
src!~src@user/src
obviously I'm writing small toy programs at this stage, was just wondering

1761953880
src!~src@user/src
(not even sure I'd call this a toy program)

1761953885
src!~src@user/src
(even)

1761953910
src!~src@user/src
lol

1761955009
siaal!~Siaal@user/Siaal
what's the argument against default parameters? it seems like the use case is valid, since the stdlib uses them pretty extensively through Option structs, why not omit the middleman?

1761955032
siaal!~Siaal@user/Siaal
it's upsetting when i check the function signature through the lsp, and the function signature doesn't actually tell me anything meaningful about the function parameters

