1758244228
ezzieyguywuf!~Unknown@user/ezzieyguywuf
is it typical for e.g. args[1] to be null terminated? for some reason this caught me off guard

1758244524
noam!81879d1ffa@2a03:6000:1812:100::dfc
grayhatter: there's clever and there's clever :D

1758244540
andrewrk!~andrewrk@mail.ziglang.org
and there's clevor

1758245482
clevor!sid649024@id-649024.hampstead.irccloud.com
noam: No, clever's in #nixos.

1758247612
mortmann!~mortmann@p5dcb245b.dip0.t-ipconnect.de
small grammar error ending up in langref.html https://github.com/ziglang/zig/blob/master/doc/langref/test_allowzero.zig#L5 (not worthy of making a full Issue/PR i suppose)

1758249418
andrewrk!~andrewrk@mail.ziglang.org
thank you mortmann

1758260902
deevus!~deevus@7wdf1tt0vhfbrrrfm74p.ip6.superloop.au
Call me crazy but I don't mind the new reader/writer interfaces. One thing that bothers me is the manual buffer creation. I don't have a problem with having to do it. I have a problem with choosing the right sized buffer. What is a sensible default, say for reading or writing a file?

1758261052
Amun-Ra!~amun-ra@retro.rocks
glib and python default buffer size is 8192

1758261055
Amun-Ra!~amun-ra@retro.rocks
glibc*

1758261089
grayhatter!~grayhatte@user/grayhatter
Amun-Ra: that seems like a perfectly reasonable default to me

1758261098
Amun-Ra!~amun-ra@retro.rocks
mhm

1758261110
grayhatter!~grayhatte@user/grayhatter
page size is another to consider

1758261115
Amun-Ra!~amun-ra@retro.rocks
yes

1758261354
deevus!~deevus@7wdf1tt0vhfbrrrfm74p.ip6.superloop.au
Page size is interesting.

1758261393
grayhatter!~grayhatte@user/grayhatter
the important part is not to get stuck trying to guess the right answer, just pick something half reasonable, and then find the optimal size with real data

1758261400
deevus!~deevus@7wdf1tt0vhfbrrrfm74p.ip6.superloop.au
In some cases, lets say if I was going to write a string that I used to use an ArrayList for. I would use a buffer size just big enough to fit the longest possible string

1758261435
deevus!~deevus@7wdf1tt0vhfbrrrfm74p.ip6.superloop.au
grayhatter: fair point

1758261980
grayhatter!~grayhatte@user/grayhatter
remember: if an engineer tells you that something is good or bad, without showing you data, they're not a very good engineer 

1758262240
andrewrk!~andrewrk@mail.ziglang.org
ðŸ¤”ðŸ¤”ðŸ¤”

1758262345
deevus!~deevus@7wdf1tt0vhfbrrrfm74p.ip6.superloop.au
grayhatter: It's a nice thought, but I don't think I believe this. There is so much weight in experience that is hard to convey. 

1758262603
grayhatter!~grayhatte@user/grayhatter
"is" vs "should be", and "here's the heuristic I use" are all very different contexts

1758262885
deevus!~deevus@7wdf1tt0vhfbrrrfm74p.ip6.superloop.au
I can get behind that

1758263035
grayhatter!~grayhatte@user/grayhatter
and I meant it more as a meme quoting a superfastmatt video, rather than a hard rule applicable everywhere. i.e. I was going more for the idea good or better sound nice, but good by itself is strictly less useful than some "data"

1758263112
grayhatter!~grayhatte@user/grayhatter
a 2Gb Io.Writer buffer sounds better, until you have the data that proves the app can never use more than 2kb

1758263217
deevus!~deevus@7wdf1tt0vhfbrrrfm74p.ip6.superloop.au
I'm not familiar with superfastmatt, which is probably why it whizzed passed me

1758274474
Earnest!~earnest@user/earnestly
deevus: A youtuber who more or less half arses everything he does and is then surprised it doesn't work according to plan, which is why it can be quite funny

1758274513
Earnest!~earnest@user/earnestly
(Presented in a laconic manner)

1758279475
Affliction!affliction@idlerpg/player/affliction
Hm, have a set of data definitions in the form of constant pre-initialized structs. I'd like to serialize/deserialize them by name in json, but have the live objects reference them by pointer or enum. Any recommendations?

1758279655
Affliction!affliction@idlerpg/player/affliction
json seems to not like me returning a *const in jsonParse, and I've been bashing my head against dependency loops trying to synthesize an enum at comptime

1758279693
Affliction!affliction@idlerpg/player/affliction
and, after all these hours, this bit of rubber ducking has made me thought of something simpler...

1758280236
Affliction!affliction@idlerpg/player/affliction
hm, nope

1758280245
Affliction!affliction@idlerpg/player/affliction
ah well, I'll take a break and come back to this later

1758280945
hadronized!~hadronize@2001:41d0:a:fe76::1
Hey; Iâ€™m doing some search on github / discourse etc. to check the history of payloads as part of error union sets, and all I can find is that it wonâ€™t be possible. The alternative Iâ€™ve found is passing an out pointers to set error payloads, or to use the object that might emit the error with an optional internal error payload. Is the discussion on that topic closed? IÂ feel like itâ€™s a design

1758280947
hadronized!~hadronize@2001:41d0:a:fe76::1
loophole as regular errors feel nice to use, but as soon as more info is required, like which path doesnâ€™t exist, or what request failed etc., having to resort to either a regular enum defeats the purpose (no errdefer, for instance), and using out pointers force to put payloads outside of the error enum definition, making it a bit less safe to attach payloads to different enum paths

1758282336
ifreund!2940d10f8b@user/ifreund
it's been discussed to conclusion years ago

1758282401
ifreund!2940d10f8b@user/ifreund
https://github.com/ziglang/zig/issues/2647

1758282493
Affliction!affliction@idlerpg/player/affliction
Yeah, the general zig pattern is to pass in a (perhaps optional) pointer to a Diagnostics struct you define to hold your error data.

1758282508
ifreund!2940d10f8b@user/ifreund
"error codes are for control flow"

1758282532
ifreund!2940d10f8b@user/ifreund
don't expect this to change

1758282569
Affliction!affliction@idlerpg/player/affliction
and, filling out a Diagnostics struct in an "orelse" or "catch" before you return isn't Too painful IMO

1758282651
Affliction!affliction@idlerpg/player/affliction
Though I do admit I miss the convenience of rust's .map_err and similar patterns for transforming errors, I've not had too much trouble with adapting to this method. Still much more generally elegant than C at least.

1758282815
Affliction!affliction@idlerpg/player/affliction
honestly, the one feature I'd really, really, appreciate in my current project is something like: if (union.field) |payload| {}, switches to handle one case feel a bit heavy. No idea if that's something that's been rejected, and I understand new features are unlikely to be accepted right now anyway.

1758282838
Affliction!affliction@idlerpg/player/affliction
That and if (slice[index]) |element| {} for bounds checked lookups.

1758283256
ifreund!2940d10f8b@user/ifreund
Affliction: you can do `if (foo == .bar) { ... foo.bar ... }`

1758283266
ifreund!2940d10f8b@user/ifreund
tagged unions coerce to their tag type

1758283316
Affliction!affliction@idlerpg/player/affliction
nice, close enough

1758283377
ifreund!2940d10f8b@user/ifreund
the slice thing could trivially be implemented as a function

1758283384
ifreund!2940d10f8b@user/ifreund
I don't see a need for special syntax there

1758283418
ifreund!2940d10f8b@user/ifreund
though I must say, I haven't felt the need for a more concise way to express that in zig, I guess I don't end up writing it often enough

1758283436
Affliction!affliction@idlerpg/player/affliction
a function I have indeed written, after not finding something like that in std

1758283518
ifreund!2940d10f8b@user/ifreund
not really sure if it belongs in std or not, finding examples in the compiler/standard library that would be made significantly more readable by such a function could motivate an addition

1758283529
Affliction!affliction@idlerpg/player/affliction
if (slice.len > index) { ... slice[index]; ... } isn't Too painful either

1758283555
ifreund!2940d10f8b@user/ifreund
yeah, I for one am not convinced it's necessary

1758283563
Affliction!affliction@idlerpg/player/affliction
I guess, I just like the fancy syntax. Which I guess, with zig trying to be simple, yeah ^

1758283881
Affliction!affliction@idlerpg/player/affliction
yeah, consider my mind changed. Leave the sugar, keep the simplicity :)

1758283981
ifreund!2940d10f8b@user/ifreund
:)

1758284698
hadronized!~hadronize@2001:41d0:a:fe76::1
ifreund: yeah IÂ read that issue, but was wondering whether this was reconsidered

1758284702
hadronized!~hadronize@2001:41d0:a:fe76::1
or has been reconsidered

1758284710
hadronized!~hadronize@2001:41d0:a:fe76::1
because it feels inconsistent

1758284765
ifreund!2940d10f8b@user/ifreund
hadronized: it's not being reconsidered, and it's not really up for drive-by discussion

1758284782
hadronized!~hadronize@2001:41d0:a:fe76::1
ifreund: even when facing constructive criticism?

1758284809
ifreund!2940d10f8b@user/ifreund
there's a good reason the issue is locked

1758284823
hadronized!~hadronize@2001:41d0:a:fe76::1
if you return an error like error.path_not_found, and you forget to set the path in the diagnostics out-pointer, then the code checking for the error has to check an optional, additionally to the error;Â it feels bad

1758284824
ifreund!2940d10f8b@user/ifreund
nobody has said anything new or interesting about it in a long time

1758284828
ifreund!2940d10f8b@user/ifreund
and you certainly havent yet

1758284858
ifreund!2940d10f8b@user/ifreund
anyhow, I'm clearly not interested in discussing this

1758285780
bblack!~bblack@wikimedia/bblack-WMF
hadronized: FWIW, I find as my designs get cleaner, it's really not much of a pragmatic issue.  e.g. when I get some kind of file read error, it may bubble up several layers as an error return before it reaches a higher level of abstraction where I want to emit a diagnostic a user cares about (e.g. std.log.err()), and generally up there I still have access to the reportable state that matters (e.g. the 

1758285786
bblack!~bblack@wikimedia/bblack-WMF
filename, which might be stored in some sub-struct, but still accessible).

1758286381
hadronized!~hadronize@2001:41d0:a:fe76::1
bblack: yeah IÂ see your point, yet Iâ€™m not convinced;Â I find it useful to have errors attached with values, because oftentimes, an error tag doesnâ€™t really provide any useful information to the user

1758286401
hadronized!~hadronize@2001:41d0:a:fe76::1
I do agree though that as soon as you get more complex error handling, you need something more, even in Rust with associated values

1758286406
hadronized!~hadronize@2001:41d0:a:fe76::1
for instance, accumulating errors

1758286415
hadronized!~hadronize@2001:41d0:a:fe76::1
(i.e. while parsing, compiling, etc.)

1758286457
hadronized!~hadronize@2001:41d0:a:fe76::1
it just feels a downgrade to me coming from Rust, because if you omit payloads as part of your error E in a Result<A, E>, itâ€™s identical to Zig (besides coercion, maybe)

1758292381
deadmarshal!deadmarsha@deadmarshal.nastycode.com
You can also do errors with payloads: https://www.youtube.com/watch?v=aFeqWWJP4LE&pp=ygURemlnIGVycm9yIHBheWxvYWQ%3D

1758292397
deadmarshal!deadmarsha@deadmarshal.nastycode.com
You can make your own result type too. 

1758292420
deadmarshal!deadmarsha@deadmarshal.nastycode.com
option type too. It's all possible

1758300510
longlonglongint!~longlongl@user/longlonglongint
is it possible to import a build.zig from a submodule and link against its required libraries

1758300720
torque!~tachyon@user/torque
you can just specify it as a local dependency in build.zig.zon and use it as you would use any other dependency

1758304235
longlonglongint!~longlongl@user/longlonglongint
ive made a little bit of progress but when importing the module (const mod = @import("mod")) its just empty

1758304327
longlonglongint!~longlongl@user/longlonglongint
actually maybe its because the dependency has a submodule

1758304578
longlonglongint!~longlongl@user/longlonglongint
nevermind that didnt fix it

1758305250
torque!~tachyon@user/torque
perhaps the module isn't defined correctly in the dependency build.zig?

1758305379
Gliptic!~glip@2a01:4f8:c012:91f3::1
or it has nothing in it that's pub

1758305389
longlonglongint!~longlongl@user/longlonglongint
dang

1758305393
longlonglongint!~longlongl@user/longlonglongint
i think thats it

1758305451
longlonglongint!~longlongl@user/longlonglongint
yeah that fixed that part

1758305454
longlonglongint!~longlongl@user/longlonglongint
now all thats left is linking

1758305456
longlonglongint!~longlongl@user/longlonglongint
thanks

1758311648
hadronized!~hadronize@2001:41d0:a:fe76::1
deadmarshal: not really, because you canâ€™t use errdefer with your own result type

1758316281
ezzieyguywuf!~Unknown@user/ezzieyguywuf
I did a thing! https://github.com/ezzieyguywuf/zig-ethernet/tree/main

1758316315
grayhatter!~grayhatte@user/grayhatter
> For the purposes of a small demo, a "virtual patch cable" can be created.

1758316322
grayhatter!~grayhatte@user/grayhatter
that's pretty cool

1758316494
grayhatter!~grayhatte@user/grayhatter
I don't think you need to import C for this, I'd try to see if you could make it exclusively zig

1758320902
longlonglongint!~longlongl@user/longlonglongint
how do i convert a '*const [_:0]u8'

1758320924
longlonglongint!~longlongl@user/longlonglongint
(accidentally pressed enter) to a '[*c]u8'

1758320984
torque!~tachyon@user/torque
have you tried using `@as`

1758321000
torque!~tachyon@user/torque
you should get a specific error message

1758321013
longlonglongint!~longlongl@user/longlonglongint
didnt work

1758321022
longlonglongint!~longlongl@user/longlonglongint
i have a struct member with type '[*c]u8'

1758321025
torque!~tachyon@user/torque
yes, but why?

1758321028
longlonglongint!~longlongl@user/longlonglongint
i have no idea

1758321041
longlonglongint!~longlongl@user/longlonglongint
its in a file generated by translate-c

1758321060
torque!~tachyon@user/torque
sorry, are you trying to convert a `[*c]u8` to `[:0]const u8` or what

1758321070
longlonglongint!~longlongl@user/longlonglongint
sorry i shoulda sent the code first

1758321074
torque!~tachyon@user/torque
technically `*const [_:0]u8` is not a valid type expression

1758321092
longlonglongint!~longlongl@user/longlonglongint
`rec.keycodes = "evdev"`

1758321100
longlonglongint!~longlongl@user/longlonglongint
RGFW.zig:6851:32: error: expected type '[*c]u8', found '*const [5:0]u8'

1758321102
longlonglongint!~longlongl@user/longlonglongint
    rec.keycodes = @as([*c]u8, "evdev");

1758321144
torque!~tachyon@user/torque
you're trying to cast away the constness of the pointee

1758321172
longlonglongint!~longlongl@user/longlonglongint
it also happened without the @as

1758321174
torque!~tachyon@user/torque
if you're sending this memory somewhere that wants to modify it, the cast is unsound in the first place

1758321210
longlonglongint!~longlongl@user/longlonglongint
do i make a var containing the string first

1758321235
torque!~tachyon@user/torque
no, I said the pointee. "evdev" is a pointer to constant memory (strings are stored in rodata)

1758321248
torque!~tachyon@user/torque
you are trying to cast this to a pointer to mutable memory

1758321305
longlonglongint!~longlongl@user/longlonglongint
i think i got rid of the error

1758321326
longlonglongint!~longlongl@user/longlonglongint
translate-c had a field day with it though

1758321340
torque!~tachyon@user/torque
you could get a mutable copy by doing something like `var mutable_str = "evdev".*;` and then `&mutable_str` will be of type `*[n:0]u8` rather than `*const [n:0]u8`

1758321361
torque!~tachyon@user/torque
but that will be a pointer to stack memory so you would have to be careful about lifetime

1758321395
longlonglongint!~longlongl@user/longlonglongint
i *think* it doesnt matter in this case but il double check with the guy who wrote this to begin with

1758321404
longlonglongint!~longlongl@user/longlonglongint
i changed it to this

1758321405
longlonglongint!~longlongl@user/longlonglongint
    char evdev[] = "evdev";

1758321407
longlonglongint!~longlongl@user/longlonglongint
    rec.keycodes = evdev;

1758321427
longlonglongint!~longlongl@user/longlonglongint
translate-c did this

1758321429
longlonglongint!~longlongl@user/longlonglongint
    var evdev: [5:0]u8 = "evdev".*;

1758321431
longlonglongint!~longlongl@user/longlonglongint
    _ = &evdev;

1758321433
longlonglongint!~longlongl@user/longlonglongint
    rec.keycodes = @as([*c]u8, @ptrCast(@alignCast(&evdev[@as(usize, @intCast(0))])));

1758321467
torque!~tachyon@user/torque
that's only valid if rec.keycodes doesn't get mutated, otherwise the program will segfault

1758321480
longlonglongint!~longlongl@user/longlonglongint
im asking him if it gets mutated right now

1758321526
torque!~tachyon@user/torque
as I mentioned your current formulation is putting a pointer to stack memory into the struct so you should be careful about its lifetime

1758321569
longlonglongint!~longlongl@user/longlonglongint
its an xorg thing so i guess it all comes down to if this function uses it interanally forever for some reason

1758321680
torque!~tachyon@user/torque
also uh sorry, the current one you have should be ok if the string gets changed (as long as the library doesn't do out of bounds writes or something)

1758321730
torque!~tachyon@user/torque
if the function doesn't modify it, then whoever wrote the c bindings didn't do a good job of specifying the types correctly, it should have been `const uint8_t *keycodes`

1758321807
longlonglongint!~longlongl@user/longlonglongint
theres large open source libraries for you

1758321876
torque!~tachyon@user/torque
do note that there's nothing magical about the output of `translate-c` and it is often better to adjust the generated output with more type information than is provided by the c compiler itself

1758321898
torque!~tachyon@user/torque
for example maybe that field type actually is `[*:0]const u8`

1758321921
longlonglongint!~longlongl@user/longlonglongint
thats somewhat impractical in this situation

1758321951
longlonglongint!~longlongl@user/longlonglongint
this is a 12k line header file

1758322025
torque!~tachyon@user/torque
yeah, that's fair

1758325822
longlonglongint!~longlongl@user/longlonglongint
its basically working now as far as i can tell

1758325825
longlonglongint!~longlongl@user/longlonglongint
https://github.com/DiarrheaMcgee/RGFW-zig

1758325873
longlonglongint!~longlongl@user/longlonglongint
still a few things that need to be added though

