1757376451
rvrb!~rvrb@156.146.51.230
it would also be a very interesting blog series. stop nerd sniping me

1757376477
andrewrk!~andrewrk@mail.ziglang.org
gottem

1757376530
andrewrk!~andrewrk@mail.ziglang.org
might be a nice opportunity to try out Fil-C ðŸ¤”

1757378784
dsal!sid13060@id-13060.lymington.irccloud.com
Where is the fmt syntax documented?  I was migrating some code that failed to compile with a `{s}` that was a `[]const []const u8` kind of thing.  Works with `{any}`, but I'm wondering if I can do something nicer here.

1757378999
andrewrk!~andrewrk@mail.ziglang.org
dsal: https://ziglang.org/documentation/0.15.1/std/#std.Io.Writer.print

1757379020
dsal!sid13060@id-13060.lymington.irccloud.com
ah yeah.  I knew I'd seen this somewhere.

1757379382
dsal!sid13060@id-13060.lymington.irccloud.com
Neat.  The .format thing worked.

1757380539
dsal!sid13060@id-13060.lymington.irccloud.com
I have a `std.debug.print("stuff: {f}\n", .{ formatSlice("{s}", stuff) });` that works.  Seems like magic that could be on a shelf somewhere.

1757381598
JailBird!jailbird@user/jailbird
Is there a reason that the links under "Latest Stable (0.15.1)" on https://ziglang.org/learn/ are pointing to /master instead of /0.15.1 ?

1757381811
andrewrk!~andrewrk@mail.ziglang.org
certainly not intentional

1757381864
JailBird!jailbird@user/jailbird
Okay, thanks. I had to double check to make sure I took my pills!

1757382594
andrewrk!~andrewrk@mail.ziglang.org
haha

1757382603
andrewrk!~andrewrk@mail.ziglang.org
so, did you?

1757382624
JailBird!jailbird@user/jailbird
I'll let you know after I figure out whom I am

1757382711
andrewrk!~andrewrk@mail.ziglang.org
smart

1757393594
mountaingoat!~mountaing@user/mountaingoat
what's the best way to "reset" a std.io.Reader.fixed ?

1757397115
squeek502!~squeek502@user/squeek502
mountaingoat, `your_fixed_reader.seek = 0;`

1757398066
mountaingoat!~mountaing@user/mountaingoat
squeek502: ok thanks, that's what i ended up doing. was wondering if there was a more proper api

1757399759
tsujp!497e1f7b6a@sourcehut/user/tsujp
I have a function which computes some data and returns the sum of two numbers, but I want to log those two numbers. So instead of copy-pasting the function's guts elsewhere just for logging should I instead have my function return a tuple, and then use vector/scalar _stuff_?

1757399800
tsujp!497e1f7b6a@sourcehut/user/tsujp
Sorry, to clarify: foo -= myfunction();   is being done currently, so if I have it return a tuple I'll have the two numbers that myFunction now doesn't sum itself

1757399818
tsujp!497e1f7b6a@sourcehut/user/tsujp
then I can use vector _stuff_ to have the sum of those subtracted from foo at the callsite instead?

1757399835
dsal!sid13060@id-13060.lymington.irccloud.com
You want to use a vector to add two numbers together?

1757399921
tsujp!497e1f7b6a@sourcehut/user/tsujp
I mean it's probably major overkill right? I should just do:    x, y = myFunction();   log(x, y);  foo -= (x + y);    right?

1757399970
dsal!sid13060@id-13060.lymington.irccloud.com
You can return a type that contains your two values and just add them together.

1757399986
tsujp!497e1f7b6a@sourcehut/user/tsujp
yeah (in this case a tuple), K.I.S.S I guess

1757400762
andrewrk!~andrewrk@mail.ziglang.org
beginner mistake: using tuples in zig

1757400784
andrewrk!~andrewrk@mail.ziglang.org
is your data named, or is it ordered?

1757400792
tsujp!497e1f7b6a@sourcehut/user/tsujp
In this case ordered

1757400816
tsujp!497e1f7b6a@sourcehut/user/tsujp
Well, either/or. Index 0 I could label as the constant_cost, and index 1 as the dynamic_cost

1757400831
andrewrk!~andrewrk@mail.ziglang.org
sounds named to me

1757400834
tsujp!497e1f7b6a@sourcehut/user/tsujp
I suppose you advise making an explicit struct with two fields of those names instead?

1757400909
andrewrk!~andrewrk@mail.ziglang.org
meanwhile, if you were to name the printed args in `std.debug.print("aoeu={d} asdf={d}", .{ foo, bar })`, you would call them "thing_to_print_0" and "thing_to_print_1". i.e. they are ordered, not named

1757406248
tsujp!497e1f7b6a@sourcehut/user/tsujp
is there a nice way to see all the function versions zig crated for an function which accepts anytype?

1757406297
tsujp!497e1f7b6a@sourcehut/user/tsujp
im making a function which i want to accept either a u64 or a fn () u64 and as a parameter and i think i should do this via anytype so that zig creates the two (intended) variants for me at comptime

1757406380
emneo!~emneo@user/emneo
tsujp: on a debug build you might be able to see the symbols in the resulting elf file, but it might also be possible with the new build web interface, though i am not sure as I have not tested it yet

1757406471
emneo!~emneo@user/emneo
worstcase, if you only want to know it once, you might be able to use compileLog

1757406485
tsujp!497e1f7b6a@sourcehut/user/tsujp
emneo: is this build interface part of 0.14.1? I think I remember hearing about this but it was pretty bare bones in 0.14.1 and is more fleshed out in 0.15.1?

1757406525
emneo!~emneo@user/emneo
it definitly is in 0.15.1, but i'm not sure it is in 0.14.1, or if it is it is missing major features

1757406589
tsujp!497e1f7b6a@sourcehut/user/tsujp
might try the symbol grep when i finish my implementation; project i am working on is locked to 0.14.1 for a while so cannot use 0.15.1 goodies yet

1757406596
tsujp!497e1f7b6a@sourcehut/user/tsujp
or as you say, worst case compileLog

1757406628
tsujp!497e1f7b6a@sourcehut/user/tsujp
would compileLog involve something like @This and trying to print that name?

1757406654
andrewrk!~andrewrk@mail.ziglang.org
tsujp: I believe https://ziglang.org/download/0.15.1/release-notes.html#Web-Interface-and-Time-Report can help

1757406946
emneo!~emneo@user/emneo
tsujp: yeah if you're currently stuck on 0.14.1 then compileLog might be your best bet indeed, just print the types of the arguments if you have multiple anytypes and it should be ok

1757407360
tsujp!497e1f7b6a@sourcehut/user/tsujp
i think i can use a union here instead actually, parameter is only valid in one of two forms and that makes the implementation a bit easier

1757407416
tsujp!497e1f7b6a@sourcehut/user/tsujp
maybe its technically slower in terms of execution _speed_ since it would be switching on the union at runtime (but if a goto is used it's still wicked fast no?) but this isn't anything god tier complex

1757407486
emneo!~emneo@user/emneo
that would need to be a very hotpath on that function for a switch on a 2 tag union to have a negative effect on performance

1757407504
emneo!~emneo@user/emneo
I don't really think speed will be impacted at all imo

1757407605
tsujp!497e1f7b6a@sourcehut/user/tsujp
it has the potential to be a very hot path (but not yet measured on real world data since the project isn't ready for that yet)

1757407622
tsujp!497e1f7b6a@sourcehut/user/tsujp
im going to try the anytype approach first just to see if i can do it, and if i get stuck ill use a union

1757407642
tsujp!497e1f7b6a@sourcehut/user/tsujp
some time later (in the future) could _measure_ whether it's actually a problem from real world data

1757408085
tsujp!497e1f7b6a@sourcehut/user/tsujp
ah, hmm, i need the created function to have a `self` parameter (and I do know the type) but i cannot supply that as an argument at comptime

1757408686
tsujp!497e1f7b6a@sourcehut/user/tsujp
effectively this is like trying to construct a function which has another parameter additional to the anytype function that creates it, im guessing this is not (nicely) possible and that the preferred solution is: just literally write that function with the extra parameter and call it in the anytype function

1757408802
tsujp!497e1f7b6a@sourcehut/user/tsujp
fn asdf(foo: u64, bar: anytype) { ... }     to construct the resulting function   fn real_asdf(self: *Thing, foo: u64, bar: u64) { ... }    (as one possible case)

1757410060
dutchie!~dutchie@user/dutchie
hmm, is there no way for an Allocator implementation to know the type that's been requested? all the vtable functions just operate on []u8

1757410337
emneo!~emneo@user/emneo
dutchie: not possible afaik

1757410375
emneo!~emneo@user/emneo
why do you need access to the requested type?

1757410443
dutchie!~dutchie@user/dutchie
wondering if I can implement the GC from craftinginterpreters.com as a Zig Allocator

1757410451
dutchie!~dutchie@user/dutchie
but I think just having some higher-level functions will be fine

1757410667
emneo!~emneo@user/emneo
yeah you might want to make something on top of allocators for that

1757410794
emneo!~emneo@user/emneo
do you need type infos for it though?

1757410841
emneo!~emneo@user/emneo
i'm not versed in gc's at all tbh, so i might be terribly wrong

1757411391
dutchie!~dutchie@user/dutchie
you could probably do it without the type info but you'd diverge from the book a bit more than I'm comfortable with, as someone new to all this

1757412108
tsujp!497e1f7b6a@sourcehut/user/tsujp
I believe I saw some _stuff_ regarding Zig allocators and referencing counting structs, maybe that might help? I'm no expert here either so take that with a grain of salt

1757425981
ezzieyguywuf!~Unknown@user/ezzieyguywuf
ooh could we add aliases in std for Sink and Source to Writer and Reader?!

1757426271
ezzieyguywuf!~Unknown@user/ezzieyguywuf
also andrewrk I'm a real fan of the IO interface and really enjoyed your Don't Forget To Flush speech!

1757429490
bblack!~bblack@wikimedia/bblack-WMF
win 26

1757444904
dsal!sid13060@id-13060.lymington.irccloud.com
This was a surprising change when upgrading to 0.15.  My metamorphic tests were failing in kind of nonsense ways.  Apparently there's some kind of strange assignment thing going on on failure:  https://github.com/dustin/zig-gpmf/commit/6fd5dfc2ca94bdf5abcd781b8b94900534bd8bd6

1757444953
dsal!sid13060@id-13060.lymington.irccloud.com
In the older case, the error would short circuit the mutation so that if it couldn't come up with a new value, it wouldn't mutate the structure.  Now it seems to mutate the structure even when it can't compute a new value.

1757444961
dsal!sid13060@id-13060.lymington.irccloud.com
(that's probably in release notes somewhere)

1757445462
lemons!~doggie@user/doggie-:49517
im trying to figure out if the api im working with mislabeled one of the values

1757445512
lemons!~doggie@user/doggie-:49517
it gives me a struct with an union of a "ref", and a f32, and the ref is secretly a u4c which C translate labeled as c_uint

1757445555
lemons!~doggie@user/doggie-:49517
but the other types defined by the header suggest that u4c means "unsigned 4 chars" when wikipedia says an uint is only 2 chars??

1757445604
lemons!~doggie@user/doggie-:49517
i hope at least im not being variadically passed structs of different sizes 

1757445734
lemons!~doggie@user/doggie-:49517
oh what the hell, OKAY SO, the header file variadically defines u4c AS EITHER UNSIGNED INT OR UNSIGNED LONG

1757445738
lemons!~doggie@user/doggie-:49517
i hate this

1757445776
lemons!~doggie@user/doggie-:49517
does 64 bit literally just mean "ints are now 64 bits in size"

1757445841
lemons!~doggie@user/doggie-:49517
ok the longer i look at this header the more confused i become, i'll just stop here i think

1757446317
bblack!~bblack@wikimedia/bblack-WMF
lemons: I'm not sure about your "wikipedia" line, or any context as to your target platform(s) and/or the API this is coming from.... but all that said, generally a C "unsigned int" is going to be 32 bits wide on almost all common targets (There might be some embedded/tiny-cpu cases where it could be 16 bits, and technically there is the possibility of an "ILP64" or even "SILP64" ABI where it's 64 bits, but 

1757446323
bblack!~bblack@wikimedia/bblack-WMF
oh nevermind, they left

1757446326
bblack!~bblack@wikimedia/bblack-WMF
this is also extremely oddball/historical]

1757446549
marty_fly_!~user@user/marty-fly:59610
Is there some sane way to loop trough each slice in a MultiArrayList? I got it working with a bit of a hack but it doesn't feel right

1757446564
marty_fly_!~user@user/marty-fly:59610
`inline for (std.meta.fields(std.meta.FieldEnum(Entity))) |field| { _ = slice.items(@enumFromInt(field.value)); }`

1757448033
rvrb!~rvrb@156.146.51.230
marty_fly_: https://ziglang.org/documentation/master/std/#std.multi_array_list.MultiArrayList.Slice? can you just use the Slice.ptrs field?

1757448140
marty_fly_!~user@user/marty-fly:59610
I suppose I could use Slice.ptrs but those don't have the type info. Feels more hacky than what I currently have

1757448163
rvrb!~rvrb@156.146.51.230
yeah

1757451668
netvor!~netvor@2a00:ca8:a1f:cd0:dbfc:7ba9:de8d:e0d2
it's always fun to read std.  TIL that in places like Reader.peekDelimiterInclusive() the way to fill a buffer is to take the free space, create ad-hoc writer with it, and have the "upstream" reader stream into it.

1757451692
netvor!~netvor@2a00:ca8:a1f:cd0:dbfc:7ba9:de8d:e0d2
just found it interesting and englightening...

1757452570
jkm!~jkm@user/jkm
netvor: at least the function is inclusive :D

1757456221
lemons!~doggie@user/doggie-:49517
how do i go about reinterpreting a u64 as a multi-value struct? just bit AND, shift and cast?

1757456310
lemons!~doggie@user/doggie-:49517
(i need to cast a struct into an int so ican pass it to arrayhashmap, since one of its fields is an extern union)

1757456957
andrewrk!~andrewrk@mail.ziglang.org
lemons: https://ziglang.org/documentation/0.15.1/#packed-struct

1757457043
lemons!~doggie@user/doggie-:49517
andrewrk: is that behaviour shared with extern structs?

1757457181
andrewrk!~andrewrk@mail.ziglang.org
can you be more specific?

1757457182
lemons!~doggie@user/doggie-:49517
oop, yeah it can be @bitCasted.

1757457259
lemons!~doggie@user/doggie-:49517
nevermind i guess

1757457268
lemons!~doggie@user/doggie-:49517
still thanks thouh

