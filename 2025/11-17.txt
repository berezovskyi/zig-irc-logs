1763346396
jack__d!~jack__d@pool-71-127-206-84.nwrknj.fios.verizon.net
Working on https://github.com/jdevries3133/libj/blob/cf70ab00d72372953dcf09db629f6b27daf946cc/src/zon.zig, leaks are detected if I switch to std.testing.allocator; any advice / tips?

1763347765
donpdonp!~donp@donp.org
zigbook.net is amazing.

1763348749
clevor!sid649024@id-649024.hampstead.irccloud.com
I wonder who made it.

1763353663
squeek502!~squeek502@user/squeek502
clevor, https://ziggit.dev/t/https-zigbook-net/13072/38

1763354552
clevor!sid649024@id-649024.hampstead.irccloud.com
Dang

1763355126
clevor!sid649024@id-649024.hampstead.irccloud.com
Zigbookgate

1763356921
torque!~tachyon@user/torque
not visible without an account?

1763356938
torque!~tachyon@user/torque
or did the thread get deleted in the last hour

1763357068
squeek502!~squeek502@user/squeek502
torque, thread seems to have been deleted, see https://gist.github.com/squeek502/c5269c03e8db71ac9d28d643d2680e8a if you're curious about what the link said

1763357131
torque!~tachyon@user/torque
ah yeah well I guess I don't feel particularly bad about having read the intro and gone "this seems like a hot mess"

1763357267
torque!~tachyon@user/torque
wow the responses on https://github.com/zigbook/zigbook/issues/4 read a lot like llm voice, probably largely due to the hideous abuse of the noble em dash

1763357361
torque!~tachyon@user/torque
this seems like kind of a bizarre psyop though

1763357895
squeek502!~squeek502@user/squeek502
torque, don't think there has to be a complicated explanation, they probably were trying to get around ziggit.dev's policy against AI generated content and didn't know enough about what they produced to know if it'd hold up to scrutiny

1763357966
torque!~tachyon@user/torque
I mean the fact that it is pseudonymous kind of indicates the author knew what they were doing, but also it seems like they were really lazy about it? I mean making that vs code issue as the first thing the account did is truly a baffling decision

1763357992
torque!~tachyon@user/torque
https://github.com/zigbook/zigbook/issues/12 this is interesting food for thought though because it's basically asking to prove a negative, which isn't really possible

1763358036
torque!~tachyon@user/torque
I disdain AI along with the best of them but there's really no way to prove that it has *not* been used for something

1763358084
squeek502!~squeek502@user/squeek502
explaining why they created this diagram and put it in this section would be a start: https://www.zigbook.net/chapters/26__build-system-advanced-topics#_how_the_build_system_executes

1763358128
squeek502!~squeek502@user/squeek502
cmake is not involved in `std.Build`/`build.zig`

1763358151
torque!~tachyon@user/torque
sure, but anyone willing to try to sweat it out could easily claim it was a mistake and they meant to include it on a chapter about bootstrapping the compiler

1763358184
squeek502!~squeek502@user/squeek502
definitely, but that explanation would at least show some understanding, unsure if an LLM would be able to provide that explanation

1763358212
torque!~tachyon@user/torque
yeah I don't think it's wrong to ask the question

1763358271
squeek502!~squeek502@user/squeek502
it's certainly a bizarre situation overall, it does seem like a decent amount of effort went into it regardless

1763358319
squeek502!~squeek502@user/squeek502
i'm not familiar with LLM's enough to know how much, though

1763358352
torque!~tachyon@user/torque
I'm kind of skeptical about the amount of human effort that went into it, but I imagine many millions of cpu-hours were involved

1763358379
torque!~tachyon@user/torque
well if it really is mostly slop, the author will probably not be invested enough to try to rigorously defend it

1763358390
torque!~tachyon@user/torque
but people might get stuck arguing with a chatbot

1763373383
tranzystorekk!86175ff574@voidlinux/maintainer/tranzystorekk
i literally read a discussion on ziggit showcase about the new zigbook.net book and now it's gone? lol this doesnt help my mounting suspicions

1763373402
tranzystorekk!86175ff574@voidlinux/maintainer/tranzystorekk
(the discussion is gone at least)

1763375409
squeek502!~squeek502@user/squeek502
tranzystorekk, yeah not sure if that thread was deleted by the author or the mods, here's my take for whatever it's worth (i posted this in the thread just before it disappeared): https://gist.github.com/squeek502/c5269c03e8db71ac9d28d643d2680e8a

1763390689
grayhatter!~grayhatte@user/grayhatter
>  I don't think it's wrong to ask the question 

1763390749
grayhatter!~grayhatte@user/grayhatter
don't waste time arguing with AI, there's more than enough here to say this is AI slop

1763390784
grayhatter!~grayhatte@user/grayhatter
there's many more zig projects that are worth your time, attention, and discussions

1763392595
grayhatter!~grayhatte@user/grayhatter
:< I'm getting typo squatting vibes from the whole thing, which makes me nervous

1763393687
bblack!~bblack@wikimedia/bblack-WMF
just catching up on this, the cookie crumbs are all there that it was written via Vercel, which is basically an "AI turns my prompts into code please" kind of platform in general.

1763393725
bblack!~bblack@wikimedia/bblack-WMF
it doesn't even hide it that the domain is hosted by vercel and deployed by vercel

1763393869
bblack!~bblack@wikimedia/bblack-WMF
https://vercel.com/agent is probably what's answering the pull reqs

1763393997
tranzystorekk!86175ff574@voidlinux/maintainer/tranzystorekk
well it seems the claim is still true insofar as the raw asciidoc book content is concerned

1763394086
tranzystorekk!86175ff574@voidlinux/maintainer/tranzystorekk
but that doesnt help the case since the general layout and pacing of the book is awful

1763394112
grayhatter!~grayhatte@user/grayhatter
what claim?

1763394124
tranzystorekk!86175ff574@voidlinux/maintainer/tranzystorekk
that it's AI-free

1763394150
grayhatter!~grayhatte@user/grayhatter
holy crap I can't believe I fell for talking about it after just saying not to... 

1763394160
bblack!~bblack@wikimedia/bblack-WMF
:)

1763394200
tranzystorekk!86175ff574@voidlinux/maintainer/tranzystorekk
but still ppl on the ziggit thread pointed out that the book starts off with bizarre deep-dives into the _start machinery and accepted fn main() return types

1763394203
grayhatter!~grayhatte@user/grayhatter
tranzystorekk: there's no chance this isn't AI slop... it's not worth talking about

1763394261
grayhatter!~grayhatte@user/grayhatter
spent your time on a project or topic that's not making the world worse

1763394268
tranzystorekk!86175ff574@voidlinux/maintainer/tranzystorekk
yeah youre probably right, but i wanted to be charitable and focus on the major problems of the book instead of bread crumbs and ai-adjacent stylistic oddities

1763394337
tranzystorekk!86175ff574@voidlinux/maintainer/tranzystorekk
just in case someone else actually attempts to write a useful and actually slop-free book, afaik we only have https://pedropark99.github.io/zig-book/ to compare

1763394339
grayhatter!~grayhatte@user/grayhatter
be charitable to someone who's not a huge POS willing to lie as their first introduction

1763394413
tranzystorekk!86175ff574@voidlinux/maintainer/tranzystorekk
yeah, i just mean that the ziggit discussion could have been actually useful to the community at large

1763394473
tranzystorekk!86175ff574@voidlinux/maintainer/tranzystorekk
even if the book is garbage and the author's behavior seems questionable

1763394479
grayhatter!~grayhatte@user/grayhatter
I think deleting the thread outright is the only option... simple redaction wouldn't work, and everything else is advertising

1763394500
grayhatter!~grayhatte@user/grayhatter
s/questionable/unethical

1763394546
grayhatter!~grayhatte@user/grayhatter
lying to people for personal gain is bad

1763394950
grayhatter!~grayhatte@user/grayhatter
std.mem takes a type as arg0, but Io.select does not... should it? 

1763394979
grayhatter!~grayhatte@user/grayhatter
if not, will std.mem.* ever drop `arg0: type`

1763395072
grayhatter!~grayhatte@user/grayhatter
I'd also be interested in theory crafting as well, I can't decide if I like explicit types better, or if I'd rather the type system do it for me

1763395143
bblack!~bblack@wikimedia/bblack-WMF
I guess either way the runtime specialization is the same, right?  You end up with an instance per T, it's just a question of an explicit T argument, vs inferring it from @TypeOf()/@typeInfo()?

1763395158
grayhatter!~grayhatte@user/grayhatter
bblack: yeah, exactly

1763395239
bblack!~bblack@wikimedia/bblack-WMF
I guess, if I try to make an argument for the std.mem style of things: it probably makes type mismatch errors more obvious and clean at compile-time (e.g. if you std.mem.eql(u8, <a slice of u8>, <a slice of something else>))

1763395264
bblack!~bblack@wikimedia/bblack-WMF
I imagine in the inferred style, you'd have some other error deeper inside the function if they didn't match, generally.  or an assert near the top that they do.

1763395279
grayhatter!~grayhatte@user/grayhatter
bblack: that's the one I keep thinking of, but you can write that as an assert

1763395299
grayhatter!~grayhatte@user/grayhatter
assert(childOf(left) == childOf(right))

1763395319
grayhatter!~grayhatte@user/grayhatter
lol, started typing before I read your msg

1763395484
grayhatter!~grayhatte@user/grayhatter
There are a lot of places I do like explicit types, but std.mem.function(ARG0, ...) has never been one of them... I think I'd rather have std.mem(T).func()

1763395791
bblack!~bblack@wikimedia/bblack-WMF
oh I thought you meant something more like changing std.mem.eql's signature to: pub fn eql(a: anytype, b:anytype) [and then dealing with the assertions about the right pair of types on the inside]

1763395977
bblack!~bblack@wikimedia/bblack-WMF
I guess by the above you mean something like: "fn std.Mem(T: type) type { return struct { fn eql(a: []const T, b: []const T) bool { ... } }; }

1763395992
grayhatter!~grayhatte@user/grayhatter
bblack: that is what I meant, the mem(T) was a 2nd idea I had, so I can have both

1763395997
bblack!~bblack@wikimedia/bblack-WMF
ah

1763396048
grayhatter!~grayhatte@user/grayhatter
yeah, I'm expecting userland to be something like `const mem = std.mem(u8); const startsWith = mem.startsWith;`

1763396963
bblack!~bblack@wikimedia/bblack-WMF
I donno, it seems like the bulk of the time for the bulk of the people, "const mem = std.mem(u8)" suffices, at least as a starting point.  But for anyone else, it's just more characters to type for one-off cases of other types there.  The other "common" case I see with std.mem for non-u8 is readInt()/writeInt() for network/disk i/o stuff (which in my code, I'll commonly have u16, u32, u64 uses of those)

1763397093
bblack!~bblack@wikimedia/bblack-WMF
apparently I even have one case of "readInt(u24, data_sec[offs..][0..3], .big)", for reading from the MaxMind binary database format heh

1763397303
bblack!~bblack@wikimedia/bblack-WMF
"const mem = std.mem(u8); const mem16 = std.mem(u16); ... " ?

1763397328
grayhatter!~grayhatte@user/grayhatter
funny you meantion maxmind, I was *just* looking at your gh profile (from the alignedalloc issue) and had to search for maxmind... I've heard of it before, but forgot where/why

1763397358
grayhatter!~grayhatte@user/grayhatter
mem16 is exactly what I would use for the websocket places where I'm doing mem(u32) 

1763397369
bblack!~bblack@wikimedia/bblack-WMF
they've been around forever, they're one of the main publishers of "IP Intelligence" or whatever databases, geoip lookup for network ranges, etc

1763397448
bblack!~bblack@wikimedia/bblack-WMF
I was using their upstream libmaxminddb in the old C version of my code.  I ended up just writing a custom one for the Zig version: https://github.com/gdnsd/gdnsd/blob/3.99-alpha/gdmaps/mmdb.zig

1763397506
bblack!~bblack@wikimedia/bblack-WMF
it does full-on struct inference stuff.  you give it a struct type you want to fetch, and it matches it up with database field names and types and populates it, basically.

1763397653
grayhatter!~grayhatte@user/grayhatter
the context for the question was because I'm playing around with the idea of trying to rewrite Io.Poll... it would be a great UX improvement to get a poll api that I could use in a switch

1763397795
bblack!~bblack@wikimedia/bblack-WMF
hmmm that's interesting

1763397812
grayhatter!~grayhatte@user/grayhatter
I kinda want to be able to use a throwaway struct too switch(poll( .{ .signalfd = fd0, .network_listen = fd1, ... })) { .signal => posix.exit(), } and what have you

1763397860
bblack!~bblack@wikimedia/bblack-WMF
I have yet to figure out where I'm going with some of my related code in the post-std.Io world (once that's more-substantially-complete anyways).

1763397923
grayhatter!~grayhatte@user/grayhatter
I added io: Io to my git module... and I hate it so much... I've decided I need to refactor it so fewer functions need to do Io

1763397974
bblack!~bblack@wikimedia/bblack-WMF
I kinda feel right now like, there will probably be two cases: generic "low-performance" event-y code that I'll port over to std.Io.Evented and not care about the details so long as everything works correctly.  And the higher-performance network i/o cases where I really care about fine details, where I'll probably try to keep rolling things up from scratch, using std.posix.poll() (for basic compatibility with 

1763397980
bblack!~bblack@wikimedia/bblack-WMF
any ~POSIX target) and some specific variants that use std.linux.IoUring and such directly.

1763397981
grayhatter!~grayhatte@user/grayhatter
std.Io is one of those syntactic sharacha that's gonna end up making me write better (read: not-horrible) code 

1763397993
bblack!~bblack@wikimedia/bblack-WMF
yes, I think so on that, too.

1763398037
bblack!~bblack@wikimedia/bblack-WMF
I don't see how the generic std.Io stuff, as magic as it will be, will have the fine-grained behavioral control I'll want for those nitpicky high-performance cases.

1763398049
bblack!~bblack@wikimedia/bblack-WMF
but we'll see, it's all still in such flux

1763398127
grayhatter!~grayhatte@user/grayhatter
I considered writing a std.testing.io that appears to be a real file system, but is sandboxed

1763398227
bblack!~bblack@wikimedia/bblack-WMF
(and network? that'd be neat to emulate)

1763398229
grayhatter!~grayhatte@user/grayhatter
a lot of my tests depend on the git repo they live within (horrifying I know), would be nice to bundle up some "test vectors" and then just call the functions exactly like "main()" does instead of needing to do the setup/teardown

1763398278
grayhatter!~grayhatte@user/grayhatter
yeah, would be dope to have a completely deterministic network stack for testing

1763398315
grayhatter!~grayhatte@user/grayhatter
listen on 0.0.0.0:80, and have it work :D

1763398360
bblack!~bblack@wikimedia/bblack-WMF
it should be possible in the std.Io world I'd think (entirely fake within the testing environment, no actual host network stack used)

1763398425
bblack!~bblack@wikimedia/bblack-WMF
and then be able to, for example, spin up testing http (or whatever) clients + servers and have them execute tests against each other.

1763398529
grayhatter!~grayhatte@user/grayhatter
bblack: also to capture a real network call, and then record it... you could test http against ziglang.org, and when it fails, you'll know that code is broken because it's not hitting the real server, (or do both)

1763412616
clevor!sid649024@id-649024.hampstead.irccloud.com
Why does std.Io.Condition.wait require a mutex?

1763412700
shachaf!~shachaf@user/shachaf
That's how condition variables work to avoid missed wakeups.

1763414936
clevor!sid649024@id-649024.hampstead.irccloud.com
In z9, I have a condition that naively signals on every message sent and received just in case the buffer it uses is empty or full. I haven't gotten the new iteration to compile yet :p

1763420090
rvrb!~rvrb@156.146.51.230
how is std.Io going to impact std.log?

1763420283
grayhatter!~grayhatte@user/grayhatter
rvrb: I'd hope and assume, if you want to override the default "single threaded" log methods, you'd use `root.std_options` and provide your own functions?

1763420361
grayhatter!~grayhatte@user/grayhatter
I actually have no idea, but I'm hoping it doesn't demand an Io

1763420954
rvrb!~rvrb@156.146.51.230
a std_options.log_io field seems reasonable without putting a lot of thought to it; but yes, passing around Io for logging seems insane

1763421021
rvrb!~rvrb@156.146.51.230
I just don't know how you provide custom logger functions, for example log to disk, or network, or whatever; without the logFn taking Io

1763421179
rvrb!~rvrb@156.146.51.230
I guess your custom log implementation uses its own static variable.. and can do a similar thing to std_options if it's a library

