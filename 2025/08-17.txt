1755426663
triallax!~triallax@lacerte/triallax
is usize guaranteed to be the same as c's size_t?

1755426749
triallax!~triallax@lacerte/triallax
i see that the c translation translates size_t to usize so i'm assuming so

1755428254
ifreund!2940d10f8b@user/ifreund
yep

1755428669
triallax!~triallax@lacerte/triallax
ok, thanks

1755470254
Profpatsch!~Profpatsc@user/Profpatsch
in the new async interface, if I call io.async(fn, .{ arg1, arg2, â€¦ }) the async will be typed as anyopaque for both the fn and args argument

1755470286
Profpatsch!~Profpatsc@user/Profpatsch
That sounds like it can be super easy to get wrong if the type checker cannot help you anymore with any IO primitives

1755470305
Profpatsch!~Profpatsc@user/Profpatsch
will this be using comptime somehow to figure out the right type sigs?

1755470331
Profpatsch!~Profpatsc@user/Profpatsch
(going from what I saw from the Zig podcast episode but that has been a week ago or two)

1755474546
rvrb!~rvrb@156.146.51.229
Profpatsch: I don't know if I understand what you are asking, but here is the signature in the `async-await-demo` branch, which indicates how comptime is used to take the arguments and return value with type safety: https://github.com/ziglang/zig/blob/8bcc91c15e966e1661124a73e17cf446e21831e9/lib/std/Io.zig#L1514-L1516

1755474613
rvrb!~rvrb@156.146.51.229
the misunderstanding you have is that netiher is anyopaque, function is anytype and args is derived from @TypeOf(function)

