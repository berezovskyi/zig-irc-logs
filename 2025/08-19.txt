1755565692
Profpatsch!~Profpatsc@user/Profpatsch
defer i += 1;

1755584355
Affliction!affliction@idlerpg/player/affliction
Thinking about starting a project involving talking to a USB device. Does anyone know if anyone's working on a wrapper for libusb that uses 0.15's I/O stuff?

1755584538
Affliction!affliction@idlerpg/player/affliction
Otherwise, only thing I've found so far is https://github.com/allyourcodebase/libusb/tree/v1.0.26-zig which doesn't look like it's being maintained for 0.14.

1755584692
Affliction!affliction@idlerpg/player/affliction
Or I might just sit atop the raw libusb API directly. Send packets, receive packets, who needs further abstraction over that!

1755597747
meidam!~meidam@user/meidam
Looks like the 0.15.0 milestone is done :O

1755597795
flower_!~archie@83-81-123-193.cable.dynamic.v4.ziggo.nl
reading a bit about bit shifting in C for fiddling with a AVR microcontroller. Bitshifting in Zig is the same as bitshifting in C?

1755598657
tsujp!497e1f7b6a@sourcehut/user/tsujp
zig compiler builtins for @log don't support integers?

1755599370
tkellen!uid716183@user/tkellen
âœŒðŸ¼

1755599434
tkellen!uid716183@user/tkellen
I am having so much fun with Zig. Just joining to see what goes on here ðŸ˜„

1755599449
hadronized!~hadronize@2001:41d0:a:fe76::1
tkellen: what are you building?

1755599457
hadronized!~hadronize@2001:41d0:a:fe76::1
itâ€™s great if youâ€™re having fun :)

1755600872
triallax!~triallax@lacerte/triallax
tsujp: no, but there are std.math.log*_int functions

1755601248
tkellen!uid716183@user/tkellen
@hadronized: Learning zig and western music theory by writing a scale generator! https://github.com/tkellen/zigmusic. Writing something in code helps my brain really understand it. Haven't touched it in a bit because I've been too busy learning to play music instead (now that I understand some of the structure of how it "works"). Just following all the zig news these days and excited to see the IO stuff come to fruition.

1755601460
bblack!~bblack@wikimedia/bblack-WMF
cccccctrnruvihbuglebuebrjvgilfutblcbiicvikfd

1755601488
bblack!~bblack@wikimedia/bblack-WMF
yubikey :P

1755601554
hadronized!~hadronize@2001:41d0:a:fe76::1
tkellen: nice :)

1755601927
tsujp!497e1f7b6a@sourcehut/user/tsujp
triallax: wouldn't a while loop (as in the std.math functions) be quite slow? Are there not intrinsic instructions for log of integers in CPUs?

1755601931
tsujp!497e1f7b6a@sourcehut/user/tsujp
curious why it's only floats

1755602020
tsujp!497e1f7b6a@sourcehut/user/tsujp
or I guess bit-twiddling is expected instead? In my case I'm trying to get log256 of a given u256, which is just the index of the most significant bit IIRC

1755602232
tsujp!497e1f7b6a@sourcehut/user/tsujp
byte I mean*

1755603827
triallax!~triallax@lacerte/triallax
well, you have your answer there

1755603831
triallax!~triallax@lacerte/triallax
but the general answer is to benchmark

1755603969
triallax!~triallax@lacerte/triallax
you could do something like

1755603998
triallax!~triallax@lacerte/triallax
std.math.log2_int(u256, n) / 8

1755604032
triallax!~triallax@lacerte/triallax
log2_int does do bit twiddling in fact

1755605257
triallax!~triallax@lacerte/triallax
is there something like splitAny, but it takes in a slice of sequences?

1755605320
ifreund!2940d10f8b@user/ifreund
don't think so

1755605328
ifreund!2940d10f8b@user/ifreund
sounds kinda niche

1755605331
triallax!~triallax@lacerte/triallax
actually forget it, it might not be appropriate for my use case

1755605611
triallax!~triallax@lacerte/triallax
ping ponging again, it is in fact what i want

1755605617
triallax!~triallax@lacerte/triallax
i'll have to write my own thing then i guess

1755605631
triallax!~triallax@lacerte/triallax
to be specific i want to split by a specific sequence of characters, _and_ newlines

1755605689
ifreund!2940d10f8b@user/ifreund
and you have more than one possible sequence?

1755605694
ifreund!2940d10f8b@user/ifreund
otherwise that's splitSequence()

1755605701
triallax!~triallax@lacerte/triallax
i misphrased that

1755605711
triallax!~triallax@lacerte/triallax
i want to split on either said sequence or a newline

1755605820
ifreund!2940d10f8b@user/ifreund
I think you need to write your own loop then if you want to do it in one pass

1755605827
triallax!~triallax@lacerte/triallax
yeah sure

1755605869
Affliction!affliction@idlerpg/player/affliction
Depending on what we're parsing, I'd generally do something like split by lines, then the tokens within. Or if that kind of construct is common, cobble together a custom iterator for it.

1755605888
triallax!~triallax@lacerte/triallax
nah it's only done in one place

1755605904
triallax!~triallax@lacerte/triallax
and i probably want to avoid multiple passes

1755605909
triallax!~triallax@lacerte/triallax
it's rather performance-sensitive

1755605918
Affliction!affliction@idlerpg/player/affliction
hm

1755605934
Affliction!affliction@idlerpg/player/affliction
then you might want a custom iterator anyway

1755605941
triallax!~triallax@lacerte/triallax
nah a loop should be okay

1755605942
Affliction!affliction@idlerpg/player/affliction
actually...

1755605949
Affliction!affliction@idlerpg/player/affliction
ACTION looks at std reference

1755605954
ifreund!2940d10f8b@user/ifreund
if it's very performance sensitive you might enjoying trying out a labeled switch + continue

1755605961
triallax!~triallax@lacerte/triallax
oh you don't know

1755605966
ifreund!2940d10f8b@user/ifreund
generally that's the way to write optimial tokenizers

1755605966
Affliction!affliction@idlerpg/player/affliction
ooh that's a construct I've yet to play with

1755605980
triallax!~triallax@lacerte/triallax
recently i just went all out and played with using simd for splitting

1755605981
triallax!~triallax@lacerte/triallax
that was fun

1755605990
ifreund!2940d10f8b@user/ifreund
heh

1755605990
triallax!~triallax@lacerte/triallax
but i'm not sure the performance improvement was worth it and the code was garbage too

1755606014
ifreund!2940d10f8b@user/ifreund
that's the nice thing about labeled switch + continue, the code stays very readable

1755606019
triallax!~triallax@lacerte/triallax
i'm not tokenising here per se so a labeled switch is not the tool

1755606040
Affliction!affliction@idlerpg/player/affliction
nope, the thing I was thinking of didn't exist in std

1755606042
triallax!~triallax@lacerte/triallax
or well i guess i am

1755606050
triallax!~triallax@lacerte/triallax
but the sequence i'm splitting on is runtime-known

1755606054
triallax!~triallax@lacerte/triallax
so no switch

1755606076
triallax!~triallax@lacerte/triallax
if i wanted to optimise it to the maximum simd is definitely the way to go though

1755606083
triallax!~triallax@lacerte/triallax
but meh

1755606085
Affliction!affliction@idlerpg/player/affliction
got a sample of what the input looks like?

1755606103
triallax!~triallax@lacerte/triallax
uh

1755606149
triallax!~triallax@lacerte/triallax
not sure how helpful that would be because the sequence to split on is arbitrary

1755606151
triallax!~triallax@lacerte/triallax
or to be specific

1755606167
triallax!~triallax@lacerte/triallax
it's actually a sequence of bytes that represents a single character

1755606175
triallax!~triallax@lacerte/triallax
but a sequence of bytes nonetheless

1755606209
Affliction!affliction@idlerpg/player/affliction
hm

1755606484
triallax!~triallax@lacerte/triallax
i can't believe this, my dumb ass hasn't saved the simd code in a branch

1755606493
triallax!~triallax@lacerte/triallax
i needed to look at it and have a laugh

1755606698
Ayo!~Ayo@45.142.232.203
I appreciate the delay between tagging a new release and actually publishing the release. Ncdu is ready for 0.15 \o/

1755606861
ifreund!2940d10f8b@user/ifreund
heh

1755606870
triallax!~triallax@lacerte/triallax
are there release notes somewhere i can look at, or not yet?

1755606888
triallax!~triallax@lacerte/triallax
didn't find them on the website

1755606888
ifreund!2940d10f8b@user/ifreund
not yet

1755606892
triallax!~triallax@lacerte/triallax
welp

1755606904
Ayo!~Ayo@45.142.232.203
compile errors make for good release notes, too

1755606911
triallax!~triallax@lacerte/triallax
trust me, i already tried

1755606914
triallax!~triallax@lacerte/triallax
didn't have a good time

1755606934
triallax!~triallax@lacerte/triallax
it's mainly writergate

1755606939
ifreund!2940d10f8b@user/ifreund
there are some in these PR descriptions: https://github.com/ziglang/zig/pulls?q=is%3Aopen+is%3Apr+label%3A%22release+notes%22

1755606977
ifreund!2940d10f8b@user/ifreund
er, look at the closed ones not the open ones

1755606988
Ayo!~Ayo@45.142.232.203
I was actually expecting far more breakage

1755607021
Ayo!~Ayo@45.142.232.203
But plenty of deprecated APIs haven't been removed yet, so that simplifies a quick migration

1755607137
Ayo!~Ayo@45.142.232.203
I also managed to support 0.14 and 0.15 with the same codebase, so distros would hopefully have an easier time upgrading

1755607200
triallax!~triallax@lacerte/triallax
i see LinearFifo is being removed, why is that?

1755607589
triallax!~triallax@lacerte/triallax
i have a reader that basically implements an optimised version of `streamUntilDelimiter` by calling `std.mem.indexOf` on the buffer rather than reading byte by byte

1755607613
triallax!~triallax@lacerte/triallax
it uses a boring old buffer but i have a branch where i've switched it to use a ring buffer and found that gave noticeable performance improvements

1755607630
triallax!~triallax@lacerte/triallax
is there something in the new io implementation that would subsume this functionality?

1755607828
Ayo!~Ayo@45.142.232.203
triallax: the *Delimiter*() methods in the new Reader interface appear to work like that, so you may not need that optimization anymore

1755607833
ifreund!2940d10f8b@user/ifreund
triallax: io.Reader does that by default

1755607889
triallax!~triallax@lacerte/triallax
hm cool

1755607904
triallax!~triallax@lacerte/triallax
though in my case, again, the delimiter need not be only one byte :(

1755607938
triallax!~triallax@lacerte/triallax
but i imagine i can copy the impls in the stdlib and adjust them, so should be fine

1755607964
ifreund!2940d10f8b@user/ifreund
or just search for the first byte of your delimiter and handle the false positives

1755607969
Ayo!~Ayo@45.142.232.203
Aye, peek() and take() look simple to build upon

1755607981
triallax!~triallax@lacerte/triallax
ifreund: did think of that but it might be worse for performance, i'll have to see

1755608695
triallax!~triallax@lacerte/triallax
i guess that means i throw out my ring buffer impl then :(

1755608715
triallax!~triallax@lacerte/triallax
(i knew i was gonna discard it anyway i just did it for fun)

1755608837
ifreund!2940d10f8b@user/ifreund
the std probably does need one generic ring buffer implementation, but linear fifo was a mess

1755608871
ifreund!2940d10f8b@user/ifreund
it should probably look pretty similar to the 0.15 ArrayList API, with functions to init with a fixed buffer rather than using an allocator

1755608932
ifreund!2940d10f8b@user/ifreund
the number of ring buffers implementations in the std has dropped significantly since I wrote this issue: github.com/ziglang/zig/issues/19231

1755608978
ifreund!2940d10f8b@user/ifreund
the TLS, lzma, and debug.FixedBufferReader ones still exist but everything else is gone I think

1755608991
ifreund!2940d10f8b@user/ifreund
there's probably a few more hiding out somewhere though

1755626006
andrewrk!~andrewrk@mail.ziglang.org
these things really are like whack a moles

1755626026
andrewrk!~andrewrk@mail.ziglang.org
the tls one should be absorbed into usage of std.Io.Reader API

1755626048
andrewrk!~andrewrk@mail.ziglang.org
same with lzma and debug.FixedBufferReader

1755627343
bblack!~bblack@wikimedia/bblack-WMF
I may have lost it in the backscroll somewhere, but is the new ArrayList API useable as a persistent ringbuffer? or do we still need something else?

1755627741
andrewrk!~andrewrk@mail.ziglang.org
bblack: ArrayList is not a ring buffer

1755627776
bblack!~bblack@wikimedia/bblack-WMF
what's meant to replace ring buffer needs? something in std.Io.Reader?

1755627788
andrewrk!~andrewrk@mail.ziglang.org
both std.Io.Reader and std.Io.Writer are ring buffers

1755627803
andrewrk!~andrewrk@mail.ziglang.org
do you have a use case outside that?

1755628049
bblack!~bblack@wikimedia/bblack-WMF
andrewrk: I'm not sure.  In the long term, maybe not.  In the short term, yes?  Where I'm using a FIFO ringbuffer now, I am technically using it for I/O stuff, but this I/O is using syscalls and some other legacy eventloop mechanism, etc.  It's not using zig std.Io to do its I/O.

1755628134
bblack!~bblack@wikimedia/bblack-WMF
but it probably should be, once the two things meet in the middle somewhere (there's a stable eventloop implementation for std.Io, and my code gets off its legacy eventloop and refactors for it)

1755628238
bblack!~bblack@wikimedia/bblack-WMF
I suppose there is probably a way to instantiate memory fifo from std.Io anyways, I just haven't figured it out yet.

1755628786
andrewrk!~andrewrk@mail.ziglang.org
well, you can always copy the old implementation into your code for now while you think about how to restructure it

1755628902
bblack!~bblack@wikimedia/bblack-WMF
I just made a quick tiny fifo for myself when I hit this earlier, but yeah

1755628937
bblack!~bblack@wikimedia/bblack-WMF
I haven't wrapped my head around all of the new std.Io stuff really, other than basic adaptation to get things running again.

1755628965
bblack!~bblack@wikimedia/bblack-WMF
it sounds very promising though :)

1755629151
bblack!~bblack@wikimedia/bblack-WMF
the main forward-looking thing on my mind now about all of this is: I was originally planning to replace my legacy eventloop with libxev sometime Soon.  Now it kinda seems likely that there will be one or more std.Io eventloop-like things are coming now.  Should I just wait, or is that far enough out that I may as well try on libxev for now?

1755629309
bblack!~bblack@wikimedia/bblack-WMF
("my legacy eventloop" ~= this project was ported from C -> Zig, and the C project was using libev for an eventloop, and so far the Zig port is still using that directly via @cImport for now, until I get around to addressing that part)

1755629969
andrewrk!~andrewrk@mail.ziglang.org
I think std.Io event loop will be able to be tinkered with in master builds within a month

1755629988
clevor!sid649024@id-649024.hampstead.irccloud.com
What

1755629990
clevor!sid649024@id-649024.hampstead.irccloud.com
oops

1755630040
clevor!sid649024@id-649024.hampstead.irccloud.com
What is to happen next for the 0.15.0 release schedule?

1755630046
bblack!~bblack@wikimedia/bblack-WMF
andrewrk: sweet :)

1755633294
andrewrk!~andrewrk@mail.ziglang.org
clevor: release notes coming soon

1755633304
clevor!sid649024@id-649024.hampstead.irccloud.com
Okay

1755633341
andrewrk!~andrewrk@mail.ziglang.org
maybe I didn't understand your question

1755639829
clevor!sid649024@id-649024.hampstead.irccloud.com
It was a redundant question as I know you have to write release notes, add the new version to the site and such, but I thought it wouldn't hurt to ask.

1755639864
bblack!~bblack@wikimedia/bblack-WMF
I imagine the release notes on this one are complicated :)

1755640019
andrewrk!~andrewrk@mail.ziglang.org
well, the release didn't finish building yet either. it takes longer now that there are so many targets

1755640075
clevor!sid649024@id-649024.hampstead.irccloud.com
Also the main page, the full overview page, and the other code samples page all need updated for Writergate.

1755645589
hadronized!~hadronize@2001:41d0:a:fe76::1
andrewrk: in your Donâ€™t Forget To Flush talk, you mentioned that using BufWriter in the Rust example would cause the whole example to be generic; how did you come to this conclusion? if you passed a writer: &mut BufWriter<&mut dyn Write> as argument, the function is monomorphized

1755645632
hadronized!~hadronize@2001:41d0:a:fe76::1
and itâ€™s also a better comparison to new Writer interface of Zig, which has the buffer above the vtable (which is exactly what BufWriter is in Rust)

1755645784
andrewrk!~andrewrk@mail.ziglang.org
hadronized: you still didn't figure out what you did wrong in your godbolt example yet

1755645794
andrewrk!~andrewrk@mail.ziglang.org
want another hint?

1755645815
hadronized!~hadronize@2001:41d0:a:fe76::1
andrewrk: which one? youâ€™re talking about yesterday?

1755646587
lemons!~doggie@user/doggie-:49517
any way to nab from which function are we being called?

1755646606
lemons!~doggie@user/doggie-:49517
doing cross-abi asserts and it'd REALLY help if i could tell what function borked

1755646621
lemons!~doggie@user/doggie-:49517
*implementnig

1755646633
lemons!~doggie@user/doggie-:49517
s/nig/ing

1755647224
andrewrk!~andrewrk@mail.ziglang.org
lemons: @returnAddress() gives you a usize that can later, with debug info, be converted into a source location

1755647236
andrewrk!~andrewrk@mail.ziglang.org
check out std.debug.Trace

1755647429
lemons!~doggie@user/doggie-:49517
andrewrk: ill snoop around, cheers

