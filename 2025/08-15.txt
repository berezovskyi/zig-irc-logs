1755218360
nephele!~vision@i59F516D1.versanet.de
Hey, I'm seeking help in using zig-sdl3. The repo mentios using a specific version for the zig stable branch, so i tried to use it's  v0.1.0 tag, copied the template, and tried to build it with  0.14.1; that failed with failed to finding a dep. I then tried to add the sdl3 zig dep as mentioned in the readme, this warned about replacing an existing dep... and afterwards still failed to build with a file not found error. Am I missing

1755218361
nephele!~vision@i59F516D1.versanet.de
 something?

1755218504
nephele!~vision@i59F516D1.versanet.de
the command from the readme is zig fetch --save git+https://<url>; and the file not found tries to open /home/user/proj/project/git+https<url><someHash>

1755219847
andrewrk!~andrewrk@mail.ziglang.org
nephele: are you using https://github.com/castholm/SDL or https://github.com/allyourcodebase/SDL3 ? I havn't had much luck with the former

1755220713
nephele!~vision@i59F516D1.versanet.de
neither actually, the one i tried to use is https://github.com/Gota7/zig-sdl3

1755221080
andrewrk!~andrewrk@mail.ziglang.org
hmm I have never interacted with the author of this one nor seen this package

1755221165
nephele!~vision@i59F516D1.versanet.de
I assumed the later project you send was "only" to build sdl3 with the zig build harness, maybe it would work for my purposes too, but a "idomatic" zig wrapper seemed more easier to start with

1755222698
rvrb!~rvrb@156.146.51.229
context: parser switching on token tag. I have EnumSets describing different sets of tokens for different productions. is there an efficient way to use them for a jump table of some kind, or do I just need to bite the bullet and copy them into a switch statement?

1755222898
rvrb!~rvrb@156.146.51.229
what I think I want is an EnumArray or EnumMap that lets me initialize with an EnumSet as a key; I can't imagine this usecase is original

1755244791
tsujp!497e1f7b6a@sourcehut/user/tsujp
It'd be nice if this was possible: const expect, expectEqual, expectError = std.testing;    instead of having to repeat it multiple times over multiple lines

1755244977
ifreund!2940d10f8b@user/ifreund
not gonna happen

1755245244
tsujp!497e1f7b6a@sourcehut/user/tsujp
just found the proposal, yeah seems fair

1755245402
tsujp!497e1f7b6a@sourcehut/user/tsujp
The test runner when you do `zig test foobar.zig` seems to print out the test names and their status, but if using std.Build.addTest it does not do that, I can try and copy the test runner used by `zig test` and make it the custom runner that `std.Build.addTest` uses but is there a flag or config struct etc I am missing that already would do this?

1755245435
tsujp!497e1f7b6a@sourcehut/user/tsujp
Not having the test names printed out seems somewhat like an antipattern to me especially given `zig build test` (via std.Build.addTest) being the more popular project-wide approach, no?

1755245530
ifreund!2940d10f8b@user/ifreund
pass --summary all

1755245633
tsujp!497e1f7b6a@sourcehut/user/tsujp
I do, and no names are printed

1755245673
tsujp!497e1f7b6a@sourcehut/user/tsujp
ifreund: no test name output https://bpa.st/J3VQ

1755246021
ifreund!2940d10f8b@user/ifreund
ah right, that's just step names.

1755246053
ifreund!2940d10f8b@user/ifreund
If a test fails it should print the name

1755246131
tsujp!497e1f7b6a@sourcehut/user/tsujp
So a custom runner would be required if I want test names (even in the case of _passing_ tests) right?

1755247655
tsujp!497e1f7b6a@sourcehut/user/tsujp
hmm style question, have a test folder within the project src folder which has zig test files in it, or a top-level "test" folder alongside "src" with test files in it

1755263042
tsujp!497e1f7b6a@sourcehut/user/tsujp
ive got a strange bug (maybe).. im copying a struct and changing one of it's fields' values and if I do not add a debug print (in this function) I get an error later on, if I do I get no error

1755263057
tsujp!497e1f7b6a@sourcehut/user/tsujp
so the struct is probably being freed after the function returns...?

1755263324
hadronized!~hadronize@2001:41d0:a:fe76::1
hm, if I want to pass or receive a pointer to/from a C function, what type should I use? *T?

1755263514
hadronized!~hadronize@2001:41d0:a:fe76::1
hm I guess ?*T is fine, since it will interpret 0 as null

1755263551
rockorager!~rockorage@2600:3c06::f03c:94ff:fea6:1f08
hadronized: yeah I'd do ?*T

1755263555
rockorager!~rockorage@2600:3c06::f03c:94ff:fea6:1f08
For anything from C

1755263595
hadronized!~hadronize@2001:41d0:a:fe76::1
I was questioning the claim that it’s safer than what Rust does lately, but I think it’s roughly the same as transmuting a C pointer to Option<NonNull<T>>

1755263610
hadronized!~hadronize@2001:41d0:a:fe76::1
and it makes sense to use the 0 as the null variant of the ? / Option::None

1755263788
tsujp!497e1f7b6a@sourcehut/user/tsujp
right a whole bunch of my stuff is being freed after it's used hmmmmmmmmmmmmmmmmmmmmmmmm

1755263815
tsujp!497e1f7b6a@sourcehut/user/tsujp
i mean freed before it's used*

1755266500
tsujp!497e1f7b6a@sourcehut/user/tsujp
Right so if I do the same thing I already had but make a `var myself = Self{ ... }` and set some of the field values, and _then_ `return myself` instead of just `return Self{ ... }` it works

1755266528
tsujp!497e1f7b6a@sourcehut/user/tsujp
I don't understand how or why that fixes it, the two should be equivalent no...

1755266732
tsujp!497e1f7b6a@sourcehut/user/tsujp
I suppose I expected the compiler to automatically know I used the local stack variable for field initialisation and NOT have that result in a use-after-return but it doesn't do so unless you explicitly make a container (in this case a struct) to hold all of them

1755266754
tsujp!497e1f7b6a@sourcehut/user/tsujp
even though that container is also stack local, and has it's fields initialised by the same stack local variables as before

1755266924
bblack!~bblack@wikimedia/bblack-WMF
just because you're not getting a UAF anymore with that trick doesn't mean it's right.  try it in valgrind or various release modes? the compiler in general won't save you from returning stack memory to a caller.

1755266956
tsujp!497e1f7b6a@sourcehut/user/tsujp
im trying it in releasesafe now and it works

1755266979
tsujp!497e1f7b6a@sourcehut/user/tsujp
ill paste a short snippet of the before/after, sec

1755267084
ifreund!2940d10f8b@user/ifreund
not all illegal behavior is safety checked

1755267225
tsujp!497e1f7b6a@sourcehut/user/tsujp
before/after is on lines ~21-37 https://gist.github.com/tsujp/a670eee6602ce8277be21c5d507c37f9

1755267287
ifreund!2940d10f8b@user/ifreund
you still have illegal behavior I think

1755267296
ifreund!2940d10f8b@user/ifreund
> &soot.env,

1755267300
ifreund!2940d10f8b@user/ifreund
this is a pointer to the stack

1755267305
ifreund!2940d10f8b@user/ifreund
and invalid after the function returns

1755267651
tsujp!497e1f7b6a@sourcehut/user/tsujp
hmm you may be right, the tests pass in ReleaseSafe though. If I print the env struct in init and then from within evm it shows the same information apart from one field whose value looks to be corrupted

1755267667
tsujp!497e1f7b6a@sourcehut/user/tsujp
is there a way to do what I am trying to do here..?

1755267756
ifreund!2940d10f8b@user/ifreund
allocate your struct on the heap or pass the memory into init

1755267785
ifreund!2940d10f8b@user/ifreund
and be careful never to copy your self-referential struct around, or you will break the self-reference

1755267897
ifreund!2940d10f8b@user/ifreund
you could also restructure your code to not need this complexity

1755268121
tsujp!497e1f7b6a@sourcehut/user/tsujp
I mean the goal of this helper is to avoid having to create a DummyEnv, create an allocator, pass it to New, and then call init in every single test case 

1755268143
tsujp!497e1f7b6a@sourcehut/user/tsujp
That pattern is required since this intended for use as a library, but in tests it's verbose and a lot of boilerplate

1755268182
tsujp!497e1f7b6a@sourcehut/user/tsujp
So being able to do `var sut: Sut = .init(.{});` is nicer than 5 lines of boilerplate repeated for every single `test` block

1755268308
tsujp!497e1f7b6a@sourcehut/user/tsujp
this might be fine, the addresses of the `.env` field of that struct are the same address at both locations

1755268663
ifreund!2940d10f8b@user/ifreund
no, it's not fine

1755268676
ifreund!2940d10f8b@user/ifreund
it's illegal behavior if you dereference that dangling pointer

1755268797
tsujp!497e1f7b6a@sourcehut/user/tsujp
The caller is responsible for the lifetime of DummyEnv and the given allocator, the goal of Sut is to provide a default for test scenarios only

1755268818
tsujp!497e1f7b6a@sourcehut/user/tsujp
How would you approach this?

1755268891
ifreund!2940d10f8b@user/ifreund
personally I would just write the boilerplate

1755268912
ifreund!2940d10f8b@user/ifreund
if you really don't want to do that, you can simply allocate Sut on the heap using the testing allocator

1755268919
ifreund!2940d10f8b@user/ifreund
then you have a stable pointer

1755269854
tsujp!497e1f7b6a@sourcehut/user/tsujp
Oh, and because I am not returning a new anonymous struct literal each time that's a problem too right..?

1755269862
tsujp!497e1f7b6a@sourcehut/user/tsujp
idk why this isn't clicking tbh :'(

1755272375
tsujp!497e1f7b6a@sourcehut/user/tsujp
I don't understand, is it just impossible to have a struct as a convience wrapper to abstract an allocator away 

1755272837
torque!~tachyon@user/torque
why do you need to abstract an allocator away?

1755272873
torque!~tachyon@user/torque
as was pointed out earlier if you heap allocate the things you are storing pointers to, you won't have the problem of leaking stack pointers beyond their lifetime

1755272896
torque!~tachyon@user/torque
(you can heap alllocate an allocator, as well)

1755273098
torque!~tachyon@user/torque
both `gpa` and `env` are local to the stack of your init fn. if you do `const gpa = std.testing.allocator.create(@TypeOf(args.gpa)); gpa.* = args.gpa;` then you will have an allocator with a stable pointer

1755273124
torque!~tachyon@user/torque
since you have a deinit function, you can then free this after doing the leak check

1755273239
torque!~tachyon@user/torque
though copying the allocator from the outer scope is still suspect. is there any reason you can't just directly use `std.testing.allocator` for this functionality that is exclusively for testing?

1755273333
tsujp!497e1f7b6a@sourcehut/user/tsujp
i dont see why not and I tried it without but I still get a panic in ReleaseSafe when testing under that

1755273365
tsujp!497e1f7b6a@sourcehut/user/tsujp
i don't understand _why/how_ i cannot copy env onto the returned struct, or in the case of an allocator and env both of them

1755273418
tsujp!497e1f7b6a@sourcehut/user/tsujp
yes its in the stack of the init fn, but doesn't the callsite get the struct _value_ when returned, why can't the lifetime of the env still be in that struct or forced to be

1755273426
tsujp!497e1f7b6a@sourcehut/user/tsujp
(if that is even the problem)

1755273519
palanix!~palanix@2a02:3100:5ffe:fb00:ccb5:5b87:426c:67df
tsujp: in evm_sut you take the pointer of the wrong (init fn stack) env

1755273547
palanix!~palanix@2a02:3100:5ffe:fb00:ccb5:5b87:426c:67df
but i don't get why you don't just allocate it on the heap. You already have a deinit function anyways

1755273654
tsujp!497e1f7b6a@sourcehut/user/tsujp
what would that look like? std.testing.allocator.allocate(DummyEnv, 1) or something..?

1755274005
tsujp!497e1f7b6a@sourcehut/user/tsujp
or const ptr = std.testing.allocator.allocate(DummyEnv); ptr.* = args.env;

1755274050
tsujp!497e1f7b6a@sourcehut/user/tsujp
but then calling std.testing.allocator.destroy(self.env);  crashes the process so hard zig's test runner waits forever

1755274067
tsujp!497e1f7b6a@sourcehut/user/tsujp
var soot = Self{ .env = ptr, ... };

1755275130
tsujp!497e1f7b6a@sourcehut/user/tsujp
omg I think I finally did it

1755275492
tsujp!497e1f7b6a@sourcehut/user/tsujp
https://gist.github.com/tsujp/99e3009295bd7ed1ec9ba3bf435604c2

1755276112
tsujp!497e1f7b6a@sourcehut/user/tsujp
hindsight being 20/20 i think i was tunnel visioning a solid 9000/10 there

1755276114
tsujp!497e1f7b6a@sourcehut/user/tsujp
_sigh_

1755276147
tsujp!497e1f7b6a@sourcehut/user/tsujp
my bad...

1755279312
seti_!~seti_@user/seti-:64798
anyone here know how zig implements its error values? In runtime how would a normal return value be differentiated from an error return value? 

1755279570
seti_!~seti_@user/seti-:64798
is there an error bit set on the cpu or something?

1755280345
rvrb!~rvrb@156.146.51.229
naively, I would expect it to be a tagged union, but I don't know

1755281224
ifreund!2940d10f8b@user/ifreund
andrewrk: thanks for the review comments! I'll be offline for a couple of hours starting now so take your time :)

1755281277
seti_!~seti_@user/seti-:64798
rvrb: someone said something similar, basically a struct with two fields with one of them containing the error code 

1755281295
rvrb!~rvrb@156.146.51.229
seti_: I am not very good at reading assembly, but I think based on this output, my intuition is correct and it is using a tagged union; the output of the function looks like it is 16 bytes in this: https://godbolt.org/z/nfP3M3beE

1755281307
rvrb!~rvrb@156.146.51.229
I would assume the compiler will also optimize where it can

1755281576
rvrb!~rvrb@156.146.51.229
key line I think "cmp     word ptr [rbp - 8], 0"; which I think is the `catch` checking if the error is 0 (no error)

1755281656
andrewrk!~andrewrk@mail.ziglang.org
ifreund: thanks for helping with the release! ttyl

1755281875
seti_!~seti_@user/seti-:64798
rvrb yeah in the not zero jump to label it makes a call to an error handler so it seems to be something like that

1755282017
rvrb!~rvrb@156.146.51.229
another point: https://zigbin.io/630925/run

1755282698
rvrb!~rvrb@156.146.51.229
well, anyways, the answer is in the name: "error unions"

1755283040
seti_!~seti_@user/seti-:64798
makes sense

1755292670
Profpatsch!~Profpatsc@user/Profpatsch
 os.linux.x86_64.F seems to be missing a bunch of definitions

1755292681
Profpatsch!~Profpatsc@user/Profpatsch
like F_ADD_SEALS or F_SEAL_SEAL

1755293185
Profpatsch!~Profpatsc@user/Profpatsch
maybe relevant that they are behind a __USE_GNU ifdef

1755293209
Profpatsch!~Profpatsc@user/Profpatsch
idk what that means since they should be supported by linux fcntl?

1755293418
rvrb!~rvrb@156.146.51.229
andrewrk: I think I have seen you contemplating moving Zig away from GitHub in various discussions here, but I just need to put out that Zig's GH issue tracker is probably THE best source of information for Zig knowledge for me right now.. the core team is super responsive to even closed issues from years ago with suggestions and code samples. I

1755293418
rvrb!~rvrb@156.146.51.229
would hope any migration took preserving issues, issue numbers, links between them, and other metadata very seriously

1755293474
rvrb!~rvrb@156.146.51.229
9/10 times I have a question I find a conversation on a GH issue that answers every follow up question I have

1755293535
andrewrk!~andrewrk@mail.ziglang.org
rvrb: the concrete proposal that I suggested to the core team this week is to focus on finding a better solution for CI, and leave issues alone for now

1755293571
andrewrk!~andrewrk@mail.ziglang.org
the CI is in a problematic state right now since they regressed the scheduling policy to be effectively random

1755293614
rvrb!~rvrb@156.146.51.229
ah, gross

1755293616
andrewrk!~andrewrk@mail.ziglang.org
that said, I have a dream for a bug tracker that uses git as the database, and I'm considering spending some time to make that a reality

1755293677
andrewrk!~andrewrk@mail.ziglang.org
even if we go that route, I will advocate for *not* migrating anything, and simply having an old and new system coexisting for a long period of time

1755293752
rvrb!~rvrb@156.146.51.229
it's been a few years since I did devops work professionally but I was quite happy with BuildKite for being self hostable, pretty affordable because of that, and quite flexible for build matrices. it is not free but I would guess they do decent open source, charity, and nonprofit discounts

1755293765
rvrb!~rvrb@156.146.51.229
the git project sounds fun. if you do, I would love to contribute

1755293769
andrewrk!~andrewrk@mail.ziglang.org
cool!

1755293779
andrewrk!~andrewrk@mail.ziglang.org
well, I would definitely want to use new io system for this project :)

1755293799
rvrb!~rvrb@156.146.51.229
seems like a good test case for it

1755293858
Profpatsch!~Profpatsc@user/Profpatsch
andrewrk: check out https://github.com/git-dit/git-dit it unfortunately never left vaporware stage, but the ideas are solid iirc

1755293871
Profpatsch!~Profpatsc@user/Profpatsch
maybe it’s time to implement it in zig :)

1755293914
Profpatsch!~Profpatsc@user/Profpatsch
basically empty commits where all the issue data is in the commit message & assorted metadata

1755293974
andrewrk!~andrewrk@mail.ziglang.org
idk, whenever people show me these projects, I can't help but think that I could get from zero to better than that faster than they could 

1755293984
Profpatsch!~Profpatsc@user/Profpatsch
andrewrk: and you would be right

1755294004
Profpatsch!~Profpatsc@user/Profpatsch
it’s was a student project back then

1755294029
andrewrk!~andrewrk@mail.ziglang.org
also there's always a temptation to reuse somebody's idea, like peeking at the answer before you try it yourself

1755294032
Profpatsch!~Profpatsc@user/Profpatsch
written in a pre-alpha language :P

1755294039
andrewrk!~andrewrk@mail.ziglang.org
if I look at the git primitives without peeking I might come up with a better way to use them

1755294074
rvrb!~rvrb@156.146.51.229
you have the advantage of always having the "it helps me test out a new use case for my language" trump card

1755294077
Profpatsch!~Profpatsc@user/Profpatsch
fwiw I think the message-only approach is the right one, cause you can avoid merge conflicts entirely that way and still piggyback on the commit dag

1755294102
Profpatsch!~Profpatsc@user/Profpatsch
but yeah, I agree

1755294108
Profpatsch!~Profpatsc@user/Profpatsch
priming is bad :)

1755294755
andrewrk!~andrewrk@mail.ziglang.org
yeah I was thinking append-only as well. also an invitation tree based on public/private key cryptography

1755294794
andrewrk!~andrewrk@mail.ziglang.org
my focus will be on ensuring the public facing web UI is as smooth as people are used to, while providing the only defense against modern spam technology

1755298474
Earnestly!~earnest@user/earnestly
Have you seen radicle.xyz yet? Unlike git-bug and co. they do seem to focus on the web ui and appears to use nostr-like id (pubkey crypto)

1755298489
Earnestly!~earnest@user/earnestly
> features such as issues, discussions and code review to be implemented as Git objects.

1755298505
Earnestly!~earnest@user/earnestly
Seems to use noise framework

1755298545
Earnestly!~earnest@user/earnestly
andrewrk: demo https://app.radicle.xyz/nodes/seed.radicle.xyz/rad%3Az3gqcJUoA1n9HaHKufZs5FCSGazv5

1755298602
andrewrk!~andrewrk@mail.ziglang.org
looks neat

1755298674
andrewrk!~andrewrk@mail.ziglang.org
looks really neat

1755299021
Drixtan!~Drixtan@user/Drixtan
I am sure you can get from zero to better than that, faster than they ever could, let's go andrewrk!

1755299159
andrewrk!~andrewrk@mail.ziglang.org
actually I think this one is looking like it's on the right track, I would try to back this before competing with it

1755299167
rvrb!~rvrb@156.146.51.229
just be aware that they are funded by a crypto organization

1755299298
andrewrk!~andrewrk@mail.ziglang.org
you have to care more about how something is funded when it's closed source. when it's open source and popular, if some central entity tries to go a bad direction, the large community can simply fork

1755299322
tydel!tydel@user/tydel
^

1755300057
jenia2!~jenia@107.171.172.254
Hello. I hear that C is awesome!

1755300063
jenia2!~jenia@107.171.172.254
oh, sorry zig

1755300183
Drixtan!~Drixtan@user/Drixtan
well, both are awesome, so you are at the right place

1755300223
Drixtan!~Drixtan@user/Drixtan
what's great, is the zig interop with C, you have to ... (sorry) /C/ that by yourself

1755300243
tydel!tydel@user/tydel
radicle is pretty cool

1755300253
jenia2!~jenia@107.171.172.254
they are. I was pleasantly surprised to see that Zig is one of libera's biggest channels

1755301178
rvrb!~rvrb@156.146.51.229
it does seem pretty cool. I hope it outgrows its benefactor

