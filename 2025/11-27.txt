1764208395
rvrb!~rvrb@156.146.51.230
rip github

1764208888
torque!~tachyon@user/torque
frankly, I hope github rests in agony, not peace

1764208904
rvrb!~rvrb@156.146.51.230
rest in piss github

1764208925
torque!~tachyon@user/torque
https://ziglang.org/news/migrating-from-github-to-codeberg/

1764208929
torque!~tachyon@user/torque
sick

1764208934
rvrb!~rvrb@156.146.51.230
andrewrk really giving families something to talk about over thanksgiving dinner with this post

1764208975
torque!~tachyon@user/torque
congrats to the team for making a tough decision

1764209036
rvrb!~rvrb@156.146.51.230
leading by example, you love to see it

1764209045
torque!~tachyon@user/torque
agree

1764209203
torque!~tachyon@user/torque
really need to set up some kind of donation... 

1764209722
torque!~tachyon@user/torque
I remember learning about git for the first time from a friend back in 2010 when I was first learning to program and making a github account. it's kind of remarkable how things have changed over the last 15 years

1764209801
clevor!sid649024@id-649024.hampstead.irccloud.com
The repos that are the most important to me have been migrated to Codeberg with the corresponding Github repo becoming a mirror.

1764209857
clevor!sid649024@id-649024.hampstead.irccloud.com
The rest on Github are either forks or repos I don't care about.

1764209879
daurnimator!~daurnimat@vultr.daurnimator.com
Ah I was wondering why I suddenly saw "An owner of this repository has limited the ability to comment to users that are collaborators on this repository."

1764209900
andrewrk!~andrewrk@mail.ziglang.org
it's read-only as opposed to archived so that we can close issues 

1764210049
daurnimator!~daurnimat@vultr.daurnimator.com
My assumption was the repo was under a spam attack or something. I wonder if you can add a banner or something that points to the blog post

1764210112
torque!~tachyon@user/torque
I kind of doubt github supports that. Most projects I've seen that have moved have just put something in the readme, but since this is the same readme used on codeberg I am not sure it really makes sense

1764210466
reykjalin!7e28cf3a41@user/reykjalin
the repo description could be updated with a link too, if you all wanted to keep the README the same 

1764210826
torque!~tachyon@user/torque
that might be a good idea

1764210849
daurnimator!~daurnimat@vultr.daurnimator.com
Could make a sticky issue?

1764211272
reykjalin!7e28cf3a41@user/reykjalin
to be clear: the readme has already been updated to link to the blog post. I was just suggesting the repo description as an alternative 

1764211533
JetpackJackson!739e7f3d14@user/JetpackJackson
Just saw zig moved to codeberg, nice!

1764211556
torque!~tachyon@user/torque
looks like the readme has been updated as well, though it links to the blog post, which does not appear to actually contain a link to the codberg repo

1764211614
torque!~tachyon@user/torque
recommend putting a link to the codeberg repo at the top of the post

1764211714
reykjalin!7e28cf3a41@user/reykjalin
the blog post does contain a link to the repo, just in a <code> tag, it’s not a hyperlink. the point still stands though; it’s a little hard to find the link

1764211760
torque!~tachyon@user/torque
ah, so it does. indeed, I was looking for hyperlinks

1764213979
grayhatter!~grayhatte@user/grayhatter
> GitHub Actions started “vibe-scheduling”

1764214007
grayhatter!~grayhatte@user/grayhatter
lmao, that's hilariously accurate

1764214012
grayhatter!~grayhatte@user/grayhatter
also depressingly

1764220516
rvrb!~rvrb@156.146.51.230
grayhatter: see if the semantics make more sense now, I am definitely happier with the current state: https://codeberg.org/ziglang/zig/pulls/30006

1764220653
rvrb!~rvrb@156.146.51.230
tldr instrumenting code log.span()/span.end(). std.Io code Executor.create()/executor.link(parent_span)/executor.unlink(parent_span).. fibers const stored_span = span.suspend(); stored_span.resume()

1764231448
rhizoome!ganwell@user/rhizoome
andrewrk: This might sound bitter, but I really only like to know how I should behave. Am I correct that the zig project is not really profiting from small contributions? I had a fixed a few simple bugs and made PRs. I really did my homework and asked people from the community to review what I did. I had good tests. Most of them just got fixed by you as refactored things. But the last one was really frustrating. I kept it alive for months then I forgot it. 

1764231448
rhizoome!ganwell@user/rhizoome
The moment there was a merge conflict you closed because of that. The situation was more complicated: the move to codeberg, it looked like CI was failing but that was a false alarm, but this is already a long message. I intended to start with small bugs, to learn how to do more valuable contributions, which never happened because of how things played out.

1764235675
vpol!~vpol@2a03:b0c0:1:d0::c45:e001
great blog post!

1764243031
Earnestly!~earnest@user/earnestly
rhizoome: Consider https://andrewkelley.me/post/open-letter-everyone-butted-heads.html

1764243069
Earnestly!~earnest@user/earnestly
rhizoome: Particularly the last 4 paragraphs or so

1764251699
erock!8a023a9e4a@pico/erock
+1 on moving off github, grats to the team for making a tough decision

1764253456
andrewrk!~andrewrk@mail.ziglang.org
rhizoome: one way to think of it is that contributions are auditions for gaining more trust. The core zig team has very limited amount of time to engage in trust building, but every time you interact, you build trust

1764253471
andrewrk!~andrewrk@mail.ziglang.org
once you build a sufficient amount of trust, you will find that your pull requests are prioritized and merged quickly

1764253510
andrewrk!~andrewrk@mail.ziglang.org
for the occasional contributors, unfortunately, it can take a very long time to get to things, especially when the changes require additional verification, testing, and consideration by the reviewers

1764253541
andrewrk!~andrewrk@mail.ziglang.org
I am sorry, if you open the PR again I will try to get to it again

1764253572
andrewrk!~andrewrk@mail.ziglang.org
this is a fundamental problem with the organization that cannot be fixed; we have sufficient funding because the team is small and the users are many

1764259832
clevor!sid649024@id-649024.hampstead.irccloud.com
andrewrk: Please rewrite the post; calling someone a monkey is derogatory and sometimes racist.

1764260170
Earnestly!~earnest@user/earnestly
clevor: You don't have to be like this

1764260423
clevor!sid649024@id-649024.hampstead.irccloud.com
?

1764263894
blackbeard420!~blackbear@user/blackbeard420
trying out some basic tcp with the new Io stuff, doing `var writer = stream.writer(io, &.{});` followed by `try writer.interface.writeAll("Testing\n\n");` works great. However i was getting a segfault when i was trying to do `var writer_interface = writer.interface` and then using my `writer_interface.writeAll();` but directly accessing via writer.interface.writeAll works perfectly

1764264160
andrewrk!~andrewrk@mail.ziglang.org
blackbeard420: you must not copy the interface

1764264251
blackbeard420!~blackbear@user/blackbeard420
understood, thanks

1764264368
blackbeard420!~blackbear@user/blackbeard420
really liking the std.Io stuff so far

1764267216
andrewrk!~andrewrk@mail.ziglang.org
happy hacking :)

1764270065
as!~schipploc@schipplock.com
hi

1764270959
rvrb!~rvrb@156.146.51.230
hi as

1764271903
as!~schipploc@schipplock.com
hey rvrb :)

1764272860
rvrb!~rvrb@156.146.51.230
ok TIL I can't use u64 atomics on some targets, but what is a man to do when he needs a portable monotonic counter that would probably overflow in a u32?

1764272933
grayhatter!~grayhatte@user/grayhatter
@cmpxchg or mutex

1764273071
rvrb!~rvrb@156.146.51.230
grayhatter: like a split high/low u32 with a cmpxchg loop? you know the context (tracing); could that be a perf pitfall for this perf sensitive path?

1764273155
rvrb!~rvrb@156.146.51.230
we're talking nanosecond precision desirable so I am wary

1764273159
grayhatter!~grayhatte@user/grayhatter
correct

1764273225
rvrb!~rvrb@156.146.51.230
perhaps an acceptable compromise for fallback (mutex I do not think would be here)

1764273296
grayhatter!~grayhatte@user/grayhatter
you don't have nanosecond precision currently

1764273346
andrewrk!~andrewrk@mail.ziglang.org
rvrb: maybe you can tolerate integer wraparound somehow?

1764273354
andrewrk!~andrewrk@mail.ziglang.org
and then use usize

1764273408
rvrb!~rvrb@156.146.51.230
that was my thought but I haven't thought of a way to do it reliably

1764273532
grayhatter!~grayhatte@user/grayhatter
what x32 arch are you thinking about rvrb?

1764273568
rvrb!~rvrb@156.146.51.230
grayhatter: just trying to deal with CI failures on my PR, currently atomic.Value(u64) fails to compile on arm-linux-musleabihf

1764273658
grayhatter!~grayhatte@user/grayhatter
wouldn't incrementOrRollover(), if (read() == 0) incrementHighInt(), be 1 cycle more than you're currently spending?

1764273871
rvrb!~rvrb@156.146.51.230
you're suggesting fetchAdd then if fetched == 0 increment high?

1764273930
rvrb!~rvrb@156.146.51.230
maybe I make the counter a usize - 1 bit, use the last bit as a hazard flag to rollover high?

1764273949
grayhatter!~grayhatte@user/grayhatter
that's basically what I was thinking, the more I think about it, the more I want to suggest a "blind" rollover, and users who know they are likely to rollover a usize can prepend their own time component

1764273970
rvrb!~rvrb@156.146.51.230
one of my concerns is that due to the nature of spans nesting, there is going to be root level spans that are in the low level integer range and I really can't afford collision on span id 0, 1, 2, etc

1764273979
rvrb!~rvrb@156.146.51.230
since they would still be active

1764273989
grayhatter!~grayhatte@user/grayhatter
I'd probably call that a carry bit, but that's a cute way of doing it

1764274032
rvrb!~rvrb@156.146.51.230
like I'm not insane for thinking it's extremely unlikely to roll through 2 billion spans in the time it takes to flip the high bit right

1764274097
rvrb!~rvrb@156.146.51.230
2 billion nanoseconds is like 10 seconds so I think that's pretty safe

1764274120
grayhatter!~grayhatte@user/grayhatter
2^31 ns in 2.14s

1764274135
rvrb!~rvrb@156.146.51.230
kagi has failed me

1764274145
grayhatter!~grayhatte@user/grayhatter
did you use the AI thing?

1764274154
rvrb!~rvrb@156.146.51.230
I didn't think so, but maybe unintentionally

1764274173
rvrb!~rvrb@156.146.51.230
thought I was using the calculator

1764274192
rvrb!~rvrb@156.146.51.230
even still, 2 seconds seems extremely acceptable

1764274253
grayhatter!~grayhatte@user/grayhatter
do you know how long a system context switch takes in nanoseconds?

1764274302
grayhatter!~grayhatte@user/grayhatter
I'm assuming that's what you're racing agains

1764274313
rvrb!~rvrb@156.146.51.230
no

1764274517
grayhatter!~grayhatte@user/grayhatter
it'll be arch dependant, obviously, but the best case seems to be around 2us

1764274585
rvrb!~rvrb@156.146.51.230
tight

1764274606
grayhatter!~grayhatte@user/grayhatter
[Xeon Gold 6256, RHEL 7, Kernel 3.10]

1764275017
grayhatter!~grayhatte@user/grayhatter
oh, this is cool, according to [google talk], you can get a ctx switch in ~170ns?

1764275029
grayhatter!~grayhatte@user/grayhatter
https://eli.thegreenplace.net/2018/measuring-context-switching-and-memory-overheads-for-linux-threads

1764275094
rvrb!~rvrb@156.146.51.230
I mean 2 seconds is obviously quite acceptable, but yeah I was interested in what the actual constraints are

1764276183
rvrb!~rvrb@156.146.51.230
why not just use a high bit for every thread, have a thread local low bit, abandon global monotonicity entirely for a global unique guarantee and a thread local monotonic guarantee

1764276224
rvrb!~rvrb@156.146.51.230
then it's the high bit that is atomic and the low bit is thread local

1764276234
rvrb!~rvrb@156.146.51.230
saving a lot of unnecessary fetchAdds

1764276318
rvrb!~rvrb@156.146.51.230
this moves constraints to thread count/lifespan; if chewing through threads you're wasting a ton of IDs

1764276355
rvrb!~rvrb@156.146.51.230
high u32/low u32* 

1764287875
grayhatter!~grayhatte@user/grayhatter
is it invalid to continue to use the std.Io.File.reader().interface.buffer after the file handle is closed?

1764287913
grayhatter!~grayhatte@user/grayhatter
interface/buffer

