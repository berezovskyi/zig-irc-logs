1757289600
tranzystorekk!86175ff574@voidlinux/maintainer/tranzystorekk
https://ziglang.org/documentation/master/std/#std.Io.Reader.streamRemaining

1757289883
dsal!sid13060@id-13060.lymington.irccloud.com
Is that meaningfully different from stream() ?

1757289962
tranzystorekk!86175ff574@voidlinux/maintainer/tranzystorekk
does the convenience loop you wanted (streams from reader to writer until eof)

1757289991
dsal!sid13060@id-13060.lymington.irccloud.com
Yeah, reading the source.  I assumed stream would do that.

1757289996
tranzystorekk!86175ff574@voidlinux/maintainer/tranzystorekk
with stream you gotta handle error.EndOfStream manually

1757290061
dsal!sid13060@id-13060.lymington.irccloud.com
Unfortunately, stream worked for me on my first try.  I'm grateful you made me look at this other thing.  :)

1757290116
clevor!sid649024@id-649024.hampstead.irccloud.com
If `null` is not necessarily going to be zero on some targets, could it be configurable? For example, address zero on the TI-84 Plus CE maps to flash, but CEmu supports a watchpoint command to cause a breakpoint on an address range like E40000-EFFFFF.

1757291796
andrewrk!~andrewrk@mail.ziglang.org
clevor: your issue is: https://github.com/ziglang/zig/issues/21870

1757291811
clevor!sid649024@id-649024.hampstead.irccloud.com
thanks

1757292096
andrewrk!~andrewrk@mail.ziglang.org
in retrospect, all 0xff bytes is a much more widely applicable null value, isn't it?

1757292107
andrewrk!~andrewrk@mail.ziglang.org
the only value that's not mappable on all systems

1757292419
clevor!sid649024@id-649024.hampstead.irccloud.com
On the CE, it is unmapped, but CEmu uses it for debug controls like watchpoints. There aren't any addresses on the CE that cause a crash upon reading.

1757309955
rvrb!~rvrb@156.146.51.230
is a comptime allocator still something within reach? https://github.com/ziglang/zig/issues/1291

1757314132
andrewrk!~andrewrk@mail.ziglang.org
rvrb: yes

1757314972
omentic!~apropos@dhcp-206-87-253-115.ubcsecure.wireless.ubc.ca
ha, reading through the manual and just learned that zig modules are structs

1757314992
omentic!~apropos@dhcp-206-87-253-115.ubcsecure.wireless.ubc.ca
and subsequently that structs can have functions and all sorts of stuff within them

1757315016
omentic!~apropos@dhcp-206-87-253-115.ubcsecure.wireless.ubc.ca
sneaky sneaky class-like syntax ;)

1757316086
andrewrk!~andrewrk@mail.ziglang.org
I think people get classes and namespaces confused

1757316096
andrewrk!~andrewrk@mail.ziglang.org
the hallmark of a class is inheritance and virtual functions

1757316439
omentic!~apropos@dhcp-206-87-253-115.ubcsecure.wireless.ubc.ca
when i found this out my first thought was "oh! this is a sneaky trick to get c++ programmers to stop using inheritance"

1757316497
omentic!~apropos@dhcp-206-87-253-115.ubcsecure.wireless.ubc.ca
haven't yet got to how this influences namespaces, i assume functions inside structs bear some method-like syntax?

1757316650
andrewrk!~andrewrk@mail.ziglang.org
https://ziglang.org/documentation/0.15.1/#struct

1757316660
omentic!~apropos@dhcp-206-87-253-115.ubcsecure.wireless.ubc.ca
interestingly wrt. namespaces, the other day i was looking at lean. they're an ml but they decouple *modules* and namespaces. kinda a funny choice, there's quite good reasons ex. rust and others don't do that, but it works nicely for their niche

1757316761
omentic!~apropos@dhcp-206-87-253-115.ubcsecure.wireless.ubc.ca
thx for the link. i'm kinda very slowly reading through the manual top-down rn and taking notes

1757316894
omentic!~apropos@dhcp-206-87-253-115.ubcsecure.wireless.ubc.ca
one thing i haven't figured out yet -- what's up with `const Name = struct {}`? i see the motivations of `struct {}` uniformity in this syntax but what exactly does it mean to have a `const` type? is it introspectable in some way?

1757317198
omentic!~apropos@dhcp-206-87-253-115.ubcsecure.wireless.ubc.ca
oh, neat, so `.` isn't both namespacing and field access -- it's just namespacing. cause field access is namespacing...

1757317308
netvor!~netvor@2a00:ca8:a1f:cd0:dbfc:7ba9:de8d:e0d2
you can introspect types in comptime with things like @typeInfo() and even construct new ones with @Type()

1757317350
netvor!~netvor@2a00:ca8:a1f:cd0:dbfc:7ba9:de8d:e0d2
std.builtin.Type is what @typeInfo() returns and @Type() takes

1757317511
omentic!~apropos@dhcp-206-87-253-115.ubcsecure.wireless.ubc.ca
cool

1757319418
ifreund!2940d10f8b@user/ifreund
more importantly perhaps, one can pass types to functions at comptime

1757319429
ifreund!2940d10f8b@user/ifreund
which is how generic containers for example are implemented

1757323951
netvor!~netvor@2a00:ca8:a1f:cd0:dbfc:7ba9:de8d:e0d2
what is the equivalent of "Pythonic" for Zig?  :)  as in "..but using ____ is more Pythonic" --> "using (unmanaged variants / writer / ...?)  is more _____"?

1757324160
dutchie!~dutchie@user/dutchie
"Ziggy"? or just "idiomatic"

1757324252
tranzystorekk!86175ff574@voidlinux/maintainer/tranzystorekk
why is a separate word so important to express a simple concept

1757324283
netvor!~netvor@2a00:ca8:a1f:cd0:dbfc:7ba9:de8d:e0d2
because it's fun?

1757324287
netvor!~netvor@2a00:ca8:a1f:cd0:dbfc:7ba9:de8d:e0d2
:)

1757324338
tranzystorekk!86175ff574@voidlinux/maintainer/tranzystorekk
lets invent sth funky then, like Zigalicious

1757324405
netvor!~netvor@2a00:ca8:a1f:cd0:dbfc:7ba9:de8d:e0d2
"Zigalicious" *is* very funky,  very funky indeed.

1757324523
tranzystorekk!86175ff574@voidlinux/maintainer/tranzystorekk
who said naming things is hard B)

1757324734
Gliptic!~glip@2a01:4f8:c012:91f3::1
move zig, for great justice

1757324905
netvor!~netvor@2a00:ca8:a1f:cd0:dbfc:7ba9:de8d:e0d2
Zigalicious wins, at least for today https://ziggit.dev/t/embracing-unmanaged-plans-with-eg-autohashmap/11934

1757325293
ifreund!2940d10f8b@user/ifreund
netvor: all containers will get the same treatment that ArrayList did in 0.15 eventually

1757325435
netvor!~netvor@2a00:ca8:a1f:cd0:dbfc:7ba9:de8d:e0d2
nice, thanks

1757329608
tranzystorekk!86175ff574@voidlinux/maintainer/tranzystorekk
lol lets get zigalicious trending

1757332799
clevor!sid649024@id-649024.hampstead.irccloud.com
zigiomatic

1757333285
dutchie!~dutchie@user/dutchie
zigtastic

1757333360
clevor!sid649024@id-649024.hampstead.irccloud.com
blazigly fast

1757335839
netvor!~netvor@2a00:ca8:a1f:cd0:dbfc:7ba9:de8d:e0d2
lol

1757336101
Franciman!~Franciman@mx1.fracta.dev
what about ziggurat

1757336103
Franciman!~Franciman@mx1.fracta.dev
?

1757336113
Franciman!~Franciman@mx1.fracta.dev
my software is a zigurat

1757336314
palanix!~palanix@dynamic-077-186-001-231.77.186.pool.telefonica.de
Franciman: That name is sadly already taken

1757336360
Franciman!~Franciman@mx1.fracta.dev
sad

1757337510
netvor!~netvor@2a00:ca8:a1f:cd0:dbfc:7ba9:de8d:e0d2
also too ancient for Zig .. zig is the fresh stuff! :D

1757337582
netvor!~netvor@2a00:ca8:a1f:cd0:dbfc:7ba9:de8d:e0d2
although zig software is meant to be eventually ancient---but still used, not just like historical artifact

1757338176
clevor!sid649024@id-649024.hampstead.irccloud.com
Haskell programs are historical artifacts due to https://xkcd.com/1312/

1757339174
ezzieyguywuf!~Unknown@user/ezzieyguywuf
unironically looknig forward to migrating to 0.15.1. I enjoyed the Don't Forget to Flush talk - specifically I liked the usage of "source" and "sink" nomenclature rather than "writer" and "reader". why then is the interface not std.Io.Sink and std.Io.Source?!

1757346140
tranzystorekk!86175ff574@voidlinux/maintainer/tranzystorekk
probably for prior consistence

1757346160
JetpackJackson!739e7f3d14@user/JetpackJackson
Is there a way to fetch images from a URL in zig while also compressing them or otherwise downloading them in a low quality?

1757346330
Gliptic!~glip@2a01:4f8:c012:91f3::1
that's two independent concerns

1757346386
Gliptic!~glip@2a01:4f8:c012:91f3::1
you can download files (including images) with std.http.Client

1757346410
Gliptic!~glip@2a01:4f8:c012:91f3::1
there's nothing in the std lib to decode or encode images

1757347188
ezzieyguywuf!~Unknown@user/ezzieyguywuf
oh neat, today I learned at work we use https://github.com/uber/hermetic_cc_toolchain, which uses zig! zig at work!

1757347249
ezzieyguywuf!~Unknown@user/ezzieyguywuf
JetpackJackson: sounds like you may want to serve a lower quality image server-side? or a compressed image?

1757347316
JetpackJackson!739e7f3d14@user/JetpackJackson
i dont have control over the server

1757347347
JetpackJackson!739e7f3d14@user/JetpackJackson
im porting an app i wrote in jetpack compose to zig+qt and in it i had a way to fetch images while having them reduced quality

1757347636
JetpackJackson!739e7f3d14@user/JetpackJackson
im displaying a preview image of a bird but i dont want the images to be super high quality if its just a little preview

1757347653
JetpackJackson!739e7f3d14@user/JetpackJackson
i also need to figure out how to not load stuff for boxes out of screen but thats a later problem

1757350462
netvor!~netvor@2a00:ca8:a1f:cd0:dbfc:7ba9:de8d:e0d2
maybe there should be an std fork which uses exclusively the Sink/Source nomenclature

1757350524
netvor!~netvor@2a00:ca8:a1f:cd0:dbfc:7ba9:de8d:e0d2
recently as i was wrapping my head around writergate (ehm, Sourcegate?  Sinkgate?)  i just realized how confusing the writer/reader nom. is

1757350645
netvor!~netvor@2a00:ca8:a1f:cd0:dbfc:7ba9:de8d:e0d2
i mean, File.writer .. wait .... is this "writer" guy somehone who takes my data and writes it into file?  or does he take the file's data and write it into my buffer?

1757350723
netvor!~netvor@2a00:ca8:a1f:cd0:dbfc:7ba9:de8d:e0d2
now the buffer is part of the interface it's actually more confusing to me.  or should i say, the new (clearly better) model is less forgiving towards the pre-existing confusion

1757353275
clevor!sid649024@id-649024.hampstead.irccloud.com
netvor: std.Io.Writer.write first writes to the buffer, and then calls into the vtable if the buffer is full or whatnot.

1757357320
JetpackJackson!739e7f3d14@user/JetpackJackson
hmm when i scroll up and down my program memory usage increases :/ ill have to figure that out

1757359990
netvor!~netvor@2a00:ca8:a1f:cd0:dbfc:7ba9:de8d:e0d2
wait, looks like std.fs.File.Metadata was removed .. and perhaps replaced with Stat, i can't see it in release notes

1757360587
netvor!~netvor@2a00:ca8:a1f:cd0:dbfc:7ba9:de8d:e0d2
but it looks like Stat is platform-independent now.  i don't recall why i relied on Metadata, i suppose it was because of the platform-indepentece but stat seems to work well

1757362590
andrewrk!~andrewrk@mail.ziglang.org
netvor: sorry, I didn't notice when Metadata was contributed, and I would have liked a chance to review it first. As you can see it's fairly redundant with Stat

1757363066
netvor!~netvor@2a00:ca8:a1f:cd0:dbfc:7ba9:de8d:e0d2
np

1757363069
netvor!~netvor@2a00:ca8:a1f:cd0:dbfc:7ba9:de8d:e0d2
:)

1757366969
dsal!sid13060@id-13060.lymington.irccloud.com
What's the second argument to dependency in the build system?  (or perhaps better, how can I know what it is?)

1757367174
andrewrk!~andrewrk@mail.ziglang.org
dsal: those are some rather load-bearing nonexistent doc comments, aren't they?

1757367229
andrewrk!~andrewrk@mail.ziglang.org
to get you unstuck: it should be a struct literal that populates the same options that the package exposes via CLI

1757367259
dsal!sid13060@id-13060.lymington.irccloud.com
I dug into the implementation a bit and didn't quite figure out where I ended up.  It looks kind of like a Module and added something from there and what you said makes it makes sense now.  :)

1757367290
dsal!sid13060@id-13060.lymington.irccloud.com
i.e., I added a `.strip = true` and it told me the dependency didn't have a `-Dstrip`

1757367408
dsal!sid13060@id-13060.lymington.irccloud.com
Thanks, though.  I'm mainly just trying to finally actually understand this thing since I updated a few projects over the weekend with cargo culting.  I got better results after trying to understand what the stuff in the file meant.

1757367439
andrewrk!~andrewrk@mail.ziglang.org
I do apologize for the underdocumentation of build system APIs

1757367444
andrewrk!~andrewrk@mail.ziglang.org
we'll get there...

1757368221
rvrb!~rvrb@156.146.51.230
I've utilized dangling stack pointers in comptime; it works, but it probably shouldn't. things like "const buf: [input.len]T = undefined;" then filtering on an input and returning a slice into buf. I assume I should not be doing this? I guess bigger picture, how do I reason with lifetimes in comptime; same as ever?

1757368381
rvrb!~rvrb@156.146.51.230
actually, I guess what I have done (and should do) in that case is first calculate the necessary size, then use that to declare the appropriately sized array, then return it by value instead of a slice

1757368409
rvrb!~rvrb@156.146.51.230
the example I was trying to recall was this https://github.com/gdzig/oopz/blob/a02a3eb8d0914437ecf317d36fca426fee300e72/src/oopz.zig#L105-L118

1757368511
rvrb!~rvrb@156.146.51.230
but I have no idea how that even works in the comptime evaluator; is it allocating? is the comptime stack dynamically sized?

1757368614
andrewrk!~andrewrk@mail.ziglang.org
rvrb: in comptime code, all memory is garbage collected (at compile time). so there's not really any such thing as dangling comptime pointers

1757368632
rvrb!~rvrb@156.146.51.230
oh, excellent

1757368652
rvrb!~rvrb@156.146.51.230
just out of curiosity, does the comptime interpreter's stack use a fixed size stack slot?

1757368678
netvor!~netvor@2a00:ca8:a1f:cd0:dbfc:7ba9:de8d:e0d2
few people know zig is actuallyh garbage collected language (AS LONG as you do everything in comptime :D)

1757368684
andrewrk!~andrewrk@mail.ziglang.org
not sure what you mean by slot - but it's using the compiler's stack directly, which is something like 32M

1757368715
andrewrk!~andrewrk@mail.ziglang.org
https://github.com/ziglang/zig/blob/0.15.1/build.zig#L14

1757368717
andrewrk!~andrewrk@mail.ziglang.org
46M

1757368825
rvrb!~rvrb@156.146.51.230
VMs like V8 and others do NAN tagging and only push u64/8 byte values to stack; I don't know the right terms 

1757368852
rvrb!~rvrb@156.146.51.230
if value is larger than u64 it is heap allocated and a pointer is pushed

1757368882
andrewrk!~andrewrk@mail.ziglang.org
oh, zig has a whole interning database for stuff like that

1757368887
andrewrk!~andrewrk@mail.ziglang.org
src/InternPool.zig

1757368911
andrewrk!~andrewrk@mail.ziglang.org
every comptime value ends up being represented by a 32-bit index

1757368928
rvrb!~rvrb@156.146.51.230
oh, tight

1757368959
rvrb!~rvrb@156.146.51.230
is that basically an arena allocator?

1757368971
andrewrk!~andrewrk@mail.ziglang.org
it's basically a hash table

1757368989
rvrb!~rvrb@156.146.51.230
what is the key?

1757368995
rvrb!~rvrb@156.146.51.230
the 32-bit index?

1757369011
andrewrk!~andrewrk@mail.ziglang.org
InternPool.Key

1757369081
andrewrk!~andrewrk@mail.ziglang.org
it's an "ephemeral" type - used in getters and setters but not stored directly in memory

1757369099
andrewrk!~andrewrk@mail.ziglang.org
in memory it uses the "encoding" strategy that I outlined in that "Practical DOD" talk

1757369129
andrewrk!~andrewrk@mail.ziglang.org
i.e. common values have small encodings

1757369153
rvrb!~rvrb@156.146.51.230
the value on the stack that points to the value in the pool is the array index in the pool, and not this key

1757369180
andrewrk!~andrewrk@mail.ziglang.org
correct. but from the array index, the key can be constructed

1757369183
rvrb!~rvrb@156.146.51.230
the key is I assume how things like types are memoized?

1757369205
andrewrk!~andrewrk@mail.ziglang.org
yes. not only types but all comptime values

1757369240
rvrb!~rvrb@156.146.51.230
wow ok, comptime melts my brain every time I think about how it works at an implementation level but this is resolving a lot of that confusion

1757369370
rvrb!~rvrb@156.146.51.230
I asked last night about comptime allocators; would that be an interface into this pool or something else entirely? maybe the pool is expanded with a heap allocated pointer type or something?

1757369379
andrewrk!~andrewrk@mail.ziglang.org
one of the neat properties of this data structure is that it can be trivially serialized by copying a handful of arrays directly to disk, discarding hash map metadata. when deserializing, populate those arrays and then compute hash map metadata

1757369405
andrewrk!~andrewrk@mail.ziglang.org
it's not taken advantage of yet, but that will be a key strategy in incremental compilation that persists across compiler processes

1757369438
andrewrk!~andrewrk@mail.ziglang.org
and it's surprisingly compact. last I checked it was 35M for zig compiler itself (300,000+ lines)

1757369444
rvrb!~rvrb@156.146.51.230
it's like a serializable/memoized computation graph

1757369483
rvrb!~rvrb@156.146.51.230
why is everything a graph

1757369491
andrewrk!~andrewrk@mail.ziglang.org
I think I left a message in that issue about where we're at with comptime allocators. last I checked we're just missing an enhancement to allow comptime-known inline function pointers

1757369516
rvrb!~rvrb@156.146.51.230
in the issue you said "set memory to undefined in allocator implementations rather than interface #4298 is an easy prerequisite"; which was why I asked, because that issue was closed/rejected

1757369531
andrewrk!~andrewrk@mail.ziglang.org
ah yeah I'll need to revisit that too. but it shouldn't be a showstopper

1757369564
andrewrk!~andrewrk@mail.ziglang.org
btw I'm pretty sure you can already use FixedBufferAllocator at comptime

1757369638
rvrb!~rvrb@156.146.51.230
dang you are probably right

1757369793
andrewrk!~andrewrk@mail.ziglang.org
the implementation I outlined in #1291 is nicer because each allocation is independently reapable

1757369820
andrewrk!~andrewrk@mail.ziglang.org
whereas with FBA you're gonna end up with the whole fixed buffer in the .data section of your executable

1757369834
andrewrk!~andrewrk@mail.ziglang.org
(unless it's only temporary and you don't have anything pointing into it)

1757369883
andrewrk!~andrewrk@mail.ziglang.org
consider that you can use e.g. `@fieldParentPtr` or more simply pointer addition/subtraction and legally access any of that fixed buffer

1757369911
rvrb!~rvrb@156.146.51.230
the idea I am toying with right now is a library for defining general computation graphs (think; vulkan render graph, asset build pipeline, gameplay logic scheduling) with resource dependencies etc, that can be comptime reduced into a single function with minimal coordination required

1757369918
rvrb!~rvrb@156.146.51.230
the allocator would be useful in just having a builder API at comptime

1757369957
rvrb!~rvrb@156.146.51.230
not strictly necessary, just nice to have

1757369961
andrewrk!~andrewrk@mail.ziglang.org
the idea I'm toying with right now is what to do for lunch today 🤔

1757369975
rvrb!~rvrb@156.146.51.230
new seasons hot bar

1757369982
andrewrk!~andrewrk@mail.ziglang.org
oh snap

1757370003
squeek502!~squeek502@user/squeek502
rvrb, in my experience you're likely to hit https://github.com/ziglang/zig/issues/4055 before comptime allocation becomes a blocker

1757370103
rvrb!~rvrb@156.146.51.230
interesting

1757370142
squeek502!~squeek502@user/squeek502
(see andrew's comment in that thread for a better explanation of the issue)

1757370159
squeek502!~squeek502@user/squeek502
(second comment*)

1757370199
rvrb!~rvrb@156.146.51.230
that screenshot, lol

1757372314
rvrb!~rvrb@156.146.51.230
what, if anything other than "not in scope", would stop Zig's comptime interpreter from being exposed as a fully capable Zig interpreter? and, is there any future in Zig having some kind of interpreted mode or companion language, even

1757372351
rvrb!~rvrb@156.146.51.230
I just like the idea of game scripting in Zig and don't want to ship the compiler to do it

1757372570
andrewrk!~andrewrk@mail.ziglang.org
rvrb: if you read some of src/Sema.zig you might start to intuit the reason: there's not really a comptime interpreter that is decoupled from semantic analysis; it's all one and the same

1757372615
andrewrk!~andrewrk@mail.ziglang.org
it all boils down basically to if (operation can be done at compile time) return computed_operation else emit runtime instructions to compute the operation

1757372866
rvrb!~rvrb@156.146.51.230
so I think I am understanding that the emitted instructions at that point could certainly be a VM instruction set, but why not just emit native ISA, since the hard work has been done

1757374416
andrewrk!~andrewrk@mail.ziglang.org
Sema ingests ZIR and outputs AIR instructions (a VM instruction set as you said). if you want to see how much more hard work there is to do to get from there to actual native ISA, have a peek at, for example, arch/x86_64/CodeGen.zig which ingests AIR and outputs MIR (not even x86 machine code yet, but an IR with a 1-1 mapping with x86 instructions)

1757374520
andrewrk!~andrewrk@mail.ziglang.org
then note that there is also wasm, llvm, spir-v, aarch64, risc-v, and C backends which have *different* hard work to do, and perhaps you start to see the value in the existence of AIR

1757374619
andrewrk!~andrewrk@mail.ziglang.org
by the way, zig pipeline started with only an AST. all these extra intermediate steps were added specifically to solve a problem - they weren't just cargo culted from a textbook or something

1757374634
andrewrk!~andrewrk@mail.ziglang.org
I recall programming comptime/generics based on AST mutations

1757374646
rvrb!~rvrb@156.146.51.230
I definitely didn't mean to trivialize or anything

1757374658
andrewrk!~andrewrk@mail.ziglang.org
of course not, I didn't take it that way

1757374668
rvrb!~rvrb@156.146.51.230
I guess if a subset of Zig existed that ran in an interpreter it would be after AIR then

1757374677
andrewrk!~andrewrk@mail.ziglang.org
some people are shocked to find out that zig had comptime and only AST in the pipeline

1757374703
rvrb!~rvrb@156.146.51.230
maybe it's naivety but that seems reasonable - AST walking can get you pretty far even if it's not optimal

1757374719
andrewrk!~andrewrk@mail.ziglang.org
I think one could reasonably make a zig interpreter based on AST alone

1757374731
andrewrk!~andrewrk@mail.ziglang.org
you just have to assume a target. a good choice would be wasm32-wasi

1757374748
andrewrk!~andrewrk@mail.ziglang.org
(when the code asks what it's compiling for, what do you tell it?)

1757374750
rvrb!~rvrb@156.146.51.230
I think that is effectively reducing any type slot recursively, at that point, right?

1757374778
rvrb!~rvrb@156.146.51.230
to simplify

1757374807
rvrb!~rvrb@156.146.51.230
yeah, I've attempted and failed to implement a language with comptime targeting wasm32 to understand how this works

1757374817
rvrb!~rvrb@156.146.51.230
I think I know more now and would get further, but still

1757374852
andrewrk!~andrewrk@mail.ziglang.org
interpreting is easier - you don't have to know much about wasm to do that

1757374895
andrewrk!~andrewrk@mail.ziglang.org
you just need to make the std lib call wasi_read_file or whatever rather than trying to make an x86_64 syscall in the interpreter, which remarkably is actually possible (see qemu) but a lot more complicated

1757374951
rvrb!~rvrb@156.146.51.230
there are just so many nerd snipes in writing this stuff that my ADHD kicks in full gear and I get bored or distracted; I need consequences for not reaching my goals

1757374985
rvrb!~rvrb@156.146.51.230
tbh that is part of why I was really excited for Zig day, accountability

1757375011
andrewrk!~andrewrk@mail.ziglang.org
haha

1757375046
andrewrk!~andrewrk@mail.ziglang.org
btw there is real value to this project

1757375048
rvrb!~rvrb@156.146.51.230
I am hoping we as a group get to a point where we are familiar with our various projects and check in on each other at each event, to help drive that kind of thing

1757375071
andrewrk!~andrewrk@mail.ziglang.org
if you can implement such an interpreter in C or Lua, for instance, it would help out those who want to package zig with a pure bootstrapping process

1757375126
andrewrk!~andrewrk@mail.ziglang.org
because right now, debian, for instance, has to either 1. trust zig1.wasm or 2. do a convoluted set of steps to get from the original c++ version of zig to latest release

1757375128
rvrb!~rvrb@156.146.51.230
so you could use a hand written C compiler to build the simple interpreter, that then builds the self hosted compiler essentially?

1757375155
andrewrk!~andrewrk@mail.ziglang.org
in practice, a C toolchain is a given, you can assume that exists

1757375167
andrewrk!~andrewrk@mail.ziglang.org
although there's a secondary bootstrapping problem to solve about how to get there

1757375175
andrewrk!~andrewrk@mail.ziglang.org
but that starts to get esoteric

1757375185
rvrb!~rvrb@156.146.51.230
yeah, I've gotten slightly familiar with that in bootstrapping Nix

1757375233
andrewrk!~andrewrk@mail.ziglang.org
in reality though a zig interpreter not written in zig that is capable of interpreting latest zig release would save distros a lot of time 

1757375292
rvrb!~rvrb@156.146.51.230
that would be pretty fun to do. I love that you basically just need to target the builtins and there's no special treatment of std

1757375377
rvrb!~rvrb@156.146.51.230
I guess you could grep the entire codebase and figure out the minimal subset to bootstrap the compiler

1757375499
andrewrk!~andrewrk@mail.ziglang.org
it's already known! you can look at the externs that zig1.wasm depends on (spoiler: just a small handful of file system operations)

1757375527
andrewrk!~andrewrk@mail.ziglang.org
and there's a build option you can set so that it compiles minimally and only the C backend, just enough to bootstrap itself

1757375560
andrewrk!~andrewrk@mail.ziglang.org
the main challenge of the project is that you don't get to use zig :P

1757375618
rvrb!~rvrb@156.146.51.230
yeah I was thinking the same thing. being someone that really learned systems development in a web -> Rust -> Zig pipeline, it might not be a bad thing to do just for the sake of it

1757375693
andrewrk!~andrewrk@mail.ziglang.org
the other funny thing is that if you run into any particularly complicated, unique function that is annoying to interpret, you can simply hard code the return value, if you know what it's supposed to be doing :D

1757375712
andrewrk!~andrewrk@mail.ziglang.org
since it's a bespoke interpreter that only needs to interpret exactly one version of one codebase

1757375726
andrewrk!~andrewrk@mail.ziglang.org
in a way, it's a bespoke compression algorithm

1757375786
rvrb!~rvrb@156.146.51.230
lol

1757375818
rvrb!~rvrb@156.146.51.230
if you used arocc, you can verify the algorithm is lossless

1757375828
andrewrk!~andrewrk@mail.ziglang.org
it's C code, whose purpose is to be source code, and ingest a (large) hard-coded string, and output a predetermined large hard-coded string of C code

1757375896
andrewrk!~andrewrk@mail.ziglang.org
you could consider simply using the final output there as the solution to the problem, but it has 3 flaws: 1. not source code 2. abysmal compression ratio

1757375920
andrewrk!~andrewrk@mail.ziglang.org
I was gonna say 3. fails to be cross platform but that's just an extension of 2

