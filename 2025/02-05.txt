1738714766
LAC-Tech!~lewis@granite-phrase.bnr.la
coleman: my big issue with kak/helix is that all the w commands select not just a word, but the space at the end of it. so vims cw becomes wc.. but you need to add back in the extra space

1738714851
hadronized!~hadronize@2001:41d0:a:fe76::1
LAC-Tech: I never use w;Â you want to use e

1738714970
triallax!f378378b91@lacerte/triallax
yeah i use helix and i just do ec for that

1738715021
hadronized!~hadronize@2001:41d0:a:fe76::1
in Kakoune thereâ€™s also <a-i><a-w> (IÂ have mapped on mi<a-w>)

1738715037
hadronized!~hadronize@2001:41d0:a:fe76::1
to select inside the word, without the delimeters

1738719537
ezzieyguywuf!~Unknown@user/ezzieyguywuf
any changes since june 2024 that might affect the answer to https://stackoverflow.com/q/78609420 ?

1738720112
torque!~tachyon@user/torque
no

1738720114
torque!~tachyon@user/torque
https://github.com/ziglang/zig/issues/14704

1738720181
ezzieyguywuf!~Unknown@user/ezzieyguywuf
ðŸ‘ thanks for the link

1738720216
ezzieyguywuf!~Unknown@user/ezzieyguywuf
ðŸ¤£ "Unfortunately I don't have time to explain in detail why nearly all of the ~463 open proposals will be rejected" rip

1738722499
reykjalin!7e28cf3a41@user/reykjalin
I really like what Andrew did with giving numbers types here: https://ziglang.org/devlog/2024/#2024-11-04 and I'm emulating this in my own project. When you have a `const NamedInt = enum(u32) { _ };` is there a way to have u32 be coerced to NamedInt when passed to a function with a signature like `func(n: NamedInt)`? I've resorted to a NamedInt.make() and NamedInt.num() functions so I'm not calling @intFromEnum and @enumFromInt everywhere ðŸ¤”

1738722763
torque!~tachyon@user/torque
no, if there was automatic coercion, you'd lose the type safety

1738722828
torque!~tachyon@user/torque
helper methods, like you're already using, are probably the most ergonomic way

1738722853
andrewrk!~andrewrk@mail.ziglang.org
reykjalin: you might benefit from methods + decl literal call syntax

1738722863
andrewrk!~andrewrk@mail.ziglang.org
foo(.fromInt(x))

1738722882
reykjalin!7e28cf3a41@user/reykjalin
andrewrk: oooh didn't know you could do that! I'm using that

1738722887
reykjalin!7e28cf3a41@user/reykjalin
thanks!

1738722900
andrewrk!~andrewrk@mail.ziglang.org
it's one of the features debuting this release cycle

1738722916
reykjalin!7e28cf3a41@user/reykjalin
ahh ok, so it's not in 0.13? I'm looking forward to updating then :)

1738722943
reykjalin!7e28cf3a41@user/reykjalin
need to wait for 1 dependency to get there, and then I'm all in on 0.14

1738722945
andrewrk!~andrewrk@mail.ziglang.org
soon! current eta is the 17th but I am admittedly behind on issues I wanted to tackle for the release

1738722963
reykjalin!7e28cf3a41@user/reykjalin
no rush! I'm excited for the release ðŸŽ‰

1738723080
LAC-Tech!~lewis@granite-phrase.bnr.la
excited for 0.14. 0.13 was a big improvement on when I last used it.

1738723308
LAC-Tech!~lewis@granite-phrase.bnr.la
I remember the compiler couldn't statically verify you were using the right bit of a tagged union before, when switching on it

1738723579
torque!~tachyon@user/torque
uh, the only time the compiler can know if you're using the right bit of a tagged union is if the current value of the tagged union is comptime known. this is why tagged union switch prongs let you capture the payload

1738723607
LAC-Tech!~lewis@granite-phrase.bnr.la
right, the compiler never used to be able to do that before IIRC

1738723627
torque!~tachyon@user/torque
that has worked for a very long time

1738723640
torque!~tachyon@user/torque
switch prong capturing, that is

1738723651
LAC-Tech!~lewis@granite-phrase.bnr.la
hmmm. faulty memory I guess

1738724071
reykjalin!7e28cf3a41@user/reykjalin
Hmmm, what is the difference between `self: *MyStruct` and `self: MyStruct` in method signatures? Do you have to use the pointer variant (I'm assuming that's what the `*` signals) if you're updating values in the struct? I couldn't find anything about the difference between the 2 in the language docs

1738724093
LAC-Tech!~lewis@granite-phrase.bnr.la
yeah pass by value is immutable

1738724139
reykjalin!7e28cf3a41@user/reykjalin
I guess I figured there was something special happening for `self: MyStruct` when calling methods defined in the struct ðŸ¤”

1738724162
reykjalin!7e28cf3a41@user/reykjalin
didn't realize it would pass itself by value in some cases and by reference in others. I sort of expected it to always pass itself by reference

1738724177
reykjalin!7e28cf3a41@user/reykjalin
That's probably just a C++ ism I'm used to though

1738726434
ezzieyguywuf!~Unknown@user/ezzieyguywuf
the more I use zig the more I like it, what a pleasant language. I feel like it's making all the right tradeoffs, e.g. I don't have to use different syntax to access a pointer's member functions versus a instance's member functions

1738727479
torque!~tachyon@user/torque
is there a way to get `zig build` to emit linker args in a specific order? I have a binary that fails to link because a library is being put in the wrong place on the command line

1738727539
andrewrk!~andrewrk@mail.ziglang.org
ezzieyguywuf: happy hacking!

1738727588
andrewrk!~andrewrk@mail.ziglang.org
torque: some linker args are decided by the compiler but others have their order respected both by the compiler CLI and build system

1738727607
andrewrk!~andrewrk@mail.ziglang.org
it's a static lib?

1738727660
torque!~tachyon@user/torque
basically the libuv unit test executable has duplicate symbols since some source files get recompiled in the unit test .o files. But it still has to link against libuv.a. This works if libuv.a appears after all the .o files on the linker command

1738727687
torque!~tachyon@user/torque
however, zig is putting it right near the beginning when I just use `exe.linkLibrary(libuv)`

1738727710
torque!~tachyon@user/torque
it's kind of an edge case that doesn't matter much but it's annoying because it links correctly on macos and windows but not linux

1738728097
andrewrk!~andrewrk@mail.ziglang.org
fwiw when I rework the linker logic (elf right?) and delete the dependency on LLD I'm going to make linker order not matter as much as I can

1738728211
ezzieyguywuf!~Unknown@user/ezzieyguywuf
andrewrk: ðŸ»

1738728431
torque!~tachyon@user/torque
elfs are dangerous

1738728462
ezzieyguywuf!~Unknown@user/ezzieyguywuf
is there any pro/con to `@import(MyFoo.zig)` vs setting it up as a library in build.zig and `@import(MyFoo)`?

1738728764
torque!~tachyon@user/torque
it's effectively the same thing, but for files that will exclusively be used by a single module, it's not really worth it to do the extra build system steps

1738728958
reykjalin!7e28cf3a41@user/reykjalin
I've had the same thought as ezzieyguywuf, but more in terms of whether there's a performance cost to it? Probably if you link it dynamically, maybe if you link it statically? My use case is a teI've had the same thought as ezzieyguywuf, but more in terms of whether there's a performance cost to it? Probably if you link it dynamically? My use case is a teI've had the same thought a

1738728988
reykjalin!7e28cf3a41@user/reykjalin
woah, irc client did something funky, let me try again

1738729026
ezzieyguywuf!~Unknown@user/ezzieyguywuf
lol irc

1738729058
ezzieyguywuf!~Unknown@user/ezzieyguywuf
torque: I think that makes sense, it also helps with encapsulation if I don't intend for these to actually be used anywhere else

1738729093
reykjalin!7e28cf3a41@user/reykjalin
My use case is an editor that uses a library available in the source-tree as a backend with a frontend/renderer using that library to drive the functionality. This is for an editor. libedit makes changes to the file (library), editor renders the file. Similar to the libghostty/ghostty split for those familiar.

1738729147
torque!~tachyon@user/torque
zig modules do not link in the traditional sense

1738729148
reykjalin!7e28cf3a41@user/reykjalin
If I'm making an app that has the choice of importing files directly vs. importing the same lib as a static library, is there some cost to it, either in performance or something else?

1738729158
torque!~tachyon@user/torque
the source is all combined into a single compilation unit and compiled together

1738729172
ezzieyguywuf!~Unknown@user/ezzieyguywuf
ðŸ¤”

1738729184
reykjalin!7e28cf3a41@user/reykjalin
yeah, but I assume that's not the case if you make part of your source tree into a static library, and then link that library to your executable?

1738729201
torque!~tachyon@user/torque
that would make no sense to do, because you would have to round trip through the C abi

1738729202
reykjalin!7e28cf3a41@user/reykjalin
or does it still combine everything into a single unit?

1738729247
andrewrk!~andrewrk@mail.ziglang.org
anyway torque is there any build.zig logic you can re-order? I vaguely recall making the build system APIs respect ordering

1738729265
torque!~tachyon@user/torque
the only reason to build a static library from zig code is if you want to expose a c api for other code to use

1738729285
reykjalin!7e28cf3a41@user/reykjalin
I get that it makes little sense, but when I'm already making the static lib as part of the build, it makes me wonder whether I should be linking to that in the main app or just importing the sources. Sounds like importing the sources is the better way to do things so you don't have to go through the C ABI

1738729328
andrewrk!~andrewrk@mail.ziglang.org
e.g. if you look at lib/std/Build/Module.zig, the field link_objects is an array of tagged union which can be any link input and when lowering to CLI it goes in order

1738729334
torque!~tachyon@user/torque
andrewrk, looking at the verbose build output, it does get passed last to `zig build-exe`, but that somehow swizzles the argument order when calling `ld.lld`

1738729349
andrewrk!~andrewrk@mail.ziglang.org
ok great so you narrowed it down to the CLI

1738730029
ezzieyguywuf!~Unknown@user/ezzieyguywuf
is it possible to `const MyFoo = struct{ Bar: *SomeOpaqueType,}` or something similar? I thought storing a pointer to the opaque type would work, but I guess it doesn't b/c the compiler doesn't know its size

1738730159
torque!~tachyon@user/torque
that should work (pointers always have a known size). what is the error you see?

1738730191
ezzieyguywuf!~Unknown@user/ezzieyguywuf
this is the full error https://dpaste.com/8B9GWK7GD

1738730205
grayhatter!~grayhatte@user/grayhatter
inb4 it's a self-referential error

1738730272
ezzieyguywuf!~Unknown@user/ezzieyguywuf
oh, I guess `allocator.create(wl.Display)` is trying to create a pointer to a pointer

1738730278
ezzieyguywuf!~Unknown@user/ezzieyguywuf
hm, still don't see the problem though...

1738730336
grayhatter!~grayhatte@user/grayhatter
ezzieyguywuf: the sizeOf(opaque) is "null"

1738730357
grayhatter!~grayhatte@user/grayhatter
not literally, but it's not == 0 and it's not > 0

1738730383
torque!~tachyon@user/torque
if `wl.Display` is an opaque type you cannot allocate it

1738730448
ezzieyguywuf!~Unknown@user/ezzieyguywuf
here's the full code of what I'm trying https://bpa.st/ICNQ#1L1083-L1096, the relevant part is highlighted on line 1083-1096 - is there a different way I should be doing this? 

1738730448
torque!~tachyon@user/torque
because the allocator cannot know how much memory to allocate. Normally, `opaque` is used to represent C types to which you will only ever have a pointer, and the c library is responsible for memory allocation (it internally knows the size of the object but does not expose that information to you)

1738730470
ezzieyguywuf!~Unknown@user/ezzieyguywuf
ðŸ¤”

1738730512
ezzieyguywuf!~Unknown@user/ezzieyguywuf
so "is it possible" in my original question (which it seems was poorly worded) is "no"?

1738730512
torque!~tachyon@user/torque
there may be a function call in the wayland api to allocate a display object for you

1738730528
grayhatter!~grayhatte@user/grayhatter
I think you need to call wl.Display.connect(null)?

1738730530
ezzieyguywuf!~Unknown@user/ezzieyguywuf
torque: I'll look around, thanks

1738730539
grayhatter!~grayhatte@user/grayhatter
I haven't memorized the api for zig-wayland yet

1738730541
ezzieyguywuf!~Unknown@user/ezzieyguywuf
grayhatter: I'll give it a whirl.

1738730559
ezzieyguywuf!~Unknown@user/ezzieyguywuf
oh wait, it already returns a pointer

1738730568
ezzieyguywuf!~Unknown@user/ezzieyguywuf
I guess I was just expecting to use an allocator

1738730652
grayhatter!~grayhatte@user/grayhatter
you know... the coolest feature about codeberg... it's lack of a search feature 

1738730704
ezzieyguywuf!~Unknown@user/ezzieyguywuf
ðŸ¤£

1738730718
ezzieyguywuf!~Unknown@user/ezzieyguywuf
zig-wayland is mirrored to github at least, though I don't love the github search feature

1738730725
ezzieyguywuf!~Unknown@user/ezzieyguywuf
google does it better lol

1738730731
torque!~tachyon@user/torque
i thought the coolest feature was the lack of obnoxious ui bubbles nagging you to use ai garbage

1738730757
grayhatter!~grayhatte@user/grayhatter
torque: you don't use uBlock?

1738730761
torque!~tachyon@user/torque
every time I try to search on github (not logged in, natch) it tells me I'm rate limited

1738730765
grayhatter!~grayhatte@user/grayhatter
I don't even see them

1738730794
grayhatter!~grayhatte@user/grayhatter
but I probably shouldn't be talking, srctree doesn't have search either :/

1738730893
grayhatter!~grayhatte@user/grayhatter
sigh... I used to be a wayland fanboi, but the more I try to use it, the more I'm starting to agree with the X11 diehards

1738731008
ezzieyguywuf!~Unknown@user/ezzieyguywuf
aintnoway

1738731026
ezzieyguywuf!~Unknown@user/ezzieyguywuf
I've never tried using X directly, but honestly it seems like a nightmare

1738731063
grayhatter!~grayhatte@user/grayhatter
I just have a personal aversion to generated APIs

1738731115
ezzieyguywuf!~Unknown@user/ezzieyguywuf
fair

1738731120
ezzieyguywuf!~Unknown@user/ezzieyguywuf
but *shrug*

1738731122
grayhatter!~grayhatte@user/grayhatter
if your API is too complex to write down yourself, or too volatile to commit to the repo... your API is bad, and you should feel bad

1738731125
grayhatter!~grayhatte@user/grayhatter
see also

1738731128
grayhatter!~grayhatte@user/grayhatter
grpc

1738731133
ezzieyguywuf!~Unknown@user/ezzieyguywuf
vulkan

1738731146
ezzieyguywuf!~Unknown@user/ezzieyguywuf
but also I use a lot of grpc at work so again *shrug*

1738731167
grayhatter!~grayhatte@user/grayhatter
that's the stockholme syndrome talking

1738731195
ezzieyguywuf!~Unknown@user/ezzieyguywuf
lulz could be

1738731200
ezzieyguywuf!~Unknown@user/ezzieyguywuf
I also don't hate protobufs

1738731264
ezzieyguywuf!~Unknown@user/ezzieyguywuf
lol I figured out why my refactor failed, it had nothing to do with opaque pointers or allocates, it's b/c I mindlessly moved my `defer`s into `init` rather that moving them into `deinit` ðŸ¤£

1738731344
grayhatter!~grayhatte@user/grayhatter
has anyone tried to use microzig?

1738731405
grayhatter!~grayhatte@user/grayhatter
I'm scanning the build.zig{,.zon} files and wondering if it's as messy of a project as these make it look?

1738731452
grayhatter!~grayhatte@user/grayhatter
> I find it a bit annoying that they kind of hijacked the word "safety". l

1738731478
grayhatter!~grayhatte@user/grayhatter
yeah... definetely stockholm syndrom

1738731488
grayhatter!~grayhatte@user/grayhatter
BAH

1738731498
grayhatter!~grayhatte@user/grayhatter
the quote was supposed to be > I also don't hate protobufs 

1738731580
ezzieyguywuf!~Unknown@user/ezzieyguywuf
ðŸ¤£

1738731589
ezzieyguywuf!~Unknown@user/ezzieyguywuf
I'm like "I didn't say that" but then I started to question my sanity

1738731652
grayhatter!~grayhatte@user/grayhatter
ezzieyguywuf: have you tried anything other that pb/grpc?

1738731857
ezzieyguywuf!~Unknown@user/ezzieyguywuf
grayhatter: can you name some alternative technologies?

1738732314
grayhatter!~grayhatte@user/grayhatter
any serialization at all

1738732339
grayhatter!~grayhatte@user/grayhatter
msgpack, json, base64

1738732411
grayhatter!~grayhatte@user/grayhatter
before you interject, yes, I know base64 doesn't count as serialization, but that's the joke, about how it's still on par with protobuf

1738732431
ezzieyguywuf!~Unknown@user/ezzieyguywuf
I've dabbled in json and base64, but I think protobufs solve a different problem - they let you define an api, which with codegen allow for strong typing in various languages for users of that api

1738732440
ezzieyguywuf!~Unknown@user/ezzieyguywuf
lol

1738732474
ezzieyguywuf!~Unknown@user/ezzieyguywuf
I mean, I'm not saying it's the end-all-be-all, and like you said probably a touch of stockholm syndrome, but it gets the job done

1738732659
grayhatter!~grayhatte@user/grayhatter
I have a friend that describes protobuf as built by committee to be as unobjectionable as possible... which is an apt description, and also why I hate it

1738732669
grayhatter!~grayhatte@user/grayhatter
regression to the mean should be resisted when possible

1738732888
ezzieyguywuf!~Unknown@user/ezzieyguywuf
I think it was built to solve very particular problems for a very particular group of engineers, and later they made it publically available

1738733033
grayhatter!~grayhatte@user/grayhatter
right... it was built to be very hard to hold wrong... which they considered a feature, and not a defect

1738733201
ezzieyguywuf!~Unknown@user/ezzieyguywuf
it was built to solve google's problems as they scaled up their search engine

1738733379
grayhatter!~grayhatte@user/grayhatter
s/search engine/empire

1738733403
ezzieyguywuf!~Unknown@user/ezzieyguywuf
*shrug*

1738738163
ksynwa!~ksynwa@49.36.209.119
Need some help reading the docs. I am looking at the source of this decompress function: https://ziglang.org/documentation/master/std/#std.zip.decompress

1738738194
ksynwa!~ksynwa@49.36.209.119
Here I see the `decompressor.next()` invocation. I want to see the source code of this next() method but I can't find it.

1738738230
ksynwa!~ksynwa@49.36.209.119
Is it this? https://ziglang.org/documentation/master/std/#std.compress.flate.inflate.Inflate.next

1738738230
grayhatter!~grayhatte@user/grayhatter
ksynwa: which "flavor" of decompression are you using

1738738241
ksynwa!~ksynwa@49.36.209.119
deflate

1738738258
ksynwa!~ksynwa@49.36.209.119
std.compress.flate

1738738296
grayhatter!~grayhatte@user/grayhatter
that uri says inflate, instead of deflate, but I assume because you found that one, you're either looking at the correct one, or will be looking at it in a second

1738738311
grayhatter!~grayhatte@user/grayhatter
ping me if you really can't find it, but I'm pretty sure you already have :)

1738738373
ksynwa!~ksynwa@49.36.209.119
Alright. Thanks a lot.

1738744998
mountaingoat!~mountaing@user/mountaingoat
do i need to pass .{ .target = target, .optimize = optimize } to b.dependency(), or can it inherit those from the thing being built?

1738756509
tsujp!497e1f7b6a@sourcehut/user/tsujp
given a u256 is shifting right 255 times and then calling @truncate more efficient or is @bitCast to i256 and checking with < or > above or below 0 better?

1738757084
ifreund!2940d10f8b@user/ifreund
tsujp: what are you actually trying to check?

1738757148
ifreund!2940d10f8b@user/ifreund
do you want to check if the most significant bit is set? I'd just do `x & (1 << 255) != 0`

1738757180
ifreund!2940d10f8b@user/ifreund
start with the most direct/idiomatic way to express what you want

1738757218
ifreund!2940d10f8b@user/ifreund
if benchmarking shows that LLVM is not able to micro optimize that to be ideal for your use case, then you can get into bithacks if you really need to

1738757292
ifreund!2940d10f8b@user/ifreund
if you're simply curious about bithacks, you might be interested in https://github.com/cryptocode/bithacks and the linked pages

1738757292
tsujp!497e1f7b6a@sourcehut/user/tsujp
The goal is: given a u256, shift it right N bits (also given) but treat the given u256 as if it were signed, so an i256.

1738757317
tsujp!497e1f7b6a@sourcehut/user/tsujp
Trying to shift right over 255 bits if the i256 interpretation is positive is equal to 0, and is -1 if the i256 interpretation is negative

1738757355
tsujp!497e1f7b6a@sourcehut/user/tsujp
ifreund: ^

1738757392
tsujp!497e1f7b6a@sourcehut/user/tsujp
But yes, checking msb for signess is the approach I thought about for doing this

1738757449
ifreund!2940d10f8b@user/ifreund
I still don't really understand what your higher level goal is

1738757461
ifreund!2940d10f8b@user/ifreund
why are you using a u256 if you want an i256?

1738757476
tsujp!497e1f7b6a@sourcehut/user/tsujp
The alternative involves floored division with 2^N but im unsure if that's faster

1738757493
tsujp!497e1f7b6a@sourcehut/user/tsujp
im implementing a VM spec, this is an opcode there's no changing any conditions here

1738757516
tsujp!497e1f7b6a@sourcehut/user/tsujp
stack values for this vm are stored as u256 always, _some_ instructions specifically interpret those u256 bits as i256 

1738757521
ifreund!2940d10f8b@user/ifreund
tsujp: llvm is much better at this kind of microptimization than you are

1738757529
ifreund!2940d10f8b@user/ifreund
start with the most obvious way to implement this

1738757534
ifreund!2940d10f8b@user/ifreund
look at the generated assembly

1738757550
ifreund!2940d10f8b@user/ifreund
benchmark it and compare with alternatives if you like

1738757557
tsujp!497e1f7b6a@sourcehut/user/tsujp
roger

1738757570
ifreund!2940d10f8b@user/ifreund
but don't try and beat LLVM at bithacks before even knowing what LLVM does

1738757668
tsujp!497e1f7b6a@sourcehut/user/tsujp
said vm is here btw (just if you're curious): https://github.com/tsujp/zevem/blob/master/src/evm.zig#L73

1738758971
tsujp!497e1f7b6a@sourcehut/user/tsujp
also, when using a BoundedArray every access by index will result in a _copy_ of the array being made for the callsite to use right?

1738759010
tsujp!497e1f7b6a@sourcehut/user/tsujp
In other words: it's easier to use due to the lack of an allocator, but because of the lack of an allocator is more _expensive_ versus an allocated data structure which wouldn't be copied when read?

1738759702
tsujp!497e1f7b6a@sourcehut/user/tsujp
I don't think this can be done the obvious way with @divFloor, @divTrunc since it doesn't produce the -1 behaviour

1738761076
tsujp!497e1f7b6a@sourcehut/user/tsujp
ifreund: managed to keep it pretty simple. Pop both u256s off the stack (bits, and value). Value is @bitCast to i256. Check bits > 255, if it is then also check value > 0 (instead of AND with a bitmask). That codepath returns the 0 and -1 case. The other codepath if bits is less than 255 just does value >> bits and @bitCast back to u256

1738763627
tsujp!497e1f7b6a@sourcehut/user/tsujp
hmm, how to slice some bytes out of a u256

1738763657
DerTeufel!~DerTeufel@87-206-205-214.dynamic.chello.pl
std.mem.asBytes ?

1738763659
tsujp!497e1f7b6a@sourcehut/user/tsujp
i suppose i can @as([]const u8, the_int) and slice that?

1738763737
DerTeufel!~DerTeufel@87-206-205-214.dynamic.chello.pl
tsujp: Can't do that, u256 is not a pointer

1738763802
hadronized!~hadronize@2001:41d0:a:fe76::1
asBytes() seems to be what you want indeed

1738764009
tsujp!497e1f7b6a@sourcehut/user/tsujp
Roger

1738764318
tsujp!497e1f7b6a@sourcehut/user/tsujp
ah asBytes is also endian specific too, still good though

1738764516
DerTeufel!~DerTeufel@87-206-205-214.dynamic.chello.pl
you could probably use a buffer and std.mem.writeInt if endianness is important to you

1738764688
tsujp!497e1f7b6a@sourcehut/user/tsujp
ive got to slice it as if it were big-endian every time

1738764702
tsujp!497e1f7b6a@sourcehut/user/tsujp
i wonder if @byteSwap would work here after the asBytes

1738764711
tsujp!497e1f7b6a@sourcehut/user/tsujp
g2g for an hour though, do some exercise

1738764895
tsujp!497e1f7b6a@sourcehut/user/tsujp
oh no i got it just had the offset round the wrong way

1738764954
tsujp!497e1f7b6a@sourcehut/user/tsujp
ill format it later cos i really g2g to the gym before i end up forgetting and it closes, but look at this cursed code: https://bpa.st/PKZA

1738764971
tsujp!497e1f7b6a@sourcehut/user/tsujp
it works, idk if it's _actually_ cursed but its funny or im just being silly idk

1738765045
DerTeufel!~DerTeufel@87-206-205-214.dynamic.chello.pl
why not just use a shift?

1738768045
tsujp!497e1f7b6a@sourcehut/user/tsujp
you mean bit shift right and then truncate to u8? i could give it a try 

1738768077
DerTeufel!~DerTeufel@87-206-205-214.dynamic.chello.pl
It should work and be a lot simpler

1738768305
tsujp!497e1f7b6a@sourcehut/user/tsujp
idk why i didn't try that first, probably overthinking i suppose 

1738777636
grayhatter!~grayhatte@user/grayhatter
has anyone seen this build error  `error: failed to check cache: [dependency path] file_hash FileNotFound`

1738778811
tsujp!497e1f7b6a@sourcehut/user/tsujp
i have not

1738779560
grayhatter!~grayhatte@user/grayhatter
ifreund: thank you for wayland-scanner, I always find myself coming back to it to figure out how to make various build scripts work :D

1738781742
ifreund!2940d10f8b@user/ifreund
grayhatter: heh, glad its been useful

1738782335
dsal!sid13060@id-13060.lymington.irccloud.com
Language nerds at work are trying to convince me zig is bad because release build `assert`s lead to undefined behavior and I'm really struggling to understand why I care about this.

1738782357
dsal!sid13060@id-13060.lymington.irccloud.com
The language "undefined behavior" might just sound too strong.

1738782371
dsal!sid13060@id-13060.lymington.irccloud.com
Something about how the compiler can do optimizations that affect correctness.

1738782375
grayhatter!~grayhatte@user/grayhatter
dsal: they're right

1738782391
grayhatter!~grayhatte@user/grayhatter
the fact that using an assert can introduce UB that otherwise wouldn't exist is stupid

1738782424
grayhatter!~grayhatte@user/grayhatter
but, if you have a test that can reach that assert, you don't care because you've proven it's impossible 

1738782425
dsal!sid13060@id-13060.lymington.irccloud.com
I guess I don't quite understand where the UB itself comes from.  My mental model is that it just optimizes away the assertion path.

1738782444
hadronized!~hadronize@2001:41d0:a:fe76::1
dsal: you should do your own research and never take anything for granted, even from language nerds;Â what are they arguments for the UB?

1738782456
hadronized!~hadronize@2001:41d0:a:fe76::1
s/they/their

1738782479
grayhatter!~grayhatte@user/grayhatter
dsal: that's the stupid part, std.debug.assert() uses `unreachable` which causes/enables LLVM to make additional assumptions and optimizations given that promise

1738782518
dsal!sid13060@id-13060.lymington.irccloud.com
So it could just explicitly panic and have a means of eliminating that call and it'd be OK.

1738782519
grayhatter!~grayhatte@user/grayhatter
dsal: think of std.debug.assert less like it's used in other languages (where it would become a nop) 

1738782550
grayhatter!~grayhatte@user/grayhatter
and think of it like an explicit promise from you, to the compiler, that you've **proven** it's actually impossible

1738782594
grayhatter!~grayhatte@user/grayhatter
if you've already proven it's impossible to reach that assert where it's evals to false, then there's no UB, just better optimizations

1738782626
dsal!sid13060@id-13060.lymington.irccloud.com
I guess that's how I think about it in general.  Though maybe not necessarily as strongly as a proof.

1738782633
grayhatter!~grayhatte@user/grayhatter
dsal: that's the stupid part: in release modes, std.debug.assert doesn't panic, it becomes undefined behavior that otherwise wouldn't exist without that assert

1738782644
dsal!sid13060@id-13060.lymington.irccloud.com
But I've also not used `assert` in zig and don't really have a need to.

1738782676
dsal!sid13060@id-13060.lymington.irccloud.com
What kinds of behavior could this be?  I'm struggling to understand what _can_ happen here.

1738782847
grayhatter!~grayhatte@user/grayhatter
dsal: a contrived example, that's more useful as a heuristic than a specific concrete this will happen... if you add an assert(slice.len < something), then LLVM will use that assert, which becomes `if (slice.len >= something) unreachable;` to guide other optimizations, e.g. it may move memory to an unexpected place. and instead of getting the memory, or the stack you expect, you get an invalid memory

1738782849
grayhatter!~grayhatte@user/grayhatter
layout.

1738782951
dsal!sid13060@id-13060.lymington.irccloud.com
Is that true independently of the assert expression or just if it fails?

1738782954
grayhatter!~grayhatte@user/grayhatter
dsal: this code will segv, only when that assert exists https://gist.github.com/GrayHatter/655542c11e087cc9cb2e35374999e6fe

1738782972
grayhatter!~grayhatte@user/grayhatter
if there's no assert, different optimizations are used that doesn't result in a sevg

1738783036
dsal!sid13060@id-13060.lymington.irccloud.com
That seems a bit undesirable.  I'll continue to not use assert.

1738783064
grayhatter!~grayhatte@user/grayhatter
this isn't a perfect example, because you'll notice that according to zig rules, the write into the left becomes UB, but by C rules, it's permissible

1738783087
grayhatter!~grayhatte@user/grayhatter
dsal: there's nothing overtly wrong with assert

1738783107
grayhatter!~grayhatte@user/grayhatter
and it doesn't ruin the language despite what the rust fanbois at your work are trying to convince you of

1738783126
ifreund!2940d10f8b@user/ifreund
dsal: assertion failures expose divergence between the mental model of the programmer and the model implemented by the code

1738783145
dsal!sid13060@id-13060.lymington.irccloud.com
Nah.  I find the language delightful.  I haven't found a situation yet where it's more helpful than just using an error.

1738783157
grayhatter!~grayhatte@user/grayhatter
the real takeaway is that `unreachable` in **very** powerful, and it will enable the compiler to improve your code when used correctly, or ruin it if you use it where it doesn't belong

1738783158
ifreund!2940d10f8b@user/ifreund
if these models do not match, then everything is essentially undefined behavior

1738783293
grayhatter!~grayhatte@user/grayhatter
I've taken to replacing `unreachable` with @panic("something") in most places where I previously would write unreachable. This was my misunderstanding,I was using it for effectively debugging

1738783333
reykjalin!7e28cf3a41@user/reykjalin
I didnâ€™t know assert wouldnâ€™t do anything in ReleaseFast ðŸ¤” I was using assert as a way to validate function inputs. I guess you want to use errors for that instead, and asserts as an optimization trick when you know thatâ€™s possible?

1738783336
grayhatter!~grayhatte@user/grayhatter
unreachable behaves more as a compiler directive

1738783348
reykjalin!7e28cf3a41@user/reykjalin
I find that a bit confusing though since some of the stdlib functions assert ðŸ¤”

1738783387
grayhatter!~grayhatte@user/grayhatter
reykjalin: stdlib functions should only use assert when you've provided inputs that violate what they say they accept

1738783392
reykjalin!7e28cf3a41@user/reykjalin
and I mean â€œconfusingâ€ because I feel like the stdlib is using those more as a way to detect invalid input rather than just optimizing the ReleaseFast output 

1738783426
grayhatter!~grayhatte@user/grayhatter
reykjalin: there's a reason assert is std.debug.assert

1738783431
reykjalin!7e28cf3a41@user/reykjalin
yeah â€œinput validationâ€ (sort of, ish, kinda, etc), not â€œoptimizationâ€ in the sense of â€œthis absolutely can never happenâ€

1738783437
reykjalin!7e28cf3a41@user/reykjalin
I guess thatâ€™s true ðŸ˜…

1738783445
grayhatter!~grayhatte@user/grayhatter
it should be used for debugging only, **never** for input validation

1738783456
grayhatter!~grayhatte@user/grayhatter
thoes are different steps, the latter being *much* more important

1738783463
reykjalin!7e28cf3a41@user/reykjalin
I agree

1738783468
dsal!sid13060@id-13060.lymington.irccloud.com
assert is more like "the programmer made an error" vs. "the user made an error"

1738783484
reykjalin!7e28cf3a41@user/reykjalin
asserting on invalid input feels a bit more like input validation to me

1738783514
reykjalin!7e28cf3a41@user/reykjalin
dsal: I like that framing, except when youâ€™re making a library that breaks down. now the programmer is the user :)

1738783515
grayhatter!~grayhatte@user/grayhatter
reykjalin: to parrot ifreund, your mental model doesn't match what the compiler will actually do in thoes cases

1738783540
grayhatter!~grayhatte@user/grayhatter
reykjalin: um... maybe

1738783550
reykjalin!7e28cf3a41@user/reykjalin
ah yeah, sorry for the lack of clarity: thatâ€™s what I was initially trying to say. I didnâ€™t have either idea of how asserts work

1738783562
reykjalin!7e28cf3a41@user/reykjalin
just talking through shifting my perspective I guess 

1738783583
grayhatter!~grayhatte@user/grayhatter
there's a reason that the zen includes "together we serve the users"

1738783625
grayhatter!~grayhatte@user/grayhatter
your lib should protect the users both from their own mistakes/accidents, but also from the mistakes of devs using your lib

1738783657
grayhatter!~grayhatte@user/grayhatter
asserts only help devs, never users... so who do you care about more?

1738783750
reykjalin!7e28cf3a41@user/reykjalin
in the way Iâ€™ve been using assets in this particular project itâ€™s only the dev that can make mistakes

1738783781
reykjalin!7e28cf3a41@user/reykjalin
asserts are probably fine in that case. itâ€™s great to find this out now, rather than later ðŸ˜…

1738783799
reykjalin!7e28cf3a41@user/reykjalin
s/assets/asserts

1738783854
reykjalin!7e28cf3a41@user/reykjalin
think things like â€œwhoever is using this library gave me an incorrect position into this 2D arrayâ€ type thing

1738783872
reykjalin!7e28cf3a41@user/reykjalin
asserting that a position is valid before running the function

1738783967
grayhatter!~grayhatte@user/grayhatter
seems reasonable, and exactly the kinda place an assert is useful

1738784115
reykjalin!7e28cf3a41@user/reykjalin
ACTION is relieved to know that

1738784228
grayhatter!~grayhatte@user/grayhatter
how is it possible for net.stream.writevAll to return InvalidArgument?

1738784826
grayhatter!~grayhatte@user/grayhatter
ahh, I missed the word "sum" from the man pages

1738785105
rockorager!~rockorage@172-234-192-125.ip.linodeusercontent.com
I look at it as: ReleaseFast means you have proven to yourself you don't need the asserts

1738785415
dsal!sid13060@id-13060.lymington.irccloud.com
Yeah.  I think the problem is that it's not just removing the assertions.

1738785645
grayhatter!~grayhatte@user/grayhatter
coming from C, that did trip me up... then so did the power of unreachable

1738788819
hadronized!~hadronize@2001:41d0:a:fe76::1
andrewrk: thank you. It took me a couple rewrites to ensure I donâ€™t convey a too harsh opinion of Zig, because even though itâ€™s currently not a good fit for it, Iâ€™ve been playing around with it for a while now with hopes to eventually use it

1738788840
hadronized!~hadronize@2001:41d0:a:fe76::1
I think Iâ€™ll wait until you reach 1.0 (and I wish you do, honestly), and will reconsider eventually

1738788936
Smithx10!sid243404@id-243404.helmsley.irccloud.com
I'm an application dev that typically has to write crud apps that make entities into postgresql.    We normally write go but I'd  love to see how much more satisfying it might be to use zig comptime polymorphism to make this experience better then what go can do with generics.    Would be cool to see a write up showing that 

1738788941
andrewrk!~andrewrk@mail.ziglang.org
I care a lot more about whether an article is factually accurate than whether it is favorable or disfavorable to zig

1738789019
andrewrk!~andrewrk@mail.ziglang.org
people who love to discuss "safety" often say incorrect things about zig, both in favor and against

1738789239
LAC-Tech!~lewis@granite-phrase.bnr.la
was chatting to people in the rust discord VC yesterday about zig. people were curious or planning to try it themselves. no one mentioned safety.

1738789361
bblack!~bblack@wikimedia/bblack-WMF
I work on systems software (like network daemon code and such) in C.  I'm having a blast working on Zig ports so far, although the std.(c|posix) landscape still has a lot of holes to fill.  At some stage I'll loop back and start filling them :)

1738789369
LAC-Tech!~lewis@granite-phrase.bnr.la
mostly size of the std lib, or tradeoffs between comptime/traits

1738789433
bblack!~bblack@wikimedia/bblack-WMF
but just on a language-level, even if you ignore stdlib, going from C->Zig for systems code is all upsides, no downsides, IMHO :)

1738791737
grayhatter!~grayhatte@user/grayhatter
I wonder if Zig wouldn't be better served by focusing on correctness over safety

1738791807
grayhatter!~grayhatte@user/grayhatter
everyone loves to rant about memory safety, often implying it's a security issue, when it almost never is

1738791903
bwbuhse!~The_Buhs@user/The-Buhs/x-5080862
grayhatter: I'll have you know I make sure my entire RAM is just my SSN on repeat before I start my computer

1738792014
grayhatter!~grayhatte@user/grayhatter
every critical security issue I've fixed has been memory safe, and yet somehow the stuff of nightmares... the memory unsafe stuff, plenty of panics, but almost never user controlled

1738792108
grayhatter!~grayhatte@user/grayhatter
anyways, security aside... my point is more

1738792117
grayhatter!~grayhatte@user/grayhatter
let rust have the word safety

1738792125
grayhatter!~grayhatte@user/grayhatter
I'd rather Zig adopt the word correct

1738792208
rockorager!~rockorage@172-234-192-125.ip.linodeusercontent.com
what does correct mean

1738792225
grayhatter!~grayhatte@user/grayhatter
rockorager: would you ask that about the word safe?

1738792233
rockorager!~rockorage@172-234-192-125.ip.linodeusercontent.com
Yeah

1738792263
grayhatter!~grayhatte@user/grayhatter
well, I can answer neither so, you're on your own :P

1738792272
rockorager!~rockorage@172-234-192-125.ip.linodeusercontent.com
heh

1738792272
rockorager!~rockorage@172-234-192-125.ip.linodeusercontent.com
Ok well

1738792277
rockorager!~rockorage@172-234-192-125.ip.linodeusercontent.com
What do you mean focus on correctness

1738792286
rockorager!~rockorage@172-234-192-125.ip.linodeusercontent.com
go is memory safe, rust is memory safe. yet their memory safety is not the same

1738792325
grayhatter!~grayhatte@user/grayhatter
OH, I mean instead of trying to debate if rust or zig enables writing safer code, or if you care about safety, which language should you pick

1738792335
rockorager!~rockorage@172-234-192-125.ip.linodeusercontent.com
my program is correct if it does all the things I want and none of the things I don't want?

1738792363
grayhatter!~grayhatte@user/grayhatter
I plan to frame the question as, if you want a language to help you write safe code, you should use rust, if you want a language to help you write correct code, you should use zig

1738792391
grayhatter!~grayhatte@user/grayhatter
rockorager: a correct program would behave as intended for all possible inputs

1738792404
dsal!sid13060@id-13060.lymington.irccloud.com
"correct" is kind of hard because I only occasionally run into programmers who even know what their goals are.

1738792422
rockorager!~rockorage@172-234-192-125.ip.linodeusercontent.com
How does a language focus on that though?

1738792490
grayhatter!~grayhatte@user/grayhatter
rockorager by making decisions that make it easier to write correct code, and hard to write incorrect code

1738792592
grayhatter!~grayhatte@user/grayhatter
e.g. rust's default hash algo was selected in part because it's resistant to adversarially selected inputs, and zig allows (demands?) you to specify one

1738792665
ThinkT510!~auronanda@sortix/contributor/ThinkT510
so being explicit means being correct?

1738792744
grayhatter!~grayhatte@user/grayhatter
ThinkT510: indirectly, yes? Being explicit requires thought, you could be lazy, or more to dsal's point you could try to understand exactly what you want, or what you need, and then select the best option

1738792776
ThinkT510!~auronanda@sortix/contributor/ThinkT510
sounds like you want a proof language

1738792782
rockorager!~rockorage@172-234-192-125.ip.linodeusercontent.com
zig should focus on being a language I want to continue to use, because i have a main character complex and like zig ;)

1738792784
grayhatter!~grayhatte@user/grayhatter
lol, no, I don't

1738792809
grayhatter!~grayhatte@user/grayhatter
I want a language that stays out of my way

1738792833
dsal!sid13060@id-13060.lymington.irccloud.com
Here's a kind of neat example.  I wrote this test:     `const x: i8 = -128; std.testing.expect(@abs(x) >= 0);`    This gives the wrong answer in most languages (I've had a production bug in C++, but also Haskell, e.g.).  In zig, it doesn't compile.

1738792836
grayhatter!~grayhatte@user/grayhatter
zig has a very limited number of opinions that I disagree with... and I'm almost exclusively the one that is wrong

1738792842
grayhatter!~grayhatte@user/grayhatter
const vs var

1738792851
dsal!sid13060@id-13060.lymington.irccloud.com
Most people wouldn't write _that_ test, but I'm a big fan of property tests and property test frameworks can find stuff like that.

1738792859
grayhatter!~grayhatte@user/grayhatter
I want to write var, because it's 2 char fewer, and I'm lazy 

1738792876
grayhatter!~grayhatte@user/grayhatter
zig is objectively correct that const is the better option

1738792896
dsal!sid13060@id-13060.lymington.irccloud.com
Oh, ha, I was wrong about the absâ€¦

1738793031
LAC-Tech!~lewis@granite-phrase.bnr.la
rockorager: re: safetty, it's actually a reasonably short equation! There's a paper by Alpern and Schenider where they give a formal definition.

1738793044
grayhatter!~grayhatte@user/grayhatter
dsal: is it promoting to comptime_int out from under you?

1738793044
dsal!sid13060@id-13060.lymington.irccloud.com
It doesn't let you write the bug, but for a different reason.  This is a cool kind of safety thing.

1738793055
LAC-Tech!~lewis@granite-phrase.bnr.la
I don't know if there is a formal definition of correctness though

1738793098
dsal!sid13060@id-13060.lymington.irccloud.com
Nah, but there are expectations.  I crashed a production database because I assumed `abs(x) >= 0`.

1738793099
ThinkT510!~auronanda@sortix/contributor/ThinkT510
if correctness is linked to intention then I'm not too sure how you'd enforce it

1738793132
grayhatter!~grayhatte@user/grayhatter
ThinkT510: what makes you think enforcement is part of it?

1738793145
dsal!sid13060@id-13060.lymington.irccloud.com
@abs in zig changes the type which is pretty neat.

1738793212
LAC-Tech!~lewis@granite-phrase.bnr.la
ThinkT510: right, you'd have to formally define the intention. which seems tricky

1738793213
ThinkT510!~auronanda@sortix/contributor/ThinkT510
grayhatter: when you say correctness do you mean right and wrong? If so, it would be a binary choice. In many cases the "correct" thing to do depends entirely on context.

1738793305
grayhatter!~grayhatte@user/grayhatter
ThinkT510: correctness is a binary result

1738793309
dsal!sid13060@id-13060.lymington.irccloud.com
On the small, abs() returning a negative number will never be "correct."  Similarly, zig at least doesn't silently roll over overflows and underflows.  These kinds of things at least nudge towards expectations.

1738793413
grayhatter!~grayhatte@user/grayhatter
`for (all_possible_inputs, all_intended_results) |input, expected| { if (function(input) != expected) return .incorrect } else { return .correct; }`

1738793521
ThinkT510!~auronanda@sortix/contributor/ThinkT510
so a model checker

1738793552
grayhatter!~grayhatte@user/grayhatter
no

1738793564
grayhatter!~grayhatte@user/grayhatter
all possible inputs != all inputs

1738793645
ThinkT510!~auronanda@sortix/contributor/ThinkT510
shouldn't that be all valid inputs?

1738793654
grayhatter!~grayhatte@user/grayhatter
ThinkT510: e.g. from what I understand you to mean a model checker would fail password hashing as an incorrect program

1738793689
rockorager!~rockorage@172-234-192-125.ip.linodeusercontent.com
What about something like this: https://zigbin.io/c1fcf5

1738793697
rockorager!~rockorage@172-234-192-125.ip.linodeusercontent.com
I'd call this correct in some cases

1738793747
grayhatter!~grayhatte@user/grayhatter
but for the definiton of correct, behaves as intended

1738793754
grayhatter!~grayhatte@user/grayhatter
yeah rockorager perfect example

1738793792
rockorager!~rockorage@172-234-192-125.ip.linodeusercontent.com
I don't join the thread, I have an obvious race condition - yet it's correct for what it is supposed to do

1738793811
grayhatter!~grayhatte@user/grayhatter
this is a perfectly correct program (unless I'm missing some bug) that can't be proven by a model checker,  but can be proven by reading it

1738793877
grayhatter!~grayhatte@user/grayhatter
alloc without a free, is also a perfectly correct program.... in some cases, but invalid in other cases

1738794123
rockorager!~rockorage@172-234-192-125.ip.linodeusercontent.com
Ok I guess I can see how you would "focus" on this as a language

1738794134
rockorager!~rockorage@172-234-192-125.ip.linodeusercontent.com
Allow it, but give tools to prevent it so you can have it both ways

1738794136
grayhatter!~grayhatte@user/grayhatter
another aspect that I consider important

1738794158
grayhatter!~grayhatte@user/grayhatter
if my programming language added a mutex lock for that write to stdout, I would consider that program to be incorrect

1738794220
rockorager!~rockorage@172-234-192-125.ip.linodeusercontent.com
I think go buffers by default which really threw me off when I started writing zig

1738794223
grayhatter!~grayhatte@user/grayhatter
another incorrect program, would be needing to wrap a linked list in a read write lock

1738794225
rockorager!~rockorage@172-234-192-125.ip.linodeusercontent.com
all my writes were slow as hell

1738794254
rockorager!~rockorage@172-234-192-125.ip.linodeusercontent.com
May not be the case for everything but damned if it didn't show up at least sometimes

1738794254
grayhatter!~grayhatte@user/grayhatter
rockorager: your go writes, or your zig writes?

1738794259
rockorager!~rockorage@172-234-192-125.ip.linodeusercontent.com
zig writes

1738794264
grayhatter!~grayhatte@user/grayhatter
they were slow?

1738794286
grayhatter!~grayhatte@user/grayhatter
oh, because you were making too many syscalls?

1738794289
rockorager!~rockorage@172-234-192-125.ip.linodeusercontent.com
Yeah

1738794301
rockorager!~rockorage@172-234-192-125.ip.linodeusercontent.com
Writing several thousand bytes a few at at ime

1738794306
rockorager!~rockorage@172-234-192-125.ip.linodeusercontent.com
s/at ime/a time

1738794318
grayhatter!~grayhatte@user/grayhatter
I would say your go program was incorrect

1738794336
rockorager!~rockorage@172-234-192-125.ip.linodeusercontent.com
it worked how I wanted it to

1738794342
rockorager!~rockorage@172-234-192-125.ip.linodeusercontent.com
zig did too, just had to add buffering

1738794344
rockorager!~rockorage@172-234-192-125.ip.linodeusercontent.com
both are correct

1738794344
grayhatter!~grayhatte@user/grayhatter
but that's only because at this moment I'm very annoyed I have to reimplement all of zigbee2mqtt myself

1738794382
grayhatter!~grayhatte@user/grayhatter
it worked how you expected, but not how you intended

1738794391
dsal!sid13060@id-13060.lymington.irccloud.com
Oh wow. I used to do that.  That software did some crazy things.

1738794395
grayhatter!~grayhatte@user/grayhatter
the delta between the two was your lack of understanding about the cost of syscalls

1738794419
rockorager!~rockorage@172-234-192-125.ip.linodeusercontent.com
yeah

