1587428423
elucent
hey folks! i'm new here, was hoping to get involved in the project working on one of the contributor-friendly issues

1587428426
elucent
has anybody been working on

1587432250
mikdusan
elucent: I haven't seen anyone mention interest on working it

1587432521
mikdusan
feel free to mark your interest in the issue and if you abandon it I believe you are able to edit (or even delete) your comment from the issue

1587432591
elucent
awesome! i'll take a crack at it :)

1587434845
Kingsquee
so...what's the expected relationship between types that could be either scalar or simd backed?

1587434873
Kingsquee
the language seems to be leaning toward @Vector(#, T), but T can only be a few base types

1587434907
Kingsquee
I suppose anything that's not a base type would have to take on a form of T(#), with # being lane count

1587434944
Kingsquee
and be internally specialized to lanecount=1

1587434950
daurnimator
Kingsquee: # is not limited to just what processors support: vectors can be huge if you want

1587434979
Kingsquee
I'm aware, but my point is that one is V(#, T) and the other is essentially T(#, V)

1587434984
daurnimator
?

1587435037
Kingsquee
'const f = Foo(16)' is not the same syntax as 'const f = @Vector(16, Foo)'

1587435048
daurnimator
what is `Foo(16)`?

1587435055
Kingsquee
Foo is type, 16 is lane count

1587435071
Kingsquee
for base types, we describe that as @Vector(16, i32), for example

1587435074
daurnimator
Foo is a function that returns a type you mean

1587435080
Kingsquee
yes

1587435104
Kingsquee
but for non-base-types, we describe it as Foo(16), with the @Vector(16, whateverbasetypeituses) internally

1587435116
daurnimator
assuming there is a base type

1587435121
Kingsquee
I am

1587435169
daurnimator
Not exactly related, but you reminded me of a contributor friendly task: gimli has a vectored implementation available: someone should port it to the zig std library

1587435202
Kingsquee
I've never been a fan of different syntaxes just for base types so this is kinda bugging me

1587435277
Kingsquee
daurnimator: who has a what now

1587435285
Kingsquee
(brb)

1587435452
Kingsquee
a more concrete version of what I'm describing is a Q-format fixedpoint number

1587435492
daurnimator
who has what now what?

1587435509
Kingsquee
("<daurnimator> Not exactly related, but you reminded me of a contributor friendly task: gimli has a vectored implementation available: someone should port it to the zig std library")

1587435533
Kingsquee
the most obvious description I can see for a signed version is something like Qi(Bitcount, IntegerBitcount, FractionalBitcount), but we can't do @Vector(4, Qi(8, 4,4))

1587435561
Kingsquee
so without making a weird redundantly typed version of VectorQi, would make more sense to just add another parameter

1587435570
daurnimator
Kingsquee: I'm saying someone should port

1587435572
Kingsquee
which gives us Qi(8, 4,4, 16)

1587435645
Kingsquee
which starts getting us into interesting places with parameters and farther from both 'Communicate intent precisely' and god

1587435660
daurnimator
Kingsquee: the idea is that zig doesn't support operator overloading: e.g. only base types and vectors of base types have a working `+`

1587435716
Kingsquee
yeah true

1587435735
Kingsquee
so I guess comptime param spam is going to be the way it be

1587435746
Kingsquee
const q2 = Qi(.{ .bitcount = 8, .integer_bitcount = 4, .fractional_bitcount = 4, .lane_count = 1 });

1587435748
Kingsquee
w e w

1587435771
daurnimator
as bad as that is to type.... as a reviewer that is more useful.

1587435814
Kingsquee
imagine it an inline qformat conversion within a chain of function calls

1587435864
Kingsquee
a.into(.{ .bitcount = 8, .integer_bitcount = 4, .fractional_bitcount = 4, .lane_count = 1 }).mul(b.into(.{ .bitcount = 8, .integer_bitcount = 4, .fractional_bitcount = 4, .lane_count = 1 })

1587435913
daurnimator
but you can make an alias for your option-set

1587435929
Kingsquee
true

1587435971
Kingsquee
const we_need_more_fractional_bits_here = .{..}

1587435982
Kingsquee
self documenting code clap emojii

1587436041
daurnimator
`const @"👏" = .{.bitcount = 8, .integer_bitcount = 4, .fractional_bitcount = 4, .lane_count = 1 };`

1587436114
Kingsquee
back, demon ✞

1587436206
daurnimator
const @"✞" = *@"👏";

1587437734
Kingsquee
is there custom formatting for types?

1587437763
Kingsquee
or is that called 'foo.formatme()'

1587440258
torque


1587440272
torque
see the paragraph starting with "If a formatted user type contains a function of the type"

1587440569
Kingsquee
oh neat, t hanks torque

1587440620
Kingsquee
so when ReleaseFast says "Safety checks disabled", does that include overflow checks on the '+' op

1587440629
Kingsquee
or is that always around

1587440707
Kingsquee
just wondering if I should spam '+%' everywhere

1587441174
Kingsquee
hmm

1587441176
Kingsquee
'pub fn foo(self: Q(Format), output_format: QFormat) Q(output_format) { .. }' "error: use of undeclared identifier 'output_format' (in return type)"

1587441395
mikdusan
Kingsquee: `+%` no-safety-check in any build mode. `+` subject to build mode: on for debug,safe; off for small,fast

1587441463
mikdusan
if your code

1587441531
Kingsquee
mikdusan: interesting, thanks

1587441546
Kingsquee
so if code

1587441609
fengb
That’s more robust yes

1587441637
fengb
Or std.math.add if you prefer working with error unions

1587441648
Kingsquee
mm, noted

1587441668
Kingsquee
still confused as to why I can't pass output_format to the return fn

1587441688
mikdusan
that's for explicit checking. what I mean with relying on overflow is... maybe you're handing out u8 numbers starting from zero. when it gets to 255, your algo actually expects i+=1 to make it 0 again

1587441824
mikdusan
make it comptime?

1587441898
Kingsquee
oof, yes

1587442043
mikdusan
the error could be better; self-hosted compiler will have much more helpful errors and hints

1587442259
Kingsquee
yeah, I understand

1587442276
Kingsquee
so for stuff like Bit Shift Left: "b must be comptime-known or have a type with log2 number of bits as a"

1587442286
Kingsquee
interesting that it can be comptime OR somecondition

1587442296
Kingsquee
is that only something the compiler can do

1587442319
Kingsquee
or is there some kinda maybecomptime logic I can write

1587442600
mikdusan
I haven't tinkered much with shifting but maybe std.math.Log2Int and std.met.IntType can help

1587442614
mikdusan
std.met.IntType

1587442620
mikdusan
blah. std.meta.IntType

1587446542
Kingsquee
hmm, yeah I see the documentation says shifting uses Log2Int

1587446599
Kingsquee
also, is there a way to conditionally define a function based on a type-returning fn's parameter?

1587446621
Kingsquee
if (n > 2) { return pub fn foo() {..}; }

1587446629
Kingsquee
or somesuchlike

1587451168
z0ltan
hey folks, i suppose the llvm+homebrew issue on macosx is going to be unresolved for a while, huh? I've reverted to an old working version (with manual CMakeLists changes) in the meantime

1587451710
Kingsquee
...wait that's Log2T :I

1587456374
antaoiseach
so much silence

1587456376
antaoiseach
:D

1587458886
Snektron
Imagine if github allowed you to add code to your bug report, and then integrate that with CI which automatically tests if its still valid

1587458900
Snektron
That would be nice

1587462466
Dominic[m]
I wonder if you could bolt that on by searching github issues for zig test blocks.

1587470367
tritao
hello folk, just compiled zig master on mac and its crashing on startup, created an issue

1587470390
tritao
seems to be some issue identifying the target, rings any bells?

1587471222
mikdusan
note to self: `valgrind zig test lib/std/std.zig` wants about 11 GiB of VRAM

1587471426
ifreund
oof

1587471436
ikskuh
piece of cake!

1587471942
ifreund
hmm, why are my tests dumping core in release mode but not in debug?

1587471963
ifreund
shouldn't debug always ensure a crash on UB?

1587471989
mikdusan
ensure? no.

1587472965
pixelherodev
11GB? Nice

1587472973
pixelherodev
Dark I ask how much Callgrind wants?

1587473357
mikdusan
I seem to recall running xcode memory profiler and it has call graph... ~20+ GiB

1587473369
pixelherodev
Wow.

1587474566
pixelherodev
Is there a way to tell Zig/LLVM not to use a specific register?

1587474572
pixelherodev
No particular reason :P

1587474574
grayhatter
> shouldn't debug always ensure a crash on UB?

1587474594
grayhatter
isn't that the whole idea of UB, is that it can do what ever it wants?

1587474599
pixelherodev
Not in Zig

1587474607
grayhatter
then that's defined behavior

1587474609
pixelherodev
Zig has "runtime-checked illegal behavior" instead of UB

1587474609
ikskuh
pixelherodev: lul. i don't think so

1587474616
pixelherodev
ikskuh, I don't either :P

1587474619
pixelherodev
was worth a shot though

1587474624
fengb
We add runtime checks when we can detect it, but we don’t capture all of them yet

1587474627
pixelherodev
grayhatter, sorta-kinda-but-not-really

1587474634
pixelherodev
There is some UB still

1587474657
ikskuh
zig has both "detectable illegal behaviour" and "undetectabe illegal behaviour"

1587474664
fengb
e.g. using uninitialized allocated memory

1587474664
pixelherodev
Yeah

1587474672
ikskuh
first class is captured in safe and debug mode

1587474672
pixelherodev
but for supported types (pointer alignment, null pointer access, wrapping addition, etc),

1587474691
grayhatter
I'm just trying to point out, that undefined behavior is by it's very nature, ambigious... that is to say, expecting something from UB is a problem with the understanding of UB

1587474697
fengb
There’s a task to add safety checks to everything but that’s a lofty goal

1587474704
grayhatter
moreover... don't call illegal operations UB

1587474718
fengb
We’re transitioning towards calling it illegal

1587474737
fengb
It’s only UB in release-fast / release-small modes

1587474748
pixelherodev
and the idea is that you use the debug/safe modes to ensure there is no UB

1587474756
grayhatter
fengb: is it actually UB though?

1587474765
pixelherodev
It's defined as undefined

1587474767
fengb
In release-fast yes

1587474767
pixelherodev
;)

1587474770
fengb
It’s the same as C

1587474775
pixelherodev
Yeah in fast and small it's just UB

1587474784
grayhatter
cool

1587474786
pixelherodev
You should

1587474789
grayhatter
thanks

1587474795
pixelherodev
Which lets you ensure your program doesn't have UB

1587474798
fengb
In release-safe it should be safety checked and panicky

1587474813
pixelherodev
Release-safe is for if you're rushing something to production and aren't certain you caught everything

1587474829
pixelherodev
Release-fast/small are for, well, fast/small builds when you think it's safe to enable it

1587474853
pixelherodev
release-safe gives you

1587474876
ikskuh
release-safe is still 5 times faster than debug though

1587474876
pixelherodev
("Release-safe is for..." <- purely my take; not official Zig stance ;)

1587474877
fengb
Lots of speed actually. My emulator improves 30x

1587474891
pixelherodev
True

1587474926
pixelherodev
It's sorta like `-O2 -emit-runtime-checks` vs `-O2` as I understand it, so a lot of optimization is still performed

1587474955
fengb
Yes, but the UB nasal demons can do some crazy stuff

1587474965
pixelherodev
Yeah :(

1587474967
pixelherodev
Like run Doom.

1587475011
fengb
Like in safe mode, doing `catch unreachable` will add a runtime check. In fast mode, it’ll convince the optimizer this can never happen and start deleting code paths entirely

1587475035
pixelherodev
Yeah

1587475037
pixelherodev
I love that

1587475047
pixelherodev
Oh yeah, here it is:

1587475077
pixelherodev
`When GCC identified “bad” C++ code, it tried to start NetHack, Rogue, or Towers of Hanoi. Failing all three, it would just print out a nice, cryptic error message.`

1587475112
fengb
I mean, running NetHack is a totally valid interpretation of UB

1587475135
hazeycode
brilliant :D

1587475137
pixelherodev
Reallllly tempted to have ZiggIRat scan for e.g. steam and run the first thing it finds

1587475139
ikskuh
oh yeah, these were wild times :D

1587475140
pixelherodev
but also, no.

1587475163
pixelherodev
Or show a skull GIF

1587475185
fengb
There should be a nasal demon emoji

1587475186
ikskuh
Start Skullgirls

1587475193
fengb
👺

1587475193
hazeycode
rick astly is valid undefined behaviour

1587475201
fengb
lol

1587475246
pixelherodev
Ooh

1587475248
pixelherodev


1587475256
pixelherodev
:P

1587475264
pixelherodev
No I won't but I really want to :(

1587475282
pixelherodev
Maybe I'll do something like `if (hostname == "pixtel")` (my laptop)

1587475306
fengb
Embed the entire video in your executable

1587475317
fengb
Encrypted of course

1587475318
pixelherodev
That would be a copyright violation, I think.

1587475325
pixelherodev
Ooh wait

1587475329
pixelherodev
If it's encrypted, that's fair use.

1587475329
fengb
But a license

1587475330
pixelherodev
Definitely.

1587475333
fengb
But

1587475335
hazeycode
"you know the rules, and so do iiiiiiiiiii"

1587475336
fengb
Buy

1587475362
pixelherodev
I think I could just say "A bunch of programmers will be really really mad" and get a free license

1587475364
pixelherodev
:P

1587475374
hazeycode
"never gonna tell a lie, and hurt you"

1587475374
fengb
I think it’s cheaper to get a music license. So make your own interpretation video

1587475376
pixelherodev
Reminds me of Rust's Lovecraft panic

1587475400
hazeycode
I mean, the song is literally about how zig treats undefined behaviour

1587475422
pixelherodev
Ha

1587475430
pixelherodev
That's - surprisingly accurate

1587475473
ikskuh
C is more like " you don't know all the rules, but I do!"

1587475499
fengb
The rules are simple: 1. That’s undefined behavior

1587475754
hazeycode
just printing the lyrics would be amazing

1587475850
oats
const rick = @embedFile("roll.mp4");

1587475890
fengb
You forgot the encryption. rot13(rot13(@embedFile))

1587475899
oats
lolol

1587475901
oats
double rot13

1587475919
ikskuh
i think rol13 is the better one

1587475961
fengb
If triple DES makes it secure, then quadruple rot13 does too right?

1587476011
ikskuh
sure!

1587476069
oats
or double AES in CTR mode ¯\_(ツ)_/¯

1587476444
oats
ooh, I should implement AES in zig

1587476462
oats
that would be fun

1587476470
oats
maybe after I get the important things done today :P

1587476766
fengb
¯\_(ツ)_/¯ I just do stupid shit all day like reimplement wasm poorly

1587477145
oats
haha

1587477153
oats
my kinda pasttime

1587478076
TheLemonMan
tritao, yo, are you on high sierra or something newer?

1587478546
tritao
TheLemonMan yeah high sierra

1587478572
TheLemonMan
tritao, what does `sysctl kern.osproductversion` return?

1587478592
tritao
sysctl: unknown oid 'kern.osproductversion'

1587478596
mikdusan
do we have a return discrepancy?: lib.std.os.linux.x86_64.clone() start function is `extern fn (arg: usize) u8` and man-page for libc says `int (*fn)(void *)`

1587478636
TheLemonMan
mikdusan, the ABI doesn't really care, the u8 is usually zext'd to fill a whole reg

1587478654
mikdusan
thx.

1587478669
TheLemonMan
tritao, well shit, the documentation stated it was supported starting from high sierra

1587478702
mikdusan
tritao: what is output for `sw_vers`

1587478735
TheLemonMan
so it seems it's supported from 10.13.6 on

1587478747
tritao
can we use `sysctl kern.osrelease`? that returns `kern.osrelease: 17.3.0`

1587478796
tritao
`sw_vers`: ProductName:Mac OS X, ProductVersion:10.13.2, BuildVersion:17C88

1587478802
mikdusan
maybe we should fallback to a mapping table if kern.osproductversion is not avail

1587478821
TheLemonMan
yay one more table

1587479159
pixelherodev
Latest microoptimization: increases performance by ~0.00224%

1587479168
pixelherodev
I really really need to stop

1587479199
companion_cube
hello improvements below noise level!

1587479256
ikskuh
pixelherodev: anything below 1% isn't measurable

1587479263
ikskuh
it's just noise

1587479307
pixelherodev
Nah, it's measurable

1587479315
pixelherodev
I think

1587479321
pixelherodev
Valgrind is measuring instruction fetches

1587479340
pixelherodev
It's consistent (running the same build N times always gives the same result)

1587479351
pixelherodev
(rebuilding again will as well, assuming deterministic optimizations)

1587479356
companion_cube
I do think it's not very useful to optimize :D

1587479371
ikskuh
yeah

1587479378
ikskuh
don't optimize before your program does what it should do ;)

1587479383
pixelherodev
Well of course :P

1587479392
pixelherodev
Here's a better one at least: 0.6%

1587479399
pixelherodev
:)

1587479412
pixelherodev
Had an index that was always being used as an offset to a constant

1587479426
xackus
if you change anything, the code layout might change completely

1587479432
pixelherodev
Replaced that with a var initialized to the constant and replaced `index += ` with `current+addr` +=

1587479441
pixelherodev
Now it's more than half a percent faster! Yay!

1587479442
ikskuh
what xackus says

1587479450
ikskuh
anything on these levels is just nise

1587479453
ikskuh
*noise

1587479459
pixelherodev
For beyond the current build, yes

1587479462
ikskuh
on larger projects, it's better optimization to randomize link order and chose the best

1587479486
pixelherodev
Not for typical Zig projects, since there's only one object file generally :)

1587479504
pixelherodev
LTO should also mitigate that for GCC/Clang, I'd think

1587479510
pixelherodev
(Not that I'm advocating its usage)

1587479512
mikdusan
10.13.4 is first one to support sysctl_osproductversion

1587479520
ikskuh
pixelherodev: yeah still things can change in-object

1587479527
ikskuh
and no, it doesn't

1587479530
xackus
I saw a presentation of a tool that randomizes code layout, you get a cool bell curve when you measure performance

1587479556
ikskuh
xackus: yeah saw the same talk, it explains pretty well where the problems are

1587479619
TheLemonMan
mikdusan, what's the lowest osx version we support?

1587479642
mikdusan
"10.13+"

1587479688
mikdusan
you know what, I'm just going to implement reading the correct .plist file and solve this.

1587479727
TheLemonMan
that's definitely the wrong angle to approach this problem

1587479738
TheLemonMan
unless you like xml and plist

1587479774
mikdusan
it's doing what apple does. the kernel value is set from the value in a .plist file at startup

1587479783
pixelherodev
So basically, compiler optimization isn't really scientifically understood and so doing random garbage is just as likely to help as anything else?

1587479793
pixelherodev
mikdusan, 'doing what apple does' doesn't seem like a good justification IMO :P

1587479826
TheLemonMan
I'd just get the kernel version and add a small switch to cover the 10.13 < x < 10.13.2 case

1587479837
TheLemonMan
everything else is handled by the sane sysctl

1587479841
pixelherodev
better than the minor performance gain: `144 insertions(+), 150 deletions(-)`

1587479844
pixelherodev
Simpler code :)

1587479846
xackus
it's just the butterfly effect

1587479860
mikdusan
oh so

1587479892
pixelherodev
The whole reason this optimization round started was because I realized I could generate a single MOV in a place I'd previously been generating two

1587479913
pixelherodev
IMM -> RAM instead of IMM -> REG -> RAM

1587479958
TheLemonMan
I don't like mantaining up-to-date tables, see what we have to do to map Windows revisions to what's returned by the API

1587479989
TheLemonMan
a small table for a couple of entries is fine

1587480082
pixelherodev
Ooh, idea for an actual non-micro optimization :)

1587480108
ikskuh
<pixelherodev> So basically, compiler optimization isn't really scientifically understood and so doing random garbage is just as likely to help as anything else?

1587480112
ikskuh
nah, it'S quite good understood

1587480118
ikskuh
but all optimizations are small-scale

1587480121
ikskuh
and ignore larger effects

1587480136
ikskuh
reordering functions in memory can greatly improve performance by using cache locality and similar effectss

1587480207
pixelherodev
Right but, there's no way of actually predicting in advance what the actual effect will be

1587480216
pixelherodev
(and yes that was an exaggeration)

1587480302
xackus
I've rarely ever used a second monitor when I had a chance to

1587480324
xackus
now I kinda want one just for irc

1587480368
ikskuh
pixelherodev: the tool from the talk was randomizing the link order

1587480377
ikskuh
and measures effects on every variant

1587480474
xackus
there are also rare cases when speeding up some code can actually have an overall negative effect because of resource contention

1587480673
pixelherodev
ikskuh, but that's my point

1587480675
pixelherodev
It's randomizing

1587480685
ikskuh
yes, but measuring

1587480693
ikskuh
it's not possible to find a definite solution

1587480695
ikskuh
#haltingproblem

1587480757
pixelherodev
It's not measuring the code and saying "Well, we know that doing X will improve Y but make Z worse, so let's measure A and see the stacking effect of these reorders"

1587480757
pixelherodev
There are no tools that directly measure

1587480757
pixelherodev
Randomizing and checking the results is

1587480758
pixelherodev
It's guessing and checking

1587481141
ikskuh
it's measuring

1587481147
ikskuh
but it's not "knowing beforehand"

1587481151
ikskuh
because that's not possible

1587481171
ikskuh


1587481189
fengb
Is there a way to inject lld options?

1587481267
sanaris
well in PC code actually is faster or slower based on tonns of factors

1587481296
mikdusan
fengb, with `zig build-exe` or similar? I don't think there is. but if you want to one-off experiment/troubleshoot I have a few suggestions

1587481313
sanaris
when there is real need to create optimizations, people use special tools to clean caches and measure clocks of processors

1587481337
sanaris
ofc these clean conditions are never met in reality

1587481361
shakesoda
every time optimizers come up i think it'd be nice if i could just leave little love notes all over the place that the optimizer can use about the expected/desired properties of a given thing

1587481395
shakesoda
on this note, the game i'm about to ship is severely backend/memory bound from early design decisions and it's a miracle the thing runs well enough to ship

1587481409
shakesoda
cache behavior: middle finger emoji

1587481545
sanaris
programs most of the time hit memory BW bottleneck and compiler/language/cpu have really nothing to do against that

1587481605
companion_cube
shakesoda: can you elaborate? it'd be interesting to read this kind of post-morterm

1587481605
shakesoda
yeah, it's sinister how much most regular profiling tools absolutely suck at showing you this, too

1587481608
companion_cube
(well, post-shipping)

1587481617
fengb
mikdusan: would it make sense to do a -mlld flag corollary to -mllvm

1587481696
shakesoda
companion_cube: I might be able to but I'm not sure

1587481734
mikdusan
fengb: for troubleshooting purposes would be very valuable. probably also useful for things zig doesn't support yet, but can't wait so do-it-yourself

1587481740
fengb
Isn't that the end result of any game? "it's a miracle the thing runs well enough to ship"

1587481744
shakesoda
a huge problem is designs based around graph processing using a lot of naive LL's to big stuff, and OO designs that hide so much work you can scarcely find the bottom

1587481770
fengb
mikdusan: great, I'd hate to pollute the parser with a bunch of wasm only flags

1587481784
shakesoda
the optimizer can do a lot against needing to inline the absolute hell out of things, but it can't help you from the horrid memory accesses that sneak in this way... as mentioned

1587481843
shakesoda
just wasn't designed for this kind of load, as is tradition

1587481843
xackus
yeah, linked lists are very cache hostile, especially without a custom allocator

1587481886
shakesoda
another way to absolutely destroy your performance is overdoing the hashmaps

1587481894
shakesoda
I was able to make those not hotspots anymore though

1587481923
xackus
at least hashmaps are often a good choice, LLs almost never are

1587481930
shakesoda
aye

1587481973
xackus
and even if they are not the best, the damage is limited

1587482027
shakesoda
yeah, I was able to make more than a strong enough case for getting the worst offenders refactored post-launch

1587482048
companion_cube
shakesoda: have you an opinion on ECS? I'm hearing a lot about them in the context of rust, even though I'm not a game dev

1587482105
shakesoda
companion_cube: yes, ecs is an absolutely wonderful tool and I've been designing my engines in ways you could describe that way for years

1587482125
companion_cube
(I imagine you're writing C++)

1587482143
shakesoda
i mean it's just a practical application of data oriented design, i.e. giving a shit about what the computer is actually doing

1587482167
shakesoda
yeah, I'm dealing with C++ (yuck!!!)

1587482205
shakesoda
I recall there being some really fancy ecs things for rust and I've got little interest in them. the ones I use in practice are almost all so simple it'd be pointless to make a library of it

1587482591
fengb
Jon Blow has an amusing rant on ECS in Rust >_>

1587482722
FireFox317
Got a cross-compiled zig binary running on my mips router <3 🎉

1587482739
TheLemonMan


1587482747
FireFox317
And it was so easy :O It just works™

1587482770
FireFox317
Thanks TheLemonMan for the mipsel support in zig std. It also works for normal mips :)

1587482823
ikskuh
FireFox317: LOL nice

1587482916
FireFox317
Some weeks ago I put OpenWRT on the router, and i thought lets try running a zig binary on it :D

1587482940
fengb
My router is ARM. I feel less cool

1587482951
companion_cube
fengb: what's his rant?

1587482985
fengb


1587483026
fengb
Oh and gingerBill has a rant about that rant

1587483046
shakesoda
fengb: blow has rants on lots of things, heh

1587483048
oats
but is there a rant about the rant about that rant?

1587483064
fengb


1587483262
shakesoda
heh, i vaguely remember this rant (blow)

1587483425
fengb
Andrew had a joke video where he pretended to rant about the rants

1587485553
companion_cube
ugh, I don't have time to watch this 1h rant

1587485555
companion_cube
so boring

1587485576
andrewrk
it's not really that insightful either imo

1587485819
kristoff_it
If anybody is interestered, while I wait for async/await to come to macos (:D), I'm going to stream on twitch the translation of a radix tree implementation from C to Zig. It's new stuff for me so don't expect it to be a perfect livecoding tutorial. I know what radix trees are from compsci classes but I've never implemented a serious version before.

1587485842
kristoff_it
I'm starting 1h from now, more or less -> twitch.tv/kristoff_it

1587485885
kristoff_it
and this is what I'm starting from:

1587485926
kristoff_it
(also if anybody knows other interesting implementations I'd be curious to compare them)

1587486087
FireFox317
cool kristoff_it!

1587486518
TheLemonMan
andrewrk, what about allowing `align(N)` on fields iff the structure is packed or, if it's not, only if the alignment is actually > than the minumum ABI alignment?

1587486652
andrewrk
the goal is to prevent under-alignment?

1587486676
andrewrk
how does that affect

1587487463
TheLemonMan
yeah, I also can't see why one would intentionally under-align a field in a regular structure

1587487531
TheLemonMan
atm the compiler fails hard as LLVM computed alignment is different than the Zig's expected value

1587487665
andrewrk
TheLemonMan, the main purpose of the align(0) proposal, and under-alignment in general, as I see it, is for data structures that will be numerous in memory. so it is worth it for more instructions when processing the data, to save bytes in memory

1587487697
TheLemonMan
if you care about the layout then just make it packed, no?

1587487721
andrewrk
align(0) in non-packed structs allows to rely on the compiler to figure out where to put everything

1587487797
FireFox317
TheLemonMan, i pushed #5122 regarding mips support. Is the TLS stuff also correct for mips?

1587487838
TheLemonMan
so align(0) allows for some weird-ass semi-packed/semi-regular structure types?

1587487842
TheLemonMan
FireFox317, let me check

1587487879
TheLemonMan
yeah, the offsets are always the same

1587487891
FireFox317
TheLemonMan, okay thanks!

1587487894
andrewrk
TheLemonMan, yes

1587487899
TheLemonMan
have you tried running the test suite?

1587488005
FireFox317
Nope, not yet. Can I somehow cross-compile the test suite too? Because this router is not powerfull enough to run the zig compiler

1587488044
TheLemonMan
sure thing, just `zig test -target mips-linux-musl std.zig`

1587488048
andrewrk
FireFox317, yes you can. in your zig source checkout: ./zig build test -Dskip-release -Denable-qemu

1587488077
FireFox317
andrewrk, will do it without qemu, i can transfer the test binaries to the router i guess?

1587488085
andrewrk
yes that will work too

1587488103
TheLemonMan
you'll have to disable some tests though or use LLVM10 with D78011 applied

1587488109
fengb
Alright, I have no clue how to enable arbitrary linker args

1587488130
mikdusan
i'd like to see internal align repr better. like an optional u8 for power. when null, it is abi-align. struct can have convenience function as_bytes() or as_bits(). the power would be starting from bits. =0,1,2 mean bitalign. =3, and higher mean bytealign. and set_byte_align and set_bit_align

1587488151
andrewrk
fengb, zig intentionally does not expose arbitrary linker args. what is your use case?

1587488171
fengb
I want to attach --import-memory to wasm lld

1587488204
fengb
And didn't want to pollute the general args parsing

1587488248
andrewrk
that sounds like something that should be handled explicitly rather than as the user handing zig a black box and saying "give this mysterious black box to your backend linker component"

1587488284
fengb
Yes probably. Should it just be --import-memory to zig?

1587488326
andrewrk
maybe --wasm-import-memory. I failed to find docs on what that does in my quick search

1587488341
TheLemonMan
andrewrk, align(0) is a special case then, what about every other N < abi-align?

1587488372
fengb


1587488409
fengb
Imports shared memory from the host env instead of owning a separate one

1587488656
andrewrk
TheLemonMan, I see those as similar cases to align(0). for example here we can save space in an array of these: struct{ a: u64 align(4), b: u32 } but without the bit shifting of align(0)

1587488692
andrewrk
I get that the struct alignment code is really messy and fragile and I have plans to improve that, but does it mean we need to change the language?

1587488870
andrewrk
fengb, keep in mind that a non-llvm (and non-LLD) backend is planned (and in progress!)

1587488942
TheLemonMan
again, why not `packed struct` and call it a day? if you're trying to micromanage the layout that's the best solution IMO

1587489014
andrewrk
so you want to do align(0) on normal structs but not other kinds of under-aligning? that seems inconsistent

1587489083
mikdusan
it's a disposition thing; defaults count and with a non-packed struct, align(0) is the exception to the rule. can be convenient

1587489172
andrewrk
here's the current plan: structs and packed structs are the same except (1) field order is declaration order in packed structs (2) the default alignment of structs is ABI alignment; default alignment of packed struct fields is align(0)

1587489181
andrewrk
what's the counter-proposal?

1587489452
via
if you want to control padding and alignment in a struct, why not just do that with explicit padding? like you would with a C packed struct

1587489521
andrewrk
here's one use case: flags. struct OpenFlags {read: bool align(0), write: bool align(0), special: enum{a,b,c,d} align(0) }

1587489550
andrewrk
why should I specify padding here? I dont care about padding

1587489575
via
what does that have to do with packing structs then?

1587489598
via
packing is when you specifically care about the in memory layout

1587489625
via
it would be when i need read and write to be 1 bit each, maybe 4 bits of padding for reserved space, then the enum, taking 4 bits or whatever it takes

1587489659
TheLemonMan
let's take a step back, I feel the the problem here is that we want more than packed/nonpacked structure

1587489662
via
i'm concerned that implementing per-field alignment for packed structs cretaes a lot of complexity

1587489664
andrewrk
that's a reasonable argument. this is getting a bit involved and I would like to focus on some code, so I would request that if you want my engagement in this discussion, move it to

1587489674
via
ok, sorry

1587489676
TheLemonMan
eg. packed with field-reordering

1587489697
via
i also cannot imagine a world where i would want a packed struct to be subject to compiler reordering

1587489808
TheLemonMan
here's one use case: flags.

1587489908
TheLemonMan
maybe handling flags as a bitfield can be done even today with some comptime magic

1587490054
via
TheLemonMan: i don't follow, you want the compiler to optimize a struct to keep all fields with no padding together, but nothing else? if anything, i just feel like that should be part of a 'optimize for space' option

1587490078
via
but `packed` should just mean 'give me explicit control over the fields in memory'. or, call it something else, but that is definitely needed somehow

1587490130
TheLemonMan
via, yeah that's what I said, we probably want more control over the layout

1587490202
via
those are just optimzations though -- you can largely do what you want with just normal explicit packed structs. on the other hand though, there is a lot that cannot be done without having traditional packed structs (namely, i can't really use zig embedded until it works)

1587490257
via
it just feels to me like perfect flexibility/annotations-for-the-compiler are preventing something simpler but necessary

1587490286
TheLemonMan
nobody's talking of taking away regular packed structures

1587490293
via
ok

1587490337
via
though i think most of the issues around how packed structs don't work are waiting for a better more flexible way to do things. maybe i've misinterpretted

1587490372
TheLemonMan
the point was, why would you want to underalign some fields in a non-packed structure? If you care about space saving/memory layout then why not a packed struct?

1587490394
via
okay, fair enough

1587490722
sanaris
Well, to be able to build Zig I was kinda forced to setting LLD_LLD*_LIB variables on src based system

1587491440
companion_cube
so what do people think of

1587491445
companion_cube
QBE as a backend?

1587491531
TheLemonMan
it doesn't seem that alive

1587491735
companion_cube
could still be a good basis

1587491741
companion_cube
could even be ported to Zig?

1587491813
TheLemonMan
cranelift is slightly more promising

1587491816
fengb
We could also maybe try Cranelift

1587491822
fengb
Doh I'm slow as usual

1587491931
pixelherodev
QBE is interesting

1587491948
pixelherodev
And I'm planning on adding it to ZiggIRat as my next step after I finish implementing the x64 stuff

1587492138
sanaris
I am a helloworldster in Zig. What's next?

1587492188
TheLemonMan
hit some compiler bug heh

1587492258
pmwhite
Write a comptime Wayland compositor?

1587492333
companion_cube
cranelift looks much bigger though

1587492340
companion_cube
I'd wait until rust has it as a backend

1587492594
fengb
"Yes, which gives about 40 lines of IR for C, and about 1300 for Rust (Godbolt truncates it at 500)." 🤔

1587492713
sanaris
I think no compiler should be very optimal right after start.

1587492737
sanaris
C had a long story of awful compilers before 95

1587492780
FireFox317
TheLemonMan, with behavior tests on mips im hitting `error: non-trivial scalar-to-vector conversion`

1587492791
FireFox317
any idea? :D

1587492798
FireFox317
sounds like @vector or something?

1587492822
TheLemonMan
eh you probably need to tweak the mcpu

1587493391
FireFox317
hmm

1587493568
FireFox317
found it

1587493891
plumm
andrewrk: what do

1587494269
TheLemonMan
plumm, GH is having connectivity problems

1587494558
plumm
okie

1587495644
FireFox317
andrewrk, are you going to stream some work being done on the self-hosted compiler? :D

1587496633
xackus
anyone had --verbose-ir segfault by dereferencing null in render_node_extra?

1587496747
FireFox317
verbose-ir always crashes when it is run on a big file i.e. hello world. you have to overwrite the panic handler and export _start to make sure that none of the std library is pulled in

1587496751
FireFox317
xackus ^

1587496936
FireFox317
xackus,

1587497653
xackus
thanks, i forgot i had to overwrite the panic handler

1587498024
TheLemonMan
mikdusan, why not returning `error.InvalidVersion` whenever the string fails to parse?

1587498065
TheLemonMan
and since the decoding logic is quite hairy can you add a few test cases?

1587498079
mikdusan
actually already done. will push that in a few

1587499896
tritao
TheLemonMan , mikdusan, mind checking my patch for the macOS crasher before I send a PR?

1587500105
tritao
mikdusan, ah just noticed you are working on a patch as well

1587500196
tritao
yours seems more comprehensive for older OS versions so i guess thats the way to go

1587500660
foobles
heyo

1587500692
foobles
in the c++ compiler, is there a strict formatting guideline? because when I copied + pasted some code it auto indented differently from normal

1587500699
foobles
and Im wondering if i need to change it bakck

1587500808
Snektron
i recommend following the existing style

1587503256
r4pr0n
btw: the link in

1587503492
oats


1587503509
oats
/r/zig has been seeing pretty significant growth :D

1587504120
r4pr0n
is _start broken again?

1587504124
r4pr0n
(self-defined)

1587504818
pixelherodev
daurnimator, you mentioned using CrossTarget for the emitter earlier

1587504843
pixelherodev
how easy would it be to take a comptime CrossTarget and ensure it's for x86/x64?

1587505124
pixelherodev
Oh wait here's an idea

1587505144
pixelherodev
Expose a convenience function `@import("lightzing").emitter(CrossTarget)`

1587505152
pixelherodev
That'll automatically return e.g. x64, x86, LIMN, etc

1587505271
pixelherodev
Long term, that allows for great integration with Zig and stdlib; short-term, it means low-level emitters can take in simpler inputs

1587506089
pixelherodev
daurnimator, is it possible to get the native info at comptime?

1587506095
pixelherodev
A native CrossTarget, for instance?

1587506595
Snektron


1587506635
Snektron
old_mem should already be aligned to the page size right? so should that check be `new_align <= max(page_size, old_align)` instead?

1587506751
pixelherodev
I prefer it as is

1587506755
pixelherodev
It's IMO more readable

1587506773
pixelherodev
Oh wait

1587506980
pixelherodev
I think I misunderstood you

1587507002
Snektron
Its about functionality yea

1587507023
pixelherodev
I'd ask for an explanation, but I'm not functional enough to comprehend it (pun intended)

1587507047
Snektron
Well thats what i was trying to do actually

1587508084
mikdusan
what's the preferred mechanism for test inclusions in a file. I'm seeing the old `test "" { _ = @import("subdir/foo.zig"); }` and also a new one `std.meta.refAllDecls(@This());`

1587508353
Snektron
Referencing all declarations will check if they contain semantic errors, but since it also references imports it also imports tests of all used files

1587508391
Snektron
I think you have to be careful with it though, for example you might accidentally reference stuff belonging to the wrong platform

1587508491
mikdusan
ah got it. if we wanted conditional includes of sub-dir-based tests, then refAllDecls is not going to work

1587509436
pixelherodev
`error: expected type '[]u8', found '*const [4:0]u8'` gah

1587509469
afontain_
add a const

1587509508
pixelherodev
thanks

1587509824
afontain_
helm has great messages in such case. maybe telling that the type would be compatible if there was a const would be nice

1587509826
afontain_
*elp

1587509829
afontain_
*elm

1587509855
Sphax
Hello. I'm getting this error

