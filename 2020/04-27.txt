1587947304
Snektron
They're non-exhaustive now

1587954693
foobles
is there a way to say "generate an IrInstGen object without appending it to the current basic block"?

1587954710
foobles
like i want to generate an instruction that my own new irInstGen will contain

1587954730
foobles
and when my own irInstGen is rendered it will create a new basic block, and do stuff like that

1587954771
foobles
so i dont want the irInstGen it contains to be automatically added to the current_basic_block, when I only want it to exist on its own

1587954893
foobles
Hmm, that seems difficult

1587955399
foobles


1587955411
foobles
this should explain better what i am trying to accomplish

1587974833
marler8997_
how would you put a compile-time integer into a @compilerError message?

1587976232
mikdusan
marler8997_: I rolled my own a while back;

1587976343
mikdusan
it looks odd to return stack but in comptime that works

1587976591
marler8997_
thanks

1587977842
st4ll1
shakesoda: oh i did not finish my question yesterday, yeah i upgraded zig to 0.6.0, so do i know need to rewrite my c.<ENUM_value> to c.<ENUM_name>.<ENUM_value> or something like that am i right?

1587978387
shakesoda
st4ll1: you can infer them with just an unqualified . also

1587978425
shakesoda
c.whatever will exist but have an int type, not enum value type

1587978520
st4ll1
shakesoda: thanks

1587984261
daurnimator
andrewrk: what is SSAT?

1587984340
alexnask
daurnimator, Static single assignment tree

1587984555
daurnimator
ah he answers later

1587984745
ikskuh
is there any documentation on what SSAT is?

1587984754
ikskuh
i can't find any resources except for what "SSA" itself is

1587985145
alexnask
ikskuh,

1587985159
ikskuh
i cannot find the word "tree" on that page :D

1587985174
ikskuh
that's why i'm asking

1587985179
ikskuh
i know what SSA itself is

1587985200
alexnask
Ah mb I misunderstood :)

1587985243
ikskuh
but nice to see that zig slowly gets into self-hosted direction

1587985262
ikskuh
would be funny if the zig self hosted compiler could beat Go in terms of compile times for unoptimized code :D

1587985559
alexnask
We should make a C->zir frontend to dethrone C as soon as possible too :-P

1587985717
ikskuh
haha that would be rad

1587985725
ikskuh
yeah, btw. our C compiler is faster than yours :D

1587985745
ikskuh
but first: make it work for Zig

1587991524
Xavi92
Hi, is it possible to specify endianness on a packed struct?

1587991575
fengb
Nope they’re always native

1587991631
fengb
ikskuh: our target should be V. 1

1587991652
Xavi92
fengb: hm, do you think it would be a reasonable proposal to the language? I think it could be useful on many situations e.g: when dealing with a protocol where endianness is fixed such as Bluetooth

1587991687
fengb
I think that was recently rejected

1587991688
Xavi92
fengb: something like `const Packet = packed struct big endian { ... }`

1587991708
fengb
I do agree though. My emulator relies on little endian

1587991752
Xavi92
fengb: many protocols and file formats do. Status quo would require handling these situations manually (at compile-time in the best case) while that's something the compiler could handle easily

1587992004
fengb
Sorry it was endian aware ints:

1587992247
ikskuh
endian aware ints would have solved this though

1587992276
ikskuh
but i'm with andrew here: It would make the language harder and probably also less efficient in the end

1587992281
ikskuh
even though it means to write more code

1587992326
Xavi92
ikskuh: I don't think efficiency is related here if we're dealing with a packed struct

1587992351
ikskuh
my point is: why should a packed struct have endianess?

1587992353
Xavi92
Run time performance (considering run time values are being used e.g.: read from a file) should be the same

1587992360
ikskuh
it doesn't make sense to me to have a

1587992367
ikskuh
an

1587992385
ikskuh
no, runtime perf would require byte swaps

1587992393
fengb
But they do... packed structs are memory guaranteed representations so by definition they need to be endian aware

1587992408
ikskuh
nah

1587992420
ikskuh
endianess is relevant when you access cross-system things

1587992421
Xavi92
ikskuh: then you need "le" and "be" for all struct members all over the place

1587992440
ikskuh
for packing stuff in memory i don't require endianess

1587992454
Xavi92
ikskuh: what about file formats or protocols?

1587992458
ikskuh
serializer.

1587992467
alexnask
You could conceivably have a struct with fields of different endianness

1587992468
ikskuh
it's tempting to use something like packed structs for this

1587992472
alexnask
packed struct*

1587992475
ikskuh
what alexnask says

1587992488
ikskuh
and (for example) using bit fields or similar to represent system elements is useful to always have in native endian

1587992491
ikskuh
but for protocols:

1587992508
ikskuh
packed struct { hdr: u32 (be), payload: u32 (le), };

1587992519
alexnask
I'm not opposed to the endianness aware integers personally but it has been ruled out so..

1587992521
fengb
Packed struct isn’t just for packing into memory. It’s to let us have full control of memory

1587992544
ikskuh
it's still required to have endianess per field then

1587992546
ikskuh
not per struct

1587992585
fengb
But also the order has meaning too

1587992591
fengb
Endianness on everything!

1587992629
daurnimator
bit-endianess matters too

1587992632
ikskuh
yeah, still

1587992633
alexnask
:D

1587992639
ikskuh
daurnimator: yep

1587992641
daurnimator
and gotta love those mixed endian formats

1587992647
ikskuh
mittle-endian!

1587992659
ikskuh
0132

1587992673
ikskuh
for me, the use case of packed structs is memory mapped i/o, not serialization/deserialization

1587992913
daurnimator
middle endian formats are all around us

1587992932
Xavi92
ikskuh: serialization/deserialization must be less efficient than packed structs

1587992935
daurnimator
uris.... american dates..... a couple of audio formats

1587992939
daurnimator
yeah they're not that common

1587992959
ikskuh
Xavi92: why *must*?

1587993016
Xavi92
ikskuh: it requires an external library with a given overhead and runtime performance. Why should it be faster than byte swapping?

1587993024
ikskuh
using something like readIntLittle() is a no-op on mipsel, but a bswap on mips

1587993047
ikskuh
because you think

1587993080
alexnask
daurnimator, how are uris middle endian?

1587993105
ikskuh
dns is bottom-to-top, path is top-to-bottom

1587993118
daurnimator
^

1587993118
ikskuh


1587993128
alexnask
huh, good point

1587993130
daurnimator
so are postal addresse in the US

1587993133
ikskuh
www is part of server is part of tld whereas root is parent of sub is parent of more-sub

1587993205
daurnimator
US front of postal envelope: Name; Street Number, Street; Apartment Number; City; State; Country; ZIP code

1587993233
fengb
Zip then country but yeah

1587993238
Xavi92
ikskuh: anyway, I wouldn't oppose to use a good serializer/deserializer library in Zig

1587993284
daurnimator
fengb: oh? I usually see ZIP last

1587993310
ikskuh
Xavi92: look here please:

1587993431
ikskuh
same code will be emitted for your proposal of packed structs

1587993449
fengb
No the country is optional. And if it exists, it’s on the 4th line while Zip is last one on the 3rd

1587993536
daurnimator
fengb: random sample from image search:

1587993570
fengb
I’ve... never seen that format before

1587993571
alexnask
Hah I love U.S.A. with dots, rare to see

1587993623
fengb


1587993649
daurnimator
fengb: yeah I'm seeing results both ways

1587993664
alexnask
Let's just make an OCR and a scraper to settle this /s

1587994287
fengb
Well the US post office will go bankrupt soon so we can start from scratch!

1587996447
Xavi92
ikskuh: sorry, was afk

1587996465
Xavi92
ikskuh: the deserializer library looks cool

1587996615
cren
Hey all. I'm learning Zig. What's the accepted way to do what in other languages would be done by a for-loop over a range of numbers (like `for (int i=0; i < n; i++)` in C)? I was assuming a while loop but I want to make sure.

1587996640
betawaffle
probably a for loop

1587996654
ikskuh
iit's the while loop

1587996658
betawaffle
oh right

1587996661
alexnask
var i: usize = 0; while(i < n) : (i += 1) { ... }

1587996666
ikskuh
var i : usize = 0; while(i < limit) : (i += 1) { }

1587996690
cren
why is `i` type `usize`?

1587996708
cren
oh wait

1587996709
cren
I get it

1587996710
cren
nvm

1587996815
cren
actually, no, I don't get it. Why is `i` type `usize`? Why not just use `u8` or something?

1587996821
fengb
usize is most "natural" for indexing into an array, but you can use any size you want: u8, u32, u64, etc.

1587996890
fengb
usize == ptrsize. It's what the CPU uses under the covers for dealing with memory

1587996936
fengb
But you can choose any size that's large enough and it should be fine

1587996941
cren
does that mean that the size of `usize` varies with CPU architecture?

1587996945
fengb
Yes

1587996955
ikskuh
i still think we should split up usize into two types…

1587996984
ikskuh
i wonder if i should make a proposal for that…

1587996994
ikskuh
especially when we now leave the lands of llvm code gen

1587996999
TheLemonMan
two types?

1587997005
Snektron
In which two

1587997007
fengb
What, like reg size and ptr size for Z80?

1587997022
Snektron
Those are equal

1587997026
ikskuh
usize → size of the largest adressable object

1587997031
ikskuh
uptr → size of a pointer

1587997046
ikskuh
Snektron: ptr on z80 is 16 bit, reg is 8 bit

1587997050
ikskuh
but:

1587997053
Xavi92
usize (as size_t in C) is what should be used in loops and array indeces to avoid potential problems

1587997054
fengb
Not exactly... u8 is more "natural" in Z80

1587997067
ikskuh
ptr on AVR is 24 bit, largest object is 16 bit and register is 8 bit

1587997075
Snektron
The bus is 8 bit afaik

1587997077
ikskuh
Xavi92: size_t is not usize!

1587997101
Xavi92
ikskuh: what is it then?

1587997106
ikskuh
uintptr_t

1587997122
ikskuh
both AVR-GCC and LLVM fuck up AVR adressing

1587997128
ikskuh
because you have three memory spaces

1587997150
ikskuh
two of which are 16 bit large (which is the pointer size used in LLVM/AVR-GCC) and one which is 24 bit

1587997159
Snektron
<ikskuh "ptr on AVR is 24 bit, largest ob"> Maybe this should be combined with other far-ptr mechanics

1587997168
ikskuh
it isn't a far ptr

1587997179
ikskuh
you cannot have a pointer to data in flash behind 64k border in AVR-GCC

1587997186
TheLemonMan
well you have addressspace() there

1587997187
ikskuh
same goes for functions

1587997209
ikskuh
even if you have functions in the space beyond 64k, AVR-GCC will insert a shim

1587997215
ikskuh
that just does a jump to the actual address

1587997224
TheLemonMan
having three pointer different types for each space makes little or no sense

1587997237
ikskuh
TheLemonMan: yeah, i know that we have addressspace()

1587997242
fengb
How do you index beyond 64k? Is there a separate instruction for load high?

1587997258
ikskuh
i just want that we change the definition from usize to actually match the definition of size_t, not intptr_t

1587997320
TheLemonMan
but then the usize <- ptrtoint mapping falls apart

1587997380
ikskuh


1587997386
ikskuh
fengb: search for z-pointer

1587997390
TheLemonMan
we could always add a platform-dependent size_t-alike definition

1587997415
TheLemonMan
but I don't see that replacing usize/isize

1587997455
ikskuh
then we have to note that you cannot safely store a pointer in usize

1587997467
ikskuh
or better: you can express invalid pointer offsets in usize

1587997473
ikskuh
that's the correct thing to say

1587997505
ikskuh
but usize is then 24 bit on AVR, because i should be able to store a function pointer address in there (which is: a pointer)

1587997507
fengb
Ah neat

1587997515
Xavi92
ikskuh: a diagnostic message would be useful. I'd have used usize without knowing it's not good practice

1587997553
ikskuh
TheLemonMan: same for 8086. (far) pointer size is 32 bit, but i cannot have objects larger than 16 bit

1587997567
ikskuh
Xavi92: zig does not have diagnostic messages and that's a good thing

1587997585
ikskuh
my point is that we should change the definition of usize to match its current use

1587997655
TheLemonMan
sure thing, I agree that usize should be big enough to be useful for all the possible address spaces on AVR

1587997682
Xavi92
ikskuh: then how would I know usize is not a good type for array indexing/pointer offsets?

1587997701
ikskuh
it is. but it depends if you can store a pointer in ther

1587997717
ikskuh
TheLemonMan: are you aware of an issue for that? or should i create one with a nice writeup?

1587997763
TheLemonMan
go ahead, there's been little interest on Zig-on-LLVM

1587997803
TheLemonMan
eh, Zig-on-AVR

1587997856
alexnask
@TheLemonMan, Im just checking if the prototype is an extern function (body is null), is there a better way to do it?

1587997895
Xavi92
TheLemonMan: Zig-on-AVR would be great

1587997932
TheLemonMan
alexnask, is_extern in the fn proto is the canonical source of truth

1587997975
TheLemonMan
Xavi92, it already (sort-of) works, see

1587998040
alexnask
Okay, I will switch to using the ast node, I just saw some other code that checked the body of the entry but it isn't necessary in this case.

1587998621
dimenus
andrewrk: I think I have my bug narrowed down from the other day on my PiOS. It looks like pointer addresses are not calculated correctly in a debug build of a flat binary

1587998679
dimenus
eg the kernel in the raspi is loaded at 0x80000, but the .ptr of a slice points to an address below that

1587998683
dimenus
only happens in debug build

1587998799
TheLemonMan
debug build of a flat binary?

1587998865
dimenus
sorry, compiling with default release options

1587998869
dimenus
and loading into qemu

1587998917
dimenus
repo is here:

1587998946
dimenus
`zig build qemu -Drelease-safe -Dbin` produces the correct results

1587998954
dimenus
`zig build qemu -Dbin` does not

1587999060
dimenus
if you remove `-Dbin` and run the elf, both are correct

1587999427
dimenus
nevermind, it's my stack pointer in the assembly

1588000145
ikskuh
okay, made a proposal for the usize thingy:

1588000639
Xavi92
ikskuh: I agree with it

1588000875
fengb
We also support 18bit architectures :P

1588000924
layneson
what is the correct method for changing the install location/path prefix in build.zig? setInstallPrefix is not supposed to be used, but resolveInstallPrefix either installs things to zig-cache or involves install_prefix (which we aren't supposed to set)

1588001065
ikskuh
TheLemonMan: i added my response to the original proposal as pro/con discussion

1588001163
TheLemonMan
ikskuh, so on AVR you'd define usize = u16 and uptr (or upointer or whatever) = u24 ?

1588001170
ikskuh
yep

1588001248
TheLemonMan
cool, I agree with the proposal as well

1588001255
ikskuh
👍

1588001261
Xavi92
Have to go. See you!

1588001267
ikskuh
also, using upointer/usize makes more clear what the integer represents :)

1588001288
layneson
oh nevermind, found --prefix

1588001324
TheLemonMan
I'd add one more constraint to be extremely pedantic, usize <= upointer

1588001389
ikskuh
i think that's actually intrinsic

1588001407
ikskuh
because you cannot have larger objects than number of bytes :D

1588001422
ikskuh


1588001464
TheLemonMan
yeah but when writing a spec you want to be extra precise

1588001491
TheLemonMan
that means you can safely add upointers and usizes

1588001506
TheLemonMan
and the pointer arithmetic is sound

1588001658
TheLemonMan
last time I checked the stdlib made a lot of assumptions about usize, namely that it's somehow related to the registers size

1588001671
TheLemonMan
that was a major hurdle when trying to port it to the x32 ABI

1588001737
ikskuh
yeah i can imagine that

1588001744
ikskuh
maybe add something like uregister as well?

1588001753
ikskuh
a type that can safely be stored in a single register

1588001780
ikskuh
don't know though, sounds dangerous to me (as 8 bit is really not that much)

1588001824
TheLemonMan
maybe that's stuff for std.builtin.types.register or something like that

1588001853
ikskuh
yeah

1588002184
fengb
Well... register is a bit ambiguous too >_>

1588002295
ikskuh
yeah, true

1588002925
fengb
Let's call it a "word". Not confusing at all 🙃

1588003110
ikskuh
oh yeah ♥

1588003113
ikskuh
let's do all the words

1588003185
TheLemonMan
{,d,q}word

1588003202
alexnask
word, dword then eventually stop making sense entirely by making dword32 and dword64 independent from the word size

1588003245
fengb
oword?

1588003251
ikskuh
hword!

1588003260
ikskuh
which is 4 bit on z80

1588003292
fengb
I've been calling that a nibble

1588003343
TheLemonMan
SPARC assembler also supports ... nword

1588003353
fengb
lol

1588003392
pixelherodev
Music-style

1588003399
pixelherodev
Quarter-word, eighth-word, sixteenth-word

1588003402
pixelherodev
(Half a bit!)

1588003404
ikskuh
fengb, yeah nibble is the right term for 4 bit

1588003422
ikskuh
byte is actually also defined as smallest machine unit (at least to an ancient IBM handbook which defined the word)

1588003437
ikskuh
and octet is the correct thing for 8 bit integer :D

1588003451
fengb
Wait, so byte didn't necessarily mean 8 bits?

1588003457
pixelherodev
It does

1588003538
ikskuh
yep, it does

1588003550
ikskuh
but no, it wasn't 8 bit, there were also machines that had 6 bit wide bytes

1588003557
ikskuh
i think the original def even had something more weird :D

1588003562
alexnask
5 bit is the best system

1588003686
ikskuh
19!

1588003738
fengb
If we can't represent PDP7, what chance to we have to kill C?

1588004029
alexnask
Also, no bi-quinary :(

1588004197
pixelherodev
Obviously we need to be able to represent

1588004209
pixelherodev
Not just

1588004215
pixelherodev
Okay there's definitely a better name for those

1588004216
pixelherodev
trines?

1588004244
pixelherodev
Okay but now I'm seriously tempted to write an emulator for a CPU using trines

1588004248
fengb
True, False, FileNotFound

1588004274
alexnask
0, 1, 2 or 0, 1/2, 1?

1588004284
pixelherodev
Former, probably

1588004296
companion_cube
didn't USSR people have ternary computers at some point?

1588004333
ifreund
why

1588004336
fengb
It's more natural as -1, 0, 1 from a physical standpoint

1588004356
fengb
Negative voltage is a lot easier to detect than half voltage

1588004362
alexnask
Huh, seems like they made Setun (ternary computer) in 1958

1588004412
fengb
-5V, 0, 5V is a simpler construct than 0, 5V, 10V. Not sure it's worth it though since it's still much harder than simple 0 -> 5V

1588004413
alexnask
@fengb, Right I'm just talking about what the trines represent :D

1588004436
fengb
We should use phase offsets instead

1588004482
pixelherodev
huh

1588004485
pixelherodev
"he first modern, electronic ternary computer, Setun, was built in 1958 in the Soviet Union at the Moscow State University by Nikolay Brusentsov,[4][5] and it had notable advantages over the binary computers that eventually replaced it, such as lower electricity consumption and lower production cost.[4]"

1588004490
pixelherodev
s/he/The

1588004632
pixelherodev
Okay so I know what project seven of Lightzing will be

1588004637
pixelherodev
Balanced ternary emulator :P

1588004703
pixelherodev
Oh wow

1588004714
pixelherodev
Samsung is funding development of an unbalanced ternary system in South Korea, apparently

1588004760
alexnask
lol

1588004780
ikskuh
<pixelherodev> Not just

1588004792
ikskuh
someone built a logic gate based on three-bit floating point arithmetic

1588004793
alexnask
what about trips?

1588004811
fengb
twits?

1588004825
alexnask
triads

1588004835
pixelherodev
Trees

1588004848
pixelherodev
I do like "twits" as a descriptor though

1588004971
pixelherodev
Ugh, apparently trits is the commonly used one

1588004974
pixelherodev
"Trinary units"

1588005018
alexnask
booo

1588005031
pixelherodev
I'm calling them twits in my VM.

1588005049
fengb
I also see ternary. So... ternits?

1588005277
ifreund
why not tits

1588005319
ikskuh
because those are birds

1588005385
ifreund
but those birds are rodents

1588005552
ikskuh
Don't you like southern black tits? (

1588005579
fengb
Mmmm hmmm

1588005590
fengb
Oh wait, birds?

1588005727
pixelherodev
Mines?

1588005731
pixelherodev
(Misleading names)

1588005931
ifreund
ah i meant the titmouse which is the best tit

1588008291
cren
Hello. I'm learning Zig. Is there a way to pass an array of an unknown number of items to a function? I mean what you would do in C by passing a pointer to the first element of the array

1588008314
ifreund
cren: you want a slice most likely

1588008334
ifreund
(which is a pointer + a length internally)

1588008338
pixelherodev
Slice == array imp'd

1588008342
pixelherodev
:P

1588008380
cren
that sounds about right

1588008383
cren
let me look at the docs

1588008399
alexnask
[]T <- slice, []const T <- const slice

1588008463
ifreund
and a pointer to an array coerces to a slice

1588008477
pixelherodev
Not going to explain what a []align(rand()) linksection(".totallylegit") T is?

1588008479
pixelherodev
;)

1588008647
alexnask
You need a phd to understand all array types in zig /s

1588008705
andrewrk
cren, a pointer to unknown number of items is: [*]T

1588008720
andrewrk
pointer to runtime known number of items is: []T

1588008982
pixelherodev
alexnask, or a *phd*... eh? eh?

1588008999
alexnask
[*:p]align(h) d

1588009078
pixelherodev
I meant pixelherodev == phd ;)

1588009115
alexnask
lol

1588009135
foobles
ok so rust has rustic, python has pythonic,

1588009138
foobles
ziggish?

1588009219
pixelherodev
ziggy?

1588009233
companion_cube
ziggity

1588009239
foobles
nice

1588009311
pixelherodev
Z'ur'gah

1588009322
pixelherodev
You're not using enough hyphens/apostrophes :P

1588009335
pixelherodev
Z'gt'y

1588009346
pixelherodev
s/g/g-/

1588009462
TheLemonMan
zigalicious

1588009496
alexnask
zidiomatic

1588009618
pixelherodev
zigiomatic?

1588009627
pixelherodev
Zigantic

1588009765
sanaris
Guys, what are your thoughts on Vlang? Sounds like the claims are little exaggerated

1588009785
companion_cube
ever so slightly

1588009798
sanaris
Also I compiled their language with itself and it doesnt equal to itself

1588009810
sanaris
the binaries differ somoehow

1588009894
sanaris
I opened the binary codes and the codes are changing like "8C" -> "8D"

1588009930
fengb
But it compiles itself in <1s!

1588009955
companion_cube
but it delegates all the compilation work to clang in <1s !

1588009959
sanaris
well people write quines in any language, doesn't make it a language

1588009996
sanaris
The binaries look ridiculous!

1588010017
sanaris
There is just graveyards of data which is not used anyhow

1588010024
foobles
i heard they recently started using an AST

1588010032
foobles
idk what in the world was used before

1588010040
foobles
might be a rumour tho

1588010169
andy_bainbridge
Hi guys. Any idea why the docs for std.mem.copy() say "dest.ptr must be <= src.ptr"?

1588010236
fengb
Implementation detail. It iterates in one direction and will start clobbering data if there's bad overlap

1588010257
fengb
There's a separate copyBackwards if you need to enable overlaps in the reverse direction

1588010273
andrewrk
do we have a mem copy that doesn't have that requirement yet?

1588010303
fengb
We could probably detect overlap and pick one of them

1588010311
andrewrk
std.mem.copyBackwards I suppose

1588010319
andy_bainbridge
So "dest.ptr must be <= src.ptr" is only true if there's an overlap?

1588010327
fengb
I thought there was a PR to merge the two

1588010356
andrewrk
andy_bainbridge, yes I think those docs are wrong

1588010369
andrewrk
andy_bainbridge, since copying bytes is so common, there is a benefit to knowing if you can supply additional constraints, such as non aliasing or conditional aliasing as you noted

1588010377
andrewrk
there's an issue open for this, these functions are not in their final form

1588010387
andy_bainbridge
OK, cool.

1588010400
andrewrk
here it is

1588010409
shakesoda
my zig vulkan rendering adventure has gotten up to "i have all the basics except textures"

1588010441
shakesoda
once i've got those i can start shaping this into the needs of my actual render api

1588010463
andrewrk
andy_bainbridge, the only reason this isn't already fixed is that I want to make sure std.mem.copy continues to work in comptime code

1588010497
andrewrk
oh! the lazy values mechanism provides a solution to this

1588010501
shakesoda
andrewrk: zig-vulkan-triangle was very, very helpful for getting started with

1588010528
andrewrk
you can thank vulkan-tutorial.com for that. All I did is port it to zig

1588010543
sanaris
Why are people so obsessed with things being immutable everywhere

1588010564
shakesoda
immutable data flows simpler

1588010585
andrewrk
shakesoda, btw I'm planning to add SPIR-V support to the self-hosted backend, so that project would not need a dependency on glslc :)

1588010625
andrewrk
lritter of Scopes has already pioneered this and I am following his lead

1588010629
shakesoda
shaders in zig...

1588010665
shakesoda
mind blown

1588010674
fengb
Wow

1588010686
Nypsie
So you write the glsl inside Zig itself and during compilation it will be compiled to SPIR-V?

1588010709
andrewrk
yes

1588010732
Nypsie
Oooh that's sweeeeet, I might rewrite my engine from Go to Zig soon then

1588010816
shakesoda
how will that work for dealing with the shader-isms (uniform blocks, samplers etc)

1588010885
andrewrk
this is the same question as how to deal with memory allocation in wasm and a few other things. probably the answer will be architecture-specific builtins

1588010913
shakesoda
makes sense

1588010927
andrewrk
unless there is some kind of ABI, in which case zig can already model it

1588010962
andrewrk
lots of questions there, and I have

1588011013
TheLemonMan
speaking of builtins, what do you think of hiding them all into some struct such as std.builtin.<sumthing> ?

1588011081
shakesoda
i've got a lot of experience in graphics (this is my day job) although i know little about things like spir-v abi

1588011099
andrewrk
TheLemonMan, I'm open to this idea, but what does that accomplish?

1588011112
shakesoda
i've had moving things to vulkan on my list for a while, since the writing is on the wall for opengl

1588011199
pixelherodev
OpenGL over Vulkan will probably be around for as long as Vulkan is

1588011205
pixelherodev
But that's probably smart

1588011251
TheLemonMan
andrewrk, less clutter, the builtins list is quite long and includes useful type-level functions (@as, @ptrCast, ...), low-level intrinsics (@intToPtr, @ptrToInt, ...) and hopefully-hardware-accelerated-ops (@sin, @cos, ...). I'd say we tidy up this by moving the last category into a neat namespace and lighten the builtins list

1588011383
andrewrk
I do want to note that while some builtins have function semantics, some have entirely different semantics. For example @field and @bitCast participate in result location semantics, and @cImport evaluates an expression in a special way

1588011416
andrewrk
I think it would be nice to evaluate this proposal closer to the end of language stabilization, when the list of builtins is otherwise complete or near complete

1588011442
andrewrk
currently builtins are a really nice tool for iterating on the language, since they allow arbitrary semantics without deciding on a particular syntax

1588011453
andrewrk
e.g. maybe @Vector will gain syntax for specifying vector types

1588011489
shakesoda
pixelherodev: i'm also interested in the efficiency gains

1588011501
shakesoda
opengl over vulkan isn't mature enough anyways

1588011526
shakesoda
besides, native opengl drivers are really cursed, and this is an opportunity to rid myself of the curse

1588011528
pixelherodev
True

1588011543
pixelherodev
Well, Intel's OpenGL drivers are good

1588011547
shakesoda
no, uh

1588011547
TheLemonMan
neither @field nor @bitCast nor @cImport are affected

1588011548
pixelherodev
Intel Iris driver == <3

1588011556
shakesoda
all opengl drivers are differently bad

1588011577
pixelherodev
Name one problem with Iris

1588011593
shakesoda
atomics are really sketchy in compute on there

1588011611
TheLemonMan
a lot of LLVM-specific intrinsics can be easily inserted (like Rust does

1588011617
shakesoda
had a hell of a time with my lighting system on there because it's quirky

1588011647
pixelherodev
With Iris? Not with i965?

1588011648
pixelherodev
HUh

1588011653
pixelherodev
s/U/u

1588011671
shakesoda
oh, yeah, i was using i965 and thinking about the iris gpus

1588011686
shakesoda
but this might be resolved by now, unsure. over on windows and mac things are unendingly cursed too though

1588011687
pixelherodev
I'm talking about the driver, not the GPU

1588011692
pixelherodev
It's Intel's fault for the naming though :P

1588011711
shakesoda
i have no freaking clue how some of the horrifying things that happen can happen in the crash logs i get

1588011722
pixelherodev
Oh wait

1588011727
pixelherodev
Run

1588011730
pixelherodev
It's

1588011738
pixelherodev
Memory errors galore!

1588011739
foobles
crazy idea: i want my own IrInstGen object to contain a new basic block with some number of instructions, which i will then render when I render my own instruction

1588011740
shakesoda
yeah i965 is really bad about that too

1588011760
shakesoda
i have a valgrind config with so very many things ignored in driver land

1588011769
foobles
what if i temporarily swap out the ira's current_basic_block, run analysis so that it puts instructions into my own struct, and then switch it back

1588011771
pixelherodev
You can do that???

1588011774
pixelherodev
shakesoda, link me

1588011822
shakesoda
hmmm, i don't have it on git

1588011825
shakesoda
i'd have to go digging

1588011825
andrewrk
TheLemonMan, can you do a proposal issue? it's definitely worth considering

1588011837
shakesoda
but yes, you can ignore sources of things

1588011856
TheLemonMan
sure thing, I'll write it tomorrow

1588011862
ifreund
shouldn't it be just build.thing not std.builtin.thing?

1588011869
ifreund
*builtin

1588011893
shakesoda
pixelherodev: look up valgrind suppressions

1588011937
TheLemonMan
ifreund, bare @import("builtin") was deprecated in favour of std.builtin

1588011954
pixelherodev
shakesoda, right thanks

1588011983
ifreund
TheLemonMan: all clear, I'll assume there was good reasoning behind that

1588011993
pixelherodev
Probably to limit the number of imports?

1588012004
pixelherodev
That is, you shouldn't be accessing it directly anyways

1588012021
pixelherodev
It's tightly linked to stdlib anyways

1588012025
shakesoda
i feel like it makes more sense in std

1588012099
TheLemonMan
the raw "builtin" struct is the one generated by the compiler, the std one contains the needed type defintions to complement it

1588012393
andrewrk
it's planned to have a "builtin" (maybe renamed) package as a compiler-provided dependency of every package, and it can have different values

1588012436
andrewrk
for example @import("builtin").mode might be .ReleaseFast for your "blake3" package and "std" package but .Debug for your main application

1588012464
andrewrk
there are a few things that need to be solved there since code currently uses std.debug.runtime_safety which would deal with this incorrectly

1588012783
pixelherodev
Isn't that overkill?

1588012794
pixelherodev
Ah wait, that's just an example

1588012803
mikdusan
that's basically like an additional IrExecutable, handing it a custom builtin to bootstrap with. of course we don't want it to recurse

1588012805
pixelherodev
I was thinking that if @optimizeFor can work on a per-module basis, that would be sufficient anyways

1588013129
GreaseMonkey
> [06:22:07] <pixelherodev> Run

1588013214
shakesoda
GreaseMonkey: performance aside, software gl isn't always viable

1588013223
shakesoda
limited feature set

1588013279
shakesoda
although that looks like it has improved a fair bit, judging by mesamatrix

1588013361
GreaseMonkey
software's been at 3.3 for a few years now

1588013563
shakesoda
yeah, and 3.3 is pretty retro now

1588013603
GreaseMonkey
it scares me to see that word attached to anything to do with any GL 3.x version

1588013608
mikdusan
I think `@` should just be

1588013627
shakesoda
compute hardware is ubiquitous these days and it's totally reasonable to rely on

1588013641
shakesoda
which puts the cutoff for modern at GL 4.3 and ES 3.1

1588013681
shakesoda
having compute available also fundamentally changes how you use the graphics api

1588013820
fengb
That’s a pretty stylish G

1588014120
pixelherodev
3.3 should

1588015216
sanaris
my ideal computer language would be LaTeX sadly it doesn't compile into anything outside of documents

1588015309
sanaris
It is so easy to screw up in mathematical languages, so I think the more dangerous language is, the better

1588015436
shakesoda
pixelherodev: it is though

1588015471
shakesoda
i mean, retro might be a bit far, but it doesn't reflect the way gpus are anymore.

1588015503
sanaris
I was learning Haskell and SL and neither of those was any close to C, simply because they either automatic or dynamic or just screw up with cost of operations

1588015552
shakesoda
consider also how old opengl 3.3 actually is (over a decade!)

1588015585
fengb
It's a false dichotomy between dangerous and Haskell

1588015621
fengb
Haskell just doesn't map to low level hardware well. But we can have something that's both low-level and safer

1588015623
sanaris
Also the thing with Haskell folks is they give you same simplicit examples which C++ folks were giving to C folks decade ago

1588015632
shakesoda
hardware capable of compute shaders has been shipping since then, too (slightly earlier)

1588015638
companion_cube
fengb: aka rust

1588015663
fengb
e.g. C pointers are "safer" than raw int accesses. But everyone agrees that's better than just making everying an int

1588015794
sanaris
Also somehow I see everywhere people blaming NULL value for something, which I don't understand what is has in common with language itself.

1588015820
fengb
Because it's easy to have a language construct to guard against nulls

1588015827
fengb
Zig has it. It works really well

1588015927
fengb
I'm pretty sure when writing Zig, I haven't had a hanging null reference yet. Whereas in C, I can't confidently say I've ever handled it correctly

1588016067
companion_cube
sanaris: null being an invalid but possible value of most types, is a source of bugs

1588016160
shakesoda
fengb: i've run into it a few times in zig... but not in pure zig code that isn't abusing ptrcasts

1588016182
shakesoda
the rules are of course totally off once you're doing that, or you're haphazardly throwing around pointers from c land

1588016229
sanaris
I am thinking of absolutely dangerous language, where bugs could be created with single typo, but giving infinite possibilities (and not being gold-language ofc)

1588016240
sanaris
golf*

1588016371
sanaris
Also I was thinking how much languages today are using non-alphabetic characters, it got to insane point. In the early ages people were blaming Lisp for being too reliant on )(

1588016560
shakesoda
perhaps terra language is interesting here

1588016636
sanaris
By just comparing how fast I can type, casual words are much faster then all special characters combinations used by languages

1588017105
fengb
Do you recommend Pascal's begin/end blocks? :P

1588017178
sanaris
nah too much characters, better stick to bs/be :)

1588017190
mikdusan
ok {}

1588017311
fengb
if / fi is the best

1588017334
companion_cube
if / end if;!

1588017352
fengb
esac

1588017355
sanaris
still 'end' looks cool, so it may end them all

1588017414
sanaris
I miss 'goto' it has something special inside

1588017426
sanaris
the spice melange

1588017432
shakesoda
i rather like lua's approach to all this

1588017441
shakesoda
and almost everything else

1588017442
ikskuh
shakesoda: everything ends!

1588018049
sammich
just curious, i saw someone say zig will reorder struct fields, is it possible to tell it to not? I've worked on stuff before that required particular struct orders

1588018055
sammich
i guess: s/will/can

1588018103
fengb
If you need explicit control of memory, you should use extern struct or packed struct

1588018162
sammich
Oh interesting, thank you!

1588018210
alexnask
If you just need to use the known offset to get a pointer to the struct from a pointer to a field you can use @fieldParentPtr

1588018228
sanaris
Laguages today are using too little from ideas of contexts and environments. For example I thing using Goto should switch environments correctly, not simply drop everything or limiting Goto to single block

1588018283
TheLemonMan
so..continuations?

1588021261
yrashk
wouldn't it be cool to have custom-packed structs? like struct packed(function-that-gets-struct-ast) { ... }

1588021395
ikskuh
yrashk: this sounds horrible, how should the compiler generate loads/stores for this?

1588023136
Snektron
It would be cool as you could implement different abi in userland

1588023155
Snektron
But the added language complexity is probably not worth it

1588023295
pixelherodev
Heh, Zig with Luaesque block syntax

1588023298
pixelherodev
That would certainly be interesting

1588023510
foobles
do/then .. end?

1588024083
dimenus
This is #offtopic, but do any of you guys use a 2k/4k monitor on linux?

1588024113
pixelherodev
...2k?

1588024121
pixelherodev
What's that in, you know

1588024124
pixelherodev
actual numbers?

1588024126
pixelherodev
and not marketing BS?

1588024129
fengb
AKA 1080p 🙃

1588024152
nephele
ah "full-hdmi"

1588024158
nephele
hd*

1588024160
dimenus
2560x1440 or 3840x2160

1588024171
dimenus
:)

1588024185
dimenus
I'm running HiDPI now and it's........fun on X

1588024286
pixelherodev
Try Wayland?

1588024298
pixelherodev
wlroots-based compositors support HiDPI AFAIK

1588024299
dimenus
sway is almost perfect, kwin is buggy

1588024337
pixelherodev
Neither of those facts shocks me :P

1588024398
nephele
does zig plan to implement dtls/tls itself?

1588025069
pixelherodev
... asBytes exists...

1588025078
pixelherodev
That makes life

1588025251
Kingsquee
If a target doesn't have simd, @Vector will be converted to scalar ops, right?

1588025259
pixelherodev
As I understand it, yes

1588025650
Kingsquee


1588025663
Kingsquee
not sure if I'm doing it right

1588025852
fengb


1588025861
fengb
There's the output for good old 386

1588025900
mikdusan
how about 6502 :P

1588025990
fengb
I didn't realize the Pentium 4 had SIMD

1588026012
fengb
Oh wait, I think those are MMX registers

1588026031
fengb
Nope... SSE

1588026045
fengb
How old is SSE? For some reason I thought that was pretty recent

1588026082
fengb
Anyway, LLVM seems to be pretty good at devectorizing. wasm32 has similar code

1588026150
Kingsquee
o boi

1588026171
Kingsquee
that assembly looks almost like pop song lyrics

1588026188
Kingsquee
nice rhythm to it

1588026195
pixelherodev
fengb, SSE is oldish

1588026199
pixelherodev
mandatory part of amd64

1588026211
pixelherodev
Every single amd64 CPU (plus some non-amd64 ones) has it

1588026232
fengb
Ah well, good thing we have 386 output

1588026273
mikdusan
we need more cpu features that shout. 3dnow!

1588026301
fengb
"Feb 23, 1999 - SSE vs 3DNow"

1588026304
fengb
... I feel so old

1588026316
fengb
Back in mah day, MMX was bleeding edge 🦖

1588026374
Kingsquee
tell us the story again granpa

1588026407
mikdusan
full story here:

1588026432
fengb
That looks so 90s

1588026521
Kingsquee
a rare glimpse into intel's engineering department

1588026564
Kingsquee
okay real talk

1588026577
fengb
"MMX is officially a meaningless initialism[6] trademarked by Intel"

1588026580
Kingsquee
how do I get fixedpoint numbers into this language

1588026581
fengb
My childhood is alie

1588026583
fengb
a lie

1588026587
mikdusan
today's commercial for 10nm+++++ would be a vinyl record... skipping

1588026656
fengb
The colors, the dancing, the retro 70s music

1588026672
fengb
I guess we're retroing the 90s now huh?

1588026678
fengb
... I feel so old

1588026710
fengb


1588026719
Kingsquee
yeah I know

1588026745
Kingsquee
but like do I just fork zig and chuck some llvm bindings et all to the C++

1588026766
Kingsquee
or are we working in the pure zig version already

1588026793
fengb
I think someone has added it in the userland before

1588026807
fengb
At least a fixed version of it... don't remember who

1588026822
Kingsquee
think I know who you're referring to

1588026829
Kingsquee
a GBA emulator or something

1588028556
Snektron
Michaël Larouche maybe?

1588028610
pilnik_
hi, i have a question about imports in zig

1588028644
Snektron
whats the question?

1588028646
BaroqueLarouche
Kingsquee:

1588028652
BaroqueLarouche
Kingsquee:

1588028652
BaroqueLarouche


1588028653
pilnik_
i've cloned the repo from the git but when i try to run the tests from one file i get "import of file outside package path"

1588028664
pilnik_
well from any file actually

1588028675
pilnik_
just wondering if there's something like a $ZIG_PATH that I should have set?

1588028676
BaroqueLarouche
Kingsquee:  This is how I emulated Fixed Point for my GBA SDK

1588028681
fengb
Oh right that other guy

1588028709
fengb
Which repo?

1588028731
fengb
The build.zig should have configured the imports

1588028736
pilnik_


1588028780
pilnik_
the zig lang repo, i didn't build zig though just installed the binaries

1588028797
fengb
Running test for any file in lib/std should work

1588028870
fengb
You’ll need to use override-lib-dir `zig test --override-lib-dir lib lib/std/file.zig`

1588029086
pilnik_
still get "error: import of file outside package path"

1588029212
pilnik_
oh right maybe that's because i'm trying for a file in a subdirectory, files in /lib/std do work now

1588029229
pilnik_
will keep looking into it thanks

1588029302
fengb
The ones in the nested directory are usually referenced via a top file: std/fmt/*.zig are pulled in via std/fmt.zig

1588029471
pilnik_
ah gotcha

1588029501
pilnik_
that worked :)

1588030103
foobles
hey, i was just talking to someone and he realized an issue in the C++ codebase

1588030154
foobles
all the constexpr ir_inst_id functions are marked as constexpr, but since they all require pointers to be called, it will NEVER be evaulated at compile time

1588030199
foobles


1588030207
foobles
this shows it not working at compile time

1588030314
foobles
this should just be a template function that you pass <T> into, instead of a bunch of parameter overloads

1588030320
foobles
and then overload the template

1588030755
foobles
also: which c++ features are allowed in general? I haven't seen any classes, or vectors, or iterators, or anything really

1588030759
foobles
ive seen a few templates

1588031806
fengb
Underscores in numbers is so nifty

