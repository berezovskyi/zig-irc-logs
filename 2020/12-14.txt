1607910634
daurnimator
:/ dns failure in tests again with 0.7.1 release. I thought we fixed that

1607910668
andrewrk
daurnimator, where do you see this?

1607910672
andrewrk
I see green checks

1607910686
daurnimator
running the packaging scripts for arch

1607910705
andrewrk
yeah your localhost patch is in there

1607911162
daurnimator


1607919814
cCCCCcccccCCc
ikskuh: As a follow-up, I had another break a bit ago and I was able to get everything going with your help. Thanks again!

1607920110
daurnimator
andrewrk: no more 0.7.0 section on download page?

1607920123
daurnimator
ah I see above you decided to replace it

1607920157
daurnimator
I guess checksums are still available from the json version of the page

1607923623
justin_smith
I'm trying to make a function that takes a string argument, when I have var foo "abc" and call f(foo.*) it says expected type '[*:0]u8' and got '[3:0]u8' - how do I fix the parameter declaration here?

1607923657
andrewrk
justin_smith, can you take a utf8-encoded string?

1607923666
andrewrk
if so, `[]const u8` is the type for you

1607923683
justin_smith
OK, thanks, trying

1607923772
justin_smith
andrewrk: cool, that solved it, I'm not sure how I would have figured it out without IRC though

1607923810
daurnimator
justin_smith: try and break down what the type means

1607923835
daurnimator
`[*:0]u8` = pointer to unknown number of u8s, but it ends in a 0.

1607923860
daurnimator
`[3:0]u8` = 3 u8s then a u8 that is 0.

1607923964
daurnimator
--> you could use `&` to turn your `[3:0]u8` into a `*[3:0]u8`. then you'd I guess need to know that "3" can coerce to "unknown number"

1607924002
daurnimator
alternatively, if you don't want an unknown number, you can use `[]u8` to say "a runtime-known number"

1607924034
daurnimator
you can also say e.g. `[:0]u8` to say "a runtime known number and there is a 0 afterwards"

1607924070
daurnimator
you'd need to consider the purpose and body of your function to know which of these you want....

1607924218
justin_smith
daurnimator: right, I started by declaring it as []u8, and then since I didn't have any examples of working string code handy, I was just trying various combinations of declarations and array / slice types to make the compiler happy

1607924278
justin_smith
it would be nice if I could use "" for an initializer, then use it as a []u8, what I want is an array of u8 with a known length

1607924342
justin_smith
I'm not trying to use C apis or anything, just match substrings from an input

1607927233
daurnimator
justin_smith: you can

1607927250
daurnimator
justin_smith: well; you can't use it as a []u8. but you can use it as a []const u8

1607928195
dch
there's no 0.7.1 download prebuilt tarball for FreeBSD x86_64, was this an oversight?

1607929330
dch
^ cc andrewrk when he wakes up again

1607929522
andrewrk
dch, still working on that tarball. should be up tomorrow

1607929537
andrewrk
same with macos

1607929584
dch
np. if there's anything I can help with, sing out. I pushed the lang/zig port up as it seems to work fine here, but obviously thats a build-from-src thing.

1607929607
dch
also, congrats! 0.7.1 is almost 75% of the way to 0.99.999999

1607929664
andrewrk
lol

1607929862
daurnimator
we doing metafont-style versioning? :)

1607929919
daurnimator
> The intervals between such maintenance periods are increasing, because the systems have been converging to an error-free state. The latest and best TeX is currently version 3.14159265 (and plain.tex is version 3.141592653); METAFONT is currently version 2.7182818 (and plain.mf is version 2.71). My last will and testament for TeX and METAFONT is that their version numbers ultimately become $\pi$ and

1607929921
daurnimator
$e$, respectively. At that point they will be completely error-free by definition.

1607930179
radgeRayden
lol

1607931083
dch
not sure if package management tools are ready to represent irrational numbers and fundamental universal constants as version numbgers yet

1607931101
dch
lmao

1607931865
semarie
I think such tools would need it only to be sure the package has reach the "bug free state". else it would be fine.

1607932346
dch
if only pkg managers reached a bug free state

1607932547
viashimo
when doing bit shifts, i keep ending up with the following formulation: "var one: u64 = 1; x = one << some_var;"

1607932580
viashimo
without doing this, the error is the the literal 1 doesn't have a comptime known width. is there are way to specify the width of an integer literal at comptime?

1607934222
daurnimator
viashimo: `@as(u64, 1) << some_var`

1607934461
viashimo
daurnimator: ok, thanks!

1607938572
kenran
I've got a learnopengl project started in Nim some weeks ago, and I looked at how andrewrk was doing it in his tetris example. I'm on NixOS, so I created a simple shell.nix that contains glfw3 and epoxy, and I could do `nix-shell --run 'zig build play'` and it would work. But now (I guess a couple of nix-channel updates later) I'm getting "C import failed" with 'epoxy/gl.h' file not found. Any idea what's

1607938578
kenran
happening maybe?

1607938581
kenran
I know it's a long shot...

1607938598
ikskuh
heya kenran

1607938655
kenran
hi :)

1607938864
ikskuh
not sure if i can help here, my nix experience is pretty shallow

1607938877
ikskuh
do you have a nix file created for the build environment?

1607938967
kenran
ikskuh: yeah, I'm using a zig version I downloaded a couple of weeks ago as well, and this is the shell.nix file:

1607939011
kenran
it basically provides only the glfw and epoxy libraries when entering the nix-shell environment. without that, the C imports fail in any case :)

1607939043
kenran
in there, I can do `zig build window` or something just fine, usually. I didn't check for two weeks or so, and now I'm getting the C import failure even in the nix shell

1607939068
ikskuh
weird

1607939068
kenran
it might not have to do anything with Zig itself though, I don't know enough about it

1607939552
kenran
ok, it's not just epoxy. that's just the first error. it cannot find glfw3.h any longer either. now it's definitely something with nix/my system

1607941855
kenran
I don't get it still. Trying out with a simple C++ example linking against -lglfw and including <GLFW/glfw3.h>, calling glfwInit() works in a `nix-shell -p gcc glfw3`, but I cannot get it to work for Zig anymore.

1607942410
jokoon
wow 220 users

1607942440
ikskuh
heya jokoon

1607942454
jokoon
how many users are using a 3D engine or doing gamedev?

1607942463
jokoon
I found an engine

1607942547
ikskuh
i'm writing a game engine, prime31 is also writing some advanced game stuff in zig

1607942555
jokoon
Curious if you can use zig to build console games

1607942566
jokoon
or android

1607942570
ikskuh
yes, you can do

1607942584
ikskuh
console was afaik done by BaroqueLarouche, android was done by me (at least the baby steps)

1607942609
ikskuh


1607942676
jokoon
I would guess zig doesn't have the same goal in terms of safety compared to rust, but it's still better than C++ or C

1607942699
jokoon
the didot engine seems quite advanced

1607942762
kenran
I think I got it now... in the tetris repo it was some weird combination of importing the seemingly wrong package (glfw vs glfw3), and then cDefining something, plus including pkg-config in the nix environment.

1607942775
kenran
AND ofc linking in the correct order.

1607942778
ikskuh
kenran: oof

1607942781
kenran
this is exhausting

1607942812
kenran
I'm trying to write a terminal emulator (for educational purposes). I've selected 3 languages to try out: Nim, Zig, and Common LISP.

1607942817
ikskuh
jokoon: no, zig doesn't try to guarantee most safety, but it tries to get very far without being in the way for the user

1607942826
ikskuh
kenran: if you only want to get an OpenGL window:

1607942838
ikskuh
problem: ZWL doesn't support text input yet, this is yet to be done :(

1607942873
kenran
Nim has a good package manager, is very fast as well and easy to learn, plus good C FFI. Zig has no package manager(? yet?), but has even easier C FFI, thus I could use freetype for font rendering (which Nim has no working bindings to atm).

1607942892
ikskuh
yeah, there is no package manager yet

1607942913
kenran
CL produces huge executables but is the most mature and best to work with imho, due to the REPL, and the awesome CFFI as well (lots of existing packages with good APIs).

1607942951
kenran
I think as long as I only use some C libraries, I don't have a need for a package manager, as I can just use nix, right?

1607942966
ikskuh
yeah, nix is a package manager :D

1607943011
kenran
ikskuh: I got the window and triangle examples weeks ago, but they were broken today. I still don't understand why they ever worked on this NixOS system, seeing what I had to do today to get them to work.

1607943384
jokoon
I left a comment, you're free to answer:

1607943483
ikskuh
> But zig seems to really the best of all of those, at least it's my favorite.

1607943485
ikskuh
that's nice to hear!

1607943721
jokoon
yup :)

1607943747
jokoon
any private interest working on zig?

1607943873
ikskuh
wdym?

1607943965
jokoon
I mean what kind of people are contributing to zig, what kind of work are they doing, what need do they have

1607943997
jokoon
Just interested in the philosophy of the language compared to rust for example

1607944001
ikskuh
ah

1607944008
ikskuh
have you read the zen of zig already?

1607944253
jokoon
no

1607944259
kenran
ikskuh: how do you cope when there's no package manager yet? Do you use git submodules for instance, or is there another mechanism?

1607944260
jokoon
you mean the fork?

1607944326
dutchie
kenran: submodules seem to be the main solution at the moment. i believe a package manager is planned for after stage2 is done

1607944338
ikskuh
jokoon: "zig zen" is a command that outputs the basic language philosphy

1607944339
dutchie
just vendoring code, in general

1607944347
dutchie
s/^/or/

1607944354
ikskuh


1607944361
ikskuh
kenran: i just use submodules

1607944382
earnestly
It's funny how there's people like me who balk at the thought of yet another language package manager, and others who literally cannot cope without one

1607944402
ikskuh
i don't really feel like zig actually needs one (at the moment)

1607944444
earnestly
Hopefully it won't

1607944520
earnestly
I often throw these new languages at a Makefile to see if it's sophisticated enough to build its objects and link things together as separate, trackable stages

1607944584
kenran
Yeah I do the same actually. I even use make for languages that have a package manager and/or build tooling because it often makes for a nicer "UI".

1607944614
earnestly
Well I'm not using it for the UI, that's often why people abuse Makefiles unfortunately

1607944619
ikskuh
"zig build" is pretty awesome though

1607944622
kenran
I'd be very fine with Zig just having a set of packages in nixpkgs, where, similar to how I use C libraries atm, I can just enter a nix-shell and then they're includable.

1607944629
ikskuh
doing the stuff i do in zig build with Makefiles would be horror

1607944634
kenran
Because I hate dealing with git submodules

1607944646
kenran
Not for the idea of it, but because they're quite unwieldy imho

1607944650
ikskuh
kenran: you can also just paste the whole library into your codebase and be done

1607944652
earnestly
ikskuh: That should be a hint

1607944656
earnestly
That it would be horrible

1607944729
ikskuh
hm?

1607944770
earnestly
That it would be horrible to transpant into something as simple as a Makefile should be a tell that something has gone wrong

1607944850
ikskuh
i think i don't understand

1607944962
earnestly
transplant*

1607944976
ifreund
I disagree, there's a reason most projects are moving to meson these days

1607944984
ifreund
*most non trivial projects

1607945007
ifreund
and the zig build system is similar in scope to meson

1607945190
earnestly
Yes, exactly

1607945275
ifreund
and for trivial projects you can call zig build-exe in a Makefile with no issue :D

1607945315
earnestly
ifreund: What's better: needing meson or not needing meson?

1607945411
ifreund
I feel like that's not the right question. Of couse you can do everything that meson can do in a Makefile, but depending on the use-case it may be far more complex to implement and to maintain

1607945434
earnestly
No you most certainly should /not/ be doing anything like that in a Makefile

1607945439
dominikh
I think his argument is that things shouldn't be complex and unless all you need is a trivial makefile, things have gone wrong

1607945444
ifreund
imo the extra dependency on meson more than pulls it's weight for non trivial projects

1607945467
ikskuh
dominikh: look at the build script for zig showdown :D

1607945467
ifreund
dominikh: that's a much more clear way of stating it :D

1607945474
earnestly
dominikh: Yes, it's a Wirthian attitude which I don't think people know about.  They also look at most Makefiles on the web and see how horrendous they are and believe that's what I'm refering to

1607945484
ikskuh
it's not a complex project, but as soon as you have some modular dependencies, hell breaks loose

1607945488
earnestly
ifreund: I like people to come to that conclusion naturally

1607945494
earnestly
ikskuh: Why?

1607945519
dominikh
FTR, I don't think I agree with it. Building things is hard, and if your makefile can be simple, it's solely because it's deferring to another build system (say zig build-exe)

1607945549
ikskuh
earnestly:

1607945567
ikskuh
12 packages, where some have C dependencies, but are only linked optionally

1607945583
ikskuh
support for 2 different platforms, 3 different renderers, with 2 ways to manage resources

1607945584
earnestly
ikskuh: That's straight forward to do with gnu make

1607945606
earnestly
Almost 500 lines for a build definition

1607945614
earnestly
400 sloc according to github

1607945620
ikskuh
stuff like "when i have pulseaudio, enable this"

1607945626
ikskuh
is not easy in gnu make either

1607945636
dominikh
500 lines in the language you're already working with, with all the logic clearly visible. Versus make's own syntax with its own quirks and magic

1607945643
ikskuh
↑

1607945653
ikskuh
and you quickly leave the path of compatible make files

1607945658
earnestly
I don't think any of you know what good makefiles look like and it may be terminal at this point

1607945660
ikskuh
ever tried writing a makefile that runs on two platforms?

1607945673
CommunistWolf
> good makefiles

1607945688
ikskuh
earnestly: there is no such thing as "good makefiles" for complex projects

1607945692
ikskuh
been there, done that

1607945693
ikskuh
i tried

1607945695
ikskuh
i tried hard

1607945731
ikskuh
but: as soon as the logic is too complex, having a imperative language is just the better option

1607945732
earnestly
Yeah sure, nevermind.  I think people are so caught up in the "makefile" thing that they're not really understanding; and I can almost guarantee that you've never seen a good makefile

1607945743
earnestly
Hence the general attitude I always get, which is so predictable

1607945747
earnestly
"Good makefile"

1607945750
earnestly
"No such thing"

1607945752
earnestly
etcv.

1607945758
ikskuh
please define what a "good makefile" looks like

1607945762
ikskuh
i've written a lot of makefiles

1607945763
dominikh
well, you haven't shown a good makefile for a real-world, complex project yet

1607945779
ikskuh
as soon as you need stuff like dependency tracking

1607945785
ikskuh
the makefile isn't good anymore

1607945791
earnestly
There's no point in this discussion

1607945811
ikskuh
earnestly: how do you do dependency tracking in your make files?

1607945814
earnestly
It misses the point

1607945818
ikskuh
if you don't ,it's not a good makefile

1607945822
ifreund
fwiw I get your point, I just have a slightly higher tolerance for software complexity than you do

1607945823
ikskuh
if you do, i want to know how

1607945824
earnestly
ikskuh: Like I said, there's no point in this discussion

1607945835
ikskuh
then i don#t get to learn how a good makefile looks

1607945836
ikskuh
well

1607945840
ikskuh
keep on your high stance

1607945842
ikskuh
and keep your secrets

1607945854
ikskuh
if you don't want to share the secret knowledge of good makefiles

1607945858
ikskuh
you'll never see them

1607945863
dominikh
ikskuh: you just haven't seen one!

1607945869
earnestly
Or read the manual

1607945876
ikskuh
i read the manual

1607945879
ikskuh
doh

1607945890
ikskuh
still, there's no nice way for proper dependeny tracking

1607945908
ifreund
the point is that you shouldn't need dependency tracking

1607945915
dominikh
just don't have dependencies

1607945924
dominikh
everything can be beautiful if you ignore the real world

1607945936
ikskuh
ifreund: it makes sense to check if i need to rebuild things that take hours to build :D

1607946006
earnestly
dominikh: (Ideally, don't ifdef)

1607946070
ikskuh
earnestly: how do you do different dependencies on different platforms then?

1607946080
ikskuh
i don't know a way except ifdef

1607946123
earnestly
ikskuh: By sharing a common internal api while striving to the most portable feature set.  An intersection of features rather than a union

1607946152
earnestly
There's an old paper called "ifdef considered harmful" which discusses some of this

1607946164
ikskuh
so

1607946172
ikskuh
how do i do it then?

1607946181
ikskuh
i write a library shim X

1607946194
ikskuh
X wraps pulseaudio for linux and wasapi for windows

1607946205
ikskuh
now i have to link to different implementations of X on windows, linux

1607946210
ikskuh
i now need ifdef in my makefile

1607946223
earnestly
Sigh

1607946230
ikskuh
yes, we're in the real world

1607946238
ikskuh
i now have the same interface (by using libsoundio)

1607946243
ikskuh
i don't need #ifdef in my code anymore

1607946249
ikskuh
but i now need the logic in the makefile

1607946263
dominikh
what is your intersection between the Linux kernel and the Windows kernel…

1607946267
ikskuh
(because i also need to link against libpulse on linux and wasapi on windows)

1607946281
dominikh
ikskuh: and someone needs to build libsoundio

1607946288
ikskuh
dominikh: i ignore that for now

1607946296
ikskuh
even without that i have the same problem

1607946299
ifreund
I'm sure the answer to that would be don't write cross-platform software

1607946309
ikskuh
↑ i think so, too

1607946310
ifreund
or rather write everything for posix only

1607946320
ikskuh
wouldn't support windows newer than XP

1607946324
ifreund
cross platform across linux/bsd/whatever is fine

1607946359
dominikh
plenty of nice APIs on Linux that the BSDs don't have

1607946365
ikskuh
even then, you cannot rely on makefiles :D

1607946367
ikskuh
dutchie: oh lol

1607946367
dominikh
thanks dutchie

1607946378
dominikh
it's a weird horse to die on

1607946394
dominikh
(does make still use mtimes to figure out what to rebuild? because that's tremendously flawed)

1607946396
ifreund
yeah, y'all should have your client show quit messages for people who have said something in the last 5 min

1607946396
ikskuh
so the solution to "how do you cope with the real world" is "don't"

1607946416
dominikh
ifreund: funny you would say that. mine does, and I still missed it in the frenzy of disagreeing with someone on the internet :P

1607946423
ikskuh
ifreund: i did, but i just mentally skip quit messages :D

1607946425
ifreund
heh

1607946433
ikskuh
dominikh: LOL same :D

1607946441
ikskuh
but i really wanted to know how they solve this

1607946452
ikskuh
because they said they know better than me, and i want to get better

1607946486
dominikh
odds are they don't solve it

1607946503
ifreund
at least not in a way that you would consider "solved"

1607946556
ikskuh
but to get a conclusion: zig build is way more portable than a "make" will ever be :D

1607946606
ikskuh
we only need dependency tracking for our self-written files now

1607946610
dutchie
yeah, and you don't have to learn another arcane syntax with non-portable implementations

1607946621
dutchie
what's that word lispers use to say that everything is the same shape

1607946633
dominikh
Personally, I think that both makefiles and zig build files are bad for most open source, and much prefer the Go model, with no arbitrary code executing at build time, and anything that doesn't fit into the build model needs to be generated and checked in. I only value the Zig model in highly custom, probably prorietary work, like games

1607946637
dutchie
homoiconicity!

1607946655
dutchie
sort of like that

1607946667
dominikh
bbl, dinner

1607946708
ikskuh
dominikh: i think doing some stuff in zig build isn't that bad. especially as you can encode most platform dependencies in a nice and configurable way

1607946770
ifreund
how do go projects add a build step to e.g. compile man pages and install them?

1607946798
ifreund
or are you supposed to check the compiled versions into git??

1607947972
dominikh
ifreund: check the compiled version in, or defer to another build system (like the linux distro package manager that builds man pages, anyway)

1607948015
ifreund
I'm using scdoc so I'd need to check them int

1607948040
ifreund
I really don't like checking the output of code generators/compilers into vcs

1607948059
dominikh
generally speaking, you can download a Go project, run `go build`, and it will build the proejct, without running custom code. if that's not good enough for your needs, you're screwed. some projects use e.g. Bazel instead

1607948079
dominikh
but I definitely do believe in checking in generated code. It means I don't need your generator to compile the project

1607948092
dominikh
and there won't be version drift in the generator, either

1607948141
dominikh
(I also can blindly build a project, outside a sandbox, and only have to worry about bugs in Go itself, not about exploits in your build script)

1607948164
ikskuh
the solution to version drifts in the generator is also checking in the generator into your repo

1607948170
ikskuh
and build it on the platform you use

1607948181
dominikh
plus my generator's dependencies, and…

1607948190
ikskuh
zig showdown for example converts assets via zig code

1607948197
ikskuh
if i check in the genereated files

1607948202
ikskuh
the repo gets 10 times the size

1607948221
radgeRayden
re: make, I've just rewritten mine that coordinates building several dependencies for a game into a doit python script and couldn't be happier about it

1607948223
dominikh
at any rate, Go's model works well for 95% of actual Go projects; the rest have to use a different build system. I'm sure Go's model would suck majorly for, say, a game and its asset pipelines

1607948250
dominikh
which sounds like what "zig showdown" is, too

1607948256
ikskuh
yeah :D

1607948262
dominikh
I don't actually know what that is

1607948278
ikskuh
for zig we need at least a convenient way to declare packages

1607948346
dominikh
I view programming languages and their tooling from two different perspectives: the "make sure junior devs can't ruin my day" perspective and the "I know what I'm doing, get out of my way" perspective. I can look at most people's Go code and not shoot myself; I definitely don't want to read most people's C code :P

1607948378
dominikh
if you only work with other experts, whoo. use a powerful language

1607948389
dominikh
if you don't, it's amazing when people can't fuck up majorly

1607948432
ikskuh
i think zig hits a sweet spot there

1607948440
ikskuh
the stuff is simple, and basically saf

1607948448
ikskuh
eif you want to shoot, you can do so,  but it will be visible

1607948467
dominikh
Somewhat. still plenty of ways to shoot yourself with vanilla-looking Zig

1607948480
dominikh
e.g. retaining a pointer to a stack variable when you shouldn't. boom.

1607948486
ifreund
yeah, zig is closer to C than Go by that mesasure

1607948491
ifreund
but it's also what I want

1607948516
dominikh
I mean, there's a reason I switched to Zig for my Wayland compositor, but will stick to Go for higher level tooling

1607948520
dominikh
way different needs

1607948539
ifreund
I'm doing AoC in go this year because it's at least partially productive if I use a language I've never used before

1607948547
ifreund
but go kinda annoys me

1607948575
dominikh
Go won't really let you swim against the current

1607948578
ifreund
especially the stupid Capitalize to make it public thing

1607948588
dominikh
^ one of my favourite features :P

1607948599
ifreund
I want my types capitalized so I can do func (point Point) Point {}

1607948625
dominikh
well, that receiver should probably be called p or pt instead

1607948654
dominikh
Go likes its 1-2 letter local variable names, so you rarely have conflicts like that

1607948665
ifreund
yeah that's pretty much what I've been doing

1607948682
ifreund
but I still think having types TitleCase is a huge win for readability

1607948684
dominikh
I'm already pleasantly surprised you didn't call it self :P

1607948694
ifreund
and go cant do that consistentl

1607948715
ifreund
also it doesn't seem to have immutability

1607948716
dominikh
looking at an identifier and knowing if it's exported or not is also a big win, though. different tradeoff

1607948726
ifreund
fair

1607948728
dominikh
it does not, no

1607948769
ifreund
that's probably a bigger blocker to me wanting to use it for larger projects tbh

1607948787
ifreund
error handling also makes me miss zig :/

1607948798
dominikh
because Go doesn't have try?

1607948801
ifreund
yeah

1607948818
dominikh
well, Zig still won't let me attach values to errors :P

1607948851
ifreund
I'm halfway convinced attaching values to errors isn't needed

1607948859
dominikh
I'm 100% convinced it is

1607948866
dominikh
unless you want to rely on out parameters

1607948884
ifreund
for what purpose? logging can be done where the error occured

1607948891
dominikh
an error "open failed" is utterly useless without knowing which path it concerns

1607948956
dominikh
and not just for the user's sake (and I disagree with logging where the error occured; that's too deep in the stack), but also the programmer for any sort of batch job

1607949060
dominikh
it also allows for nested errors, ideally. this big operation failed because some sub operation failed.

1607949130
ifreund
I'm not sure how this could be implemented cleanly without allocation or making returning errors very expensive

1607949192
dominikh
you probably can't do full Go-style errors without allocation, but the simpler form of one value per error would "only" need a errorset-specific union of possible values

1607949236
dominikh
and I still definitely want to know for what path the open syscall failed when the error bubbled up the stack

1607949538
ikskuh
i'm convinced we don't need error attachments

1607949545
ikskuh
especially not for the example you've shown

1607949615
ikskuh
FileNotFound is pretty much 100% precise which file was not found

1607949626
ikskuh
if you bubble it up when you open two files though, you lose information

1607949637
ikskuh
which means that your returned error code is bad

1607949661
dominikh
well, there is an infinite number of file names and only a finite set of error codes

1607949679
ikskuh
yes

1607949682
ikskuh
but

1607949689
ikskuh
there is a very finite number of files you open

1607949693
ikskuh
in a function invocation

1607949694
ikskuh
that is mostly 1

1607949697
ikskuh
like

1607949704
ikskuh
std.fs.cwd().openFile("foobar", .{})

1607949707
ikskuh
if that returns FileNotFound

1607949713
ikskuh
i don't have to ask

1607949772
dominikh
That's a very trivial example. Consider a more polymorphic use case. Maybe openFile determines the file to open via some computation

1607949785
dominikh
in which case, it needs to communicate to the caller which file it chose that failed to open

1607949994
leon-p
in that case, why not simple split it into two functions, chooseFile and openFile? Then when the FileNotFound error comes up the context calling openFile definitely knows which file was not found.

1607950081
dominikh
do you further want to split up the function if it needs to choose multiple files? have some sort of contiuation to pass in all the file names? you're also quickly going break abstractions.

1607950131
dominikh
*going to

1607950161
hexaflex
I found another compiler bug: #7442

1607950187
dominikh
at the end of the day, `main` should be the one doing logging. if something failed, it should have enough information to log how the action failed

1607950199
dominikh
and main doesn't know all the arguments for all the functions in the entire call stack

1607950221
dominikh
all other examples are just more specific variations of this.

1607950327
dominikh
if you really think we don't need error values, you may want to veto

1607950328
ikskuh
dominikh: in that case, it looks like the error reporting is non-trivial anyways

1607950471
hexaflex
Errors are not very useful without adequate context

1607950650
ikskuh
dominikh: your example in that proposal is a parser

1607950661
dominikh
(not my example)

1607950669
ikskuh
oh, sorry

1607950673
ikskuh
but even then:

1607950684
ikskuh
there are two kind of errors in programs

1607950701
ikskuh
zig errors are only one kind, and exceptions (what people use in other languages) are also of the same kind

1607950708
ikskuh
unexpected errors in the program flow

1607950713
ikskuh
the other kind is expected errors

1607950726
ikskuh
most programmers i know don't really distinct between them

1607950747
ikskuh
parsing some text is either expected to fail (user input) and not expected to fail (non-user input)

1607950793
dominikh
I find the notion of "unexpected errors" to be misleading. errors are always expected, they happen all the time. Zig already gets that right by

1607950798
ikskuh
zig errors are meant for the second use case

1607950819
dominikh
if I ask the kernel to open a file, I fully expect it to fail

1607950838
ikskuh
i think they should not be conflated

1607950847
ikskuh
because i don't need to report most failure conditions

1607950856
dominikh
(and if parsing cannot fail, it should be parsed at compile time)

1607950868
ikskuh
or even have more complex reporting than "oh no"

1607950880
ikskuh
what i mean is:

1607950886
ikskuh
when i expect a file to have a certain format

1607950904
ikskuh
"InvalidChar" and "Overflow" are the same error: InvalidFormat

1607950927
dominikh
But InvalidChar and Overflow subsume InvalidFormat. one is strictly more powerful than the other

1607950939
dominikh
you don't need the less capable kind of error if you have the more capable kind

1607950952
ikskuh
that's a question of philosophy

1607950983
dominikh
using InvalidFormat also assumes that the caller never cares to know about the actual error

1607951012
ikskuh
in most cases, that's true

1607951020
dominikh
my "philosophy" is probably strongly biased by Go and its notion of interfaces and behavior

1607951026
ikskuh
like "i want to load a 3D model"

1607951034
ikskuh
and i don't care if a number overflows

1607951039
ikskuh
or if a vertex is out of bounds

1607951046
ikskuh
the model is still broken and i cannot continue

1607951047
dominikh
which makes it very straightforward to have N errors that all identify as "invalid format (because ...)"

1607951066
ikskuh
when i'm writing a santizer for 3D models that's a different use case, but that requires very different data structures

1607951067
dominikh
if I want to load a 3D model and it doesn't, I really want to tell my user how the model is broken

1607951073
ikskuh
why?

1607951090
ikskuh
do you really wnat to say: "byte 34523424 in file C:\…\file.fbx is out of bounds"?

1607951097
ikskuh
do you really expect

1607951107
dominikh
because the user knows more. they may know why that error occured. maybe they just edited the model with their own tool

1607951133
dominikh
imagine if `ls foo/bar/baz` just said `error.`

1607951151
ikskuh
yeah

1607951158
hexaflex
Can somene help me understand how this is shadowing?

1607951159
fengb
Counterpoint: Zig already has some “defacto” error payloads in parsers that would be nicer if they had a standardized structure

1607951196
dominikh
hexaflex: the parameter name b is shadowing the function name b.

1607951197
ikskuh
hexaflex: "b" has two different meanings in "a": the function b() and the parameter "b"

1607951205
ikskuh
if you now use "b", which one is referenced?

1607951214
hexaflex
ah right. from a's perspective

1607951224
hexaflex
fair enough

1607951226
ikskuh
dominikh: i think this discussion is not really fruitful, we have a very different kind of philosophy there

1607951233
dominikh
ikskuh: agreed

1607951239
ikskuh
i quite never used the content exceptions in c#/java

1607951252
ikskuh
and mostly just printed ex.Message :D

1607951273
dominikh
read through my Go code if you want to see error values get used :P

1607951282
ikskuh
hehe

1607951349
fengb
Also dealing with unexpected errno

1607951350
fengb
There’s quite a few places where having a payload is useful

1607951355
dominikh
just don't show me

1607951395
dominikh
the error message wasn't good enough if I have to strace your program

1607951425
ikskuh
dominikh: the thing is: for whom do you build your programs?

1607951433
ikskuh
the people i write software for don't read error messages

1607951436
ikskuh
they just

1607951459
dominikh
I write programs for "hackers", people with roughly the same understanding of computers as me

1607951463
ikskuh
yeah

1607951467
ikskuh
that's very different :D

1607951472
dominikh
and I write programs the way I'd want them to be

1607951473
ifreund
they'd probably prefer an error trace then

1607951479
ikskuh
^=

1607951482
dominikh
I

1607951485
ikskuh
write the return trace to the log

1607951491
ikskuh
which you can enable/disbale

1607951500
ikskuh
but the normal user doesn't

1607951509
dominikh
I also hate error traces, tbh. I don't call about your call stack, I care that some file had the wrong permissions

1607951518
dominikh
*don't care

1607951554
dominikh
Python-style error "handling" is the worst. you hit ^C and it shows you a stacktrace because it got a sigint "exception"

1607951583
dutchie
`raise SystemExit`

1607951602
dominikh
there's still a distinction between a hacker

1607951607
fengb
Why is that bad? It shows you where it bailed out

1607951628
dominikh
because I don't care where it bailed out; I just wanted to kill the process. it doesn't have to tell me anything

1607951645
dominikh
it's not unexpected that the process got a sigint after I hit ^C

1607951673
dominikh
similarly, if it can't find a file, I don't care about where in the code opening that file failed. I wanna know the file name, that's the useful information to me as the user

1607951680
dominikh
not 30 lines of stack trace

1607951697
dominikh
stack traces are for programmers, error messages are for users

1607951732
dominikh
stack traces are for truly unexpected errors, like a segfault. expected errors don't need stack traces

1607967684
ikskuh
andrewrk: is there a reason the 0.7 release notes have vanished?

1607967692
ikskuh
a friend of mine searched for them

1607967698
ikskuh
as 0.7.1 are only diff to 0.7.0

1607967974
ifreund
ikskuh:

1607967979
ifreund
they just aren't link any more

1607968155
ikskuh
they should be linked from the 0.7.1 release notes

1607974203
leeward
hmm, I wonder if that hack in the linker script to drop "elf32-msp430" is why "info reg" in gdb showed me x86 register names.

1607974246
leeward
The thing it called eax was r0 though, which is amusing.

1607977325
leeward
If I have a comptime-known constant, is there a way to get it into an inline asm statement without going through a register?

1607977343
leeward
Other than literally writing its value in the string, that is.

1607977359
ikskuh
leeward: good question, i think you can use a fitting inline info

1607977408
ikskuh
i think using "i" is the right thing

1607977477
leeward
ikskuh: Can you elaborate?

1607977499
leeward
`: [number] "{i}" (my_constant)`?

1607977505
ikskuh
only "i", not "{i}"

1607977507
ikskuh
but yes

1607977544
leeward
trying

1607977680
leeward
Hey, it works!

1607977784
ikskuh
\o/

1607978531
g-w1
why does test-stage2 not tell me which test leaked memory, (or am I just not seeing it)

1607978879
g-w1
Just realized that I can tell from the stack trace of the zir_sema, but this would still be a nice feature to have

1607982952
g-w1
ok, this is the weirdest thing, I am getting those memory leaks shown to me when doing zig build test-stage2, but when I just try to build a test that is causing a memory leak using `./zig-cache/bin/zig build-exe test.zig` it does not show a leak? I have pushed the code to `g-w1/stage2-compile-log` if anyone wants to take a look.

1607983353
g-w1
*pushed to `g-w1/zig branch stage2-compile-log` on github

1607983394
marler8997
zig build test-stage2 doesn't just build an executable, it builds and runs tests

1607983520
pixelherodev
Finally made up my mind: going to work on an alternative compiler :)

1607983533
marler8997
pixelherdev, share more

1607984076
pixelherodev
marler8997: not much to say just yet

1607984082
pixelherodev
Still in the planning stage

1607984095
marler8997
what made you think to make an alternative compiler?

1607984140
pixelherodev
See backlog :P Mostly, stage1 == :( and stage2 is (IMO) overcomplicated

1607984189
marler8997
backlog as in the number of bugs/issues?

1607984219
pixelherodev
chat history :P

1607984303
marler8997
which day?

1607984336
pixelherodev
grep pixelherodev; should be one of the most recent commentsby me

1607984356
marler8997
not sure how to grep the logs...is there a way to download them?

1607984390
g-w1
around here

1607984394
pixelherodev
Ah, I'm used to weechat; I have them locally already :P

1607984415
marler8997
yeah I'm clicking through each day looking for "pixelherodev" on the web interface

1607984419
marler8997
so knowing the day would be helpful

1607984433
g-w1
dec 2

1607984469
marler8997
thanks g-w1

1607984699
marler8997
pixelherodev, you said you find CBE-ing stage 2 "kinda repulsive after more thinking about it"...what sort of things did you discover are repulsive about it?

1607984936
pixelherodev
Firstly, CBE is explicitly intended to produce binaries disguised as C source - which is one reason its input is ZIR, not Zig. This is akin to producing asm, then using a naive decompiler, and manually cleaning up the output. It's absolutely

1607984938
pixelherodev
to make its output easier to work with, which I don't agree with. Fundamentally, it means that we'll need to maintain two copies of an identical compiler in different languages.

1607985056
marler8997
pixelherodev, yes I recall the plan being a one-time generation to C, then maintaining both backends independently

1607985093
marler8997
I asked why we wouldn't just use the CBE as part of codegen, why would we maintain it independently but never got an answer

1607985100
pixelherodev
...?

1607985103
g-w1
is your backend going to be adopted by the zig project once it gains momentum?

1607985116
marler8997
...?

1607985125
fengb
Generated code isn’t considered maintained code

1607985125
pixelherodev
marler8997: the generated compiler would be stage1

1607985127
pixelherodev
Not a backend

1607985134
marler8997
yes

1607985148
fengb
Projects like Debian will not include raw generated code

1607985152
pixelherodev
It'd be maintained separately because we need a proper bootstrap compiler

1607985159
marler8997
right, I'm saying why

1607985161
pixelherodev
And generated code isn't remotely acceptable as such :P

1607985170
marler8997
right

1607985172
pixelherodev
Might as well use a binary.

1607985173
fengb
Ask Debian :P

1607985176
marler8997
right

1607985180
marler8997
so then why is that the plan?

1607985181
pixelherodev
I fully agree with debian on this

1607985214
pixelherodev
g-w1: Who knows? That's not my

1607985217
marler8997
I think my first statement was confusing, let me reword

1607985243
marler8997
I recal the plan to be that once CBE was working, we would perform a one-time generation to convert the compiler to C, then maintain that C compiler independently

1607985253
marler8997
to support bootstrap

1607985286
marler8997
but why would we do that?  Instead, why not keep the CBE unmodified?  Why do we need to maintain it?  If it has a problem, we should fix it in CBE correct?

1607985304
fengb
Because it’s a generated code base and not fit for real bootstrapping

1607985314
marler8997
fengb yes

1607985324
marler8997
but what about my question?

1607985338
marler8997
oh wait nvm

1607985346
pixelherodev
CBE != generated code

1607985348
marler8997
you're saying we shouldn't use the gnerated code for bootstrapping

1607985352
fengb
The problem is generating it at all nullifies it from certain tool chains

1607985354
fengb
Yeah

1607985366
marler8997
isnt' that what Nim does?

1607985368
marler8997
and other languages?

1607985386
fengb
A lot of languages bootstraps into C yes

1607985394
marler8997
I was perusing another langauge that only supports a CBE, and it commits it's generated C code to a repo for bootstrapping

1607985399
fengb
Zig wants to bootstrap without C, but also with C

1607985404
pixelherodev
Yes. That's one of the key reasons I'll

1607985416
marler8997
fengb, not following

1607985447
marler8997
what's wrong with using CBE for bootstrapping?

1607985468
fengb
Cause the rule lawyers don’t allow generated sources

1607985479
pixelherodev
Same as using a binary for bootstrapping, which defeats the purpose

1607985481
fengb
I don’t know why they don’t like it

1607985505
marler8997
who are the rule lawyers?

1607985513
fengb
Debian for one

1607985521
marler8997
oh gotcha

1607985542
marler8997
So the reason for not using CBE to bootstrap is because of Debian?

1607985550
pixelherodev
That's

1607985555
fengb
Basically, anything with CBE is considered starting with Zig, which isn’t really bootstrapped from C at a purity level

1607985564
marler8997
pixelherodev, all programs are technically bootstrapped by binaries if you go down far enough

1607985582
pixelherodev
marler8997: but most

1607985590
pixelherodev
There's a distro that bootstraps from a raw assembler

1607985599
marler8997
pixelherodev, by using CBE, we're bootstrapping from the Zig source

1607985605
marler8997
and using C as an intermidiary format

1607985613
pixelherodev
We're using C as a

1607985623
pixelherodev
It's not any better than using ELF

1607985623
marler8997
pixelherodev yes

1607985632
marler8997
but we're generating it from the Zig source

1607985640
pixelherodev
That's the *problem*,yes :P

1607985660
marler8997
it's not the same as having a binary that you don't have source to

1607985669
marler8997
for the C code from CBE, we have the source to re-generate it

1607985670
pixelherodev
Doesn't matter

1607985677
marler8997
that's all that matters :)

1607985680
marler8997
that's the distinction

1607985693
pixelherodev
If you have the GCC source, that doesn't make the binary acceptable for bootstrapping

1607985715
marler8997
The source is what is used for bootstrapping

1607985719
marler8997
The GCC source

1607985720
pixelherodev
Exactly

1607985723
marler8997
and the binary is an output of that

1607985737
pixelherodev
Using the CBE would mean using a Zig

1607985737
marler8997
so in the Zig case, the Zig source code is the source, CBE is an intermediate representation

1607985741
pixelherodev
CBE output == binary

1607985761
marler8997
pixelherodev, sure, but I'm not saying that we submit just CBE to debian

1607985763
pixelherodev
It's

1607985779
marler8997
you can submit the Zig source, and generate the CBE

1607985785
pixelherodev
Nope!

1607985792
fengb
They can’t process zig source

1607985795
pixelherodev
Can't generate the C variant

1607985799
marler8997
they can only process C source then?

1607985803
pixelherodev
Which you can't build...

1607985803
fengb
And they can’t use the CBE code because it’s generated

1607985823
marler8997
they can only process C source then?

1607985835
pixelherodev
Or langs with a C-based compiler

1607985839
pixelherodev
That's true of almost every distro

1607985845
marler8997
so how do they process C source?

1607985881
fengb
That’s the bootstrapping problem

1607985888
marler8997
which they have solved

1607985891
pixelherodev
Depending on the distro: with the existing C compiler (GCC, self-bootstrapped), with a bootstrap chain from assembly (simple assembler -> complex assembler -> simple C compiler -> complex C compiler)

1607985892
fengb
The point is they only have to trust the C bootstrap right now

1607985899
fengb
They won’t trust the Zig bootstrap

1607985902
marler8997
why?

1607985907
pixelherodev
Trusting trust, for starters

1607985914
fengb
Because Zig isn’t big enough

1607985917
fengb
Or trustworthy

1607985920
pixelherodev
Eh, not quite

1607985921
marler8997
why would they trust source written in C but not in Zig?

1607985934
pixelherodev
They don't trust the

1607985937
pixelherodev
It's not about the source

1607985947
fengb
They have to trust something. And they already trust C

1607985954
marler8997
pixelherodev, I've moved on to the next question

1607985955
pixelherodev
It's possible to write a compiler which maliciously injects code into binaries

1607985963
marler8997
the next question is...."how do they process C source"

1607985969
pixelherodev
I answered that :P

1607985972
pixelherodev
> Depending on the distro: with the existing C compiler (GCC, self-bootstrapped), with a bootstrap chain from assembly (simple assembler -> complex assembler -> simple C compiler -> complex C compiler)

1607985995
marler8997
so they are using binaries to bootstrap?

1607985997
pixelherodev
When bootstrapping Gentoo for instance, it uses the system compiler (typically GCC) to build the target compiler

1607986004
pixelherodev
Then the target compiler builds everything else

1607986017
marler8997
so they are using binaries to boostrap?

1607986023
pixelherodev
Depends on the distro

1607986036
marler8997
there's a distro that doesn't us binaries to bootstrap C code?

1607986038
CommunistWolf
also debian's definition of FOSS is pretty strict

1607986040
pixelherodev
Like I said, there's at least one that uses an assembler

1607986042
fengb
The point is, you can’t introduce a new binary in the chain. Zig is considered a binary if you can’t build it. And the source is considered tainted

1607986046
CommunistWolf
if it's not the form preferred for making changes, it's not the source

1607986054
marler8997


1607986063
CommunistWolf
ran into this with some shaders once

1607986064
marler8997
how did the original C compiler get introduced into the chain?

1607986065
pixelherodev
marler8997: because that expands how much needs to be trusted

1607986069
pixelherodev
Via assembler

1607986082
pixelherodev
There are paths to bootstrapping GCC from ahex editor

1607986095
CommunistWolf
there was a time when debian wasn't self-hosting, but today is not that time

1607986102
marler8997
pixelherodev, yes, but you're limiting everything to custom maintained C code

1607986110
pixelherodev
The emphasis is "maintained"

1607986111
marler8997
i.e. you're saying you can't use CBE in this chain

1607986114
pixelherodev
generated sources aren't maintained

1607986116
pixelherodev
Ever

1607986128
fengb
Because you shouldn’t have to add more trust

1607986134
marler8997
right, so by extension, binaries aren't maintained, so you can't use binaries either

1607986138
marler8997
but the chain does have binaries

1607986149
marler8997
these rules are contradicting each other

1607986152
pixelherodev
no

1607986156
fengb
C exists because it exists. Kind of a roundabout answer yes but that’s the bootstrapping problem

1607986170
marler8997
yes, but that's not the contradiction

1607986171
fengb
You can’t add more assumptions to trust though

1607986185
fengb
Cause some people won’t trust it

1607986195
pixelherodev
the binaries in the chain aren't comparable to adding an arbitrary new binary

1607986201
marler8997
the contradiction is that you're saying we can't use the CBE in the chain because it's generated code, but binaries themselves are generated, so saying that the chain can't have generated code doesn't hold true

1607986214
fengb
CBE source is tainted source

1607986222
pixelherodev
The binary was at some point produced by a trusted compiler, and is thus in turn trusted

1607986227
marler8997
it's generated source just like binaries

1607986235
pixelherodev
Trusted source -> trusted binary -> trusted binary -> today's compiler

1607986237
fengb
Which is not allowed by the rules

1607986242
marler8997
if you disallow generated code then you can't use binaries either

1607986248
pixelherodev
CBE output (or any random binary) isn't a known part of the chain

1607986255
marler8997
and do these toolchains update the C binaries?

1607986260
pixelherodev
The existing compiler has a history

1607986269
marler8997
you said that you can't add new binaries, but I have a hard time believing that they never update their toolchains

1607986280
fengb
Most bootstrapping starts with some assumptions

1607986286
CommunistWolf
some parallels can be had with bootstrapping debian to a new architecture

1607986293
fengb
One common assumption is a C compiler

1607986294
pixelherodev
There was at one point a trusted binary built from trusted source

1607986299
pixelherodev
That was used to build a trusted binary, etc

1607986306
fengb
It sucks that C gets to be special but that’s how history has evolved

1607986316
pixelherodev
CBE output itself has to be produced

1607986323
fengb
Other bootstrapping chains actually code up a C compiler in assembly

1607986327
pixelherodev
That Zig compiler

1607986341
marler8997
pixelherodev, and that Zig compiler can be generated with C source (that is also generated)

1607986345
pixelherodev
Who gets to generate the CBE-ed compiler? Not Debian./

1607986350
pixelherodev
marler8997: nope

1607986350
CommunistWolf
these days they use the amd64 compiler and cross-compile things to solve the bootstrapping issue. way back before debian 1.0, they probably snagged a gcc from redhat or so. they won't do it today

1607986359
marler8997
pixelherdev, yup :)

1607986363
pixelherodev
because at some point in the history, there

1607986378
pixelherodev
If I do it, that means I had an arbitrary Zig binary, which I could've tweaked to be malicious

1607986383
pixelherodev
Which means CBE source could be malicious

1607986388
marler8997
pixelherdev nope

1607986392
pixelherodev
The distro cannot produce the binary themselves

1607986401
pixelherodev
Not without analready-trusted binary

1607986415
marler8997
you take your trusted C compiler, compile the code generated by CBE, now you have a Zig compiler

1607986419
fengb
Anal ready 🤔

1607986432
fengb
CBE is tainted source. Already not viable

1607986439
marler8997
what do you mean "tainted"?

1607986440
pixelherodev
marler8997: but that CBE output was produced

1607986446
pixelherodev
Which

1607986447
marler8997
so

1607986454
pixelherodev
The CBE output isn't trustworthy

1607986457
marler8997
it's source code that you can read and verify

1607986461
pixelherodev
No, it's not.

1607986461
marler8997
just like any other source code

1607986461
fengb
So committees argue this and reject generated source

1607986466
pixelherodev
CBE output

1607986474
marler8997
how do you verify any source is trusted?

1607986475
pixelherodev
CBE output is 100% considered binary code

1607986477
pixelherodev
Even by Zig.

1607986480
fengb
Again, you don’t have to convince us

1607986486
pixelherodev
Actually, you do :P

1607986492
marler8997
it's not 100% binary code, it has aspects of both binary and source code

1607986494
fengb
(You might have to convince phd, but he doesn’t really matter here)

1607986506
marler8997
how do you verify any source is trusted?

1607986514
pixelherodev
marler8997: according to the Zig project (or, if you prefer, according to Andrew): CBE output is 100% intended to be a binary

1607986514
fengb
If Debian rejects this, and they will, then it’s unviable

1607986528
marler8997
you're claiming that CBE is untrusted, so that how do you determine whether any new source is trusted or untrusted?

1607986535
pixelherodev
It's not about the CBE

1607986543
pixelherodev
It's about the compiler producing it

1607986548
marler8997
how do you verify whether new source is trusted or untrusted?

1607986549
pixelherodev
Which is stage2 built by stage1

1607986563
pixelherodev
(or stage2 built by stage2 built by stage1)

1607986568
fengb
Lots of people auditing the source

1607986569
marler8997
how do you verify whether new source is trusted or untrusted?

1607986577
marler8997
so why can't people audit CBE source?

1607986581
fengb
They won’t touch generated sources

1607986583
pixelherodev
Because it's

1607986588
pixelherodev
It's machine code disguised as C

1607986591
pixelherodev
Deliberately

1607986595
pixelherodev
That's how it was designed

1607986606
pixelherodev
Forgetting Debian for a second

1607986625
pixelherodev
Every decision made in the CBE's design has been to make its output machine code disguised as C, and

1607986638
marler8997
so you're saying because it's hard to read?

1607986647
pixelherodev
It's as good as assembly

1607986652
marler8997
not really though

1607986654
pixelherodev
Yes, really

1607986661
marler8997
but in any case, assembly is still source that can be audited

1607986663
pixelherodev
It runs after optimization, and isgenerated from IR

1607986679
marler8997
are you saying that all assembly code is untrusted?

1607986681
fengb
Not generated assembly though

1607986684
pixelherodev
Good luck getting anyone to take "Let's audit a few MLoC of asm!" seriously :P

1607986691
pixelherodev
Handwritten asm, sure

1607986692
fengb
No, just generated code is off limits

1607986693
marler8997
if so, how did they verify the original compilers written in assembly?

1607986701
pixelherodev
Because handwritten asm is readable

1607986713
pixelherodev
The output of `gcc -O2` is nonsense

1607986722
marler8997
ok, so the reason is, generated code is harder to read than handwritten code?

1607986724
pixelherodev
(as far as humans are concerned)

1607986734
pixelherodev
Not "harder," "unreasonable"

1607986741
pixelherodev
It's

1607986746
marler8997
so if we made CBE readable then it wouldn't be a problem?

1607986754
pixelherodev
You know how Super Mario 64 was decompiled?

1607986756
CommunistWolf
no

1607986761
pixelherodev
Understanding it requires the same kind of process

1607986761
CommunistWolf
it has to be the preferred format for making changes

1607986767
CommunistWolf
that is what the definition of source means in this case

1607986773
marler8997
CommunistWolf gotcha

1607986778
marler8997
ok what about this

1607986782
pixelherodev
Hence, the one shot translation

1607986800
pixelherodev
In which we, effectively, compile it to machine-code-as-C and  then decompile it  into C

1607986817
pixelherodev
That's not  something that can reasonably be done multiple times

1607986820
marler8997
deploy Zig code and CBE code, during build, compile CBE to make Zig compiler, then compile Zig code to CBE, compare that generated CBE is the same as the committed CBE

1607986826
pixelherodev
You

1607986833
pixelherodev
Because that requires trusting it

1607986839
pixelherodev
Which is never going to happen

1607986845
CommunistWolf
easiest (haha) way to solve the bootstrapping problem is probably to write a minimal zig compiler in C-or-something-else

1607986845
marler8997
if they are equivalent, then you by veryfing the Zig code you are transitively also verifying the CBE code

1607986855
pixelherodev
marler8997: nope

1607986861
pixelherodev
trusting trust

1607986870
pixelherodev
compiler can modify the sources it's compiling

1607986880
pixelherodev
if you don't trust CBE, then the produced Zig compilerisn't trustworthy either

1607986886
marler8997
pixelherodev, be careful what I just said is a bit complicated, you may want to take a moment to ponder on it

1607986887
pixelherodev
So its generated  CBE can't be trusted

1607986890
pixelherodev
Not really

1607986894
pixelherodev
This is a known problem

1607986895
marler8997
I didn't say CBE is trusted

1607986897
CommunistWolf
go probably got into debian via gccgo, although I'm not certain of that

1607986900
pixelherodev
It has to be for that to work

1607986905
marler8997
my scenario assumes CBE isn't trusted

1607986914
pixelherodev
yes, but it doesn't solve it

1607986923
marler8997
again, take a moment to look at it

1607986923
pixelherodev
The  generated CBE could be malicious

1607986924
CommunistWolf
maybe it was added when the go compiler still wasn't self-hostingf

1607986925
marler8997
it's not simple

1607986926
pixelherodev
I

1607986931
marler8997
pixelherodev yes I agree

1607986933
pixelherodev
Don't assume that I don't understand lol

1607986944
marler8997
I didn't assume, you just responded very quickly to something that is complex

1607986950
pixelherodev
All it proves is that the generated CBE and the sourceCBE are equally malicious

1607986953
marler8997
I'm still thinking about it myself and am unsure about it

1607986969
CommunistWolf
yeah, seems so:

1607986977
pixelherodev
If the source CBE is untrustworthy, then the Zig compiler from it isn't, and the final CBE  -

1607986993
pixelherodev
marler8997: I responsed quickly because, as I said, this is a known problem with aknown solution

1607986997
pixelherodev
Look up "trusting trust"

1607987037
marler8997
pixelherodev, we're not dependign on CBE being trustworthy

1607987040
pixelherodev
False

1607987043
marler8997
we're depending on the Zig source being trusworthy

1607987054
pixelherodev
Nope

1607987065
pixelherodev
With a trusting trust attack, the source doesn't have to be malicious

1607987070
pixelherodev
The compiler

1607987080
pixelherodev
An untrustworthy compiler means no source is trustworthy

1607987082
marler8997
We're using CBE to verify that Zig's trustworthiness implies CBE's trustworthiness

1607987109
marler8997
we're using the trusted C compiler

1607987114
marler8997
along with untrusted CBE

1607987115
pixelherodev
marler8997:

1607987121
marler8997
we generate an untrusted Zig compiler

1607987124
pixelherodev
Output of CBE is an untrusted compiler

1607987132
pixelherodev
Untrusted compiler on trusted source == untrusted output

1607987134
marler8997
We use that untrusted Zig compiler to compile the trusted Zig code to a new CBE

1607987140
pixelherodev
marler8997: yes,

1607987151
pixelherodev
The output is untrusted

1607987156
pixelherodev
Which means

1607987157
marler8997
we compare the new CBE with the original CBE to verify they are the same, which implies that the original CBE is equivalent to the trusted Zig code

1607987166
pixelherodev
The finalCBE matching the original CBE doesn't prove that its trustworthy

1607987185
marler8997
I didn't say it did

1607987192
marler8997
I said it proves that CBE is equivalent to the Zig code

1607987198
pixelherodev
No, it doesn't!

1607987200
pixelherodev
All it proves is that

1607987214
marler8997
but that "smartness" is encoded in the Zig source

1607987216
pixelherodev
"if (compiling_zig) { inject_malicious_code(); }"

1607987229
marler8997
that code would have to be in the Zig code as well

1607987231
pixelherodev
Then the produced Zig compiler will match the CBE *in being equally malicious*!

1607987233
pixelherodev
No, it doesn't!

1607987239
pixelherodev
The CBE compiler could inject it!

1607987251
pixelherodev
That's the

1607987270
marler8997
if it changed the source, then the original and newly generated CBE wouldn't match

1607987279
pixelherodev
Unless the original was malicious too

1607987285
marler8997
yes it can be malicious

1607987288
pixelherodev
Because a previous compiler did the same thing

1607987289
marler8997
did you not read the sequence?

1607987317
marler8997
"along with untrusted CBE"

1607987321
pixelherodev
I did

1607987325
pixelherodev
It's

1607987335
pixelherodev
Seriously, read the trusting trust paper!

1607987352
marler8997
this one?

1607987372
pixelherodev
Probably

1607987375
leeward
Ken's Turing award speech?

1607987394
marler8997
pixelherodev, all you have to do is come up with a way to break my sequence

1607987407
pixelherodev
marler8997: I did :P

1607987417
marler8997
ok let me check your proposed break

1607987427
pixelherodev
If the CBE source is malicious, the generated Zig compiler will know that, when building CBE, it should make sure it's malicious

1607987431
marler8997
let's formalize a bit here so we can be sure

1607987448
pixelherodev
No need to formalize lol. "Untrusted compiler means no source is trustworthy"

1607987463
marler8997
pixelherodev yes

1607987467
marler8997
that's not what I proposed

1607987480
pixelherodev
Not wasting my time lol, you're allowed to be wrong ;)

1607987492
marler8997
I'm basing the trust on Zig's source code

1607987499
leeward
So is your plan to hand-write an assembler in machine code, then use that to hand-code a compiler in assembler?

1607987509
marler8997
and I came up with a way to verify CBE's trustworthiness from the trustworthiness of the Zig source code

1607987543
marler8997
pixelherodev, I'm not saying I'm right or wrong, I proposed a solution and I'd like to know if it's right or wrong

1607987558
pixelherodev
leeward: no, because I already trust a C compiler

1607987562
earnestly
The only known solution so far, tmk, to the TT problem is:

1607987574
marler8997
yes, all of this depends on the trustworthiness of the C compiler

1607987575
pixelherodev
marler8997: fundamentally, your solution misses a key fact.

1607987584
marler8997
pixelherdev, ok but what is that fact?

1607987593
pixelherodev
The generated Zig compiler can, when producing CBE,

1607987601
pixelherodev
Which will of course match the malicious input

1607987631
marler8997
pixelherodev, the Zig source code is trusted though, so if it did produce malicious code then that's fine

1607987635
pixelherodev
No!

1607987638
leeward
pixelherodev: That seems like a large leap, but ok.

1607987639
pixelherodev
It's not!

1607987649
pixelherodev
The generated Zig compiler will be exactly as malicious as the compiler used to build it!

1607987649
CommunistWolf
it's totally a thing

1607987659
marler8997
my solution assumes we can verify the trustworthiness of the handwrittne Zig compiler

1607987666
pixelherodev
It

1607987668
leeward
Do you trust a C++ compiler? Because I can compile Zig from scratch with one of those.

1607987673
pixelherodev
No

1607987675
marler8997
pixelherdev yes!

1607987675
pixelherodev
:P

1607987683
pixelherodev
marler8997: Even if the source is trustworthy, the output isn't

1607987688
pixelherodev
That's

1607987691
marler8997
The Zig compiler's maliciousness == the maliciousness of the compiler used to build it

1607987694
marler8997
yes that is true

1607987699
marler8997
I never said it wasn't

1607987709
pixelherodev
And since that's malicious, its output is too

1607987717
pixelherodev
Which means it'll match

1607987719
leeward
Ok, so get an old version of G++ that's written in C, build it with your trusted C compiler, use it to build a modern version of LLVM, then use that to build Zig?

1607987719
marler8997
I'll go through the sequence again with more details

1607987720
pixelherodev


1607987730
marler8997
we start with a trusted C compiler (TCC for "trusted C compiler")

1607987731
earnestly
leeward: That doesn't help

1607987732
pixelherodev
leeward: there's nothing more to go through lol

1607987734
leeward
That sounds like less work than reimplementing Zig from scratch in C.

1607987750
pixelherodev
leeward: that requires the ability to trust

1607987758
marler8997
Then we have "untrusted C code generated from Zig's CBE" (UZC1 "untrusted Zig C code 1")

1607987772
leeward
Ah, so you don't trust even the source version of a C++ compiler.

1607987780
marler8997
Then we have the trusted Zig source code that is handwritten, verified by humans TZC

1607987785
pixelherodev
leeward: I don't trust anyone who would willingly write a C++ compiler lol

1607987792
pixelherodev
marler8997: it doesn't matter

1607987793
marler8997
Then we compiler the untrusted C backend code to create an untrusted Zig compiler

1607987802
pixelherodev
The Zig source's trustworthiness is 100% irrelevant

1607987803
marler8997
pixelherodev, I'm not done with the sequence

1607987808
pixelherodev
It doesn't matter

1607987815
pixelherodev
You've already broken it :P

1607987831
marler8997
pixelherodev, it's broken because it's not finished yet...lol

1607987835
pixelherodev
What you're missing is that a malicious compiler

1607987839
leeward
How is it broken? It's an untrusted compiler.

1607987847
pixelherodev
You

1607987854
leeward
As long as he means untrusted, it doesn't matter if it's malicious.

1607987856
pixelherodev
Because you can't

1607987865
pixelherodev
If the compiler is malicious, it can fully ignore the source code

1607987866
leeward
I want to hear the end, marler8997.

1607987877
pixelherodev
It can see "I'm compiling Zig!" and use an in-memory malicious copy it bundles

1607987882
marler8997
ok, so we have an untrusted Zig binary

1607987903
pixelherodev
untrusted binary's output could legitimately be an RNG :P

1607987907
leeward
Oh, important point: do you have an objdump that you trust, pixelherodev?

1607987909
marler8997
Then we can take that Zig binary, and use it to re-generate a new vesrion of the C Backend from the trusted Zig source code

1607987938
pixelherodev
marler8997: for that to work, you have to trust that that Zig binary is in fact translating the zig to C

1607987950
marler8997
If we find that the new C backend is equivalent to the original C backend code that we generated our Zig compiler from, then that says the CBE is equivalent to the trusted Zig code that we verified

1607987969
earnestly
Trusting trust is about how you can't trust the "trusted compiler"

1607987971
marler8997
pixelherodev yes

1607987973
pixelherodev
marler8997: fundamentally, that "untrusted compiler" can't even be trusted to

1607987981
marler8997
but you can trust that because the Zig source code is trusted

1607987983
pixelherodev
It can literally just spit out its own source

1607987985
pixelherodev
No, you can't!

1607987991
marler8997
that's literally the only thing you can do, is verify the original source

1607987994
pixelherodev
The source

1607987998
marler8997
it would be the same if the compiler was written in C

1607988008
marler8997
pixelherdev. yes

1607988028
CommunistWolf
I'm not sure this one is going to get it

1607988030
pixelherodev
That "compiler" can literally just run `puts(MALICIOUS_CBE);`

1607988042
marler8997
pixelherodev, again this is a bit complicated but you need to think about this for a minute

1607988046
pixelherodev
No, it's not!

1607988068
pixelherodev
A malicious compiler's output is effectively meaningless

1607988085
marler8997
I'd have to formalize it a bit more on my end, but I believe I'm using induction to prove it

1607988087
pixelherodev
There is

1607988092
pixelherodev
Why would you think that?

1607988092
CommunistWolf
still, worth another go. your original source, and what you trust, is zig. so you take that and run it through something to get some CBE. later, you do it again. you can't trust either copy

1607988098
leeward
marler8997: UZC1 is generated from what source by Zig's CBE?

1607988099
CommunistWolf
whether the two CBEs are equivalent is irrelevant

1607988104
pixelherodev
^

1607988114
pixelherodev
You're proving them equivalent, sure

1607988124
marler8997
leeward, it doesn't matter because the second time we generate it, it has to be generated form the Zig source

1607988126
pixelherodev
That doesn't prove that

1607988129
CommunistWolf
now, if your "something" took in the trusted zig and outputted zig, you could compare its output to the trusted input

1607988130
marler8997
and they have to be equivalent

1607988133
CommunistWolf
that utility would be called "cat"

1607988134
pixelherodev
marler8997: it's

1607988136
CommunistWolf
it doesn't help us

1607988137
pixelherodev
That's the mistake!

1607988140
marler8997
but practically it's generated from the Zig source

1607988143
pixelherodev
Nope!

1607988149
pixelherodev
The untrusted compiler

1607988159
leeward
marler8997: Ok, so what does it purport to do? I'm missing some context.

1607988164
pixelherodev
So there is

1607988181
earnestly
The point is that you can't trust the "trust"

1607988194
CommunistWolf
a separate compiler doesn't solve the trust issue at all, incidentally, it just solves the bootstrapping issue

1607988201
pixelherodev
marler8997: the malicious compiler can always produce a binary that's equivalent to `echo 'printf("Hello world!");'`

1607988215
pixelherodev
That'd result in it "generating" that printf regardless of the input

1607988224
marler8997
pixelherodev, how does that binary compile the Zig source code into a CBE that is equivalent?

1607988225
pixelherodev
s/printf/complex malicious CBE output

1607988232
pixelherodev
marler8997: that's literally my point

1607988239
earnestly
CommunistWolf: Wheeler claims it does

1607988249
pixelherodev
The output of the malicious compiler has

1607988258
marler8997
pixelherdev yes

1607988275
marler8997
but you're assumign that the compiler is malicious before proving that it is...my sequence relies on an unknown compiler

1607988285
CommunistWolf
it's unlikely that independent source implementations will have the same bug, but it's not proof

1607988285
marler8997
it is "untrusted"

1607988286
leeward
pixelherodev: So your plan is to implement Zig in C and use this compiler that you trust to build it?

1607988289
pixelherodev
leeward: no

1607988294
pixelherodev
This isn't about trust lol

1607988307
marler8997
and then we prove that it actually is trusted by proving that it is equivalent to the trusted Zig source code

1607988307
leeward
Oh, I get it.

1607988310
pixelherodev
The Zig-in-C compiler is for a) bootstrapping and b) simplifying

1607988324
pixelherodev
Someone else brought up trust and I've been trying to explain trusting trust :P

1607988330
pixelherodev
marler8997: it

1607988335
pixelherodev
seriously, just...

1607988340
CommunistWolf
it's common to assume that unknown things are untrusted

1607988348
CommunistWolf
it's less common to assume that they're trusted

1607988351
marler8997
I asked if the paper I sent was the paper and you said it might be

1607988358
pixelherodev


1607988363
marler8997
but I can't really read why we're talking like this :)

1607988406
pixelherodev
marler8997:

1607988421
pixelherodev
if the input compiler is untrusted, you've proven that

1607988422
earnestly
(And the ddc solution doesn't stop malicious compilers; it just means the compiler's source code is what the compiler used)

1607988426
leeward
We're talking about Ken Thompson's turing award lecture, right? That's the kind of thing everyone interested enough to be in this channel should read.

1607988439
marler8997
pixelherdev, untrusted doesn't mean malicious

1607988462
marler8997
it has not been proven to be malicious or non malivious

1607988472
pixelherodev
all you're proving is that they're equally trustworthy

1607988478
pixelherodev
Which is redundant information

1607988481
marler8997
a compiler can be untrusted, then then verified after the fact and then become trusted

1607988486
pixelherodev
No, it can't

1607988489
marler8997
which is what my proposed solution attempts to do

1607988499
pixelherodev
An untrusted compiler will produce an untrusted output

1607988504
marler8997
pixelherdev yes

1607988509
pixelherodev
You keep insisting that the generated CBE is meaningful

1607988511
pixelherodev
Why?

1607988513
marler8997
I didn't say anything to the contrary

1607988533
pixelherodev
Why do you think that the CBE produced by the compiled CBE is useful information?

1607988537
marler8997
I'm saying, a compiler can be untrusted at one point in time, and then trusted after verifying it sometime later

1607988544
pixelherodev
Okay, but again

1607988546
pixelherodev
> Why do you think that the CBE produced by the compiled CBE is useful information?

1607988550
pixelherodev
Forgot trustworthiness

1607988556
pixelherodev
Why is this remotely relevant?

1607988562
marler8997
the CBE it untrusted

1607988565
marler8997
*is untrusted

1607988569
pixelherodev
Its output is for all intents and purposes gibberish

1607988572
marler8997
but the Zig source is trusted yes?

1607988581
pixelherodev
Source can't be trusted

1607988586
leeward
Why not?

1607988591
pixelherodev
The question is "if this was machine code would it be trustworthy"

1607988594
marler8997
pixelherodev....uh wut

1607988604
marler8997
source can't be trusted? so then what can be trusted?

1607988605
pixelherodev
If the compiler is malicious then

1607988616
leeward
No, the question is "if this source is compiled by a trusted compiler, would I trust it?"

1607988616
pixelherodev
The question is "given a trusted compiler, can we trust this?"

1607988620
pixelherodev
^

1607988622
pixelherodev
Yes, exactly

1607988624
marler8997
a compiler doesn't make source malicious, it produces malicious binaries

1607988624
leeward
If the answer there is yes, then the source is trusted.

1607988637
pixelherodev
marler8997: sure. and malicious CBEs.

1607988643
marler8997
pixelherdev yes

1607988646
pixelherodev
That's literally my point

1607988652
marler8997
you're not following here, you keep going back to this point, which i AGREE with

1607988656
pixelherodev
The CBE-ed output of the "trusted source" can't be trusted

1607988658
pixelherodev
ever

1607988664
pixelherodev
(unless the compiler is)

1607988671
marler8997
pixelherodev, yes I agree

1607988676
pixelherodev
(which is, in your argument, *unknown*)

1607988678
marler8997
no it's not

1607988687
pixelherodev
Yes it is

1607988687
CommunistWolf
how do you prove CBE generator is safe, without reference to the CBE?

1607988698
pixelherodev
marler8997: that was the coreof your argument!

1607988701
marler8997
it's very simple

1607988705
CommunistWolf
can it be done?

1607988705
pixelherodev
We don't yet knowif we can trust the compiler

1607988724
marler8997
but first I need pixelherodev to agree with the points, the first one being "The Zig source is trusted"

1607988728
pixelherodev
unless you already trust a compiler, its output can't be assumed to be related in any way to the source

1607988737
marler8997
pixelherodev I agree

1607988738
pixelherodev
marler8997: you still haven't answered

1607988743
marler8997
answered what?

1607988756
pixelherodev


1607988762
pixelherodev
You say "we can compare its CBE output"

1607988782
pixelherodev
But if we can't trust theCBE compiler,

1607988803
marler8997
thinking...

1607988817
pixelherodev
Unless you trust the input, you

1607988837
pixelherodev
For all you know, it might produce the output regardless of what sources you give it

1607988850
pixelherodev
Which means that your trust chain still doesn't include the Zig sources at all

1607988860
pixelherodev
Which means no part in the chain is trustworthy

1607988871
marler8997
yeah I'm missing a piece here

1607988873
pixelherodev
Fundamentally, your argument relies on the trustworthiness of the Zig source, corret?

1607988877
pixelherodev
s/corret/correct/

1607988879
marler8997
pixelherodev yes

1607988894
marler8997
what I'm trying to do is find a way for the Zig source code to verify the CBE source code

1607988898
pixelherodev
Well, unless the compiler is

1607988920
pixelherodev
Which means that the trustworthiness of the source

1607988931
pixelherodev
Which means that the original cannot be trusted

1607988937
marler8997
pixelherodev, correct, if we can find a way to verify the CBE is equivalent to the Zig source, then we can solve the problem yes?

1607988937
pixelherodev
And thus, the output cannot be, either

1607988976
pixelherodev
marler8997: this is an unsolved problem, so I wish you luck :P

1607988984
marler8997
this is equivalent to trusting the binary of A C program so long as we trusted the C source and the compiler yes?

1607988984
pixelherodev
The best we can do is prove equivalence

1607988997
marler8997
pixelherodev, can you answer the question though?

1607989000
pixelherodev
yeah

1607989025
pixelherodev
Thing is, in a very real way, it's impossible to trust the

1607989028
marler8997
ok, you could be right this is an unsolved problem, I'll think on it a bit more

1607989039
pixelherodev
The most obvious example is evil microcode

1607989058
pixelherodev
Imagine a microcode smart enough to detect when e.g. `sudo` is being run

1607989074
pixelherodev
There's

1607989104
marler8997
pixelherodev can you answer the other question?

1607989112
marler8997
> if we can find a way to verify the CBE is equivalent to the Zig source, then we can solve the problem yes?

1607989114
pixelherodev
marler8997:which one?

1607989115
pixelherodev
Ah

1607989117
pixelherodev
Yes

1607989119
pixelherodev
s/Yes//

1607989125
marler8997
ok cool, we're on the same page now

1607989127
pixelherodev
Meant, "ah yes that question" :P

1607989131
pixelherodev
That'd prove equivalence

1607989132
pixelherodev
That is doable

1607989149
pixelherodev
There's a solution involving using two compilers

1607989171
pixelherodev
Which, IIRC, allows proving source/binary equivalence to a higher degree

1607989196
pixelherodev
unless you can trust

1607989217
marler8997
sorry what?

1607989221
marler8997
what was the answer to the question?

1607989223
pixelherodev
I believe Thompson's conclusion was "you have to trust the people instead of trying to trust the tools"

1607989237
pixelherodev
marler8997: you can prove that source == binary, yes

1607989249
marler8997
hmm, I don't think that was the question

1607989254
pixelherodev
Or at least that the compiler isn't the

1607989276
pixelherodev
Imagine e.g. `hexdump`, `cat`, `objdump`,... are malicious

1607989283
marler8997
the question is, if we can prove that the Zig soruce code is equivalent to the CBE, can we solve the problem of creating a trusted Zig compiler from the Zig source?

1607989306
pixelherodev
marler8997: yes, but the only solution that's been devised in the last few decades requires

1607989317
pixelherodev
Which wouldn't help us here

1607989325
marler8997
huh?

1607989341
pixelherodev
Yes, it would; no, you can't prove it

1607989352
marler8997
can't prove what?

1607989357
pixelherodev
that source == CBE

1607989359
earnestly
Unless you're willing to write another (or more) zig compilers

1607989361
pixelherodev
Or maybe you can

1607989367
marler8997
oh, how do you know that?

1607989385
pixelherodev
But if you figure out a way, it'll be a relatively big dela

1607989387
pixelherodev
deal*

1607989402
pixelherodev
since the only method currently known got someone their doctorate IIRC :P

1607989403
marler8997
because it would have big implications?  Why is that?

1607989409
fengb
You could probably rewrite a dozen compilers with that time

1607989416
pixelherodev
marler8997: because you're far from the first person to try this

1607989426
pixelherodev
marler8997: and nobody's figured out a solution

1607989439
marler8997
you're saying the Zig situation is equivalent to others that have not been solved, if that's true then sure

1607989445
marler8997
I'm not sure that's true though

1607989447
pixelherodev
It's not Zig-specific

1607989452
pixelherodev
It's a compilers problem

1607989471
fengb
The bootstrap problem

1607989471
pixelherodev
proving CBE==Zig is no different from proving GCC binary == GCC source

1607989490
marler8997
This situation sounds unique because not many other tools have a CBE like this, I'm operating under the insight that this may produce a unique situation with a fairly simple solution

1607989499
pixelherodev
and, fundamentally, the very idea of proving it requires the assumption that kernel/toolchain isn't malicious

1607989506
pixelherodev
marler8997: CBE

1607989506
marler8997
if it's equivalent to this very difficult problem then it's not going to be solved simply like this

1607989521
pixelherodev
that's what I was trying to explain :P

1607989532
pixelherodev
There's no practical difference in proving that CBE == Zig and that ELF == Zig

1607989534
marler8997
pixelherdev, in many ways yes

1607989551
marler8997
in regard to trust I'll assume it is 100% equivalent here

1607989571
marler8997
ok so you're calling this situation equivalent to others by treating CBE as a binary

1607989580
pixelherodev
CBE and binary are both "code generated by a program"

1607989598
pixelherodev
There is no simple solution to "prove code generated by program equals inputs to program"

1607989631
marler8997
pixelherodev oh?

1607989632
pixelherodev
`zig fmt` is easy to prove; you can prove that the ASTs are equal

1607989664
pixelherodev
marler8997: let's make this a bit worse (paranoid level 9000!): what if cat,objdump,readelf,hexdump,etc are lying to you?

1607989666
marler8997
I'm not familiar with this problem

1607989678
leeward
There's another well established method: auditing the object code.

1607989692
pixelherodev
Which only works if the tools for viewing it can be trusted :P

1607989707
leeward
yes

1607989708
marler8997
leeward yeah, but I'll assume we can't do that here to get through pixelherodev's arguments

1607989731
pixelherodev
also, in case this wasn't abundantly clear: trust isn't remotely why I want an alternate compiler

1607989738
earnestly
"The problem of trusting trust"

1607989763
leeward
Though objdump is not so complicated a tool that it can't be hand-written in machine code. Particularly if you're taking on a project like auditing a compiler's object code.

1607989764
marler8997
so where does this statement come from ""prove code generated by program equals inputs to program"

1607989799
earnestly
leeward: blackbox silicon, dijkstra original problem with tests

1607989801
pixelherodev
marler8997: if I give you a random binary, and its source, how would you prove them equal?

1607989802
leeward
If code generated by a program equals its inputs, your program is cat and the proof is trivial.

1607989811
CommunistWolf
distantly related if you enjoy this kind of thing:

1607989819
pixelherodev
leeward: haha :P

1607989830
pixelherodev
ugh, that's Yudkowski, right?

1607989832
marler8997
thinking...

1607989860
pixelherodev
CommunistWolf: I kinda lost all respect for Yudkowski after reading his "autobiographical" post

1607989868
leeward
earnestly: Yes, trusting hardware is getting to be a challenge these days. Used to be you could pop the cap off your 8086 and verify that the transistors are where they're supposed to be.

1607989880
CommunistWolf
I don't really care about the individual humans

1607989883
leeward
I used to have a poster of that somewhere.

1607989883
marler8997
pixelherodev, the obvious way is to take a trusted compiler and regenerate the binary from source

1607989895
pixelherodev
marler8997: ah, but what if it optimizes differently?

1607989913
pixelherodev
even the obvious way only works if the compiler  produces an identical binary

1607989917
leeward
-O0: the most trustworthy of optimizer settings

1607989921
fengb
leeward: you don’t have a SCT to validate the trillions of gates?

1607989922
pixelherodev
Which for a lot of projects is unusual already

1607989927
marler8997
sure, but it's still solvable in certain cases

1607989939
marler8997
I'm not saying it's solvable in the general case

1607989950
CommunistWolf
but no, the original seems to be from a paul christiano, whoever that is

1607989969
pixelherodev
marler8997: if you assume the tools are trustworthy, sure - but keep in mind that you specified "trusted compiler" as a prerequisite

1607989975
leeward
fengb: 8086 doesn't have trillions of gates. It has less than 30k transistors. Still, yes, you do need some fancy equipment.

1607989985
marler8997
pixelherodev, yes I realize that :)

1607989998
marler8997
you have to start somewhere of course

1607990005
leeward
And I guess you have to trust that your scanning electron microscope is telling you the truth.

1607990062
CommunistWolf
if "the solomonoff prior" is one of your "tools",  this is basically the thompson paper extended to the many-worlds hypothesis

1607990065
CommunistWolf
very painful

1607990094
pixelherodev
marler8997: you stumbled on exactly why all source has to go through C

1607990102
earnestly
Yeah, you may not want to take the implications of this into meatspace

1607990107
pixelherodev
e.g. Debian has compiler builds they consider trustworthy already

1607990118
pixelherodev
Therefore, given trusted sources, they trust the outputs

1607990128
marler8997
pixelherodev, what?

1607990136
earnestly
And reproducible builds to try and limit the nsa quantum problem

1607990146
pixelherodev
if  we give them a Zig compiler whose source istrustworthy, they'll trust the binary

1607990149
leeward
Or we could go further back in time. LSI features are in the micrometers, which you could probably see with a good enough optical microscope.

1607990156
pixelherodev
and we could potnetially use itfor bootstrapping

1607990186
pixelherodev
marler8997: there's existing

1607990190
marler8997
sure, but I'm still not sure we can't solve the CBE case, I'm formalling it a bit right now to be sure

1607990196
pixelherodev
good luck

1607990200
pixelherodev
Like, genuinely

1607990205
marler8997
thanks :)

1607990217
pixelherodev
I'm not expecting much; feel free to prove me wrong ;)

1607990245
marler8997
well the solution I proposed earlier is at best incomplete

1607990313
pixelherodev
maybe task a neural network to solve it ;P

1607990320
pixelherodev
(please don't, that was friendly sarcasm :P)

1607990351
marler8997
Back in college I did alot of this Lisp variant called ACL2 that allowed you to write mathematical proofs in Lisp.... :)

1607990353
pixelherodev
How to prevent (and/or cause) the robot uprising: "yo, AI: solve the halting problem!"

1607990384
marler8997
I'll just get a nueral network to create a proof in lisp :)

