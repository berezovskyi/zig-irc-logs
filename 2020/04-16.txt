1586998323
wilsonk
copy: if you are trying to cross compile for Mac you can just build object files on linux/win and then link with ld64 (or the osxcross compiler) and the binary will work. Here are my commands: 'zig build-obj main.zig -target x86_64-macosx -lc' -> 'o64-clang main.o ~/zig/temp/libcompiler_rt.a -o main'

1586998367
wilsonk
I haven't gotten it working with a library that uses Cocoa yet, but command line stuff seems to work with my minimal testing

1587001155
daurnimator
mikdusan: 10.5 is ancient. we can specify that as the minimum

1587001169
daurnimator
mikdusan: infact we can specify 10.13 as the minimum can't we?

1587001354
mikdusan
I think my digging so far is half-assed, in that I only tried setting minimum during exe linking. but that was against a non-minimum libcompiler_rt.a which I assume builds at current host levels, in my case 10.15.4

1587001469
mikdusan
I'll do a quick try at (when null, aka zig0 bootstrapping) setting  10.13 universally for compiling/linking so libcompiler_rt.a is in the loop and see what happens

1587001867
terinjokes
is there a way to specify the cache/maniest directory?

1587001945
terinjokes
probably cache-dir

1587002030
terinjokes
ah, but can't pass to zig cc

1587002615
daurnimator
andrewrk: "By default, the size of enums is not guaranteed." -> really? I didn't realise `enum(u16) { .... }` could be not a u16.

1587002723
daurnimator
oh and a thought about math.clamp and some other functions: with @TypeOf now doing peer-type resolution, something like: `fn (a: var, b: var, c:var) @TypeOf(a,b,c)` might make sense.

1587006277
mikdusan
daurnimator: yup 10.13,... all the way back to 10.7 helps with -pie but hit another bug in --library processing

1587006403
mikdusan
if using `-target native-native` all is good. but as soon as os becomes specified, even if it is same as native: `-target x86_64-macosx` is_native is now internally set to false. and for some reason --libraries are cond is_native==true

1587006426
daurnimator
mikdusan: yes that's intentional

1587006440
mikdusan
what part?

1587006442
daurnimator
mikdusan: the idea is that unless you're targeting native-native then -l shouldn't look in /usr/lib

1587006459
daurnimator
you'd have to add -L/usr/lib to look there

1587006465
mikdusan
but if I'm targeting anything, I need to be able to setup custom paths and libs

1587006499
mikdusan
what I'm saying is custom -lWHATEVER does not get added if (is_native == false)

1587006508
daurnimator
oh. that's wrong

1587006517
mikdusan
hell this might even extend to `zig cc`

1587006534
terinjokes
that works for me when using zig cc

1587006542
terinjokes
i was using it last night without issue

1587006556
mikdusan
w/ -target ?

1587006559
terinjokes
yes

1587006571
mikdusan
ok i need to investigate further

1587006797
mikdusan
terinjokes: linux?

1587006871
terinjokes
mikdusan: yeah, I'm on x86_65-linux. i missed seeing you were on macosx

1587006968
grant_
my cmake generate step failed

1587006970
grant_


1587006984
terinjokes
(x86_64, I do not have an extra 65th bit)

1587006986
grant_
most of those errors repeat

1587007004
grant_
so should I edit the cmake files now?

1587007125
mikdusan
terinjokes, darithorn: it's a macho (macosx) thing. all build-exe/test and `zig cc` linking.

1587007138
mikdusan
whups i mean daurnimator

1587007153
mikdusan
verified linux is ok

1587007177
terinjokes
mikdusan: okay. again, sorry for disrupting you

1587007926
foobles
I just noticed something weird about `ir_analyze_bin_op_bool`. I have tested it, and it definitely short circuits. like: `comptime { if (false and undeclared_ident) {} }` will compile

1587007947
foobles
since the `and` only evaulates the left side at comptime

1587007969
foobles
but in the function, it runs `ir_resolve_const` on the lhs and rhs before comparing them

1587007988
foobles
how is this possible? Does `ir_resolve_const` not actually resolve anything?

1587019340
pixelherodev
git seems awfully quiet post-0.6.0

1587019350
pixelherodev
commit-wise at least

1587020304
Xavi92
How can Builder execute/include another build.zig from another library?

1587020360
Xavi92
Just 'cd path_to_lib && zig build'? Or are there other, more appropiate methods?

1587020387
Xavi92
appropriate*

1587021196
Xavi92
Are always all struct members public if the struct is pub? Or could some of the members be private/internal?

1587022523
FireFox317
Xavi92, build.zig is just a regular zig file, so you can just `@import` the other build.zig file

1587022806
Xavi92
FireFox317: thanks!

1587022821
Xavi92
FireFox317: do you know the answer for my other question, BTW?

1587022992
kenaryn
Hello, please what does imply 'null-terminated'? for example, in the case of a string, does it mean ending with `\n` sequence? is it stripped off its LF byte? I do not understand the concept.

1587023008
mikdusan
ending with u8 value 0

1587023035
kenaryn
Isn't that a sentinel-value?

1587023069
Xavi92
kenaryn: yes, but it's also called null-terminated, at least in C

1587023072
mikdusan
yes, it's c-string style. zig calls them terminations "sentinels" . because we can teminate on other values too.

1587023214
kenaryn
Thank you mikdusan and Xavi92.

1587023272
Xavi92
kenaryn: you're welcome :)

1587023469
mikdusan
Xavi92: think of it like this, if the symbol is not `pub` then no other file can see it. And for it to be accessible outside current file, it has to be pub, and any of its same-file enclosing structs need to be too

1587023553
mikdusan
also I assume by "members" you meant NON-fields . if you're asking about fields, they don't have pub option

1587024029
Xavi92
mikdusan: oh. That would be useful when a library does not want to expose internal information to the user, but data must still be allocated

1587024190
Xavi92
mikdusan: in C, there are some ways to achieve this, all of them with pros and cons. One is to allocate the private resources dynamically and return an opaque pointer, other is creating a public interface with dummy names but same types as the private interface, and another would be creating a public interface as 'struct tag {char[X] buf};', where X is the number of bytes actually used by the private data structure

1587024230
Xavi92
mikdusan: the first is not acceptable on constrained devices where dynamic allocation is not an option. OTOH, Zig wants to target these devices too

1587024289
Xavi92
mikdusan: the latter two allow allocating the resources statically, but are not portable since private struct members could have different sizes according to the target (e.g.: pointers)

1587024382
Xavi92
mikdusan: the best way I could think of so far in Zig is based on the 'struct tag {char[X] buf};' method, where fortunately X could be extracted at compile-time by calling a comptime function.

1587024525
Xavi92
mikdusan: for example, 'const buf: [getSize()]u8 = undefined;' (or even '[getSize()]var u8', as I suggested on ##5056), where (in a separate file) 'pub fn getSize() usize {return @sizeOf(PrivateStructure);}'

1587024604
Xavi92
If I'm not mistaken, I think it could be even changed to 'pub fn getSize() usize {comptime return @sizeOf(PrivateStructure);}'

1587024900
Xavi92
FireFox317: @import() would work in many cases, but for my specific case the path is given by an environment variable which is obtained at runtime. Obviously, @import would not accept that, so what other solutions are available?

1587024913
mikdusan
I may have misled you by calling them "symbols". `pub` is for globals and yes, they can become exported symbols in a c-compatible fashion; but I was speaking only about globals

1587024997
mikdusan
now if you take a c-compatible structure and export it, then it is exported in an ABI fashion

1587025030
mikdusan
are the struct fields visible? yes. and the interface is through .h . so if .h says they're visibile then they are.

1587025048
mikdusan
c-structs are public iirc

1587025143
Xavi92
mikdusan: I know, but for improved modularity some libraries prefer hiding the internals to the user

1587025235
Xavi92
mikdusan: talking only about zig here (let's now forget about C), if I had to write a library that wants to hide the internals to users but still allow them to allocate the needed resources statically, how could that be achieved?

1587025392
antaoiseach
Hello all! I am working through the memory section of the master doc, and the following code throws an OOM error -

1587025651
mikdusan
Xavi92: right now libraries in zig are source. Zig wants to see it all. is that the kind of library you are talking about?

1587025657
kenaryn
How can I contribute to the documentation? In the technical documentation (i.e.

1587025699
FireFox317
Xavi92, uhm i guess then you could use a systemcommand and run `zig build` from that directory, maybe somebody else has a better idea tho

1587025866
Xavi92
mikdusan: not exactly. Let's look at it from another angle: in Rust, a struct can be public, but the visibility of each member can be assigned individually

1587025868
l1x


1587025870
l1x
nice one

1587025983
Xavi92
mikdusan: so you can have 'pub struct Bar {field: i32, pub other_field: i32}', where 'field' is private whereas 'other_field' is public. This means anyone using Bar can access 'other_field', but not 'field'; that one would be only accessed by the library itself

1587026067
Xavi92
mikdusan: that provides encapsulation, "similarly" to scope for class members in C++ (and only similarly)

1587026094
FireFox317
hey kenaryn, that is a limitation of the docs generator currently. The function is a generic function (because it takes a type) and i think there is not enough information emmited yet to be able to figure out that the return type is bool. You can find the relevant parts in

1587026191
mikdusan
antaoiseach:

1587026405
mikdusan
llx nice

1587026411
mikdusan
l1x: nice

1587026560
l1x
mikdusan: yeah i just got to know that project but it is extremely nice because zig supports so many platforms and the code can be leaned up quite a bit

1587026571
l1x
i am interested in how much code reduction it is going to be

1587026767
kenaryn
Thanks FireFox317 for the detailed answer.

1587026996
antaoiseach
mikdusan: Thank you! So for now I can simply follow the idiom of `const allocator = &<allocator initialisation>` consistently?

1587027059
mikdusan
yes but the lifetime of allocator is only good until end-of-scope

1587027112
mikdusan
if you did that in 2 steps it would be clearer; `var fba_state = FixedAllocator.init(...); const fba = &fba_state.allocator;`

1587027139
mikdusan
your other choices are make state global or put state itself on heap

1587027156
antaoiseach
mikdusan: Ah, okay. That does actually make it clearer to understand

1587027182
antaoiseach
Thank you!

1587027235
mikdusan
tbh, I always 2-step it.

1587027867
pixelherodev
I do the same

1587027871
pixelherodev
I 2-step everything really

1587027881
pixelherodev
I prefer to have multiple simpler pieces than fewer complex ones

1587027890
pixelherodev
e.g. I

1587027947
FireFox317
pixelherodev, neither `var i: usize = 0; while(i < 10) : (i += 1) {}`?

1587028079
antaoiseach
Interesting... I'll also follow the idiom then! :-)

1587028108
pixelherodev
FireFox317, that I do

1587028117
pixelherodev
I mean I don't do e.g. `a(b += c);`

1587028132
pixelherodev
Function calls should never contain assignments inline IMO

1587028146
antaoiseach
One more question - I am almost done with the master documentation. I was planning to start reaading the lib source code to understand the standard library better, especially for the data structures and algorithms in it. Is there any specific way you guys would recommend I go about it?

1587028150
pixelherodev
I think that allowing e.g. `if (a = 1)` to

1587028160
antaoiseach
I believe that documentation for the stdlib will be some time coming?

1587028168
Xavi92
Sorry for insisting, but is there any feasible solution to the issue I described above?

1587028273
FireFox317
antaoiseach, we have some experimental std library documentation:

1587028467
antaoiseach
Firefox317: that's a great suggestion - to start with the tests. I think I'll follow this route - should make it easier to trace the flow

1587028870
pixelherodev
Xavi92, what's the issue?

1587028916
Snektron
assignment in if statements can be useful in some cases

1587028939
Snektron
Assignment-in-while is a good example

1587029008
Snektron
But that rather points at a weird implementation of a language feature where you avoid having to repeat yourself in that specific kind of construction

1587029008
Xavi92
pixelherodev: it was a long conversation, please read

1587029068
Snektron
Didn't pub members get removed recently?

1587029153
Xavi92
Snektron: why were they removed?

1587029169
Snektron
I dont know, i just read it in the update notes

1587029197
Snektron


1587029235
Snektron
I would assume that members of private structs are still private, so if you return a private struct you get an opaque handle

1587029326
Xavi92
Snektron: if dynamic allocation is not available, then you can either return it from the stack or perform static allocation

1587029385
Xavi92
The former might be problematic on constrained devices with low amounts of RAM, while the latter needs to know the size of the private struct outside the module

1587029400
Snektron
i mean opaque as in you can't view the insides

1587029446
Xavi92
Snektron: I know what opaque means, but if the struct needs to be statically allocated, then the user must allocate the resources before calling the function

1587029494
Snektron
im not sure how we suddenly arrived at allocation

1587029593
Xavi92
Snektron: please read the following simple example in C:

1587029668
Xavi92
Here, a.c could happily modify any of the members from 'm', usually without knowing what they mean and often creating potential bugs, if 'my_struct' was only meant to be modified by 'b.c'

1587029680
Snektron
ah, like that

1587029785
Snektron
you'd best look up the relevant issue about removing them

1587029822
Snektron
Oh and also, the returning thing works different in Zig because of the result value locations

1587029825
Xavi92
Snektron: some libraries would do this ->

1587029854
Xavi92
But this is not portable since sizeof pointers changes between architectures, and is very error-prone

1587029899
Xavi92
Snektron: do you know which issue was it?

1587029926
Snektron
So in the first example you posted, you could just return my_struct from bar, and everything will be fine. There are some quircks with the mechanism though, but young language and all that i suppose

1587029936
Snektron
No sorry, i only learnt it through the update notes

1587030676
mikdusan
heh I'm still not clear on wether this is about public ABI or API ?

1587030767
mikdusan
those links are basically c idioms for library ABI barriers. hiding stuff from those users. Zig doesn't have an ABI.

1587031104
Xavi92
mikdusan: this is API AFAIK

1587031139
daurnimator
crap. I pressed enter and

1587031151
daurnimator
sorry everyone.... I am expecting this issue to take me a day or two to write out

1587031240
Xavi92
Snektron: returning my_struct from bar would be fine if the struct was small enough (as in the example), but it the struct was very large e.g.: 1024-byte long, you might face a stack overflow on some microcontrollers

1587031287
Xavi92
mikdusan: it has nothing to do with ABI as far as I can tell. It's just a matter of encapsulation and hiding the internals to library users

1587031293
mikdusan
daurnimator: accepted! /s

1587031351
Xavi92
Snektron: that's why static allocation is needed. Placing the large buffer on .bss instead of the stack avoids potential stack overflows

1587031408
Xavi92
Snektron: of course one wouldn't care when writing zig for a x86_64 CPU with GiBs of RAM, but the situation changes when facing a microcontroller with 2 KiB SRAM

1587031492
Xavi92
Snektron: and, AFAIK, zig also wants to target such devices. IMHO at least it should attempt to do so if it really wants to replace C, where very often is the only available language for microcontrollers

1587031650
FireFox317
Xavi92, static allocation is totally possible in Zig

1587031730
Xavi92
FireFox317: I'm not saying static allocation isn't possible, which I know it fortunately is. It's the fact of allocating statically an opaque structure from the user's point of view that is later casted into a private structure by the library

1587031816
mikdusan
.bss? yeah. zig makes use it

1587031818
mikdusan
use of it

1587031920
mikdusan
we already have std examples of static allocation that is private with interfaces made public. see std.heap.page_allocator, c.allocator, etc.

1587032157
Xavi92
mikdusan: I'm afraid I'm not explaining myself right

1587032291
Xavi92
mikdusan: std.heap.page_allocator is a static global variable used internally by heap.zig. Ignoring how std.heap works internally, what if two or more page_allocators had to be used simultaneously?

1587032500
Xavi92
mikdusan: (considering heap.zig does not know how many page_allocators will be used, since it is determined by the user who uses the library)

1587032566
mikdusan
page allocator is an interface to the operating system. the operating system offers a global page allocator. what's the issue?

1587032750
mikdusan
heap.HeapAllocator exposes an os-provided many-heap pattern. when used the way it's meant to be used, you get access to heap allocator's interface and that's all.

1587033786
Xavi92
mikdusan: again, I think I'm not explaining myself right. Nevermind, it's possible to do what I meant in Zig:

1587033863
Xavi92
mikdusan: I was only asking if there was a more idiomatic solution to it, but I guess this is the way to go. I'm glad Zig has powerful compile-time capabilities

1587033918
Xavi92
mikdusan: probably access() should take '*Op' instead of 'Op', so it is ensured the reference is modified

1587034217
Xavi92
mikdusan: hrm, using pointers triggers alignment errors ->

1587034547
mikdusan
`access(buf: *align(8) Op) !void {`

1587034573
mikdusan
or `(buf: *align(@alignOf(Priv)) Op)`

1587034773
mikdusan
and ... `var buf: b.Op align(8) = undefined;`  so you may have to make public the alignment requirement

1587034785
mikdusan
maybe there's a more elegant way. me shrugs

1587034882
mikdusan
oh three is: make Op a struct instead:

1587035029
mikdusan
`Op = struct { first: u8 align(@alignOf(Priv)), data: [@sizeOf(Priv)-1], }`

1587035069
Xavi92
mikdusan: that worked, although it feels a bit cumbersome ->

1587035286
Xavi92
mikdusan: unfortunately, 'pub const OpPtr = *Op align(OpAlign);' does not seem to be possible

1587035920
mikdusan
we can't do this yet today but there is an open issue for it:

1587035922
mikdusan


1587036086
mikdusan


1587036362
Xavi92
mikdusan: thanks for your help

1587036542
daurnimator
Unknown Clang option: '-target=linux-x86_64-musl'

1587036548
daurnimator
uh.... am I using zig cc wrong?

1587036689
daurnimator
doh. yes. need to s/=/ /

1587036766
mikdusan
-target x86_64-linux-musl

1587047886
Snektron
<Xavi92 "Snektron: returning my_struct fr"> (sorry for the late reaction) I don't think the result location semantics discriminate between stack, static or heap memory. Afaik its a kind of implicit transformation of  `fn a() Struct { return Struct{...};}` to `fn a(result:

1587047913
Snektron
where `result.* = Struct{...}` would be inlined to `result.a = ...; result.n = ...;` etc

1587047975
Snektron
I'm not certain on the details though

1587048283
fengb
Returning the struct at the same time it's built (`return Struct{}`) would be equivalent to passing a pointer

1587048328
fengb
We haven't guaranteed it for any other type of returns yet... but LLVM may choose to use a pointer under the hood

1587048357
Snektron
I'm pretty sure it doesn't work for `{const a = Struct{...}; return a;}`

1587048360
Snektron
I find that kind of odd

1587048373
fengb
I think it's in the pipe but it's not built yet

1587048399
Snektron
Seems like a basic block peephole optimizer would take care of stuff like that

1587048577
fengb


1587049246
foobles
i submitted a patch to my PR and i saw the automated tests on azure failed

1587049257
foobles
turns out the mac one just disconnected

1587049264
foobles
I didnt even see if it ran any tests at all

1587049281
foobles
i just submitted another patch, cleaning up formatting, and it seems to be working

1587049357
fengb
Yeah that happens :(

1587049372
fengb
Nobody's fault (except Microsoft 🙃)

1587049585
foobles
hoorayyy

1587049606
foobles
well im just glad i didnt accidentally blow something up with that original patch :)

1587052965
mikdusan
oh that is new. PR github has a "convert to draft" clickable

1587053018
fengb
Oh finally!

1587053081
AndroidKitKat
they do? nice

1587053203
ikskuh
can somebody explain what this does?

1587053385
fengb
You can create a PR draft which tracks your changes but doesn't let it get merged. Previously you can only

1587053402
ikskuh
ah

1587053445
mikdusan
or for me it's like "nah this PR is so good it doesn't need draft mode" and the CI runs and changes my mind

1587053540
fengb
Oh maybe it'll be better than close/reopen :P

1587054654
kenaryn
Hello again computerizing people. Please what is the intent behind the 'Avoid local maximums' narrative in zig zen philosophy? Perhaps a simple example would be in order to explain it to me :D (And Andrew, by the way, 'maximum' is a singular word; hence, it cannot be put with a trailing 's'. In Latin, you might want to use 'maximata' to express a plural concept, like 'eloh'/'elohim' in hebrew).

1587054720
fengb
I think technically the word is 'maxima' but that sounds super pretentious :P

1587054764
kenaryn
You may be tend to the thrust :)

1587054765
shakesoda
fortunately, we speak english, and there are no rules in english

1587054774
fengb


1587054781
shakesoda
noun any verb, verb any noun, plural any singular!

1587054805
shakesoda
capitalization!? foolish!

1587054813
shakesoda
WE USE CAPS ONLY TO YELL

1587054814
fengb
Basically it means, we shouldn't make decisions to fix short sighted problems. Sometimes we have to go backwards a little to reach the global maximum

1587054850
shakesoda
fengb: maybe the wording should be made more... plain

1587054860
shakesoda
i'm not actually sure i'd have ever interpreted it that way

1587054930
fengb
Like how Zig switched to `const Foo = struct` syntax. It was painful at first but now we don't even think about it

1587054958
fengb
I'm also not andrewrk so I'm interpreting his words too :P

1587055027
ikskuh
fengb: we all can only interpret the words of god

1587055029
ikskuh
<shakesoda> fortunately, we speak english, and there are no rules in english

1587055037
ikskuh
well, same rules apply to pretty much all languages

1587055049
ikskuh
like "oh yeah, let's just make that adjective a verb"

1587055053
fengb
Am I a prophet?

1587055068
kenaryn
Nicely put, thanks for your explanation fengb (and I suppose you're right, maximata doesn't not exist, but maximita means 'grandeurs'. Hence, you may be right about maxima, thanks for instructing me).

1587055083
fengb
I'm sure English especially would drive the French crazy :P

1587055100
kenaryn
I'm not crazy :D

1587055101
fengb
kenaryn: English isn't latin. We like to invent our own rules

1587055103
ikskuh
yeah it's maxima :D

1587055113
shakesoda
fengb: that's fine, everything drives the french crazy

1587055116
shakesoda
;)

1587055122
fengb
Some are Latin based. Some are German based. But mostly 'murican

1587055136
ikskuh
fengb: Kindergarten! Rucksack!

1587055146
kenaryn
but I regret main guidelines on github recommend to switch from en-GB towards en-US :/

1587055164
shakesoda
well, github is a us company

1587055171
shakesoda
or do you mean zig github

1587055184
kenaryn
github belongs to Microsoft so they it is US...

1587055193
kenaryn
so yeah*

1587055195
shakesoda
github was in the us to begin with

1587055218
shakesoda
so it makes sense that en-us would be preferred

1587055230
fengb
Zighub?

1587055244
kenaryn
zig github would be the same as Andrew is from NY

1587055257
ifreund
you want to write a website in zig?

1587055268
shakesoda
i'd consider it

1587055269
ikskuh
why not?

1587055278
ikskuh
static site generator in zig

1587055278
kenaryn
yeah let's all adopt emscripten in production :p

1587055299
shakesoda
i was thinking in the generating html sense, but okay

1587055345
fengb
Like our docs?

1587055345
ifreund
the generator sense makes more sense yeah, though i was thinking of the wasm/emscripten sense originally

1587055399
kenaryn
It will be a event when we'll reach Tier 1 support

1587056420
kenaryn
Please why `assert((std.math.maxInt(u32) +% 1) == 0);` return an `assertion failure`?

1587056557
fengb
`std.math.maxInt(u32)` returns a comptime_int, so it doesn't have a concept of wrapping

1587056587
fengb
Only runtime ints can be wrapped. comptime_int has 'unlimited' storage

1587056677
kenaryn
Thanks, you're kind.

1587056690
fengb
I'm really not :P

1587056761
kenaryn
i would have attempt a joke but we french are too prudish :D

1587056803
kenaryn
Are you crazy? no i'm just fucking chaotic neutral!

1587057271
fengb
Nah I just have low wisdom

1587057615
kenaryn
you're using a concealment spell you cunning buddy ^^

1587057641
kenaryn
Please is there a reserved key-words available list somehere? to avoid name collision of course.

1587057737
ifreund
kenaryn: don't think so, feel free to filter by the accepted label on the issue tracker though

1587057752
ifreund
of the top of my head `anytype` will be a keyword soonish

1587057949
kenaryn
Yes I read about that, thank for the filter-related tip.

1587058095
fengb


1587058384
fengb
I’m really liking the new allocator direction

1587058656
Xavi92
Hi there :)

1587058696
owl_000
hi

1587058740
owl_000
good wishes zig

1587058850
kenaryn
Didn't know your reply, thanks fengb who is non-kind :D

1587058980
kenaryn
doesn't the std.testing.allocator intended for early prototypes before replaced by a more specific ones?

1587058991
kenaryn
does*

1587059157
fengb
It’s mostly for running the test suite

1587059193
fengb
Libraries typically accept any allocator so in test mode, we can give it a special allocator that’s decently fast and checks for stuff like leaks

1587059220
fengb
Not recommended for actual programs

1587059261
fengb
In the future, it will have more robust debugging checks

1587060183
kenaryn
Thanks again.

1587060266
kenaryn
I think early prototypes concepts in Zig competes with some of Python's market segment and I'm quite pleased about it.

1587060303
kenaryn
Python's use cases I mean.

1587060621
Xavi92
I would like to ask you all to please review this issue so it grabs more attention from the community in order to make a decision ->

1587065799
kenaryn
Hey dude, be cautious with endlessly enhancing the language's parsing expression grammar. D has lost himself and never developped its own identity by being obssessed with 'what/how are the other languages doing?' narrative to end like a scripting glue for C++ codebase and in the process, became more and more complex to deal with.

1587065819
kenaryn
to end up*

1587065887
companion_cube
it was started  by C++ devs, though, maybe it was already lost

1587065899
kenaryn
lol... you're right

1587065910
BaroqueLarouche
C++ compiler dev to be exact

1587065912
kenaryn
By the way, are you French or Canadian?

1587065925
BaroqueLarouche
me ?

1587065936
BaroqueLarouche
Québecois

1587065937
kenaryn
you both actually

1587065943
kenaryn
Allright :)

1587065951
companion_cube
(well, technically, I'm both, but I grew up in france)

1587066115
kenaryn
A small language would have more traction and reach a critical mass more rapidly if the entry barrier is quite low and would be a favorable reason to migrate a existing industrial basecode towards Zig. For example, everybody has at least notions of Shell because it IS a small language.

1587066155
companion_cube
you mean `sh`? what a nightmare

1587066160
companion_cube
but Zig is still pretty small

1587066168
kenaryn
Hence, the employers are more favorable to its adoption in professional context because he's aware of a rapid learning curve from his employees.

1587066218
kenaryn
Yes, there's no function in 'sh', but I had 'zsh' in mind actually. Never mind :)

1587066250
companion_cube
zsh is … not small :D

1587066510
kenaryn
Please do `orelse` and `catch` have equal priority during the semantic analysis? I do not know whether there is a precedence or not for operators in the same line in the 'Precedence operators' documentation subpart.

1587066582
kenaryn
Another example would be: is `<<` and `>>` have equal precedence?

1587067055
ikskuh
kenaryn, there's an issue regarding precedence

1587067075
ikskuh
in short: if the precedence is not obvious (like 3 + 4 * 5) then you must put parenthesis around it

1587067781
Xavi92
kenaryn: "Hey dude, be cautious with endlessly enhancing..." <- is that because of what I posted above?

1587068139
kenaryn
Yes, I'm sorry for being rude, you are not a dude.

1587068348
Xavi92
kenaryn: np. I don't think my proposal adds any complexity to the language though

1587068500
Xavi92
kenaryn: the proposal just adds zero-cost safety that IMHO should be already there. I'm the first to think Zig should be kept as simple as possible, but not simpler

1587068617
Xavi92
I'm the first who agrees*...

1587068627
kenaryn
Xavi92: It's nice to know you're following Albert's Einsten philosophy.

1587068692
Xavi92
kenaryn: glad you caught the reference :)

1587068741
kenaryn
I admit being mistrustful towards your proposal because it's based on a beginner's bad practice (like you eloquently put it).

1587068893
kenaryn
if ( zig_user_skill == low) then decrease_readibility=true and force_convention_guideline=false. You get the picture.

1587068940
Xavi92
kenaryn: Still I think a beginner (or anyone in general) would prefer a compile time error than shooting on his/her foot because of a bug caused by non const-correct code

1587068984
kenaryn
In order to resume, your postulate is pessimist. That's my opinion.

1587069000
kenaryn
You're right about that.

1587069251
Xavi92
kenaryn: C makes everything mutable by default (including pointers, which are my main motivation behind the proposal) and, while it might make the language more readable to beginners, IMO it's just an illusion. Const-correct code is less readable in C, but that doesn't mean it's superfluous

1587069282
kenaryn
Nevertheless, if 'Only one obvious way to do things.' is correcly enforced, there is no reason to project oneself in a beginner's shoes perpetually because we SHOULD hope that's the begginner's user base is still fleeting (i.e. short-lived) thanks to a allegedly learning curve (except the fact that new begginner's are endlessly replaced for the sake to the language continuity).

1587069301
shakesoda
part of what I don't like is that it throws syntax in yet another place, and I'd really rather have a language that favors not making you write more than you need to

1587069308
kenaryn
smooth learning curve* I mean

1587069357
foobles
"prioritize reading code over writing code"

1587069395
kenaryn
Agreed with you all, as strange as it may look like.

1587069449
kenaryn
A snippet is insufficient to take action, a real use case would be sane to balance pros and cons.

1587069462
Xavi92
kenaryn: unfortunately I've read many non const-correct libraries in C written by not-so-beginners from big companies, which force me to remove const checks from my code while crossing my fingers to avoid compiler warnings

1587069521
shakesoda
I'm not entirely even convinced this is a real problem in zig as it stands, since it's a lot harder to violate to begin with.

1587069543
shakesoda
zig is already rather heavy on the syntax for stuff, too, I'd rather have less than more

1587069544
kenaryn
I recommend you to add your last sentence to a Nota bene in your github proposal.

1587069595
shakesoda
note that my complaint applies to writing out *const and *var on everything, I'm indifferent if it just removes writing const and makes you write var

1587069622
Xavi92
shakesoda: again, I don't think this proposal should be left out because of this reason. I'm sure there are other places in the language (can't tell now since I'm not that experienced in Zig) that might need or have already been simplified from their initial revision

1587069641
shakesoda
default immutability is not something I have a complaint about, just the implementation of it increasing the total amount of syntax

1587069825
kenaryn
Like Andrew pointed out in the release notes, the whole point of zig is to rethink abstraction concepts, maybe, it's time to stop reasonning like C and adopt a new paradigm. But I still think there's never enough safety mechanisms in any language.

1587069906
Xavi92
kenaryn: wouldn't that imply removing the concepts of pointers and array?

1587069910
kenaryn
A strong use case would be ideal to help settle the proposal.

1587069988
Xavi92
kenaryn: that's saying I would have to justify const-correctness. I'm sure the Internet has lots of articles on that, regardless the language

1587070059
Xavi92
kenaryn: unless I've misunderstood you. Which strong use case would you propose?

1587070175
kenaryn
I do not know, I'm speaking of a real codebase from one or several zig's user(s) for at least medium-size projects to report a feed-back based on practical experience.

1587070240
shakesoda
a large amount of zig's entire appeal is that you can reason about it like C.

1587070280
shakesoda
I'm free to scribble on pointers all I want as long as I tell it I'm doing so on purpose

1587070331
kenaryn
Maybe, your proposal will lead towards unsuspected new mechanisms in the next weeks. I forbid you to lose hope. You SHOULD keep defending your initiative :)

1587070365
Xavi92
kenaryn: thanks for your kind words :)

1587070577
Xavi92
kenaryn: OTOH, if such a codebase existed today (which I don't know), I don't think it's a representative example. Zig users today are much likely experienced with other programming and are used to common pitfalls in similar languages such as C or C++, so they might not find explicit mutability necessary. But that might change in the future as the number of user grows and first-time programmers are introduced to Zig

1587070596
Xavi92
...with other programming languages* and are...

1587070651
companion_cube
does Zig really stand a chance of becoming a really mainstream language? I mena, beyond kind of power users?

1587070652
kenaryn
shakesoda, you're right as usual. Being convinced to switch to another language thanks to an already implemented and mastered one is no-doubt a driving force for the latter one.

1587070680
companion_cube
(I'd say C is not exactly mainstream either in that sense, at least on the desktop and server)

1587070692
kenaryn
but what will become of Zig in 5-10 years if it doesn't develop its own identity (beware of Dlang syndrom lol).

1587070763
kenaryn
C is still a mover for embedded programming industry.

1587070797
shakesoda
I use C extensively in games, graphics

1587070813
kenaryn
Now I'm jealous.

1587070823
shakesoda
zig has utterly destroyed my need to deal with C++ for anything personal

1587070833
shakesoda
huge quality of life improvement, there

1587070862
Xavi92
kenaryn: I work for the embedded industry and I feel the need for the industry to move for something else than C, at least in a long term

1587070966
Xavi92
shakesoda: also liked Zig a lot. Coming from C and C++, I learnt some Rust (even got the official book) but after reading real-world code I didn't feel it really fits on constrained hardware. And I also feel Rust is becoming very complex, similarly to what happened to C++

1587070972
kenaryn
And mutability by default is a blocker you mean? or is it part of something more that you're waiting to propose too? (no offense lol)

1587071025
kenaryn
It's a trick question, do not answer it :)

1587071035
shakesoda
rust has a lot of good ideas combined into one extremely complicated and frustrating mess

1587071073
companion_cube
complicated compared to what, though?

1587071078
kenaryn
yeah the borrow checker you mean... not appropriate for numerous use cases.

1587071080
shakesoda
everything other than C++

1587071094
companion_cube
seems simpler to me than, say, scala, or D

1587071122
shakesoda
rust just isn't my thing.

1587071134
shakesoda
but it gets a lot of the basics right

1587071218
Xavi92
companion_cube: I find C++ complicated since it has many (IMHO sometimes too many) ways of doing things. One could read C++ from two or three programmers and none of them might look similar e.g.: STL, Qt C++ or Boost look like different languages from my own perspective

1587071219
kenaryn
replacing c++ firefox's codebase was the Rust raison d'être, it was never intended to become industrial-wide adopted (my opinion only of course).

1587071245
companion_cube
Xavi92: I'm saying rust isn't as complicated as C++

1587071276
Xavi92
companion_cube: I didn't said that, I just meant it

1587071289
mikdusan
it's funny what happens when you build an industrial tool to handle a huge project (re: rust for firefox/mozilla? codebases)

1587071291
Xavi92
(or is heading towards to)

1587071300
companion_cube
I don't think so, it evolves quite slowly

1587071301
mikdusan
git is another example. made for a huge project, and now git is everywhere.

1587071337
companion_cube
(besides, C++ added things it was never designed to do and made it even worse, like move; what could rust possibly add that'd be that bad?)

1587071355
Xavi92
Good example :)

1587071369
shakesoda
c++ is built on bad ideas to begin with, so rust will always have advantage

1587071397
shakesoda
although maybe i should avoid getting too deep into that holy war

1587071412
Xavi92
Exactly :)

1587071412
companion_cube
I mean, rust's foundations seem pretty sturdy to me

1587071418
companion_cube
enums + move + borrowing

1587071424
companion_cube
the rest is nicetise

1587071425
mikdusan
if you look closely right now, zig is building in what it needs to cross-compile. from the get-go, comptime access to all this information is available. and sooner or later people are going to say "why am I bothering mucking with building cross toolchains, I can just use zig for .c, .cpp or .zig"

1587071431
fengb
I find Rust's syntax to be very noisy, and I can't wrap my mind around the borrow checker

1587071466
Xavi92
companion_cube: also lambda functions and lifetimes

1587071480
shakesoda
lifetimes are one of the most cryptic programming concepts i have ever encountered

1587071488
companion_cube
lifetimes are paired with borrowing

1587071512
companion_cube
I'd add traits to my list, and say lambdas are just sugar for traits :)

1587071517
shakesoda
it is /incredibly/ easy to get into mystifying and hard to resolve situations when you get into that stuff

1587071518
Xavi92
companion_cube: I know, but in Rust they need an additional specific syntax

1587071530
shakesoda
anyway, I want my language to be dumber than all that

1587071531
BaroqueLarouche
When I tried Rust and have a start of a 65816 assembler, I found it hard to deal and couldn't imagine my coworkers at the time dealing with it.

1587071546
shakesoda
zig is the kind of dumber that I want

1587071551
companion_cube
Xavi92: C++ does, too… :)

1587071552
mikdusan
rust surprised me in how long it took to bring in non-lexical lifetimes around. when I first tried rust, the lexical lifetime issue was very disappointing

1587071564
companion_cube
indeed. I think it was just hard to implement right

1587071565
fengb
I tried to learn Rust but all I got was a slap in the face :/

1587071570
BaroqueLarouche


1587071590
mikdusan
i agree it was a hard thing to implement, but it's like a cornerstone of the language

1587071595
Xavi92
companion_cube: my experience in Rust is that it took me weeks to understand user-level code. In Zig it took me less than three days to understand the std library

1587071624
companion_cube
I agree, but zig will have more runtime errors that you need to learn how to debug

1587071630
companion_cube
(if you're not already used to C and gdb, that is)

1587071646
shakesoda
Xavi92: that's kind of where I stand with it too, as with many complicated C++ codebases

1587071663
mikdusan
and to be honest, I feel like rust dropped the ball and deferred that opportunity to get the lifetimes better

1587071670
shakesoda
zig just doesn't let you build the same nature of demons

1587071671
Xavi92
companion_cube: well, then we can eliminate at least one of this possible runtime errors by introducing explicit mutability, as suggested on my proposal :)

1587071677
kenaryn
Xavi92, I would like to add that immutability by default is a good point to conquer medical software's market segment for it made zig more safe and can compete with Eiffel.

1587071686
shakesoda
you can certainly make an awful demon in any language, mind you

1587071696
fengb
I don't think Rust is bad. I just don't get Rust

1587071707
fengb
It's just too much for me

1587071707
shakesoda
I also don't think rust is bad. it's bad for me.

1587071738
fengb
And I think it's great that we have a language that can be "fully safe"

1587071740
shakesoda
I do, however, think C++ is bad, and I only suffer at its hands because I'm being paid to.

1587071742
shakesoda
:D

1587071753
fengb
But I'm not writing medical devices. I'm making stupid emulators

1587071794
companion_cube
so… talking about footguns… why no RAII? :s

1587071812
shakesoda
the moment zig has raii is the moment i drop zig

1587071820
shakesoda
it is the champion of footguns, defer is better in every possible way

1587071825
fengb
RAII is lifetime management. I'm not sure I want to deal with that

1587071840
Xavi92
I don't think Rust is bad either. Actually, the good thing is programs usually worked once got them to compile. But I feel it more difficult to port into small microcontrollers, which is what I enjoy working on (and it's what I do for a living, too)

1587071842
companion_cube
shakesoda: why is it more a footgun than defer?

1587071856
companion_cube
to me that's the opposite, a small bit of RAII saves you from leaking resources

1587071857
shakesoda
because defer hides nothing, raii is explicitly hiding control flow

1587071863
kenaryn
I'm under the impression that among the 187 zig's contributors, 186 have alimentary job and only 1 live from his passion.

1587071882
fengb
Maybe it can be better with something less anal than Rust, but with better language support than C++

1587071887
companion_cube
shakesoda: hmm, what if there was an equivalent of `try` for resources? :)

1587071891
Xavi92
kenaryn: I don't think you need to go to the medical market for that, nor the need to compete with Eiffel. Any embedded device that needs to operate for days or months (IoT anyone?) should benefit from safety features

1587071900
companion_cube
you'd have to explicitly say "clean  that at the end of the scope"

1587071915
fengb
Don't you love how IoT runs on Python and Javascript? :P

1587071917
companion_cube
and couldn't forget, unless you explicitly choose to discard the resource

1587071948
shakesoda
imagine how awful interfacing with c would become

1587071970
companion_cube
I'm not following?

1587071973
shakesoda
I think I will just stick to a leak checking allocator

1587071982
kenaryn
I agree with you Xavi92. Good point.

1587071984
companion_cube
not all resources are memory

1587071999
Xavi92
fengb: Not on anything I have access to as a programmer. Ever. :)

1587071999
companion_cube
but error sets already make it weird to interact with C, don't they?

1587072033
fengb
Please don't trust the leak check allocator. It's dirt stupid >_>

1587072045
shakesoda
fengb:

1587072046
fengb
It's a good heuristic but by no means robust

1587072064
fengb
Oh okay

1587072071
shakesoda
the standard one is handy, but not strictly what I mean

1587072079
Xavi92
I like the 'defer' concept, though. Saves boilerplate code (or goto statements) I'd have to write in C instead

1587072161
shakesoda
defer and errdefer do pretty much everything I want for cleaning up on scopes. I'm not particularly opposed to some hint you could add to indicate the caller will have cleanup to do, though

1587072195
shakesoda
and they're dirt simple

1587072196
Xavi92
It'd be even better to somehow force the user to use 'defer' after specific functions (usually initialization ones), but I don't want to flood Zig's github with proposals :)

1587072208
shakesoda
I very much want dirt simple

1587072210
companion_cube
yeah, I  think it's more explicit indeed

1587072213
companion_cube
just like `try` really

1587072228
companion_cube
explicit cleanup code that you can defer/errdefer or discard

1587072246
shakesoda
this is the same complaint I have with most languages, really, they do all kinds of complicated crap that I have no desire for. I want simple.

1587072273
companion_cube
but ofc different people want different things.

1587072278
companion_cube
it's always a tradeoff

1587072283
fengb
There's a floating proposal for resources. andrewrk still wants to handle async cancellation

1587072300
shakesoda
robustness and comprehensibility fall off like a rock the further away from simple you get :)

1587072319
shakesoda
if all your complexity is geared toward one of them you can subvert one of them.

1587072357
companion_cube
damn I'd love to see serenityOS rewritten in Zig

1587072360
fengb
Or in the case of

1587072362
companion_cube
it's such a crazy project

1587072365
fengb
C++, subvert both!

1587072380
shakesoda
fengb: C++ subverts all positive attributes you could have

1587072549
Xavi92
:)

1587072556
Xavi92
Good luck, shakesoda!

1587073246
Xavi92
companion_cube: didn't know about serenityOS. Looks like a nifty project :)

1587073308
Xavi92
companion_cube: do you know the system requirements for it? I have a spare AMD K6-II laptop that might enjoy running it :)

1587073322
companion_cube
it's pretty cool, and they have an IRC channel

1587073330
Xavi92
companion_cube: just joined lol

1587073339
companion_cube
mostly qemu I think but these days it works on

1587074204
Xavi92
Bed time. See ya!

1587074308
fengb
Good night!

1587076299
fengb
;.;[[=[

1587076307
foobles
bless you

1587076308
fengb
Sorry, toddler attack

1587076402
fengb
It's a series of sad emojis

1587077966
pixelherodev
Don't apologize, I'm curious what he has to say!

1587077986
pixelherodev
It's a treatise on why `[[` should be the same as `[` in shell scripts!

1587079911
Snektron
<companion_cube "damn I'd love to see serenityOS "> Someone is making a nice kernel i believe

1587079968
Snektron


1587081398
r4pr0n
is there something like a enumerate in zig or do i have to use a while loop instead of a for loop there?

1587081424
fengb
enumerate? Like adding an index?

1587081430
r4pr0n
yeah

1587081444
r4pr0n
i have a arraylist and want to iterate over it and i have a special case for the last iteration

1587081454
fengb
`for (slice) |item, i|`

1587081566
r4pr0n
oh that works? nice

