1593136447
leeward
Should there be a GenericReader that anything that wants a reader can accept if it's willing to tolerate the overhead of runtime dispatch? It seems like writing functions that take `Reader(std.fs.File,std.os.ReadError,std.fs.File.read)` is a bit limiting.

1593136487
leeward
It could be a part of Reader, to minimize code duplication.

1593136519
fengb
Biggest problem with runtime dispatch is mixing errorsets

1593136551
leeward
Does anyerror help?

1593136883
leeward
I guess an alternative is to have every function that wants a Reader also want a type so it can specify what kind of Reader. That leads to madness: pub fn thingWithReader(ReaderType: type, reader: ReaderType)

1593136897
leeward
Huh, maybe it's not tooooo bad.

1593136924
leeward
thingWithReader(@TypeOf(my_reader), my_reader)

1593137142
leeward
No, it is. fn map(I: type, T: type, fn(I) T, iter: I) I

1593139104
marler8997
the nice part about using generic readers in the standard lib is that you can always wrap them with a common type for runtime dispatch

1593139221
marler8997
so it allows the application to control the trandoff between 'generic bloat' and runtime overhad

1593139232
marler8997
man my typing is bad today

1593139260
daurnimator
andrewrk: I saw you closed

1593139425
leeward
marler8997: Right. I'm just suggesting that maybe that common type should be included in the standard library. Let people choose between the bloaty looking code and runtime overhead without writing as much code.

1593139461
marler8997
leeward, gotcha, something to explore

1593139582
marler8997
daurnimator, it took me a minute to get what your PR was doing...but now I see, that's pretty clever

1593139605
marler8997
you're limiting the type by the "cardinality" of the element type set

1593139655
marler8997
wait I don't think I get it anymore...what if you have an infinite number of duplicate values?  Maybe I didn't get it

1593139900
daurnimator
marler8997: max(usize) is the max number of bytes on a machine. if you have a 2 byte element, you can't have max(usize) of them.

1593139931
marler8997
I don't understand why not?

1593139939
marler8997
you could have max(usize) of zeros of 2-byte elements

1593139946
marler8997
all set to zeros right?

1593139950
leeward
Something something segmented memory?

1593139960
leeward
Isn't usize defined as the size of a pointer?

1593139966
marler8997
yes

1593140021
daurnimator
marler8997: how?

1593140051
daurnimator
marler8997: you can't have 2^64 * 2 byte elements on processor that only has 2^64 bytes of memory

1593140064
marler8997
oh!

1593140075
marler8997
I see now

1593140112
leeward
I feel like I've used a processor that had different sized physical and virtual pointers, so the machine could have more than <virtual pointer size> bits of address space.

1593140114
marler8997
I like it

1593140148
leeward
Unfortunately, the ISA for the one I'm thinking of is proprietary and I don't have a copy. I'm probably wrong anyway.

1593140182
daurnimator
leeward: isn't every processor like that? even x86_64 and arm64?

1593140275
marler8997
leeward, yes that's the case for the old 16 bit 8086 processors

1593140302
marler8997
actually modern processors boot in that mode

1593140405
marler8997
also consider the 6502 8-bit processor, with 16K of address space

1593140480
marler8997
I wonder how Zig's types would look on the 6502...

1593140563
marler8997
as I think about it, I think usize would have to be 16 bits

1593140828
leeward
marler8997: It definitely would.

1593140883
leeward
Yeah, 8086 and successors have segmented memory, but I think physical pointers on amd64 are 64 bits...haven't checked though.

1593141361
marler8997
segmented memory is a b***, here's my 8086 bootloader if you're interested in learning more about it:

1593141498
leeward
Ugh, I haven't looked at 8086 assembler since college and I don't miss it.

1593141595
stripedpajamas
during zig test, is a segfault without stack trace something to report as an issue ?

1593141617
leeward
Are you running master?

1593141624
stripedpajamas
yes

1593141630
leeward
seems likely

1593141646
stripedpajamas
seems likely that it would happen or seems likely that i should report it

1593141724
leeward
that you should report it

1593141748
leeward
zig test runs under debug, so if you found a way to make it not dump a trace, it's almost definitely a bug

1593141769
leeward
Unless you're doing something like -Drelease-fast

1593142851
stripedpajamas
no release-fast

1593142854
stripedpajamas
just normal zig test

1593142868
stripedpajamas
will try to cut out my cruft and to demonstrate in an issue

1593146157
andrewrk
daurnimator, worth considering

1593146226
andrewrk
ok, self-hosted Module.zig is getting big enough that I'm going to try out ZLS now :D

1593146294
leeward
It works pretty well.

1593146703
wilsonk
Woot, it took about 5 hours, but I managed to replace the keyboard on my daughters Macbook Pro 13" (A1708) and everything works!!! What a pain, had to rip out the old acetone splattered keyboard one key at a time with pliers, then pop all the rivet heads off one at a time and then super glue the keyboard back down via the rivet posts...then put it all back together. Whew.

1593146810
wilsonk
also a hint for others...get high quality, hardened tip torx screwdrivers for that job because I managed to strip two T3 drivers and had to go buy a hardened one to finish

1593147330
andrewrk
congrats wilsonk

1593147715
andrewrk
gat damn this zls is snappy

1593150439
marler8997
ok I disabled all the extra assertion checks on the C and page allocator and now the drone CI is back to 30 minutes instead of 1h15m

1593150450
marler8997


1593150474
marler8997
oh wait, looks like other builds also take 30m

1593150499
marler8997
so drone must just have some fast and slow machines

1593151101
andrewrk
now that I'm willing to believe

1593152100
andrewrk
oof just had to work around a nasty miscompilation :(

1593152330
pixelherodev
Ouch

1593152334
pixelherodev
That's always annoying

1593152425
andrewrk
I think "no analysis/codegen bugs in stage2" is a reasonable goal to have

1593152442
pixelherodev
For sure

1593152446
andrewrk
where "bug" is a distinct concept from "unimplemented"

1593152453
pixelherodev
Those should also definitely be in the test suite

1593152461
pixelherodev
Though how to do that is unclear...

1593152469
pixelherodev
Fuzz testing, maybe?

1593152503
pixelherodev
Would be nice to fuzz test the parser, for instance

1593152507
andrewrk
I just mean from an meta-organizational standpoint. if there are open stage2 analysis/codegen bugs, I think it's worth prioritizing those before working on new features

1593152523
pixelherodev
Ahh, gotcha

1593152525
pixelherodev
Yeah, agreed

1593152538
andrewrk
whereas with stage1... maybe we can build a new ship before the old one sinks :)

1593152541
pixelherodev
Going to finish up the test harness PR rn

1593152548
pixelherodev
Hopefully tomorrow I'll get back to codegen

1593152596
andrewrk
I'm 80% through with adding arg, block, and break ZIR instructions, function parameters, and runtime conditional branching

1593152625
pixelherodev
Oh whoops

1593152631
pixelherodev
Should have gotten the function parameters done more quickly :(

1593152648
pixelherodev
I can push what I had locally to a branch if that helps?

1593152695
andrewrk
actually if you want to take a crack at it, I left things in a good state for you

1593152698
andrewrk
have a sec?

1593152723
pixelherodev
What for?

1593152749
pixelherodev
Oh yeah, just remembered that I need to rebase my function parameters stuff before I can extend it

1593152767
andrewrk
I'm going to give you something to rebase on

1593152771
pixelherodev
Ah, okay

1593152790
pixelherodev
andrewrk: should I also `case.addCompareOutput` -> `case.compareOutput` ?

1593152917
pixelherodev
The only problem there is addError...

1593153049
andrewrk
pixelherodev, check the commit message:

1593153085
pixelherodev
Got it

1593153087
andrewrk
I'm going to spend tomorrow morning preparing for showtime, so you have some time to work on the machine code stuff if you want to

1593153089
pixelherodev
I had basic codegen

1593153101
pixelherodev
So I can just copy a bit over and tweak it a bit

1593153112
pixelherodev
Shouldn't be too hard to get integer parameters working at least

1593153232
pixelherodev
andrewrk: what should be the name for error cases?

1593153237
pixelherodev
exe/exeZir -> addExe

1593153253
pixelherodev
_error / errorZIR -> addError ?

1593153257
andrewrk
nearly all the compile error test cases we have use build-obj

1593153273
pixelherodev
I mean in ctx

1593153275
pixelherodev
not case

1593153283
pixelherodev
The convenience wrapper that just does `addObj().addError`

1593153291
andrewrk
compileError

1593153299
pixelherodev
Gotcha

1593153415
andrewrk
well, if we measure self-hosted progress by how many lines of code Module.zig is compared to ir.cpp then self-hosted is 11% done 🙃

1593153464
pixelherodev
Hopefully we can get self-hosted to have more functionality than stage1 in a fraction of the total code (including LLVM + Clang)

1593153480
pixelherodev
(albeit with lighter optimization passes)

1593153484
pixelherodev
(not that that's a bad thing)

1593153982
pixelherodev
andrewrk: to confirm, the symbol_name in a ZIR export is the name given in the binary, and the decl_name is the name of the internal symbol to reference?

1593154005
pixelherodev
so e.g. `@0 = str("_start") \ @1 = export(@0, "start")`?

1593154170
andrewrk
yes

1593154191
pixelherodev
Gotcha, thanks

1593154201
pixelherodev
Working on adding collision detection

1593154229
pixelherodev
(so that e.g. `@1 = export(@0, "start") \ @2 = export(@0, "start")` fails)

1593154296
andrewrk
don't forget to test it with incremental updates too

1593154308
pixelherodev
True

1593154319
andrewrk
for every error we gotta test getting

1593154326
pixelherodev
Gotcha

1593154352
andrewrk
ZLS is gonna be ridiculously fast with this design

1593154361
pixelherodev
All exports are in export_owners, correct?

1593154377
pixelherodev
Wait, what does this have to do with ZLS?

1593154401
andrewrk
I mean IDE integration using this backend

1593154428
pixelherodev
Ah, gotcha

1593154432
andrewrk
I suggest to read the fields and doc comments in Module that match a search for "export"

1593154463
pixelherodev
Ahh, I want to check decl_exports, not export_owners, correct?

1593154710
pixelherodev
andrewrk: for duplicate exports, the new export should still be added, but marked as a failure, and the error added, correct?

1593154830
pixelherodev
Got the ZIR one passing :)

1593155387
pixelherodev
Ugh, broken on incremental compilation though :(

1593155495
pixelherodev
Ahh, messages need to be removed from failed_* on each round of incremental compilation

1593155709
pixelherodev
Got it working :D

1593156073
pixelherodev
Azure is consistently the only failing CI, and it won't let me see why ugh

1593156332
pixelherodev
... isn't AutoHashMap(T, void) just an ArrayList(T)?

1593158748
marler8997
I see ArrayList as an ordered collection of items, I would expect AutoHashMap(T, void) to function be an unordered set of unique items

1593158764
pixelherodev
Ah, true

1593158766
pixelherodev
Thanks

1593158832
pixelherodev
Slowly getting more of the tests up and running :)

1593158850
pixelherodev
Function redefinitions, missing function names, etc

1593158871
pixelherodev
Ohh, Azure fails on old commits on a PR automatically when you push new ones

1593158874
pixelherodev
Oops

1593162142
pixelherodev
Ugh, can't push new changes because it'll break CI again :P

1593162725
pixelherodev
Biggest remaining thing for that PR now is docs

1593163199
pixelherodev
Oh hey, I

1593163202
pixelherodev
I even opened a PR lol

1593163219
pixelherodev
#5411 - the biggest blocker was the test harness :)

1593163249
pixelherodev
Going to have to redo it largely, given that it's ancient in stage2 terms, and it did a refactor which it shouldn't

1593168987
pixelherodev
andrewrk: unless there's anything you want changed, I'm satisfied with #5708 now

1593169172
pixelherodev
Not even going to try rebasing function-args onto master; going to just redo it instead

1593169306
pixelherodev
#5505 is good to go, too

1593169312
pixelherodev
CI passed :)

1593173539
pixelherodev
`:9:12: error: TODO implement passing parameter type i32` Getting there :)

1593174695
pixelherodev
Okay!

1593174700
pixelherodev
Integer passing works! (i think)

1593174715
pixelherodev
Just need to do a bit of refactoring, and add in some test cases

1593178445
pixelherodev
Heh

1593178454
pixelherodev
Working with Zig now with stage2 reminds me of my custom backend lol

1593178463
pixelherodev
Using @ptrToInt for strings, for instance :P

1593180980
pixelherodev
Working with ZIR is already so pleasant :)

1593180999
marler8997
why's that?

1593181069
pixelherodev
Everything just works

1593181519
marler8997
what backends is zir starting out with?  x86_64? i386?

1593181560
pixelherodev
x64, for now

1593181567
pixelherodev
There's some x86 in place as well, since they share some code

1593181589
pixelherodev
But x86 isn't actually usable at all, since some basic codegen isn't in place for it

1593181596
pixelherodev
It'd be really straightforward to add though

1593181600
marler8997
gotcha

1593182097
antaoiseach
Do you guys know if any third party people generate llvm+lld+clang, specifically for macOS? The one from homebrew does not work, and my machine cannot handle building from source.

1593182121
antaoiseach
Right now I'm making do with the master binary, but I wish to resume building from source (if possible without waiting for LLVM 11!)

1593182166
antaoiseach
(I've asked this question over on #llvm as well, awaiting response :-))

1593182236
pixelherodev
There we go! `:49:19: error: expected usize, found *const [14:0]u8`

1593182245
antaoiseach
Second question - for a general purpose library, which existing allocator would you recommend? I'm leaning towards arena allocator, but not sure if that's the best choice - memory requirements similar to something like a json library, say

1593182278
ifreund
antaoiseach: usually zig libraries accept an allocator from the user

1593182300
marler8997
if it's a library, usually you just take an allocator from the client/application so you don't need to choose one

1593182310
ifreund
you can of course wrap that allocator in an arena if it makes sense though

1593182560
antaoiseach
ifreund: marler8997: ah yes, that's right

1593182573
antaoiseach
I was mixing up the client side of it as well

1593182596
antaoiseach
So in case I also provide a parser of sorts that would read in a bunch of text and use the core lib ... in that case?

1593182682
mq32
marler8997: it was a mistake to watch the allocator issue…

1593182687
mq32


1593182705
shcv
what's the best way to substitute characters in a string? E.g. "-" -> "_" for compatibility with stringToEnum

1593182721
ifreund
arenas are a good choice when you build up a bunch of allocations and want to free them all at once

1593182759
antaoiseach
ifreund: yes, that's my line of thinking as well ... might as well munge everything and then free in one go ... don't expect any OOMs too! :-)

1593182762
antaoiseach
thanks!

1593182784
antaoiseach
By the way ... looking forward to the next zig show touching upon allocators... that should be useful as well!

1593182801
marler8997
m32...lol

1593182844
mq32
i just want to know when it's merged! :D

1593182851
marler8997
mq32, well I've pretty much finished, now just need andrewrk to review

1593182861
mq32
yeah, i've been reading here :D

1593182875
mq32
i wish github had an option to watch only creation/closig/merging of issues/PRs

1593182924
antaoiseach
mq32: agreed ... the current watch settings on github are annoying at best

1593182986
mq32
yep

1593182989
mq32
but hey

1593182991
mq32
we got a new layout…

1593183524
shcv
is there anything like destructuring, to assign elements of a slice to multiple variables?

1593183577
ifreund
not currently, no

1593183598
ifreund
though I believe there are a few open proposals for something like that

1593184423
antaoiseach
Hey folks, another quick question. I downloaded the llvm-all-in-one from the official releases pages, set compilers to gcc-9 and g++-9, and then I run into errors such as this one:

1593184429
antaoiseach
src/zig_llvm.cpp:1299:73: error: 'AVR_SIGNAL' is not a member of 'llvm::CallingConv' 1299 | static_assert((CallingConv::ID)ZigLLVM_AVR_SIGNAL == llvm::CallingConv::AVR_SIGNAL, "");

1593184442
antaoiseach
Anybody have an idea what is wrong?

1593184466
antaoiseach
I simply used the commands `cmake .. -DCMAKE_PREFIX_PATH=<path to local download>; make install`

1593184527
leeward
If you're trying to build llvm from source,

1593184546
leeward
I think the error you quoted is because you need -DLLVM_EXPERIMENTAL_TARGETS_TO_BUILD="AVR"

1593184567
leeward
in the cmake command for llvm

1593184601
antaoiseach
leeward: I've already got a binary of llvm+lld+clang ... I'm trying to compile the zig part now. You're right about those flags, but they're needed if building llvm or clang from source, right?

1593184625
antaoiseach
That may point to the issue though - maybe these releases are built without those flags turned on? Hmmm... well, that would suck

1593184645
leeward
Yeah, that's what it sounds like.

1593184689
antaoiseach
okay, that's too bad for me.... I dare not try building clang and llvm themselves from source. My poor old machine couldn't handle it. No worries, will make do with the zig binaries for now... thanks!

1593184701
leeward
no problem

1593184722
leeward
I actually built llvm and clang from source on a raspberry pi last weekend. It did take the whole weekend :P

1593184773
shakesoda
i envy such patience

1593184798
leeward
Didn't take much of my time; I just kicked it off and left.

1593186224
pixelherodev
andrewrk: got a present for you ;)

1593186227
pixelherodev
Function args work in ZIR now :D

1593186422
pixelherodev
Just need to rebase the branch...

1593186925
pixelherodev
#5411 woo

1593188247
aruniiird
compiling zig from source is failing for me... (did created build directory. from build directory did `cmake ..` and `make install`)

1593188262
aruniiird
is it a known issue

1593188358
pixelherodev
could be, can't know without more info

1593188527
leeward
What OS are you building on?

1593188551
leeward
Did the error message mention LLVMPolly.so?

1593188570
ifreund
I wish zig fmt did

1593188590
aruniiird
Here is the error output,

1593188646
ifreund
hmm, what OS are you building on?

1593188657
ifreund
do you have development versions of clang, llvm, and lld?

1593188662
aruniiird
Manjaro (Arch flavour)

1593188693
ifreund
do they use the arch repositories?

1593188713
aruniiird
```extra/clang 10.0.0-3 [installed]

1593188713
aruniiird
C language family frontend for LLVM```

1593188751
ifreund
do you have lld and llvm-libs installed though?

1593188766
ifreund
er, llvm not just llvm-libs

1593188775
leeward
And make sure you have the -dev versions of them.

1593188788
ifreund
leeward: arch doesn't split them :(

1593188814
aruniiird
lld (yes) extra/lld 10.0.0-3 [installed]

1593188814
aruniiird
Linker from the LLVM project

1593188818
ifreund
aruniiird: you also will need to pass a flag to cmake, which you can copy from the zig pkgbuild

1593188846
leeward
ifreund: Huh, weird. I thought it was a Debian derivative.

1593188878
ifreund
nope, i think arch is one of the few non-derivative distros

1593189001
leeward
RH, Slackware, Debian, can't think of any other widely used ones (I hear Void exists, but have met maybe 1 user)

1593189008
leeward
That is rareified air.

1593189031
leeward
Oh, Mint. I was confusing Arch with Mint.

1593189037
aruniiird
trying...

1593189044
aruniiird
with the flags

1593189050
leeward
oh, and Gentoo

1593189096
fengb
SUSE is its own thing too

1593189182
ifreund
there are more void users every day

1593189189
fengb


1593189199
aruniiird
leeward: thanks it worked with the flags... (=

1593189204
ifreund
is alpine a derivative?

1593189227
scientes
fengb, that is pretty silly

1593189272
ifreund
i love it

1593189282
fengb
The other one I found is more comprehensive but totally unreadable

1593189295
fengb


1593189305
scientes
except very few distros are interesting

1593189320
leeward
SUSE uses RPMs.

1593189329
scientes
and very few distros are maintained

1593189414
leeward
fengb: That tree has BSDs on it.

1593189434
fengb
I can't even read it

1593189434
antaoiseach
hello again, folks ... have a few broad design questions: 1). We can use generic functions to simulate trait-like functionality to some extent - true/false, to what extent? 2). `zig init-exe` and `zig init-lib` can be used create bare project templates, and we can also combine lib+exe functionality by tweaking build.zig. Is this correct? 3). About project structure, the stdlib seems to have a general

1593189440
antaoiseach
pattern of `foo/bar.zig` which may call `foo/bar/bar.zig` .. is this idiomatic? How would you resolve directory structure vis-a-vis modules, and finally 4). free functions or methods (well, functions nested within structs/unions/etc. oop style)?

1593189442
fengb
So no idea what's going on in there

1593189475
leeward
2: yes

1593189492
antaoiseach
cool!

1593189513
leeward
4) whatever's most appropriate for your interface

1593189528
leeward
1) I actually wrote something about this recently...

1593189546
antaoiseach
leeward: that looks quite promising... thank you!

1593189547
leeward
Short version of 1: yes-ish

1593189603
leeward
3) The stdlib is as idiomatic as Zig code gets these days. Note that, e.g. mem.zig has public declarations of things in mem/

1593189621
antaoiseach
leeward: yes indeed

1593189635
donaldallen
I would like to create an array of string literals. My reading of the documentation tells me that "hello" and "goodbye" are different types, because they have different lengths. And arrays seem to be of a single type.

1593189641
antaoiseach
I was thinking of following the same idiom ... not sure if the indirection is worth it

1593189648
antaoiseach
maybe cleaner

1593189664
leeward
donaldallen: use slices

1593189670
donaldallen
But on a hunch, I tried      const test_array = .{"hello", "goodbye"};    warn("test_array: {}\n", .{@typeName(@TypeOf(test_array))});    warn("test_array[0]: {}\n", .{test_array[0]});

1593189700
donaldallen
This produces the output test_array: struct:94:25test_array[0]: hello

1593189707
antaoiseach
leeward: that link is exactly what I was thinking about - but with a better concrete example... this should prove very useful for me! :-)

1593189708
leeward
antaoiseach: The mechanism in the link definitely adds some runtime overhead.

1593189737
antaoiseach
yes ... but looks much cleaner and understandable!

1593189741
donaldallen
Much to my surprise. Is this documented anywhere? I may have missed it, certainly, so if you can point me to where this is discussed, I'd appreciate it.

1593189799
fengb
There should be a segment on how `*[N]T` automatically coerces into `[]T`

1593189838
antaoiseach
fengb: donaldallen:

1593189849
donaldallen
Ah -- I will have a look. Thank you.

1593191818
antaoiseach
I have a probably dumb question, but here goes - why is it that we can coerce a bigger alignment value into a smaller alignment, but not vice versa?

1593191894
pixelherodev
If something is 16-bit aligned, it's also 8-bit aligned, definitionally

1593191902
pixelherodev
Something that's 8-bit aligned might not be 16-bit aligned

1593191916
pixelherodev
etc

1593192000
fengb
Example: a byte is align(1). A pointer is align(8). We can always directly map the pointer into raw bytes, but going from bytes to a pointer requires alignment concerns

1593192066
antaoiseach
Wow ... that was a dumb question indeed!:D ... hahaha, yeah, I should have thought that through

1593192073
antaoiseach
Makes perfect sense... thanks, folks!

1593192198
antaoiseach
Okay, maybe a better question this time ... do we have any standard serializer/deserializer in the stdlib?

1593192265
antaoiseach
I found something in io/serialization.zig, not sure if that can be used ... will try it out in any case

1593192294
antaoiseach
yes, looks promising

1593192465
tgschultz
why would you think it couldn't be used?

1593192526
antaoiseach
tgschultz: That was me jumping the gun there - I'd thought that that was an internal-use only module, but the test cases (which are excellent!) show otherwise :-)

1593192536
antaoiseach
yes, this should suit me quite nicely indeed

1593192546
tgschultz
glad to hear it

1593192552
antaoiseach
cheers!

1593192782
pixelherodev
The big blocker for function params in Zig source now is local variable lookups

1593192790
pixelherodev
I haven't worked with the Zig-specific parts enough to do that quickly

1593193716
nrdmn
mq32: you had trouble building zig on gentoo, right?

1593193761
nrdmn
I've written a few notes on that:

1593193764
mq32
no, i don't use gentoo

1593193773
nrdmn
huh.

1593193780
pixelherodev
?

1593193784
pixelherodev
Wdyn?

1593193791
mq32
i thought you use gentoo

1593193795
pixelherodev
I do

1593193800
pixelherodev
What do you need*

1593193848
nrdmn
Zig 0.6.0 currently does not build on gentoo and I've written down why that is. In case someone else is affected.

1593193922
nrdmn
Unfortunately gentoo's llvm/clang/lld maintainer doesn't like the idea of including arch linux' workaround to the issue discussed at

1593193941
pixelherodev
So I've heard.

1593193948
pixelherodev
It's why I don't use their ebuilds.

1593193965
nrdmn
:/

1593195317
shcv
nrdmn: thanks for the notes, that addresses most of what I ran into when trying to build on gentoo the other day

1593195330
shcv
I eventually gave up when someone reminded me that there were binaries available :P

1593195380
shcv
zig's build system is so much nicer (so far anyway) than llvm+cmake; thanks for all the work guys

1593195624
leeward
shcv: If you want to know more about it, pixelherodev did some streamy stuff about how it works a little while ago. He can probably tell you where to find it.

1593195751
ifreund
one thing I have yet to figure out is if there is a good way for my custom steps to take advantage of the artifact caching system

1593195846
ifreund
right now I write the custom step artifacts to directories ouside of zig-cache and then use installFile(), but I think this results in the steps being rerun every build regardless if something changed

1593196315
alexnask
Now that we have @Type for error sets, I made an "error dispatcher" which lets you narrow down your error types and update the type of the error at comptime

1593196341
alexnask
This relies on a couple of tricky comptime concepts, here is the link if anyone is interested:

1593196362
alexnask
I recall people discussing something like this for a language feature in this channel

1593196529
leeward
We have @Type for error sets?

1593196532
leeward
I have to update!

1593197087
ifreund
wild

1593197882
alexnask
Slight variation that doesnt require an inferred error set on init:

1593199004
shcv
ifruend: maybe we could make a wrapper around the custom steps, like memoizing a function? hash the inputs, store the outputs in the resulting hash location?

1593199055
shcv
that would give you a target directory to store the artifacts in too

1593199147
shcv
I guess I should read more about how the current build system works

1593199177
shcv
er, sorry for mispelling your name, ifreund

1593199180
ifreund
the current system already does that for zig files afaik

1593199197
ifreund
but I didn't find an easy way to tie into that last time I poked at it

1593199212
ifreund
for reference my custom steps are here:

1593199345
alexnask
The cache hash api is in std btw so you could probably do it

1593199425
shcv
one thing I noticed while reading cache_hash.zig was that the digest len is supposedly 24, but the cache files seem to have a much longer digest; any reason for that, and where is it set?

1593199496
ifreund
I'm sure I could do it, but ideally it should be as easy as calling one extra Builder function or something

1593199528
ifreund
it's not really worth my time to implement it just for my project, if I were to dig further I'd try to add it in a generic way

1593199572
alexnask
Sure

1593199762
alexnask
shcv, hm looks like the C++ implementation uses 48 byte digests (aka 64 bit base64 digests) while the stdlib one uses 24 bytes aka 32 bytes of base64

1593199767
alexnask
I thought they were compatible

1593199770
alexnask
Guess not

1593199887
shcv
interesting

1593199931
shcv
where's the cpp version?

1593199954
alexnask
src/cache_hash.cpp

1593199965
shcv
just found it

1593199967
shcv
thanks

1593200006
shcv
when is each version used?

1593200056
shcv
looks like the cpp version is blake2b, whereas I think the zig version claims to be blake3

1593200189
alexnask
ah could be, didnt notice it >.>

1593200202
alexnask
Only the c++ version is used atm I believe

1593200245
alexnask
this was a port to start self hosting some of this stuff which is why I thought it was compatible

1593200256
alexnask
But I guess it doesnt actually need to be (beyong the dir structure)

1593200278
shcv
makes sense

1593200498
shcv
with format we can print a buffer in hex, etc.; how does one parse a hex string? I only see individual parseInt, etc.

1593200536
alexnask
{x} and {X} will print in hex I believe

1593200566
ifreund
shcv: parsInt takes a radix

1593200571
ifreund
so you can pass 16 to parse in hex

1593200727
shcv
so, I guess I can approximate a short buffer with e.g. u256?

1593200773
ifreund
i'm not sure why you would want to use that over a [8]u8 but sure

1593200795
ifreund
er, [32]u8 i guess

1593200797
shcv
the test cases don't show an array example

1593200810
shcv
does math.add work with arrays? probably not the most efficient way to do it...

1593200836
ifreund
this is for parsing an int?

1593200838
leeward
Huh, a funny problem: when I use ZBS to generate things depended on by Make, the cache can cause stuff to not get rebuilt. I built my .a file with -Drelease-fast and -Drelease-safe, and when I switch between the two the .a file I see in my output_dir does change, but its timestamp is from when it was originally built.

1593200868
shcv
well, parsing a hex-encoded digest

1593200911
leeward
I guess the easiest way to deal is to touch it.

1593200954
shcv
interesting...

1593200993
shcv
maybe it would be useful to have ZBS touch the files automatically?

1593200995
ifreund
well, it kinda depends on what output form is most convient for whatever you want to do with it

1593201022
marler8997
I bet it is hashing the source and seeing it was already built, then it just copies it from the cache which has the old timestamp

1593201067
marler8997
this is an issue for Make, because it assume that if an input file has an older timestamp than an output file, then the output file must be up-to-date

1593201131
leeward
marler8997: Yep, that's exactly what's happening.

1593201144
leeward
shcv: It might be. Worth thinking about, anyway.

1593201176
marler8997
ZBS could update the timestamp of any file that it copies out of the cache

1593201179
shcv
since it's a new copy of the files in the output dir, it doesn't seem unreasonable

1593201231
shcv
ifreund: I was probably going to use it as a [32]u8, but if u256 has better / faster support for comparison operators, etc., that might actually be better

1593201291
ifreund
only way to know is to try both and benchmark :D

1593201328
leeward
shcv: It ought to at least be more natural to write code with a u256. I wouldn't depend on the implementation being awesome yet, but this feels like a "one obvious way to do it" kind of thing.

1593201373
shcv
are there any benchmarking utilities?

1593201398
leeward
shcv: std.time includes a microsecond timer.

1593201412
shcv
I'll try the u256; I do really like that zig supports arbitrary bit sizes, so I might as well take advantage of it

1593201427
alexnask
nanoseconds too ;)

1593201438
leeward
Right, that's what I meant.

1593202003
shcv
so, how do I cast a [32]u8 to a u256?

1593202077
shcv
@bitCast?

1593202187
fengb
Yep

1593202193
ifreund
there's also std.mem.bytesAsValue

1593202367
shcv
when I try to print the u256, I get an LLVM unsupported library call operation...

1593202375
shcv
It could be breaking elsewhere though

1593202380
fengb
Yeah, LLVM doesn't support anything greater than u128

1593202398
fengb


1593202498
andrewrk
it will be easier to break this restriction in self-hosted, where we control the compiler-rt ABI

1593202823
fengb
And then I can finally use u262144 for the wasm page allocator :P

1593202852
fengb
Wait bad math. I meant u524288

1593202883
shcv
I think one difference between u256 and [32]u8 is the endianness vs the string representation

1593202883
andrewrk
yeah I mean with a robust implementation it should work fine

1593202936
shcv
fengb: uh, what would you need that for? O.o

1593202984
fengb
65536 bytes of bitfields

1593202994
ifreund
alexnask: yo, for semantic token highlighting is this a bug or unimplemented feature?

1593202995
alexnask
wew

1593203017
ifreund
my files with toplevel fields dont show up as types :?

1593203024
fengb
I don't need it since it's currently using an array of u128, but it'd be pretty funny

1593203026
alexnask
ifreund, these will all be marked as "struct"

1593203032
ifreund
but overall, this is pretty awesome, the more colors the better

1593203039
shcv
fengb: isn't there a limitation of max u65536?

1593203047
alexnask
So you need to map the "struct" token type to some color or textmape scope

1593203051
ifreund
hmm, so it can't differentiate between namespace structs and structs with fields?

1593203053
alexnask
depending on what kakoune does idk

1593203082
alexnask
This was a design decision but Im open to alternatives

1593203090
alexnask
But imports are structs

1593203097
alexnask
So I chose "struct" :)

1593203111
ifreund
they're technically types though no?

1593203114
andrewrk
oh wow that's super nice

1593203126
andrewrk
semantic token highlighting is a game changer

1593203128
alexnask
I use "type" for primitive types + type functions

1593203137
alexnask
I could possibly make it a modifier instead

1593203176
alexnask
These were pretty hastily chosen tbh theres a lot of room for improvement. (also I list an async modifier but dont use it at all atm)

1593203198
ifreund
imo it would make sense to use it for enums unions and non-namespace structs as well

1593203247
alexnask
This is the list of the token types I use atm btw:

1593203254
ifreund
andrewrk: better screenshot, it truely is glorious:

1593203278
andrewrk
I'm all about this

1593203316
ifreund
andrewrk: ok, i see that the lsp spec has a namespace token type as well

1593203327
ifreund
alexnask: ^ (oops)

1593203329
alexnask
^_^

1593203337
ifreund
maybe we should use that for structs with no fields?

1593203340
andrewrk
the generated docs detect when a struct has no fields and calls it a namespace

1593203347
andrewrk


1593203360
alexnask
Hmm I guess it makes sense then to do it then

1593203405
ifreund
oh lol, that screenshot actually shows some weird behavior of zig fmt I found

1593203450
ifreund
i feel like

1593203504
alexnask
yeah prob a bug, I think it may work if you use a block for the while instead of single-statement while

1593203507
alexnask
Just a hunch :P

1593203514
ifreund
or

1593203525
ifreund
yeah it does work if I use a block for the while

1593205088
shcv
I guess I'll put using u256 on hold for now, until it can be handled directly by std.fmt; otherwise I have to keep juggling the endianness

1593205108
shcv
and converting back and forth between [32]u8; might as well stick with [32]u8

1593205164
fengb
Just assume little endian :P

1593205195
fengb
There's mem.readInt that'll do endian processing for you

1593205276
shcv
the problem is that english is mixed endian; printing a [32]u8 is effectively big endian, the opposite of a bitcast to u256

1593208067
alexnask


1593208258
leeward
That is a lot of colors.

1593208299
alexnask
:-) Should have shoved a label into there too I use a yellow for that :P

1593208301
andrewrk
so beautiful 😍 😍

1593208315
andrewrk
what editor is that?

1593208319
alexnask
VSCode

1593208702
mq32
alexnask: nice, so semantic highlighting is going well?

1593208747
alexnask
Yeah its been done for a while ;) I only need to correctly add a couple of modifiers like async and generic and some extra details

1593208751
alexnask
Im working on renaming rn

1593208787
mq32
whoo

1593208955
andrewrk
this is probably enough to make me switch to vscode

1593209016
shakesoda
vscode + zls has made using zig a lot better

1593209019
alexnask
lol, what, the rendering? :P The semantic tokens will work in all editors that support LSP once the next version of the protocol comes out

1593209039
alexnask
(already supported in a couple but not coc which is the main vim lsp client)

1593209063
andrewrk
btw I tried vim+coc+zls "go to definition" yesterday but it was unavailable

1593209085
alexnask
hm Ill give it a shot I have an install

1593209110
leeward
I've been using ZLS with Emacs and it works very nicely. Not that anyone else in the world would be caught dead using Emacs.

1593209117
alexnask
I have so many editors installed now >.<

1593209120
shakesoda
i run into things that won't complete a lot though :(

1593209122
shakesoda
mostly cimport stuff

1593209130
alexnask
cImport is not supported yet yeah

1593209139
mq32
andrewrk: i'm not sure if it's worth switching to vscode for you, but it's wort a shot

1593209147
mq32
i've seen you using vi like i never could :D

1593209174
andrewrk
dvorak+vim does have some interesting one-handers

1593209179
shakesoda
not usually troublesome for pure zig although i regularly have problems with getting the completion to come back once vscode has decided it doesn't want to show me the signature of something anymore

1593209188
shakesoda
seems like a vscode issue but i don't know the implementation details

1593209201
leeward
andrewrk: You use dvorak?

1593209213
andrewrk
yep, at this point been using it longer than qwerty by several years

1593209214
shakesoda
it's like it thinks i can remember the thing it was telling me :(

1593209226
leeward
I think that makes...4 people I know, for certain values of know.

1593209249
leeward
I've been using dvorak since 2001. Not the best decision I've ever made.

1593209261
shakesoda
i used dvorak for a while but it didn't net me enough to deal with the mapping problems chronically

1593209303
alexnask
I think I had trouble getting coc to jump to definitions over import boundaries too

1593209307
alexnask
But I dont recall

1593209315
leeward
Switching back and forth is the worst. I have a bash alias on computers I need other people to be able to use: aoeu -> setxkbmap us; asdf -> setxkbmap dvorak

1593209316
alexnask
exaclty what the issue was

1593209334
shakesoda
leeward: i like that

1593209500
shcv
I use colemak and emacs

1593209539
leeward
shcv: You fiend

1593209556
leeward
Never tried colemak; switching keyboard layouts once was painful enough.

1593209604
shcv
yeah; I made the poor decision to switch like a month before my GRE, which turns out to be on a provided computer, and involves an essay...

1593209609
andrewrk
damn, I have to send my laptop into dell to repair a swollen battery

1593209617
andrewrk
that's going to be annoying not having this machine

1593209624
leeward
That's...not awesome.

1593209630
shcv
:(

1593209631
leeward
The battery isn't removable?

1593209644
andrewrk
maybe I'll try to get more comfortable with windows ;)

1593209659
alexnask
Time to install wsl2 :P

1593209665
andrewrk
image search for "battery swelling trackpad"

1593209692
shcv
lol

1593209710
leeward
Fun times.

1593209711
shcv
but no, I wouldn't want to develop on windows... I use exwm and emacs all the things

1593209721
mq32
andrewrk: no getting comfortable with windows once you've mastered the ways of the shell

1593209745
leeward
I have a windows machine for work, because Lotus Notes. WSL is...kinda ok.

1593209762
r4pr0n
LSW though

1593209769
shcv
lotus notes? I didn't know it was still a thing

1593209771
leeward
You mean WINE?

1593209777
leeward
shcv: Neither did I!

1593209786
r4pr0n
WSL => wine

1593209874
leeward
I like how it's called Windows Subsystem for Linux, but so many distros make such a big deal about how it's GNU/Linux. Linux is the only thing that's missing from a GNU/Linux install on WSL.

1593209891
leeward
Oh, yeah, I'm running Debian GNU/Windows.

1593209923
mq32
leeward: true for WSL1, false for WSL2

1593209925
marler8997
leeward true, but it's "emulating" the linux kernel syscall interface

1593209951
leeward
marler8997: That's exactly what Wine does in reverse. Don't call it an emulator though.

1593209956
marler8997
meaning any OS coded for linux should work, not just gnu

1593209957
leeward
What does WSL2 do?

1593209964
nycex
I use musl/busybox/linux

1593209972
shcv
would be funny to run WINE on WSL then

1593209973
marler8997
wsl2 is basically a VM, so you can load your custom kernel instead of emulating a kernel syscal interface

1593209975
alexnask
wsl2 is a vm

1593210014
leeward
Well that's...why didn't they do that in the first place? VMs already existed and didn't need anyone to write a whole userland interface shim.

1593210016
mq32
WSL2 is just a VM

1593210029
marler8997
yeah you could totally run WINE on WSL, I've worked on project that did similar things, even went 3 levels deep in places

1593210034
mq32
WSL1 isn't a userland shim though

1593210037
leeward
Does that mean I can run OpenBSD on WSL2?

1593210055
mq32
afaik the kernel is actually emulating the syscalls in WSL1

1593210058
mq32
which is quite awesome

1593210060
leeward
marler8997: You're making me sad.

1593210073
marler8997
I'm not too familair with OpenBSD...isn't it a bsd kernel?

1593210077
leeward
It is.

1593210081
mq32
wine is just a PE loader + replacement libs with syscalls

1593210090
mq32
so wine is not an emulator while WSL is

1593210090
marler8997
I doubt it would have the same syscall interface as linux

1593210092
leeward
If WSL2 is just a VM, can it run other kernels?

1593210123
marler8997
WSL1 is just an implementation of the linux syscall interface

1593210136
leeward
Oh, I didn't realize WSL1 was implemented in kernel space.

1593210142
marler8997
leeward good question, I don't know that one

1593210205
alexnask
running windows 10 in wsl2 is the true big brain move

1593210232
leeward
alexnask: They do it for speed.

1593210243
mq32
alexnask: while running linux instead of windows 10? :D

1593210268
shakesoda
i don't think it's accurate to call virtualization emulation

1593210276
shakesoda
in the case of wsl2

1593210299
mq32
nah, WSL2 isn't emulation

1593210302
leeward
Well, it's hardware emulation, right?

1593210312
leeward
I guess it doesn't have to be.

1593210317
shakesoda
no, virtualization is different

1593210318
mq32
leeward: no, it's not

1593210336
mq32
virtualization: "qemu -enable-kvm", emuation: "qemu"

1593210349
mq32
first one uses the same processor as the host, no instruction translation used

1593210352
leeward
Yeah, if the guest and host machines are the same type.

1593210354
mq32
second one actually JITs the CPU

1593210362
mq32
otherwise it's nt virtualization :D

1593210382
andrewrk
oh neat somebody posted zig showtime to HN

1593210391
leeward
nifty

1593210434
marler8997
going to have to port my wsl-register code to Zig...

1593210776
nephele
WSL2 is the linux kernel... on the vm windows already has and uses nartively :D

1593210818
nephele
also, running wine on WSL2 makes perfect sense... with windows caring less about backwards compatibility (and dx9 -> opengl giving better performance than dx9 comparitively, so that could be used on win potentially)

1593211829
shcv
should I try to implement a full ctrie, or just a hamt?

1593211854
shcv
a ctrie has the advantage of better concurrency support I guess; hamts are simpler though

1593211889
mq32
what is both?

1593211994
shcv
they're k/v stores like hash tables, but designed to work well in immutable, data-sharing contexts

1593212096
marler8997
andrewrk, I've finished working on new allocator interface PR.  It's ready to merge.  The last 3 pushes were final touches and all 3 fully passed all CI tests.  Please have a look when you find the time.

1593212182
shcv
a HAMT (hash array mapped trie,

1593212267
mq32
oh neat

1593212270
shcv
the ctrie (

1593212295
mq32
ctrie sounds sexy

1593212416
andrewrk
marler8997, brilliant

1593212467
shcv
apparently there hasn't been much work on non-GC ctries

1593212491
pixelherodev
andrewrk: ... oops. That clearError thing is going to be annoying...

1593212500
fengb
Great, do I need to update my slides already? :P

1593212539
andrewrk
lol perfect timing

1593212556
andrewrk
fengb, that's what you get for not procrastinating. I haven't even started my slides yet

1593212562
fengb
lol

1593212569
shcv
slides? what for?

1593212576
andrewrk


1593212581
andrewrk
showtime tomorrow

1593212585
fengb
I'm actually using a hybrid interface that doesn't map to anything directly

1593212608
pixelherodev
Oh nice!

1593212609
shcv
how often do y'all do that?

1593212611
pixelherodev
What's tomorrow's showtime?

1593212617
pixelherodev
shcv: there's one every week basically

1593212622
shcv
cool

1593212941
andrewrk
how have I not heard of / tried this before?

1593212984
marler8997
it records execution so you can play it back? wow sounds cool

1593213035
andrewrk
you can even play it back in reverse

1593213053
andrewrk
get to a failure state, then set a breakpoint, then rewind until you hit it

1593213063
andrewrk
or get to a failure state, set a memory watchpoint, then rewind until you hit it

1593213087
andrewrk
it answers the question, "how did this data get set to [unexpected value]?"

1593213087
marler8997
that's a really good idea

1593213235
pixelherodev
andrewrk: the "looking at just one line of code" thing was impressive TBH :)

1593213257
pixelherodev
Hmm, instead, I should just clear

1593213271
andrewrk
that already happens

1593213282
andrewrk
marler8997, oh nice, you integrated malloc_usable_size

1593213282
pixelherodev
... then I'm suddenly very confused what the error was.

1593213288
pixelherodev
This'll be fun

1593213335
andrewrk
look at markOutdatedDecl, it removes the error for it

1593213358
pixelherodev
I'm not doubting you lol

1593213537
pixelherodev
ohh

1593213545
pixelherodev
andrewrk: idea: did you not hook that up for Zig sources yet?

1593213604
pixelherodev
... wait no, this is happening in a ZIR case

1593213613
marler8997
yeah it was easy to implement malloc_usable_size with the new interface

1593213675
andrewrk
pixelherodev, I don't think it's worth supporting incremental updates for ZIR modules

1593213687
andrewrk
just .zig source

1593213769
andrewrk
I'm pretty sure ZIR is just going to be an implementation detail + debug tool, not a stable API or ABI for third party applications

1593213787
andrewrk
and release builds will ship with ZIR support comptime-disabled, to improve binary size and perf

1593213803
pixelherodev
I think it's worth it for testing at least

1593213811
pixelherodev
Even if we disable it in proper builds

1593213821
pixelherodev
It makes it easier to make sure everything's hooked up properly

1593213886
andrewrk
there's a non-trivial surface area that is required to make incremental compilation of .zir files work, which does not overlap with making it work for .zig source

1593214060
pixelherodev
So I should disable the tests? (and, in a separate PR, nuke incremental ZIR support?)

1593214219
pixelherodev
well actually, the exact same issue occurs with Zig code

1593214492
pixelherodev
retraction of the retraction, the ZIR test passes

1593214497
pixelherodev
It's only the Zig one that doesn't

1593214499
pixelherodev
:P

1593214964
pixelherodev
orrr not? Whatever, I'mma just fix it.

1593215303
pixelherodev
facepalms*

1593215306
pixelherodev
I'm an idiot

1593215311
pixelherodev
Forgot to set the export's status to failed

1593215645
andrewrk
you're not an idiot, we just need better debugging infrastructure that make the state of everything more obvious

1593215665
mq32
zigdbg when?

1593215681
andrewrk
in my experience nearly all debugging difficulties are lack of observability / intuition about state

1593215698
andrewrk
and I don't think it's something that can be solved generically

1593215714
andrewrk
that's why we have a text based ZIR format in the first place

1593215721
andrewrk
it's an investment in debugging the compiler

