1592870571
ifreund
C bitfield support would be really great to have

1592872035
leeward
Working packed structs would be really great to have, but we have to wait until stage1 is ready for it.

1592872123
ifreund
i think you mean stage2?

1592872146
ifreund
but yeah I agree, a proper stage1 implementation would be wasted effort

1592872540
leeward
Yes!

1592872555
leeward
What I should have said was self hosted.

1592872586
leeward
I am looking forward to getting them though. They're important for replacing C.

1592872599
leeward
Bitfields have always been kind of a crappy hack anyway.

1592873786
ttmrichter
leeward: You mean implementation or notionally?

1592873835
leeward
implementations

1592873889
leeward
they tend to be bad

1592874717
leeward
Also, the syntax is feels tacked on (probably because it is).

1592874740
leeward
s/is//

1592875685
ttmrichter
What bugs me about them most is that the relationship between the bit fields and the bits is undefined.

1592875707
ttmrichter
You can have a standards-compliant C that sets aside a full machine word for every bitfield, regardless of size.

1592875725
ttmrichter
Which renders the one thing I REALLY want to have them for completely pointless.

1592875803
leeward
Yeah, it turns out C is really not designed for embedded systems. It just happens to kinda work ok in them.

1592875826
fengb
C was also not specced out for a long while

1592875860
fengb
So when implementations disagreed with each other, the spec just decided to leave it implementation defined

1592875916
ttmrichter
C became popular because the Unix kernel was free and written in it.  That is all.

1592875922
leeward
yep

1592875926
ttmrichter
By any metric C is a terrible programming language.

1592875934
leeward
False! It's very easy to implement.

1592875938
leeward
That's a metric :)

1592875940
companion_cube
is it though? :)

1592875943
ttmrichter
It's easier to implement a Modula.

1592875955
ttmrichter
Modula-2, for example.

1592875979
ttmrichter
Back when I was in practice I could toss out a Modula-2 parser in an afternoon ... maybe a day.

1592876004
companion_cube
was it pascal with ML-like modules?

1592876007
leeward
Parser is a bit different frum implementation, but sure, Modula-2 is also easy to implement.

1592876012
companion_cube
I heard about modula but don't know much else

1592876035
ttmrichter
companion_cube: Basically.  Pascal was Wirth's teaching language.  Modula-2 was the language he advocated for real work.

1592876041
companion_cube
damn

1592876048
leeward
I mean, if you look at C and see a weird decision, the reason for it is likely "it was easier to implement."

1592876051
companion_cube
another path that'd have been, indeed, better than C

1592876069
ttmrichter
leeward: That or "we couldn't decide which way to go so we threw up our hands and gave up".

1592876087
leeward
Sure, or that.

1592876119
ttmrichter
Modula-2 gave actual modularity, actual data types with actual enforceable properties.  (Arrays had SIZES and weren't just syntax saccharine for pointer notation!)

1592876166
companion_cube
wait, is Wirth still working on Oberon?

1592876169
leeward
Arrays with sizes? That'll never catch on.

1592876170
ttmrichter
You could declare variables as falling within a given range: "This is an integer from -3 to +8".

1592876195
ttmrichter
companion_cube: I think so, though "work" is a strong term.  He seems to have pretty much retired.

1592876204
companion_cube
ah, well, makes sense

1592876224
ttmrichter
Isn't Oberon now up to Oberon-3?  I never really followed the Oberon branch.

1592876290
companion_cube
godamnit, and of course, modula-2 has sum types

1592876292
companion_cube
curse you, C

1592878094
ttmrichter
C was a hack made to provide a high-level assembler to quickly port something to a PDP-11.

1592878103
ttmrichter
Modula-2 is a language designed for engineering purposes.

1592878112
ttmrichter
The difference in feel is palpable.

1592878215
ttmrichter
That feel carries on through Modula-2+ (adding coroutines, if memory serves?) and Modula-3 (adding OOP, and threading).  I never worked with 2+, but 3 was nice.

1592878990
jayschwa
Is it possible to `@export` a function without mangling it by prefixing an underscore? I'm messing around with Zig and DOS, and the DJGPP (DOS cross compiler) linker and crt0 use "start". When I declare `fn start() callconv(.Naked) noreturn` and `@export(start, .{ .name = "start" })`, `zig build-obj` is prepending an underscore when I inspect the

1592878990
jayschwa
output with `objdump`.

1592880470
daurnimator
it shouldn't for naked calling convention....

1592881365
daurnimator
andrewrk: re

1592881438
andrewrk
daurnimator, no I don't see the comment

1592881465
andrewrk
marler8997, btw `nosuspend` does not modify the behavior of suspend points - it's actually an

1592881496
andrewrk
it's UB in unsafe build modes if you have a suspend point actually do a suspension in a nosuspend block

1592881510
andrewrk
it won't prevent them, it just promises to the compiler that it will never happen

1592881672
daurnimator
andrewrk: on april 4: > n the traditional libc/POSIX ungetc api, you are only allowed to put back what you last read: a subsequent read makes it undefined if you can fit things in or not

1592882000
andrewrk
I'd like to see that in the doc comments and probably also the function name/return type

1592882040
andrewrk
although, an even better API would be a fixed reserve size

1592882054
andrewrk
if the perf didn't suffer, that would be ideal

1592882152
daurnimator
I don't think a fixed reserve size is a useful idea

1592882178
daurnimator
`putBack` is used in situations where you read something; realise its not what you wanted after all; and put it back

1592882588
andrewrk
I'm ok with that API but it should be reflected in the doc comments and also the function signature\

1592882600
andrewrk
you shouldn't have to use `catch unreachable` for the main use case of an API

1592899589
dch
how are the official ziglang.org/download tarballs generated? They're used in zigler (from last zig.show) and I'd like to see if I can make a freebsd aarch64 tarball at least locally

1592899600
dch
I'm guessing its actually

1592899612
andrewrk
yes that's right

1592900925
dch
andrewrk: the script wants to download dependencies "

1592900937
dch
how are

1592900946
dch
I guess one of these doesn't exist

1592901157
dch
and given I have clang in freebsd ports, is that sufficient already?

1592901318
andrewrk
dch, they are built manually.

1592901332
dch
awesome I'll trawl through that.

1592901341
dch
do you

1592901468
andrewrk
dch, given that I'm not entirely sure what your use case is, I suggest to follow the directions exactly, except where you understand the details enough to stray from the suggestions

1592901988
JimRM
dch, given that I'm not entirely sure what your use case is> we have been looking at ziglar - which is a cool zig integration with Elixir. Ziglar automatically downloads a zig package based on host arch + platform. So to get it working on FreeBSD+Aarch64 we would need a tarball for that combo available.

1592902003
JimRM
andrewk: ^

1592902141
JimRM
Assuming the FreeBSD+AARCH64 combo builds without incident, (which it should, I got 99% of the way there on my Rpi4 until I got OOM) - how would we help/look at making this something available as a downloadable package alongside all the other arch+platform combos?

1592915578
gonz_
mq32: Is that a german Spongebob song you have open in the Showtime talk? :D

1592915690
mq32
can you link me a timestamp?

1592915716
gonz_


1592915865
mq32
what are you referring to? My wifi name?

1592915878
gonz_
Ahh, perhaps

1592915887
mq32
the thing in the bar below is my wifi name

1592915889
gonz_
Is it a Spongebob reference?

1592915892
mq32
yes

1592915904
mq32
"is here the crusty crab?" is my primary wifi, the guest wifi is called "no, here is patrick!"

1592921691
fengb
Cute

1592925985
leeward
So I was thinking about iterator protocols, and it seems like it's inconsistent with Zig's philosophy. They'd necessarily be implemented with functions, and "no hidden control flow" feels inconsistent with "implicitly calls a function sometimes, unless it's an array or a slice." Is that an accurate interpretation?

1592926048
leeward
The conclusion being that if we want iterators, we have to use `while` and conventions.

1592926056
ifreund
i mean, iterators that work with `while (it.next()) |item|` are already in use and work well

1592926125
leeward
Right.

1592926159
leeward
It's just been suggested that there would be some official sugar that, say, automatically calls next if an iterator is put in a for loop. It seems to me like that's not in the cards.

1592926532
ifreund
I agree

1592927109
shakesoda
leeward: +1

1592927116
shakesoda
magical sugar for iterators doesn't... fit

1592927128
shakesoda
i also don't want to have to remember how they work

1592927182
mq32
i don't think it's required to have sugar for iterators

1592927206
shakesoda
if you don't then you're just left doing what we already do, which is fine?

1592927233
shakesoda
the case i find the most painful is without question basic numeric for

1592927290
shakesoda
where you have to put a loop counter outside, maybe do the weird glued on :() thing etc and it's just very awkward

1592927367
leeward
I think the fact that there's no way to initialize the thing in the while loop inside the scope of the while loop is the biggest issue. It's surprising to people coming from pretty much every other language.

1592927409
shakesoda
i kind of feel like the funky usage of :() is the real problem i have, it is just absolutely bizarre

1592927431
leeward
Something like `while (var i: u32 = 0; i < 10) : (i+=1)` would solve it.

1592927433
shakesoda
in a "why does this exist, seemingly useful in only this specific case?"

1592927454
leeward
The :() syntax is wierd, but it makes sense since `for` is only for arrays.

1592927467
mq32
shakesoda: i would even go that far and just remove the :() iteratr

1592927474
mq32
it's not necessary in any way

1592927486
mq32
while(a < 10) { defer a += 1; … }

1592927489
mq32
is equivalent

1592927490
shakesoda
mq32: yeah, i'd actually be in favor of that

1592927504
fengb
Breaking the loop skips the iter increment

1592927514
fengb
But it would not skip a defer

1592927537
leeward
fengb: Good point.

1592927581
mq32
i'm willing to accept this

1592927589
mq32
i've used defer instead of :() in some places already

1592927612
shakesoda
leeward: if we had that kind of form with init;condition then we're already most of the way to just having a c for

1592927641
leeward
shakesoda: Yep.

1592927642
shakesoda
which, while i'd like, is the specific thing being avoided

1592927860
leeward
If the only reason not to do something is "C does it" I'm not convinced. Scoping the loop variable to the loop is available in every language I know that has mutable variables and loops.

1592927875
leeward
Wrapping your while loop in {}s is...hacky at best.

1592927914
shakesoda
the actual reason is that it's special syntax for one specific case where you're doing 3 separate statements in one

1592927919
shakesoda
which is just super inconsistent and weird

1592927938
shakesoda
and also confusing to learn (when you're not coming from a language that works this way, and have forgotten that it is weird)

1592927956
leeward
I get that there's a high bar for syntax that takes mental effort to use, but it's

1592927959
shakesoda
rather, the actual reason AFAIK

1592927967
shakesoda
maybe not the true one :)

1592928081
shakesoda
the while loop increment strikes me as the weirdest syntax exception in zig

1592928139
leeward
Heck, since we can iterate until null, we could make a sensible userland iterator protocol if we only had initialization and a thing to run per-loop: `loop-keyword (iterator = range(10)) : (iterator.next())`

1592928177
leeward
|capture| of course

1592928371
leeward
Heh, we could confuse a lot of people with `do <initialization> while (condition) : (next) |capture| {`

1592928386
shakesoda
now that i think about it, the syntax of `test` is also unique

1592928403
shakesoda
the difference being that i don't really care ;)

1592928430
mq32
test "x" { } is something i've seen before

1592928432
shakesoda
leeward: single expression do, where the entire while is the expression?

1592928442
shakesoda
mq32: i've seen it before, but it's not internally consistent with zig's other stuff

1592928451
leeward
shakesoda: the expression between do and while is only for initialization

1592928460
mq32
shakesoda: ah, true. still okay with me though, it should stand out

1592928484
leeward
Unusual syntax doesn't bother me, as long as the semantics are unsurprising.

1592928508
mq32
leeward: it's important to have consistent syntax

1592928526
leeward
Consistent, sure. But it doesn't have to be consistent with other languages.

1592928527
shakesoda
mq32: i'm just wondering if maybe we could take what it needs and make a useful and more consistent thing of it

1592928533
leeward
Just internally

1592928560
shakesoda
like turn tests into functions after 1717, and a way to do string identifiers so you can name tests the same way... then test can just be a special class of variable, or something

1592928605
mq32
@test("my_test", fn() !void { return error.Lol; })

1592928613
mq32
which is 100% nice actually

1592928619
shakesoda
then you can have a legal syntax of test "foo" = fn() {} which is almost the same, but you can also name other stuff like "foo" whenever you want

1592928623
mq32
would have to be in a comptime block though to be callable

1592928625
leeward
If a thing is inconsistent, it needs to be made easier to use by the inconsistency. I think test passes that.

1592928628
shakesoda
perhaps subject to some restriction about if you can export it

1592928670
shakesoda
leeward: if the inconsistency can be removed without meaningfully making it more difficult, i think that's a win for everyone

1592928688
leeward
Right, that's another way of phrasing what I was saying.

1592928830
marler8997
andrewrk, yes that's what I thought, my explanations on reddit may not have come accross that way

1592928891
marler8997
andrewrk, it took me a few attempts and some time to think, but I think I've come up with a way to start integrating the new allocator interface.  I've updated my PR when you get a chance to take a look:

1592928932
shakesoda
mq32: @test makes sense, i can't decide if i

1592928942
mq32
i actually don't like it :D

1592928948
mq32
i think test "foO" { } is totally fine

1592929016
shakesoda
mq32: figured i'd at least mention the inconsistency

1592929024
mq32
yeah

1592929037
shakesoda
it's functionally equivalent to something that doesn't really need syntax

1592929057
shakesoda
nor does having the syntax save lines, just a few characters

1592929066
shakesoda
but i don't mind test either.

1592929804
fengb
std.test.add(name, fn() !void {})

1592929935
leeward
Where does that call live? Certainly not in main.

1592929952
mq32
comptime { }

1592929972
marler8997
whoa, did github just get a new look?

1592929976
alexnask
maybe an @export option could make sense

1592929982
mq32
if(@import("builtin").is_testing) { @import("testing").addTest(…) }

1592930005
ifreund
ugh the github redesign is no longer optional

1592930018
mq32
yep

1592930035
marler8997
they must have turned the switch in the last few minutes

1592930045
ifreund
seems like it

1592930076
ifreund
the worst part imo is that they made the boxes for issues/comments/PRs wider, which seriously hurts readability

1592930087
fengb
Wow it's different

1592930104
ifreund
also round profile pics are dumb as rocks

1592930109
leeward
The only difference I see is...wider?

1592930115
shakesoda
oh goodness what happened

1592930140
shakesoda
ifreund: you're not kidding here this is much worse to read

1592930165
ifreund
yeah, it seems like they have no idea what they're doing

1592930173
fengb
Round profile pics are the gold standard :P

1592930186
shakesoda
guess i have to just use github with a half width window now

1592930192
fengb
Wait, they cut off my ear. Atrocious

1592930193
shakesoda
for it to be remotely tolerable

1592930231
ifreund
i think there's probably some way to hack it with user CSS plugin

1592930241
shakesoda
probably, but that's a pain too

1592930251
ifreund
It's super dumb that that's necessary though

1592930322
shakesoda
they removed the separator lines in the file list :(

1592930354
ifreund
another loss for readability/functionality

1592930378
shakesoda
no doubt the changes will be claimed as helping those things, too

1592930542
ifreund
alright, i figured out the CSS to make it narrow again

1592930565
ifreund


1592930583
ifreund
i'm using the Stylus plugin for firefox to apply this

1592931661
alexnask
ifreund, thanks that works like a charm

1592931743
ifreund
no problem

1592932853
pixelherodev
andrewrk: did you end up getting tests done for AST -> ZIR?

1592932860
pixelherodev
I don't see anything on it in the PR

1592932867
pixelherodev
If not, I can quickly finish up the work I have locally and push it

1592933259
andrewrk
pixelherodev, everything I have is pushed, go for it

1592933285
pixelherodev
Alrighty

1592933946
pixelherodev
andrewrk: `src-self-hosted/tracy.zig:3:20: error: unable to find 'build_options'`

1592933950
pixelherodev
Should I do a fresh build?

1592934011
pixelherodev
no, that doesn't help either :(

1592934048
pixelherodev
Ohhh

1592934064
pixelherodev
First patch: shouldn't check for it in tests

1592934740
pixelherodev
From

1592934755
pixelherodev
CI had the same issue I did, so it definitely wasn't a local issue

1592934815
andrewrk
marler8997, I'm having a look now!

1592934847
andrewrk
pixelherodev, I don't have the tests passing in that branch

1592934874
pixelherodev
I know

1592934879
pixelherodev
But this gets them

1592934973
pixelherodev
I should probably fix the tests first

1592934979
pixelherodev
Before modifying the harness

1592935174
pixelherodev
Good chance to get a better understanding of src-self-hosted too

1592935522
leeward
Are friendly error messages on the back burner until self-hosted?

1592935554
pixelherodev
Wdym?

1592935557
pixelherodev
What errors are unfriendly?

1592935569
pixelherodev
And I'm willing to bet patches fixing them would be accepted into stage1

1592935627
leeward
The specific one I'm thinking of is "type 'blah blah.ErrorSet!RealReturnType' does not support field access" which could be made friendlier by highlighting the fact that it's an error union and you forgot to `try`.

1592935719
marler8997
andrewrk, great

1592935801
andrewrk
leeward, there's an issue open for this somewhere

1592936098
leeward
andrewrk: Any hints on how to find it? Is it for this specific error message or errors in general? I've turned up nothing so far.

1592936313
alexnask
Another one is when using try in a function that does not return an error

1592936325
alexnask
I see a lot of beginners confused by that one

1592936382
alexnask
s/does not/cannot

1592936607
fengb
Not just beginners. I've spent hours staring at that error before :P

1592936644
fengb
Rite of passage to finally surpass that hurdle

1592936668
leeward
Isn't there something in zig zen about not hazing the newbies?

1592936712
ifreund
together we serve end users?

1592936718
leeward
Yeah, I'd say that qualifies.

1592936794
leeward
I have to say, it will be a nice change to have an actual low-level language where gotchas are actively stepped on.

1592936861
pixelherodev
Only haze newbies!

1592936879
pixelherodev
Who else are we going to haze? Haze?

1592936892
ifreund
i don't think haze uses irc

1592936940
pixelherodev
yeah, I don't think she's on here

1592936991
pixelherodev
It was just a pun though :P

1592937001
pixelherodev
See, it's a play on words, and that's where the humor comes in

1592937087
leeward
Could you explain the joke more? I don't think it's funny enough yet.

1592937120
leeward
And as we all know, the more a joke is explained, the funnier it gets.

1592937125
leeward
Wow, it hurt to say that. I'm done.

1592937184
gonz_
At some point it becomes so unfunny that it wraps around,  though.

1592937195
gonz_
Around the time someone makes a dissertation on why the joke is funny.

1592937217
leeward
Maybe funny in theory, but I would not want to read it.

1592937248
marler8997
it gets so unfunny, the joke overflows...that's why Zig was made, to protect from that

1592937301
pixelherodev
Nobody gets my references.

1592937308
leeward
test "joke"...integer overflow

1592937356
alexnask
I got it for once phd

1592937376
leeward
pixelherodev: It's hard to tell if nobody gets it or if it's just not funny. I have that problem all the time.

1592937394
pixelherodev
Nah, it's easy in this case

1592937404
pixelherodev
Like I said, nobody gets my references

1592937450
pixelherodev
The "joke" wasn't actually intended to be funny, it was a reference

1592937472
marler8997
which reference "See, it's a play on words, and that's where the humor comes in"?

1592937493
pixelherodev
and the "nobody gets my references" :P

1592937495
pixelherodev
Two references

1592937508
marler8997
I recognize the first one, I can't remember exactly where though

1592937526
fengb
It takes a lot of skill to tell jokes so bad it's funny

1592937699
andrewrk
that's why tommy wisaeu is the greatest actor, director, screenwriter, and producer of all time

1592937713
fengb
lol

1592937730
BaroqueLarouche
hahahaha

1592937798
pixelherodev
pft

1592937824
pixelherodev
"We should watch the greatest movie of all time: The Room!"

1592937838
pixelherodev
Convincing someone to watch it when they have no idea what they're in for is probably the worst sin someone can commit

1592937864
BaroqueLarouche
I have a signed DVD copy that my friends bought from his website

1592938230
alexnask
Nice

1592938980
marler8997
anyone know where that proposal is for custom integer type ranges?

1592939232
alexnask


1592939257
pixelherodev
andrewrk: ping

1592939389
pixelherodev
found the test failure, but I'm not 100% certain if this was deliberate or not

1592939539
pixelherodev
nvm, I see what's going on here

1592939580
shakesoda
wow i was just wondering if zig could do exactly that

1592939604
marler8997
alexnask, thanks

1592939713
tgschultz
result location is still TODO in the docs. What's the current state? Is it yet possible to safely return a struct instance that has a pointer to itself?

1592939725
andrewrk
tgschultz, not yet

1592939735
andrewrk


1592939789
tgschultz
thanks

1592940098
leeward
Is there a Zig way to spell "this loop does something, don't optimize it out" other than to have it modify a volatile pointer?

1592940373
andrewrk
that's an important language design question that doesn't have a stable answer yet

1592940426
leeward
Seems like a good job for a built-in.

1592940482
leeward
Unless the debate is over whether or not such a thing should exist, in which case I'd weigh in on the "yes" side for the sake of people writing delay-loops on microcontrollers whose timer interrupts are all being used.

1592940690
andrewrk
for this use case try this workaround: `asm volatile("":::"memory");` inside the loop

1592940775
andrewrk
marler8997, couldn't std.mem.Allocator have all the functions of both ExactAllocator and InexactAllocator? I'm confused why there is a need for separation

1592940778
leeward
Yep, that's an awful lot like what I do in C.

1592940804
marler8997
thinking...

1592940862
marler8997
so for page allocator, exact and inexact allocations cannot be mixed

1592940863
andrewrk
I was thinking keeping all the existing API exactly the same, and adding a couple new functions, which I expect to be more rarely used, which request inexact allocations

1592940884
marler8997
you can't take an exact allocation and pass it to an inexact allocation function

1592940888
marler8997
and vice versa

1592940905
andrewrk
the allocator implementations would always be inexact, but the Allocator interface could provide exact functions on top of it. why is that not possible?

1592940923
marler8997
it could

1592940930
marler8997
I started out that way

1592940962
marler8997
so this design stems from wanting the type system to be able to distinguish between exact and inexact allocators

1592940972
marler8997
so functions could indicate whether the allocator they use needs to be exact or not

1592940982
andrewrk
hmm I actually see that as a downside

1592940998
andrewrk
I see it as unwarranted type complexity

1592941002
marler8997
the touble I had with mixing the two

1592941012
marler8997
is that you can't mix allocations

1592941025
andrewrk
not sure I follow - can you elaborate?

1592941029
marler8997
so if you allocate an inexact allocation, you can't pass it to exact allocation functions

1592941061
marler8997
we could solve that by prefixing all the functions with something like exact... and inexact...

1592941066
marler8997
I tried that

1592941081
marler8997
using 2 different types ended up being alot simpler, but I'm definityl open to other ideas

1592941094
marler8997
I have a few different branches with different attempts

1592941121
andrewrk
hmm just checking, did you see this idea in the doc comments of my proposed resizeFn? /// The length of `buf` is a hint to the allocator, to help it find the allocated

1592941122
andrewrk
// block more efficiently. The hint may be too small, but too large is illegal behavior.

1592941140
marler8997
yeah

1592941156
marler8997
the interface allows for that

1592941165
andrewrk
this should let you call the inexact function, get a slice, and then return a smaller slice

1592941178
andrewrk
I'm still not able to understand the need for 2 interfaces

1592941200
pixelherodev
re: decl analysis, if I fix up the other branches in analyzeDecl, I end up with something realllly weird

1592941204
marler8997
yes, because allocators may need the exact size

1592941207
pixelherodev
Segfault with non-pointers

1592941213
marler8997
for example

1592941222
marler8997
say you allocate a 16K buffer from mmap

1592941236
marler8997
but the caller changes it to 4K

1592941240
pixelherodev
`std.debug.warn("test {} == {}\n", .{ a, b });` reading b there causes a segfault, but b isn't a pointer...

1592941244
marler8997
and then only passed a 4K buffer when freeing it

1592941258
marler8997
the c allocator would be fine with that

1592941262
marler8997
but the mmap allocator would not

1592941287
pixelherodev
IMO that's correct behavior?

1592941331
andrewrk
marler8997, I see, thanks - let me think about that

1592941348
marler8997
this allocator stuff has been kicking my butt

1592941397
pixelherodev
I don't see why that would be a bad thing?

1592941406
marler8997
here's 3 other attempts I've saved to branches:

1592941409
marler8997


1592941413
marler8997


1592941416
andrewrk
wow

1592941511
marler8997
one thought is we may be able to remove the ExactAllocator once clients' logic change to support inexact allocations

1592941546
marler8997
at minimum, I would expect most code to use InexactAllocator, and an ExactAllocator would be an one-off thing someone could use

1592941553
andrewrk
one thing to consider is that we don't necessarily

1592941561
pixelherodev
Ehh, I like the idea of an allocator that takes in the length while freeing instead of tracking it

1592941569
pixelherodev
That allows for lower memory usage anyways

1592941575
pixelherodev
Since it means not needing to track it internally

1592941582
pixelherodev
And clients often want to track it anyways

1592941589
marler8997
maybe

1592941609
marler8997
I think having an inexact allocator interface is pretty useful in general

1592941636
marler8997
it's what arraylist would be using for example

1592941795
marler8997
but the thing is, some allocator inherintly support exact allocations (the C heap allocator) and some do not.  If you do not, you would implement the InexactAllocator interface, if you do, you would support the ExactAllocator interface.

1592941821
pixelherodev
Uninitialized pointer, okay that makes sense, no idea how this is turning into a segfault

1592941822
marler8997
And code using allocators, could decalre which kind they need, ExactAllocator or InexactAllocator

1592941834
andrewrk
marler8997, another idea: "The length of `buf` is a hint to the allocator, to help it find the allocated block more efficiently. The hint may be too small, but too large is illegal behavior. === new part ===> If a given allocation returns the exact size requested, the hint must be exactly correct."

1592941867
andrewrk
this would make page allocator work without tracking size, and no need for 2 interfaces

1592941877
andrewrk
and this rule is easy for clients to follow

1592941897
pixelherodev
Huh, I like that

1592941927
pixelherodev
hmm

1592941930
pixelherodev
I think there's a compiler bug

1592941932
marler8997
that puts the burden on the allocator to track the size if it requires it

1592941959
pixelherodev
If you have an uninitialized pointer, and you do e.g. `std.debug.warn("{}", .{ &uninted_ptr.val });` it seems to infinite loop

1592941961
pixelherodev
in debug mode

1592941966
marler8997
by supporting an InexactAllocator, the caller can decide where to store the exact size if it is required

1592941980
marler8997
Either in the allocator (using InexactToExactAllocator) or just storing the exact size itself

1592941993
marler8997
so the interface is less flexible, because it only allows the allocator to manage the exact size

1592942005
pixelherodev
But that requires extra interfaces, which aren't needed.

1592942099
marler8997
The InexactAllocator already supports that rule

1592942120
marler8997
If you don't care about inexact allocations, you can forget about it and just use ExactAllocator

1592942124
pixelherodev
But that's my point

1592942132
pixelherodev
There shouldn't be multiple allocator interfaces

1592942138
marler8997
You can think of InexactAllocator as an internal detail if you want

1592942142
tgschultz
I read that differently, I read it as the client being responsible for keeping the size if it isn't exact, which would work fine for my purposes where I have an allocator that uses the size of the allocated memory to find it.

1592942146
marler8997
A way to share code between inexact allocators

1592942151
marler8997
to make then exact

1592942169
pixelherodev
but that's only useful if nothing uses it directly

1592942180
pixelherodev
Clients should never use anything other than std.mem.Allocator

1592942187
marler8997
> There shouldn't be multiple allocator interfaces...I'm not sure where this rule comes from or what it means exactly

1592942213
marler8997
>  Clients should never use anything other than std.mem.Allocator

1592942216
marler8997
I started with that

1592942220
pixelherodev
hmm

1592942224
pixelherodev
I'm going to have to backtrack :P

1592942226
pixelherodev
Reread from the start

1592942231
marler8997
the problem came up when I provide functions to allocate "exactly" and functions to allocate inexactly

1592942268
marler8997
you can't mix the 2, because an inheritnly inexact allocator would need additional metadata to track the exact sizes of inexact allocations

1592942300
marler8997
which means that buffers returned by std.mem.Allocator, would only be able to pass them back to some of the functions, but not others

1592942301
pixelherodev
What do you mean by "inherently inexact?"

1592942304
marler8997
this is a disaster of an interface

1592942315
marler8997
mmap is an example

1592942341
pixelherodev
Ah, in that it will definitionally provide extra RAM until the page end?

1592942344
marler8997
meaning it can only allocated certain sizes of allocations

1592942361
pixelherodev
Why?

1592942386
marler8997
because it's minimum allocation size is 4K, so if you request anything less than 4K, it still needs to reserve/allocate 4K

1592942408
marler8997
if you request 10 bytes, it will reserver 4096 (hence the name inexact)

1592942412
pixelherodev
Right, so?

1592942417
pixelherodev
Why does that matter for the interface?

1592942427
marler8997
You asked what inherintly inexact meant

1592942429
pixelherodev
It's not great in terms of efficiency of course, but that shouldn't matter

1592942439
marler8997
what do you mean so?

1592942442
marler8997
I answered your question

1592942445
pixelherodev
Why does such an allocator need to track exact sizes?

1592942457
marler8997
I already explained this example in the cat

1592942460
pixelherodev
> it would need additional metadata to track the exact sizes of inexact allocations

1592942460
alexnask
The point is that if you provide functions for exact and inexact allocations for every allocator

1592942460
marler8997
*chat

1592942465
marler8997
but I suppose I will explain it again

1592942472
pixelherodev
Sorry :P

1592942490
alexnask
The allocator will need to keep track of the actual allocation size to free it if the inexact allocated memory is freed with an exact function

1592942497
andrewrk
marler8997, you've clearly put a lot of work into this, I just want to make it clear that work is appreciated, and your observations are valuable, having done that work

1592942512
marler8997
thanks, and I'm not claiming I know all the answers

1592942543
marler8997
New ideas are very much appreciated, and I happy to discuss

1592942550
tgschultz
If I understand the inexact allocator problem correctly: if you allocate 5000 bytes, reslice it to 1000, then free it, you leak memory, however I think that is already against the API: thou shalt free the exact slice you were allocated.

1592942557
andrewrk
I think we're already asking a lot from people to care about allocators at all, I just want to weigh all the options before further complicating that

1592942568
pixelherodev


1592942574
pixelherodev
That's true for exact allocators oo

1592942575
pixelherodev
too*

1592942587
marler8997
tgshultz, yes

1592942597
marler8997
but the problem is, that allocators cannot resize allocations to be smaller

1592942613
marler8997
some allocatos cannot resize things to be exactly a particular size

1592942614
pixelherodev
ahh, so it's related to shrink?

1592942618
marler8997
and alot of code requires that behavior

1592942623
pixelherodev
Well, for mmap, you can pretend it is

1592942625
marler8997
pixherodev, yes

1592942626
pixelherodev
and the results are 100% correct

1592942628
tgschultz
mmap is a bad example then, since you can free unused pages

1592942632
pixelherodev
More than that

1592942642
pixelherodev
If you have 0x4001 bytes (two pages)

1592942642
marler8997
mmap kinda

1592942646
pixelherodev
and you free 0x4001

1592942650
pixelherodev
it'll free both full pages

1592942654
pixelherodev
So it won't leak at all

1592942664
pixelherodev
*unless you reslice*, which, as pointed out already, is already illegal

1592942684
marler8997
if you allocate 3 pages with mmap, and resize it to only be 2 pages when you free, then that 3rd page will leak

1592942693
pixelherodev
Yeah, so?

1592942697
pixelherodev
YOu're

1592942700
tgschultz
I have an allocator that meets the criteria though: it allocates things based on the smalles Po2 they fit into. Thus shrink causes a problem.

1592942704
pixelherodev
If you allocate memory, and don't free it, it'll leak

1592942708
marler8997
pixelherodev, that was the proposed interface

1592942715
marler8997
to allow clients to reslice before freeing

1592942720
pixelherodev
... why?

1592942731
pixelherodev
What's the use case for this?

1592942735
marler8997
so then we don't have 2 interfaces

1592942738
andrewrk
ok hear me out: resizeFn docs: "The length of `buf` is a hint to the allocator, to help it find the allocated block more efficiently. The hint must be >= the

1592942743
pixelherodev
*Why do we need any interface for it*?

1592942762
marler8997
so that clients that want inexact allocations (access to the full allocation) can have it

1592942762
pixelherodev
I'm not seeing why we need to allow reslicing before freeing

1592942764
andrewrk
so basically the client either tracks how much it requested or how much it received. the allocator implementation has to accept both

1592942777
pixelherodev
That's the problem to me though

1592942781
marler8997
if you request 10 bytes, but you get 4096, you want to know you actually have 4096 bytes

1592942784
pixelherodev
I don't like the idea of increasing the burden on allocators

1592942793
marler8997
this doesn't increase the burden on allocators

1592942799
andrewrk
pixelherodev, if you do allocator.alloc(Foo, 10) you need to get a slice with 10 Foos in it, not more

1592942802
tgschultz
I don't think that's actually the problem though andrewrk, it's that shrink cannot fail and must resize in place.

1592942817
pixelherodev
Why is that?

1592942827
pixelherodev
I remember seeing that, but I think I ignored it in my implementation lol

1592942879
marler8997
oh, allowing resize to accept a sub-slice does put the burden on the allocator, I misread what you were saying

1592942917
andrewrk
tgschultz, in which allocator is it a problem? for PageAllocator, this latest rule that I outlined would make it work fine

1592942932
marler8997
andrewrk, actually no

1592942944
marler8997
if you allocate 3 pages, and resize it to 2 pages, you leak the 3rd page

1592942954
andrewrk
nah you unmap the 3rd page

1592942958
andrewrk
that's what we do right now

1592942962
marler8997
oh, you're saying that you call resize

1592942966
tgschultz
None that are in the stdlib, but allocators like one I wrote or, IIRC, rpmalloc.

1592942975
marler8997
not that you sub-slice the buffer without calling resize?

1592942996
marler8997
is that right andrew?

1592942999
tgschultz
right, with mmap shrink can just free the third page

1592943010
andrewrk
the client would be responsible for tracking either the requested size or the actual size. if it wanted to track a smaller number than requested size it would be required to call resize

1592943013
shakesoda
cool, moved everything on my rpi to the ssd. build times are distinctly better

1592943026
marler8997
but I thought the proposal was, the client can slice the allocation without telling the allocator

1592943038
marler8997
so mmap wouldn't know there is a 3rd page to unmap

1592943053
marler8997
oh, requested or actual size

1592943054
andrewrk
that was a side effect of my initial doc comments proposal, but that wasn't the goal

1592943080
marler8997
that would work for something like mmap

1592943088
shakesoda
andrewrk: if ~/.cache/zig is symlinked to somewhere missing/gone, zig hangs and eats all ram

1592943095
andrewrk
the main goal is to allow implementations to return more than requested, and allow clients to optionally take advantage of it

1592943097
shakesoda
just ran into this :D

1592943116
marler8997
I think the current InexactAllocator accomplishes that goal

1592943116
pixelherodev
Uhh, this is almost definitely a compiler bug...

1592943120
tgschultz
for the record: I just accepted the limitation of the std interface and ate a byte of every allocation to store the Po2 the memory is part of.

1592943124
pixelherodev
Testing `0x7ffda3020fd8.* == 0xaaaaaaaaaaaaaab2.*`

1592943129
pixelherodev
`segfault at 0x0`

1592943134
pixelherodev
Neither address is zero...

1592943141
andrewrk
pixelherodev, run it with valgrind

1592943159
andrewrk
pixelherodev, with -Dforce-link-libc

1592943200
alexnask
tgschultz, are you using buckets for every power of 2? (just curious)

1592943206
pixelherodev
andrewrk: thx

1592943227
pixelherodev
Wow

1592943232
pixelherodev
That's... a

1592943243
pixelherodev
Valgrind: "More than 1000 different errors detected.  I'm not reporting any more."

1592943247
pixelherodev
"Go fix your program!"

1592943248
tgschultz
If that's the goal, andrewrk, we could return a struct with the requested slice and a total size. Client is free to take advantage of extra memory if desired.

1592943256
pixelherodev
Wowzers

1592943260
tgschultz
alexnask: yeah, that's how it works.

1592943285
andrewrk
tgschultz, the client already knows the requested size, and the proposed interface returns the total size, so I think we are in agreement

1592943339
marler8997
the questio is, when you need a slice of an allocation, who tracks the size, the allocator, or the client?

1592943341
tgschultz
yeah, as long as the client doesn't reslice the memory before freeing it it shouldn't be an issue (except in my particular case because of the implementation details).

1592943350
marler8997
I decided to punt and say that either could track it, it's up to the caller

1592943377
marler8997
there are some allocators that already track the exact size (like the C allocator)

1592943389
andrewrk
status quo: the client tracks how much it requested, and the allocator returns always the requested amount

1592943396
marler8997
right

1592943466
andrewrk
my proposal to keep only 1 Allocator interface: client tracks either how much it requested, or the actual amount returned by the allocator. Allocator impl returns either requested amount, or more, and has to support freeing/resizing based on both requested amount and actual amount that it returned

1592943506
marler8997
that might work

1592943523
marler8997
can they pass in a size in between the 2?

1592943548
pixelherodev
I really dislike this idea

1592943558
andrewrk
I think it would be reasonable from a client's perspective for it to be required to be only one or the other

1592943580
marler8997
so if they need to reslice it to a value in the middle, they need to call resize

1592943597
andrewrk
yes

1592943604
marler8997
pixelherodev, do you have another idea?

1592943605
pixelherodev
I would prefer it if we just kept the "slicing returned values is a no-no" rule, but as long as allocators remain simple, it's really not a big deal IMO

1592943606
tgschultz
I don't hate this idea, but I feel like it overcomplicates things.

1592943609
pixelherodev
^

1592943611
pixelherodev
Yeah, exactly

1592943618
pixelherodev
I think it introduces unnecessary complexity

1592943632
andrewrk
tgschultz, it's addressing a specific use case that is not addressed currently:

1592943659
andrewrk
with my proposal the Allocator interface stays the same, and gains a couple of "advanced" functions

1592943690
marler8997
andrewrk, yes I think it's a good proposal

1592943696
andrewrk
from an allocator implementation perspective, you now have the option to return extra bytes. that's all

1592943730
pixelherodev
andrewrk: the bug is exactly what I said it was earlier

1592943734
pixelherodev
Using an uninitialized value

1592943751
marler8997
andrewrk, I'll work on that proposal

1592943751
pixelherodev
But the

1592943786
andrewrk
marler8997, I know you just put a lot of work into this, I'm sorry to push back again. But I really think this is going to make zig's "you have to think about allocators now" approach more palatable for people in general

1592943803
fengb
So to summary... we're allowed to use the requested size or the returned value, but anything in-between requires an explicit resize?

1592943815
marler8997
andrewrk, I don't consider it push back, I consider us all pushing forward together

1592943823
andrewrk
nice, I like that :)

1592943832
andrewrk
fengb, yes that's the current proposal

1592943858
pixelherodev
Yeah, that's a good way of putting it :)

1592943880
pixelherodev
Hmm

1592943885
pixelherodev
Worse is that there's a number of errors in stage1

1592943905
pixelherodev
`Use of uninitialized value at 0x9F2446: ir_resolve_type(IrAnalyze*, IrInstGen*)` for instance

1592943926
fengb
It feels a little odd... but I guess that makes sense. Existing code will still work and we unlock "natural" sizing

1592943927
andrewrk
pixelherodev, have you discovered UB when compiling self-hosted?

1592943930
pixelherodev
Yes

1592943935
pixelherodev
Well

1592943942
pixelherodev
When compiling the test suite at least

1592943949
pixelherodev
But it might be my fault, been working on fixing resolveDecl

1592944006
pixelherodev
Lotttts of memory leaks in stage1 though, I think

1592944035
andrewrk
pixelherodev, you know the original strategy for stage1 was "never free anything" right?

1592944040
alexnask
stage1 wasnt freeing for the longest time

1592944046
pixelherodev
...

1592944070
pixelherodev
So I've heard, yes

1592944081
pixelherodev
From someone who was... rather unamused by it :P

1592944097
pixelherodev
What was the reasoning for that?

1592944118
fengb


1592944158
pixelherodev
fengb: hahahaa

1592944163
andrewrk
honestly once we are shipping self-hosted, we can probably go back to not freeing anything in stage1 again

1592944183
andrewrk
if self-hosted was done sooner we would never have had to care about memory management in stage1

1592944191
pixelherodev
...

1592944192
pixelherodev
uh

1592944232
pixelherodev
Seriously, what's the reasoning there?

1592944254
andrewrk
how much peak rss is reasonable to use for bootstrapping?

1592944262
pixelherodev
IMO? Not a lot.

1592944266
andrewrk
how much?

1592944271
pixelherodev
I'd like it to be able to be bootstrapped reasonably on e.g. a RasPi

1592944285
pixelherodev
4GiB

1592944298
shakesoda
that's a heck of a lot still!

1592944304
pixelherodev
For sure

1592944313
pixelherodev
and I'd hope it'd be nowhere near that

1592944317
pixelherodev
That's as a bare maximum

1592944324
pixelherodev
Preferably, 1GiB at worst

1592944340
pixelherodev
The lower the resource requirements to run it, the more often we can e.g. run CI / test suites

1592944352
pixelherodev
Which means minimizing RAM and CPU usage is definitely worthwhile if only for that

1592944394
fengb
My pi only has ~250mb available ram :(

1592944411
andrewrk
1 GiB, so that's how much RAM you need to build your self-hosted components. if you don't need to free anything to hit that goal, that's the simplest way to do it

1592944413
alexnask
can llvm compile hello world with 250mb of ram? /s

1592944428
shakesoda
alexnask: no :(

1592944460
shakesoda
fengb: i'm currently on one of the shiny new 8gb models, feels very luxurious

1592944488
shakesoda
fengb: i usually work on a zero w, very different machine

1592944504
fengb
Yeah I'm on a zero atm. Mostly setup for playing games

1592944523
fengb
I wonder if I can reclaim vram without a reboot. Probably not

1592944525
andrewrk
it's also possible, and I know this in away goes against what I've been saying the whole time, but it's also possible that we do a

1592944553
andrewrk
this is just an idea, not a plan

1592944559
shakesoda
i've been doing little games and a toy desktop env

1592944570
shakesoda
zero is very fun for such things

1592944575
pixelherodev
I really don't see why it's worthwhile to avoid free()ing

1592944590
pixelherodev
Even if we don't

1592944608
shakesoda
maximum simplicity and discouraging actually using it :D

1592944624
pixelherodev
Ugh

1592944625
shakesoda
given a choice though i want things to use the least resources they can

1592944628
pixelherodev
That's not simplicity.

1592944635
pixelherodev
That's inefficiency and wastefulness

1592944638
alexnask
/pats stage1 on the head "I still love you buddy"

1592944641
andrewrk
not freeing is the same thing as using one giant arena allocator for the whole process. there are valid use cases for it

1592944641
pixelherodev
I mean

1592944642
shakesoda
well, it's both.

1592944652
pixelherodev
Not when it reaches the triple digit MBs IMO

1592944654
shakesoda
it's not like you lose the ram forever

1592944664
shakesoda
but yes it's absolutely wasteful

1592944670
pixelherodev
Of course

1592944680
leeward
Ok, people who complained about new github are right. This text box is way too wide.

1592944719
andrewrk
the way stage1 is built right now it's not really possible to free ZigValue structs. it's a problem, yeah. self-hosted is designed much differently because of it. But ZigValue wasn't planned from the start, it arose organically as the language evolved over time

1592944723
tgschultz
new github is a good example of how modern design trends often make things arbitrarily worse.

1592944769
andrewrk
the freedom to put data wherever without having to sit down and plan out where everything goes, while still designing the language, was a freedom that helped quick iteration early on. I don't regret it

1592944779
shakesoda
how far from usable is self hosted anyways

1592944784
andrewrk
still pretty far

1592944790
tgschultz
I recall at one point my dev environment couldn't actually compile zig because it had too little memory, even with swap.

1592944791
pixelherodev
Depends on your definition of usable

1592944793
pixelherodev
:P

1592944802
shakesoda
how far in terms of release cycles lol

1592944807
alexnask
You can use it if you really like inline asm

1592944807
shakesoda
i know it's a current focus

1592944812
alexnask
:D

1592944814
tgschultz
that was a particularly tiny dev env though

1592944814
pixelherodev
alexnask: not yet lol

1592944821
andrewrk
I haven't given up hope of shipping it in this release cycle. it's a long shot but not impossible

1592944824
pixelherodev
After the next few PRs, yeah

1592944833
leeward
pixelherodev: usable defined as "passing all the tests we're passing now"

1592944834
pixelherodev
If I had to guess, 0.8 at the absolute latest

1592944839
pixelherodev
leeward: then very far

1592944844
shakesoda
ok, that's a pretty good picture of the situation

1592944878
andrewrk
there are still a few Hard Design Problems to solve in self-hosted, before we really start cruising

1592944896
pixelherodev
On that note

1592944910
pixelherodev
re: decl lookup, is the only thing needed for resolveDecl to change the hash function used?

1592944912
andrewrk
progress will feel slow, and then once those problems are sorted out, it will suddenly feel very quick

1592944919
pixelherodev
Because it looks like moving it to scope.fullyQualifiedHash should be fine

1592944933
pixelherodev
`const name_hash = scope.fullyQualifiedNameHash(mem.spanZ(old_inst.name));`, rather

1592945096
pixelherodev
Hmm

1592945104
pixelherodev
Seems to infinite loop in tests when looking an undefineds

1592945105
gonz_
tgschultz: I don't think the GitHub redesign is particularly bad. Is there anything in particular I'm missing?

1592945145
leeward
gonz_: Are you running it full screen on a wide monitor?

1592945202
gonz_
Yeah.

1592945206
leeward
Comment threads in English do not need to be 135 characters long.

1592945213
leeward
er, wide

1592945237
gonz_
Hmm, I'm getting very constrained viewports for the time being.

1592945260
gonz_
As in taking up maybe 40-50%, slightly offset to left of center.

1592945280
fengb
Everything should be 80 chars max :P

1592945324
pixelherodev
Eh

1592945333
pixelherodev
Depends on font size and screen size, among other things

1592945338
pixelherodev
No reason to waste space

1592945363
gonz_


1592945466
leeward
fengb: Agreed 100% firm rule no exceptions.

1592945480
leeward
(mostly serious)

1592945539
gonz_
This screenshot is from my 1080p secondary screen, if I move it to my bigger one it keeps the same proportions. This is with 110 zoom across all of GitHub, by the way.

1592945568
leeward
gonz_: That's about what I see.

1592945638
gonz_
I like it, to be honest. I'm sure there will be other things I notice that I don't like about their redesign, though, but we'll see.

1592945643
leeward
For what it's worth, I wrap my comments at 70 characters. English just doesn't need to be that wide, and humans are way better at reading up and down.

1592945703
pixelherodev
andrewrk: found the new test failure in self-hosted

1592945710
pixelherodev
resolveInst is returning an undefined pointer when it should be erroring

1592945727
pixelherodev
Input: valid Inst. Output: undefined pointer.

1592945742
pixelherodev
Oh, you changed it, I see

1592945799
pixelherodev
Going to fulfill that TODO, and see what else breaks :P

1592945917
fengb
leeward: switch to Japanese or Chinese :P

1592945946
pixelherodev
Which variant?

1592946064
leeward
fengb: Good plan. I'll start writing my comments in simplified chinese.

1592946698
shakesoda
what happened to readFileAllocAligned

1592946736
gonz_
`readFileAlloc` & `readFileAllocOptions`

1592946746
gonz_


1592946765
marler8997
shakesoda, you missed andrew's last twitch stream :)

1592947205
pixelherodev
andrewrk: is there supposed to be a way to check if a zir.Inst has been analyzed?

1592947269
shakesoda
marler8997: i did

1592947329
shakesoda
gonz_: thanks

1592947670
pixelherodev
andrewrk: when are positionals analyzed? By their parent analysis function?

1592949440
alexnask
Hah, finally hit a compiler bug in ctregex

1592949443
alexnask
I was getting worried

1592949464
pixelherodev
lol

1592949472
alexnask
I was getting worried

1592949472
pixelherodev
andrewrk: let me know when you have a chance to discuss stage2

1592949474
alexnask
woops

1592949766
pixelherodev
Got the tests giving more useful info at least

1592949767
pixelherodev
`:9:13: error: unimplemented: resolveDecl`

1592949773
pixelherodev
Instead of an assertion failure

1592950069
shcv
hey; I'm still trying to build the lastest zig, but am getting stuck on "undefined reference to clang::driver::(...)" errors when linking zig0... any suggestions? I have clang installed with all of its libraries, so I'm pretty sure those files are available

1592950119
pixelherodev
PREFER_DYLIB, or something like that

1592950144
pixelherodev
shcv: try setting ZIG_PREFER_CLANG_CPP_DYLIB on

1592950211
shcv
like "cmake -DZIG_PREFER_CLANG_CPP_DYLIB=ON .." ?

1592950225
pixelherodev
Yeah, exactly

1592950304
shcv
I'm also wondering if the list of paths to look in in the cmake files are wrong, or at least don't include the place mine are stored

1592950335
shcv
I don't know much about cmake though

1592950354
marler8997
I'm seeing an issue with the latest allocator proposal, one is that there are some places where a client needs to get the full size of an allocation when they possibly have a partial size

1592950391
marler8997
for example, in failing_allocator.zig, when a buffer is freed, it doesn't know whether the buffer being passed in is the requested size of the full size, so it doesn't know how much memory is actually being freed

1592950431
marler8997
one way to solve this, would be to add an allocator function, getFullSize, instead of returnning the full size from allocFn

1592950477
pixelherodev
That doesn't matter though

1592950484
marler8997
another place where this can matter, is when invalidating memory

1592950485
pixelherodev
failing_allocator just passes it through

1592950503
marler8997
failing_allcoator keeps track of the memory allocated and memory freed, and validates it has all been allocated and freed

1592950517
pixelherodev
Ah right, gotcha

1592950520
pixelherodev
I see what you mean now

1592950637
marler8997
this issue also comes up during realloc, first we try to resize in place, but if that fails, it may return a size larger than what was passed in, so we have to restore the original size, but we don't know the original size

1592950785
pixelherodev
Ohhh, I see the big issue here

1592950797
pixelherodev
Decls use the AST / ZIR node index now, not the source index

1592951519
shcv
ok, managed to get past the clang libs issue, but now I get "CommandLine Error: Option 'mc-relax-all' registered more than once!"

1592951644
pixelherodev
Oof

1592951648
pixelherodev
That's definitely a known issue

1592951656
pixelherodev
Don't remember the solution though

1592951659
pixelherodev
LLVM's fault :P

1592952135
shcv
of course :(... I'll be glad when I can use zig's build system instead

1592952155
shcv
unfortunately, the 0.5.0 compiler I have isn't recent enough

1592952195
alexnask
shcv, You can donwload a nightly build on the website if you only want to use it and dont have a particular need to compile it yourself

1592952268
pixelherodev
^

1592952272
pixelherodev
I do that to work on stage2

1592952340
gonz_
Wasn't shcv one of the ones who wanted to run on FreeBSD aarch64?

1592952392
alexnask
ah, idk I guess they will have to struggle with llvm then :P

1592952393
gonz_
Or was that someone else? In that case I'm not sure there are builds up?

1592952420
gonz_
I may be misremembering.

1592952685
gonz_
Ah, his nick was dch

1592953138
pixelherodev
Got transformation tests *running*, but they're producing zero ZIR :P

1592953237
pixelherodev
Got more tests passing!

