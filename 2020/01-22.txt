1579651529
plumm


1579651535
plumm
whats wrong with this?

1579651641
daurnimator
plumm: well I get a segfault running it :P

1579651648
daurnimator
s/running/compiling/

1579651673
plumm
i know its wrong, just idk where

1579651679
plumm
not gdb-smart enough

1579651876
plumm
something in the zero'd function

1579652066
plumm
im assuming its the undefined

1579652520
fengb
I always get confused when handles here doesn’t match GitHub >_>

1579652736
Snektron
Aah

1579652764
Snektron
So the Vulkan registy specifies which parameters and members are optional

1579652779
Snektron
But i'm told that its not very consisted and that i should just ignore it

1579652781
Snektron
A shame

1579652870
Snektron
That reminds me, which kind of pointers can be exported to C?

1579652888
Snektron
apart from [*]T and [*c]T

1579652911
fengb
T, [:sentinel]T

1579652934
fengb
`*T, [*:sentinel]T`

1579652945
fengb
Matrix wins. Matrix always wins

1579652995
fengb
Pretty sure any pointer is exportable. Slices cannot be

1579652998
Snektron
compiler explorer isn't complaining about `?*T` either, does that do what i think it does?

1579653010
mikdusan
daurnimator: yes, big dump: json.test "parse into struct with misc fields"

1579653026
fengb
Hmm I’d expect optional pointer to be well defined

1579653027
Snektron
<fengb "Matrix wins. Matrix always wins"> Beats IRC if you ask me

1579653035
daurnimator
mikdusan: "big dump"?

1579653053
mikdusan
trace

1579653218
mikdusan
it does look a bit odd. if you run `zig test lib/std/json.zig` it gets shorter than failing test trace on std.zig

1579653270
mikdusan
and it gets down to 4 line trace with this: zig test lib/std/json.zig --test-filter "parse into struct with misc fields"

1579653759
fengb
Snektron:

1579654224
Snektron
great

1579654403
fengb
Curious... what do we do when the abi defines null to something other than 0?

1579654474
andrewrk
do you have an example of this?

1579654516
Snektron
Sounds like one of those cases which is technically possible but nobody should be doing

1579654549
Snektron
I can imagine some project defining -1 to be NULL though

1579654603
fengb


1579654689
Snektron
its like architectures where CHAR_BIT != 8

1579654781
fengb
PDP7 was an 18bit architecture cause why not

1579654869
Snektron
I think the most straightforward solution would be to remove `allowzero`

1579654886
Snektron
and instead add a method to define a `null`-value for the pointer

1579654975
Snektron
that would also include a way to define a pointer that doesn't have any null value

1579655029
Snektron
I could imagine something like `@PointerType(i32, .{.null_value = 1234})`

1579655039
andrewrk
pointers would be definable in terms of integer address ranges

1579655044
Snektron
or `@PointerType(i32, .{.null_value = null})` to define one without

1579655050
andrewrk


1579655064
andrewrk
I think I briefly went over this point in the discussion here

1579655080
Snektron
That would work also

1579655103
Snektron
But then you need a way to express the pointer type of a pointer

1579655115
fengb
I feel like I’m derailing everyone with silly goose chases

1579655121
Snektron
pretty much

1579655128
Snektron
but its 2 am and im bored anyway

1579655211
andrewrk
I got the true zig experience today: went down a really promising path that involved comptime, got super close to being done, then hit a brick wall of compiler bugs

1579655227
Snektron
I can relate to that

1579655246
Snektron
Every time i push my friends into Zig i get "that language where the compiler crashes every few seconds?"

1579655286
daurnimator
mikdusan: ah yep

1579655295
daurnimator
mikdusan: any idea what might be causing the trace to be so.... wrong?

1579655369
mikdusan
it smells like a similar situ with build_runner, where it accumulates stack traces that are handled as returns and not errors

1579655381
mikdusan
I'll try to find PR

1579655407
andrewrk
Sahnvour came up with a nice (accepted) proposal to solve this

1579655482
mikdusan
ah yes

1579655500
mikdusan
not entirely sure if it's the same thing, daurnimator

1579655605
daurnimator
hmm okay

1579655717
BaroqueLarouche
any reason why std/elf.zig use extern enum and extern struct ? Legacy code ?

1579655870
Snektron
Probably needs to be compatible with C

1579656291
mikdusan
daurnimator: here's the little instigator:

1579656352
mikdusan
each such test involving `error.Something` has a proportional effect on stack trace

1579656776
quetzalb
commit 7a1cde7206263c8bb3265c225ed4213d1b7bdb58 seems to have introduced build break for me (Assertion failed at /home/qbradley/src/zig/src/analyze.cpp:7624 in get_builtin_value)

1579656851
quetzalb
break on x86-64 ubuntu

1579657019
plumm
fengb: i would gladiator battle the guy who owns nick on here

1579660009
andrewrk
argh, on sr.ht sys::getHostCPUName() reports "athlon-xp" as the native cpu, but clang says "unknown target CPU 'athlon-xp'":

1579660037
andrewrk
and llvm says "LLVM ERROR: 64-bit code requested on a subtarget that doesn't support it!"

1579660362
andrewrk
ok I think llvm is simply incorrect about the cpu name

1579660461
andrewrk
sys::getHostCPUName() reports athlon-xp which is a 32 bit cpu, but sys::getHostCPUFeatures() reports an inconsistent list with this, including +64bit

1579660476
andrewrk
ugh, now I have to write code to work around llvm giving the wrong answer for the native CPU

1579660639
BaroqueLarouche
andrewrk: any reason why std/elf.zig use extern enum and extern struct ?

1579660684
andrewrk
yes these structs are memory-compatible with the ELF format

1579660804
andrewrk
you can mmap and @ptrCast for example

1579660805
BaroqueLarouche
packed struct should do the same job no ?

1579660837
andrewrk
it would be more verbose to do that. the ELF structs adhere to the C ABI by design

1579660866
BaroqueLarouche
got it

1579663281
daurnimator
andrewrk: thoughts about using a distinct type for fd_t?

1579663326
daurnimator
something like `pub const fd_t = enum(u32){_};` could even add methods on it.....

1579663532
andrewrk
we have fs.File

1579663701
daurnimator
true... but we use fd_t in os.zig

1579663747
daurnimator
I feel like it could prevent mistakes if you e.g. were unable to accidently pass a length as an fd

1579663755
daurnimator
Same with pid_t

1579663837
fengb
I’m in favor. In Elm I learned to wrap record ids and it prevented accidental mixing of very similar types

1579664029
fengb
Also, stdin/ stdout/ stderr should be named enum members right?

1579664077
daurnimator
fengb: ah yeah good idea :) `pub const fd_t = enum(u32) { STDIN = 0, STDOUT = 1, STDERR = 2, _ };`

1579671797
daurnimator
One note though is that we can't have enum members conditional on target due to lack of @reify

1579678605
mq32
daurnimator: we do actually have @reify, but it's not implemented for enums yet:

1579679266
daurnimator
mq32: right.

1579687281
bgiannan
Did something change with fmt? seems like `{c}` with say 193, gives me two { 92, 120 } Is there some utf8 things happening?

1579687909
daurnimator
bgiannan: that was done about a month... and then undone recently (last week?)

1579690028
daurnimator
great success; got zig code running on my FOMU

1579690044
daurnimator
the new cpu features branch was necessary!

1579690410
mq32
daurnimator: FOMU?

1579690438
daurnimator
mq32:

1579690486
daurnimator
FPGA that fits into a usb A port. You can load a riscv32 core onto it. And I just targeted it with zig

1579690621
mq32
nice!

1579690629
mq32
this is great news

1579693582
bgiannan
daurnimator, so how do i avoid that transformation?

1579693722
daurnimator
bgiannan: upgrade to anything after

1579693727
bgiannan
ah nevermind i just upgraded

1579694987
mq32
nice read about some good qualities of go:

1579697484
TheLemonMan
andrewrk, can you grab a copy of /proc/cpuinfo from the sr.ht ci machine?

1579697492
daurnimator


1579697553
TheLemonMan
daurnimator, `.abi = gnu` makes little to no sense when you're targeting a freestanding target

1579697737
daurnimator
TheLemonMan: what should I put instead?

1579697752
daurnimator
TheLemonMan: doesn't the gnu api set things like e.g. the signed-ness of chars?

1579697774
TheLemonMan
daurnimator, `none`

1579697817
daurnimator
TheLemonMan: oh

1579697845
TheLemonMan
it sets a few flags inside llvm that may affect the codegen phase, it really depends on the target arch

1579699654
daurnimator
TheLemonMan: I remember you wrote some compiler_rt for a few platforms: would it be easy to add riscv32 ones?

1579699968
TheLemonMan
uh, what kind of riscv32 core is that?

1579699980
TheLemonMan
I mean, what extensions are enabled?

1579700024
scientes
daurnimator, compiler_rt is under a liberal license

1579700031
scientes
you just go and port it to zig

1579700049
fengb
mq32: I actually love using Go despite it being one of the languages I like the least.

1579700085
scientes
daurnimator, oh, that one is in assembly

1579700086
fengb
Okay that’s harsh but it’s definitely not what I consider great... but it’s good enough in all the right ways and

1579700123
scientes
daurnimator,

1579700187
scientes
daurnimator, that is only for super-cheap platforms that do not have multiple instruction......

1579700236
scientes
and it is quite simple and could be written in zig (although the risk there is that the compiler optimizes it to a call to itsself)

1579700250
TheLemonMan
yeah it has to be written in asm because of that

1579700368
TheLemonMan
daurnimator, I'd wait for the cpu-features branch to be merged before porting that

1579700380
scientes
TheLemonMan, you just use no-optimize flag, and probably produce something similar

1579700414
TheLemonMan
it doesn't work like that, the mul instruction is always lowered to a builtin call

1579700436
scientes
but the optimizers has to realize it is a multiple

1579700439
scientes
*multiply

1579700448
scientes
which it probably can't

1579700458
TheLemonMan


1579700477
TheLemonMan
been there, done that

1579700511
scientes
wow, I totally called that bug without knowing you guys already ran into it

1579700564
daurnimator
TheLemonMan: no extensions

1579700574
daurnimator
TheLemonMan: and I'm currently already on the cpu feature branch :P

1579701878
TheLemonMan
yay the sr.ht mistery is now solved

1579701890
TheLemonMan
as usual it was not LLVM that was wrong :P

1579709959
fengb
Hmm, emscripten is a valid LLVM target so I can compile my Zig wasm VM into emscripten and run it in the browser 🤔

1579709999
mq32
fengb, have you seen

1579710018
mq32
they've done the "we have emscriptend our wasm interpreter with wasm"

1579710036
fengb
Well damn, I'm no longer unique

1579710055
mq32
i want to try wasm3 some time, it looks promising and is damn fast

1579710108
fengb
It was pretty buggy the last time I tried it. WAVM was the best performer so far

1579710122
fengb
I'm not sure what's going on with Rust but their wasm memory performance is atrocious

1579710301
fengb
Apparently my first step to wasm is... writing a sexpr parser

1579710309
mq32
^^

1579710326
mq32
wasm3 is afaik the fastest non-JIT runtime

1579710342
mq32
and it supports embedded devices which is nice

1579710383
fengb
RIIZ

1579710442
mq32
RIIZ?

1579710466
fengb
Rewrite it in Zig 🙃

1579710572
mq32
ah!

1579710639
mq32
i thought about writing a tar archiver/unarchiver in zig

1579710646
mq32
i wanted to learn how tar works anyways

1579710654
mq32
but: time :(

1579710666
fengb
That'd be useful actually. Probably more useful than what I'm doing >_>

1579710682
mq32
yeah, i know

1579710688
mq32
package manager and such

1579710699
fengb
Although andrewrk really wants wasm builtin to Zig for some reason, so having a "native" implementation is still useful

1579710747
fengb
I just want to toy around a VM. See what I can do when I'm not confined by "cycle accuracy" like with my emulator

1579710749
companion_cube
mq32: can you extract-c on tar's implementation? 🙃

1579710769
mq32
D: you mean just convert the original tar to zig? :D

1579710804
Snektron
its probably full of hacks

1579710822
companion_cube
surely there are other implementations

1579710824
companion_cube
libarchive or whatnot

1579710927
mq32
i'd like to write it from scratch, but right now i need time first:D

1579710964
companion_cube
I think it's fine to bootstrap everything by binding to C or translating from

1579710966
companion_cube
C

1579710995
mq32
yeah true, but that doesn't help to understand tar as a file format

1579711566
fengb
lol... I'm abusing generators everywhere it's not needed -_-

1579712069
TheLemonMan
andrewrk, I'd suggest you to read again what I wrote about LLVM being incorrect

1579712085
TheLemonMan
the problem is a bug in Qemu, triggered by how sr.ht defines the VM

1579712146
andrewrk
ok but all the other software can compile code just fine. you're suggesting zig should fail?

1579712227
andrewrk
e.g. we just used gcc to build zig and it worked

1579712281
andrewrk
(I agree sr.ht/qemu should fix the cpu to report correctly)

1579712290
TheLemonMan
the cpuid is wrong, any software attempting to do feature detection based on the model will fail

1579712314
TheLemonMan
Zig does that and allowed us to spot and report the problem, that's good

1579712328
andrewrk
let me test what the cpuid reports exactly

1579712366
TheLemonMan
I've linked you the scripts used by sr.ht, a link to qemu source code and I've also had a brief chat with Drew some hours ago

1579712392
andrewrk
where is llvm getting the cpu features that disagrees with the cpu name?

1579712392
TheLemonMan
and he did confirm they're using "qemu64" because freebsd is having problems with the host cpu

1579712418
TheLemonMan
the cpu features are extracted from the cpuid, the model name from...well the model field?

1579712436
andrewrk
so the cpuid has correct features but not the model name

1579712479
andrewrk
what about the skylake thing? which set of features is correct?

1579712487
TheLemonMan
everything's faked by qemu, they grabbed a few features and picked up a random model and voila

1579712716
andrewrk
so you would suggest to revert

1579712764
TheLemonMan
I'll have a look at the skylake problem later, I'm a bit in a hurry right now

1579712776
TheLemonMan
yeah, there's no need to overcomplicate it

1579712808
andrewrk
fair, thanks for the help

1579712814
andrewrk
aarch64 and windows are still a mystery

1579712832
TheLemonMan
the windows thing was fixed in LLVM10 last time I checked

1579712854
andrewrk
ok I can test in the llvm10 branch, which needs to be updated

1579712872
andrewrk
the branch happened btw

1579713121
TheLemonMan
wrt the fast_gather stuff, I suppose that setting the cpu name also sets a bunch of base features

1579713157
TheLemonMan
the cpuid code covers only a few of them

1579713213
TheLemonMan
you should ask the LLVM devs if that's the case and/or check out what clang does when you specify the "native" arch

1579713222
andrewrk
so the correct set of features would be the longer set corresponding to the known cpu features

1579713244
andrewrk
ok I'll ask

1579713308
TheLemonMan
it depends, if your cpuid reports you have no AVT (eg. you're on a VM where it's been disabled) you shouldn't blindly take

1579713371
andrewrk
that would be an argument to not revert cbe9a51

1579713414
fengb
Tangentially related: would it be useful to build a fat binary that can detect features at runtime and swap out the implementation?

1579713487
andrewrk
yes

1579713500
andrewrk
that is

1579713543
TheLemonMan
hah "FIXME: We should also incorporate the detected target features for use with -native."

1579713565
andrewrk
now there is some evidence for my argument that we have something to gain from self-hosting native CPU detection :)

1579713575
fengb
Ahhh cool

1579713665
andrewrk
fengb, the broader topic here is making a binary that is as portable as possible. it would be interesting to try to make an ELF binary that had multiple OS and arch implementations of the same thing. universal binary

1579713684
andrewrk
that might be silly, but it does simplify things for the user if they don't mind a few extra bytes on their hdd

1579713707
andrewrk
this use case is valuable to game devs

1579713736
fengb
Yeah Apple did it with the 64bit transition and it seemed to work pretty well

1579713757
andrewrk
also idk the PortableExecutable format very well yet, but it's possible you could do a thing like pdf/zip where you make something that is both an elf and a .exe

1579713800
mq32
there's the

1579713836
andrewrk
neat!

1579713879
pixelherodev
I've made executables that were simultaneously PNG images and z80 ROMs :)

1579713946
pixelherodev
Alrighty, beginning work on porting that is going on my todo list for today

1579713953
pixelherodev
The self-hosted CPU detection

1579713954
mq32
pixelherodev, afaik the Pico8 does this as well

1579713958
pixelherodev
Not the PNG/z80 ROM :P

1579713961
pixelherodev
mq32, 99% sure it does

1579713970
pixelherodev
I think that was my inspiration to research the PNG format actually

1579713995
Snektron
Did you do the pixel thing

1579714000
Snektron
Or did you just another tag

1579714009
Snektron
Because i think you can just add random tags to png images

1579714016
andrewrk
pixelherodev, it should be pretty clear how to integrate that work if you base it on #4264. slap your code right here:

1579714052
pixelherodev
Snektron, neither :)

1579714061
pixelherodev
I'd considered it, but the fasted to implement was literally just `cat`

1579714070
pixelherodev
`cat png rom >jointfile`

1579714086
TheLemonMan
andrewrk, check out `getFeatures` in MCSubtargetInfo.cpp

1579714092
pixelherodev
andrewrk, rightyo

1579714127
TheLemonMan
it picks all the features from the specified cpu and then it applies the +/- modifiers specified by the feature string

1579714168
TheLemonMan
I guess that if you don't specify any target cpu then it's on you to pass the correct feature set

1579714595
andrewrk
I think we should keep cbe9a51

1579714666
andrewrk
self-hosted native target detection can hopefully be improved to return a value that more strongly indicates "the cpu is 'xyz' and you can trust that it has all the expected features"

1579714703
pixelherodev
Well, it can do a CPUID test against all expected features

1579714707
pixelherodev
Seems pretty trivial to implement

1579714722
andrewrk
in the sr.ht environment, it would detect the model/features mismatch and return something like "cpu is unknown; feature set is xyz"

1579714766
pixelherodev
Or `CPU self-reports as XYZ but lacks XYZ features ABC`

1579714774
pixelherodev
I feel like that list will typically be smaller and easier to read

1579714792
TheLemonMan
cbe9a51 is wrong. If the cpu has 'a,b,c' and LLVM feature detection returns '-c' what does it return?

1579714840
andrewrk
CpuFeatures { .features = featureSet(&[_]Feature{ .a, .b, .c }) }

1579714847
andrewrk
correction:

1579714889
andrewrk
sorry I misunderstood the question. that doesn't happen, llvm feature detection specifies all the features, + or -

1579714907
andrewrk
do you have evidence to the contrary?

1579714916
TheLemonMan
not really, the target detection code for x86 specifies only a handful of them

1579714934
pixelherodev
Question

1579714940
pixelherodev
Is the goal to match the LLVM behavior?

1579714946
andrewrk
so it should take the cpu features, and then add/remove features from the set?

1579714947
pixelherodev
That is, should I do a straight up port?

1579714949
TheLemonMan
...namely only the few ones that may or may not be available, hence the cpuid test

1579714957
pixelherodev
Or should I implement detection of

1579714966
pixelherodev
I can do either one

1579715001
andrewrk
the goal is to do what makes sense according to hardware, with the knowledge that we do have to be able to translate this info to a format that llvm understands

1579715006
TheLemonMan
llvm is already doing that for you, if you want to do the intersection yourself you're welcome to do so

1579715038
andrewrk
TheLemonMan, are you suggesting to change the data layout of std.Target.CpuFeatures?

1579715071
andrewrk
in the branch it's a tagged union: baseline, a specific cpu, or a feature set

1579715080
TheLemonMan
the algorithm is: if (target == "native") { cpu_name = host_cpu_name(); cpu_features = host_cpu_features(); }

1579715129
TheLemonMan
otherwise it's `cpu_features = base_cpu_features_of(cpu_name); cpu_features |= runtime_enabled_features; cpu_features &= ~runtime_disabled_features;`

1579715132
pixelherodev
Why do we care about name at all, other than reporting to user?

1579715155
TheLemonMan
the name sets the base profile

1579715158
pixelherodev
Isn't it always better to do proper detection of CPUID bits though?

1579715163
andrewrk
cross compiling

1579715187
pixelherodev
Talking specifically about native compilation though

1579715193
TheLemonMan
you also telling LLVM what microarch you're targeting and that heavily influences the codegen

1579715194
pixelherodev
Why does host_cpu_name need to exit?

1579715204
TheLemonMan
the cost tables are different and so on...

1579715213
pixelherodev
Right, but feature  - ohh right

1579715231
pixelherodev
It's not just about feature presence, it's about feature cost, which varies dependent on HW

1579715266
TheLemonMan
yeah not only that, there are several erratas and various bits of trivia that affect different cpus in different ways

1579715285
andrewrk
TheLemonMan, ok sounds like CpuFeatures should be actually a struct, with a cpu always specified (maybe it is baseline), and feature set always specified

1579715353
andrewrk
TheLemonMan, I would also value your opinion on

1579715392
andrewrk
the target "triple" could be improved to handle features like that gcc page shows: aarch64+v8_5a-linux-musl

1579715400
andrewrk
this would allow std.Target.Arch to be an enum rather than a tagged union

1579715457
TheLemonMan
(I haven't read yet the patchset) is it a bitset right now?

1579715545
andrewrk
std.Target.Cpu.Feature.Set is a bit set; that part works fine. std.Target.CpuFeatures is a tagged union of {baseline, *const Cpu, Cpu.Feature.Set}

1579715577
pixelherodev
4

1579715583
pixelherodev
woops. ignore that

1579715630
TheLemonMan
I think it'd be less clunky if the baseline features were already "folded" into the feature bitset

1579715672
andrewrk
yes I think that is the way forward here, so it becomes a struct of *const Cpu, and then the bitset has the cpu features, with the + and - adjustments added to it, and dependencies resolved

1579715672
TheLemonMan
as a end-user I only care about what's available for my binary, reasoning about the feature hierarchy is slightly distracting

1579715686
TheLemonMan
that sounds good

1579715701
pixelherodev
Dependencies?

1579715751
pixelherodev
Ahh, like AVX512 -> AVX256?

1579715753
TheLemonMan
oh dependencies, right... do we have something that checks for dependency violations?

1579715771
companion_cube
the stdlib docs don't point to the source code?

1579715785
andrewrk
so you will be able to do: if (comptime std.Target.current.hasCpuFeature(@enumToInt(std.Target.aarch64.fp_armv8)) {

1579715799
Snektron
Should `&.{}` be valid?

1579715808
Snektron
In this case when converting to a slice

1579715832
TheLemonMan
that's quite a moutful heh

1579715864
pixelherodev
Why is hasFeature int and not enum?

1579715878
pixelherodev
Worst case, the @enumToInt can be done in the function

1579715878
andrewrk
Snektron, yes I think probably. I'm guessing you're trying to use the std.fs.path api

1579715884
pixelherodev
No need for the caller to have to depend on it

1579715895
pixelherodev
s/depend on it/call it manually

1579715903
pixelherodev
That makes it slightly less of a mouthful

1579715908
andrewrk
TheLemonMan, I didn't implement dependency violation detection in this branch

1579715927
pixelherodev
`if (comptime std.Target.current.hsaCpuFeature(.fp_armv8)) {`

1579715927
TheLemonMan
wild idea, hasCpuFeatures(.{...}) ?

1579715948
pixelherodev
That would still require a way of checking for a singular feature

1579715949
andrewrk
that can work

1579715957
TheLemonMan
andrewrk, cool, that's definitely out of the scope for a MVP

1579715962
pixelherodev
MVP?

1579715973
TheLemonMan
Minimum Viable Product

1579715974
andrewrk
pixelherodev, the bit set is arch-independent

1579715975
pixelherodev
ah

1579715992
pixelherodev
to both :)

1579716025
andrewrk
otherwise it would turn into generic spaghetti

1579716058
pixelherodev
Wait, how does that work though? Doesn't that require a direct mapping of features between ISAs?

1579716200
andrewrk
each bit is an index in the arch-specific enum

1579716210
andrewrk
so you have to know the arch to make any sense out of the bit set

1579716327
pixelherodev
... then what's the advantage of using the bit and not just `var`? Smaller binary?

1579716353
andrewrk
avoiding generic spaghetti

1579716363
pixelherodev
Right but

1579716372
pixelherodev
How is it any worse if the type of the arg is `var`

1579716374
andrewrk
std.Target is not a generic type

1579716379
pixelherodev
and then you do @enumToInt on the inside?

1579716406
andrewrk
in zig if a struct field has type var then the entire struct must always be known at compile time

1579716409
TheLemonMan
that's not a good elevator pitch for Zig's generics heh

1579716411
pixelherodev
Ohh

1579716457
Snektron
In theory its possible to re-monomorphize the code, especially because the backing type of enum's will probably be the same in most cases

1579716475
Snektron
Probably tricky to implement

1579716482
andrewrk
I don't really see it as a problem

1579716492
andrewrk
types are a tool; when the tool gets in the way of the job then don't use it

1579716536
Snektron
rather youre probably using the wrong type

1579716784
pixelherodev
Closing IRC to focus on some work; I'll be back in an hour or two

1579716841
companion_cube
that was fast

1579716883
TheLemonMan
wild idea again, what if instead of a bitset we use a struct with `has_<feature_name>`: bool that are filled at compile time?

1579716914
andrewrk
std.Target is used at runtime. sounds like this will break that?

1579716967
andrewrk
oh I see, it would be a union based on arch

1579716984
andrewrk
I like that

1579717011
andrewrk
maybe not for MVP? I want to get this working

1579717028
TheLemonMan
haha we're

1579717107
BaroqueLarouche
I wanted it yesterday

1579717245
TheLemonMan
getting the API right is hard, even if it's not set in stone yet I wouldn't want to break all the user code over and over

1579717272
TheLemonMan
I'm delighted that nobody complained yet about @export having a different syntax

1579717466
andrewrk
did you see my proposal for similar syntax for @extern ?

1579717483
andrewrk


1579717525
TheLemonMan
I think I've answered on hryx's ticket

1579717570
andrewrk
ah

1579717737
andrewrk
ok I'll look at that issue (after cpu features) and try to get it to either closed or accepted by end of week

1579717799
metaleap
when i `os.exit(code)` directly from my `main` does its `defer` still run? unlikely but thought i'd doublecheck. in go it wouldnt for example. reckon the underlying syscall tends to kill , given that i see an `unreachable` in std/os/linux.go#exit

1579717981
metaleap
nevermind saw that `fn main` can return `u8` so will assume thatll be the exitcode

1579718039
Snektron
multi level pointers in c are so weird

1579718041
Snektron
const T**

1579718053
Snektron
i keep forgetting where to place the const

1579718074
Snektron
at least its better if you write `T** const`

1579718127
shachaf
Those aren't the same, though.

1579718148
shachaf
Someone once told me to think of const as a subscript applied to *, as in "T *_{const}".

1579718150
Snektron
See

1579718156
Snektron
i keep forgetting

1579718171
andrewrk


1579718221
shachaf
That spiral thing is way more complicated than you need to read C declarations and I think it's also not really correct.

1579718232
fengb
One thing that’s weird in Zig is pointers to namespaced values feel backwards

1579718252
shachaf
C declarations use the same syntax as C expressions. It's not really an ideal syntax but it's internally consistent.

1579718262
fengb
I typed `std.mem.*Allocator` on cruise control

1579719351
metaleap
so a sugar question/notion. we can `if` on optionals and errs with the 'then' case getting the good-path value and the 'else' case for the "bad" path. ever considered being to invert via the ("technically only bool right now") `!` operator? sometimes could be more readable for multiple nestings where the "bad path" is short (but not empty) until finally arriving after multiple subsequent ifs at a fat "good path"

1579719366
metaleap
s/being/being able

1579719407
metaleap
eg. `if (!couldResultOrFail()) |err| {} else |result| {}`

1579720238
andrewrk
metaleap, `orelse`

1579720252
andrewrk
and `catch`

1579720416
metaleap
well thats still "good path first (possibly bulky) bad path last (brief)", i was asking about for the `if` syntax the possible idea/notion of inverting the order via !-operator .. although on 2nd thought could be detrimental for later reading such code and assuming a bool from the `!`. so scratch that

1579720444
metaleap
so nvm

1579720463
fengb
Let's introduce the `unless` keyword! 🙃

1579720492
companion_cube
`!x or whatevs`

1579720542
TheLemonMan
you can also use a switch

1579720553
Snektron
considering the null-terminated pointer type, is there a more appropriate type than [N]u8 for a null terminated char array at most N bytes?

1579720669
metaleap
no, no more keywords, lets just drop the matter, was fluff :D 80% of readability is outsourcing-into-rightsized-funcs rather than more sugar, i fear. i'm just always easily tempted by the latter (the syntax kind =)

1579720977
fengb
I'm joking. I hate the unless keyword

1579721024
andrewrk
perl was my first scripting language :)

1579721053
companion_cube


1579721056
andrewrk
side note: I love that you can change `union(enum)` to `struct` in zig, and everything still makes sense, but you get some "missing field" errors

1579721062
companion_cube
crystal also has `unless` I think

1579721110
fengb
10 years into Ruby and I still can't process "unless" without changing it into "if not", and it's largely impossible to read with any compound operator

1579721149
companion_cube
I barely played with crystal but I think I found `return unless …` or `raise unless …` pretty cool

1579721150
adamkowalski
andrewrk: what would you think about changing the semantics of .?  Right now it tries to unwrap the optional, but I feel like if it doesn't succeed shouldn't it return an error?

1579721167
adamkowalski
then you have to write const value = try optional.?;

1579721168
andrewrk
(foo orelse return error.Bar)

1579721171
mikdusan
fengb: actually I appreciate ruby's `unless` sugar, especially for trailing if syntax

1579721212
adamkowalski
What is the use case for .? in production code? That seems rather scary right now, since it's essentially just an assumption that it is safe

1579721237
andrewrk
if you have deduplicated data

1579721251
andrewrk
e.g. if you proved 2 lines ago that it's not null

1579721267
andrewrk
for example try writing how to compare two optional ints for equality

1579721281
andrewrk
never mind the open proposal to make the language support it :)

1579721350
adamkowalski
well how did you prove they were non optional in the first place?

1579721368
adamkowalski
then you could do it like so

1579721377
adamkowalski
const x = try optional_x.?;

1579721382
adamkowalski
const y = try optional_y.?;

1579721391
adamkowalski
const result = x == y;

1579721406
andrewrk
try my exercise- write actual code to do it

1579721426
Snektron
except now your optional compare returns an error

1579721459
adamkowalski
Snektron: as oppossed to what? Would you prefer to return false instead?

1579721476
Snektron
of course, but thats trivial

1579721487
adamkowalski
andrewrk: if (optional_x) |x| {

1579721497
adamkowalski
if (optional_y) |y| {

1579721501
adamkowalski
return x == y;

1579721503
adamkowalski
}

1579721505
adamkowalski
return false;

1579721506
adamkowalski
}

1579721507
adamkowalski
return false;

1579721524
Snektron
`return (x orelse return false) == (y orelse return false);`

1579721547
Snektron
oh wait, i forgot about the null == null case

1579721641
adamkowalski
in haskell you use applicatives

1579721650
adamkowalski
(==) <*> (Just 5) Nothing

1579721653
Snektron
I use .? everywhere in the code im currently writing, but i followed the build.zig principe

1579721659
andrewrk
adamkowalski, use a paste site plz

1579721666
Snektron
cause its intended as a tool so never to be run outside of debug mode

1579721675
adamkowalski
sorry, will do

1579721743
Snektron
It seems to me that adding such a try optional.? method would result in rewriting .? as `x.? catch unreachable`

1579721768
Snektron
While the point of .? was to provide syntactic sugar over `x orelse unreachable`

1579721772
adamkowalski
yeah, which I would prefer? It means everytime somebody makes an assumption about validity there is a trail of unreachable

1579721783
adamkowalski
I can grep for a single word and validate my whole codebase

1579721834
fengb
How difficult is Kotlin's narrowing types?

1579721852
andrewrk
basically all of kotlin's narrowing types is planned, if you use const instead of var

1579721875
fengb
Oh neat

1579721894
andrewrk
well let me slow down. at least awareness of integer ranges are planned in this way, to allow coercion

1579721920
andrewrk
and zig already does a little bit of this to avoid bad codegen when we know something is not an error at a return site

1579721952
andrewrk
anyway it is planned for const values to have extra info that the type system is aware of

1579721989
adamkowalski
I saw in the roadmap for 0.6 that the proposal for let instead of const is approved. Is that still gonna happen?

1579722050
adamkowalski
I kindof like the symmetry of const declarations and const in type signatures. Having let for declarations and const in types seems a little strange

1579722091
adamkowalski
Unless const is the default and you need to write mut everywhere you want it

1579722106
metaleap
Snektron: "`return (x orelse return false) == (y orelse return false);` --- oh wait, i forgot about the null == null case" --- no you didnt. (if null then false == if null then false) -> false == false -> true

1579722114
betawaffle
does an array of u1 have the in-memory representation i would expect, or is there a bunch of padding?

1579722142
Snektron
metaleap, the return exits the function, not the expression parenthesis

1579722160
TheLemonMan
betawaffle, each element is padded to 1 byte

1579722187
adamkowalski
betawaffle: look at packed structs if you want somethign different

1579722187
betawaffle
is there a plan to support bit arrays of some kind? like packed structs and such?

1579722201
adamkowalski
already have em

1579722216
Snektron
theres a bit vector in the std too

1579722230
metaleap
aah i'm so blind

1579722238
betawaffle
adamkowalski: where?

1579722274
adamkowalski


1579722309
betawaffle
oh, i wasn't talking about packed structs, i was saying "like packed structs" as in, bit arrays in the same way that packed structs

1579722325
Snektron


1579722373
betawaffle
ah, interesting

1579722529
Snektron
if you use u1 as int type you can use it as bit array

1579722534
Snektron
same with structs for bit fields

1579722561
betawaffle
Snektron: that's what i was asking

1579722616
andrewrk
it's weird that the second part of the triple is called "arch". it should be called "cpu"

1579722623
andrewrk
arch would be a sub-field of cpu

1579722646
TheLemonMan
isn't the second part the os?

1579722648
betawaffle
don't cpus belong to an arch?

1579722655
andrewrk
sorry, the first part

1579722680
andrewrk
it's information about the cpu. the arch is only one piece of information about it

1579722688
betawaffle
oh i see what you mean

1579722735
andrewrk
not going to make that change in this branch, but this "data in the wrong place" situation will become more apparent

1579722785
TheLemonMan
well it's still an architecture, you don't have pentium4-linux-gnu

1579722863
TheLemonMan
the cpu is out-of-band data wrt the triple

1579722866
andrewrk
pentium4-linux-gnu would be even more descriptive than i386-linux-gnu

1579722885
andrewrk
it's an unambiguous, actually preferable triple

1579722901
andrewrk
since it gives all the cpu features you want too

1579722955
betawaffle
what would you use to build something for 16-bit or 32-bit mode? just a different cpu?

1579722963
pixelherodev
Someone mentioned a pointer-to-any type, and the consensus was c pointer to c void - I'd contend that it's better to just use a `usize` for that and use `intToPtr` to obtain the desired type

1579722980
andrewrk
my actual proposal would be to support the syntax like gcc, e.g.:  aarch64+v8_5a+bti-linux-musl

1579722987
andrewrk
the `-` are a problem to solve however

1579722994
pixelherodev
`_`?

1579723014
pixelherodev
Could either use `_` for the feature `-`, or the triple separator

1579723025
andrewrk
there is a _ in that feature

1579723032
pixelherodev
e.g. `aarch64+v8_5a+bti-thingy_linux_musl` oh wait yeah

1579723046
pixelherodev
`:` separator?

1579723050
pixelherodev
or `;` or something

1579723072
pixelherodev
But I feel like `:` is less likely to result in people accidentally running `linux` as a command :P

1579723081
andrewrk
the benefit of c_void (which is proposed to rename to anyopaque btw) is that the type keeps track of alignment. but if you don't want that, probably usize is easier

1579723092
Snektron
imagine the "triple" for x86 cpus

1579723129
andrewrk
mostly I'm just talking about the data layout of std.Target

1579723134
Snektron
would be more like a googol with all those extensions

1579723177
andrewrk
pixelherodev, alignment and const

1579723375
adamkowalski
andrewrk: is there a way to concatenate anonymous list/structs?

1579723437
andrewrk
++

1579723453
andrewrk
it's new; you might find bugs

1579723555
adamkowalski
ah that would only work with compile time known data right

1579723590
adamkowalski
Is there any way to have a heterogenous list at runtime without having a pointer idirection for each element, or using some other form of type erasure?

1579723633
betawaffle
you mean like a struct?

1579723649
metaleap
with variable length i guess =)

1579723667
adamkowalski
The use case is that I want take the gradient of an expression with respect to some parameters. All the parameters are nd arrays (tensors) which have an elemnt type and a rank. I don't want to throw that information away since it's useful to type check operations like addition (you don't want to allow addition between matrix and vector)

1579723694
pixelherodev
andrewrk, ah, fair

1579723695
andrewrk
++ will concatenate a tuple together which has runtime values, constructing a new tuple

1579723713
adamkowalski
so I need to return to you a "tuple" of tensors where each one can potentially be a differen type, but it's all based on the types of the inputs you give me. They should match

1579723788
adamkowalski
okay I'll see if I can make that work, thanks

1579723860
adamkowalski
also once the proof of concept is done I need to come up with an idea to demonstrate the library, thats trivial enough to be easily understandable quickly. But complicated enough to show how the library works in depth. Is handwriten digit recognition still okay, or is that so overdone that it's boring?

1579723963
fengb
wasm opcodes are so much easier to work with than Z80 >_>

1579723975
pixelherodev
... z80 is really easy

1579723978
pixelherodev
What are you talking about

1579724052
fengb
Half the op codes are loads. Really hard to name and keep track

1579724142
pixelherodev
meh

1579724156
companion_cube
have y'all heard of serenity OS? it's quite amazing

1579724486
pixelherodev
link?

1579724502
andrewrk
companion_cube>

1579724523
fengb
Wow it's by 1 guy?

1579724555
betawaffle
did he write it in zig?

1579724560
companion_cube
in C++ sadly :D

1579724570
betawaffle
ah, shit

1579724608
fengb
We're still struggling with IO a year later ;)

1579724645
companion_cube
seems like you can actually be productive with C++ :D

1579724668
edr
I have been watching him for a while, has a ton of youtube content of him working on it, and also does "commute talks" that are typically very good

1579724669
Snektron
nobody said you can't

1579724675
fengb
All good compilers begin their life in C++ 🙃

1579724699
companion_cube
nah, some started in lisp or ocaml :-°

1579724711
fengb
And... I didn't mean that as a backhand to Rust >_>

1579724712
Snektron
I'd pick c++ over most other languages tbh

1579724741
fengb
Subsets of C++ can be good. The problem is no 2 people chooses the same subset

1579724761
andrewrk
sometimes I don't even choose the same subset as myself

1579724811
companion_cube
andrewrk: once Zig 1.0 is reached, we all know someone will RIIZ serenity OS

1579724815
companion_cube
in 6 months :p

1579724829
Snektron
Just pick anything but macro's tbh and you're good

1579724838
pixelherodev
Heh, I already have a different base kernel I could use for that :P

1579724841
adamkowalski
fengb: I feel like there is a consensus now though. The transtition from c++11 -> 14 -> 17 -> 20 made many things way better. People don't really use inheritence anymore, it's mostly static polymorphism with concepts and template meta programming is transtitioning to using constexpr. Runtime polymorphism is handled by type erasure. Smart pointers for owner ship, etc

1579724937
fengb
I don't understand half those words >_>

1579724972
companion_cube
wait, concepts are released??

1579725001
BaroqueLarouche
coming soon, some compilers have partial support for concepts

1579725014
adamkowalski
yeah they are part of the c++20 standard. clang just merged to trunk, but had a forked version working for over a year. gcc has had them forever.

1579725015
fengb
C++98 or bust 🙃

1579725062
adamkowalski
fengb: we use most of what they use in zig too. constexpr allows a function to be evaluated at compile time, just like Zig

1579725071
BaroqueLarouche
errgh no, C++11 fix so many warts

1579725089
adamkowalski
concepts are compile time enforced properties on types

1579725105
Snektron
c++98 gives me anxiety

1579725108
adamkowalski
so rather then passing things by template (compile time duck typing) you can say I want any type that supports these operations

1579725121
companion_cube
c++ is trying to catch up with rust

1579725155
Snektron
adamkowalski, i think you use concepts with templates no

1579725169
Snektron
template <Concept T>

1579725174
adamkowalski
yeah

1579725193
adamkowalski
but they add requirements on the type T

1579725200
adamkowalski
so like SFINAE

1579725208
Snektron
still templates

1579725209
adamkowalski
they participate in overload resolution

1579725232
adamkowalski
of course, templates are the mechanism for static polymorphism, It just allows you to constrain the type being passed in

1579725252
adamkowalski
I think we could use something like that in zig, so rather then var you can reason about the type you expect

1579725255
Snektron
There was a proposal for zig-like templates with constexpr parameters

1579725261
Snektron
i doubt it'll be added though

1579725268
adamkowalski
I don't know if we need templates

1579725271
companion_cube
it's just like rust's traits

1579725275
adamkowalski
we have first class types

1579725307
adamkowalski
I think the simplest thing is to allow a predicate (a function which takes a type and returns a bool) instead of var

1579725355
Snektron
there was a proposal for that

1579725357
adamkowalski
if you call a function which constrains it's parameter type with a predicate and it returns false, it's a compile error

1579725374
Snektron
but the thing is that Zig doesn't have any overloading

1579725378
adamkowalski
Snektron: yeah I know, I'm just saying I think it's a good idea

1579725383
Snektron
So you can implement that simply with a debug

1579725385
Snektron
assert

1579725394
fengb
We can do comptime traits

1579725402
adamkowalski
sure, but in my opinion it's a good idea to document your requirement in the type signature

1579725403
companion_cube


1579725415
companion_cube
adamkowalski: like that?

1579725418
adamkowalski
this will help with reading other peoples code.

1579725422
Snektron
yeah i agree with you on that

1579725448
adamkowalski
companion_cube: template constraints are D's version of concepts. However, they don't allow you to overload on them as well as they should

1579725466
Snektron
anyway, i had a cheeky thought about defining traits in userland

1579725469
companion_cube
maybe, it just sounds like what you said

1579725490
adamkowalski
For example if I have two functions one which takes a random access iterator, and one which takes an forward iterator, D's template constraints would say it's ambiguious

1579725492
Snektron
With tuples you can define an interface pretty neatly

1579725506
adamkowalski
in c++ you would go with the the random access iterator function since it's more specialized

1579725524
companion_cube
adamkowalski: in zig you'd comptime if inside the body, right?

1579725530
companion_cube
it's not like Zig has overloading anyway

1579725540
adamkowalski
yeah here we would do an if of a switch statement

1579725570
companion_cube
so I think it's fine :p

1579725583
adamkowalski
you just need to make sure to check them in reverse order of specialization. So if two compile time traits could have matched, you want the most specialized version in the top most if statement

1579725589
companion_cube
`fn foo(comptime T: var) if p1(T) || p(2) { … }`?

1579725594
companion_cube
yeah

1579725605
companion_cube
but that's more intuitive than relying on complex overloading rules

1579725614
companion_cube
you know there's only one place where the function is defined

1579725634
adamkowalski
i'm not arguing, I was just saying what exists elsewhere

1579725652
adamkowalski
I'm sold on the Zig way of doing things now that i've used it for a while

1579725654
companion_cube
o/\o

1579725677
adamkowalski
I just wish we had a way of documenting minimal requirements of a type being passed in rather than just writing var

1579725692
pixelherodev
Seconded

1579725697
pixelherodev
Predicates have my vote

1579725701
fengb
Is that a high five or an owl?

1579725706
companion_cube
a high five

1579725709
adamkowalski
why not both?

1579725738
Snektron
I could for instance see something like this working

1579725750
Snektron


1579726652
metaleap
adamkowalski: "I just wish we had a way of documenting minimal requirements of a type being passed in rather than just writing var" --- i'll attack numerous code-analysis/annotation things (aka extra derived code intel that can be rendered into docs or into one's not-too-bare-bones code editor) in the medium-term future and this is one of them. zig with comptime `type`-"driven" branching combined with being able from parsed-asts to see how things are

1579726652
metaleap
passed on (or dot-accesses) makes this more tractable than macro-driven langs or langs that have merely-to-be-runtime-inspected `object`/`any`/`interface{}` functionality. i need such myself anyway, and it allows for much wider scope of linting depths. the next few months will occupy my little free time with such

1579726816
metaleap
sure you'll get supremely-verbose (dang turing completeness) "type descriptors" that way but then it's all about figuring out how to reduce them neatly while remaining accurate/complete. and aiming for "80% of the time more helpful than confusing" suits most folks immediate/practical concerns

1579732131
TheLemonMan
andrewrk, wrt #4263, that was about stack traces and not compile errors

1579732300
andrewrk
oh!

1579732370
andrewrk
merged

1579732373
andrewrk
thanks

1579732385
TheLemonMan
thank you :)

1579732606
andrewrk
alright let's see how this new cpu features commit performs in the CI

1579732648
mikdusan
TheLemonMan: did you see this comment:

1579732650
mikdusan


1579732686
TheLemonMan
yeah, I cannot be arsed to send a PR to fix that heh

1579732714
mikdusan
ok I'll PR it if you want

1579732784
TheLemonMan
sure thing, thank you

1579734256
Snektron
weird, for some reason std.fmt.format won't call my custom format function

1579734281
Snektron
ah, forgot `pub`

1579734407
andrewrk
TheLemonMan, does the --verbose-llvm-cpu-features output look good in the latest layneson-cpus_and_features commit, for -target aarch64v8-linux-none ?

1579734425
andrewrk
it's passing the tests for me locally but the linux ci is giving qemu: uncaught target signal 4 (Illegal instruction)

1579736790
daurnimator
andrewrk: re: cpu features: perhaps it should be a ternary: no/maybe/yes. that we can dispatch `if (runningTarget.hasFeature("sse4")) { sse4_code() } else { sse2_code() }` -> the condition could be compile time or runtime.

