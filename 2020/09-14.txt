1600041847
andrewrk
what is the relationship between ARM / NVIDIA / RISC-V ?

1600041857
andrewrk
I'm realizing how little I know about it

1600041928
fengb
Indirect. People might migrate to RISCV now that a company who’s traditionally hostile to open source is in charge

1600042027
leeward
Yeah, I saw that.

1600042122
leeward
I don't think it's likely that ARM will take any steps hostile to open source. They know how they make their money.

1600042571
leeward
It's not like if Microsoft bought GitHub or anyth...oh.

1600043206
andrewrk
less competition is worse

1600043255
pixelherodev
^

1600043263
pixelherodev
This kind of consolidation is terrible for everyone.

1600044788
andrewrk
it's the premise of capitalism

1600044980
Snektron
<andrewrk "less competition is worse"> Do nvidia gpus compete with arm cpus?

1600045013
andrewrk
yes

1600045125
companion_cube
in what sense? that seems counter intuitive to me

1600045143
pixelherodev
companion_cube: companies use ARM CPUs with ARM GPUs

1600045148
pixelherodev
e.g. Mali IIRC

1600045153
andrewrk
but also just the fact that previously we had 2 independent companies using their power to tug on the market in non-parallel directions, and now we have 1 mega corp with more tugging power

1600045154
companion_cube
there are ARM GPUs? :o

1600045156
companion_cube
TIL

1600045172
pixelherodev
companion_cube: not to the same level as AMD / NV of course

1600045174
companion_cube
I guess it's like intel GPUs, heh… should have thought of it

1600045181
pixelherodev
But what did you think were in LineageOS phones?

1600045189
pixelherodev
and, fine, Android ones too if you want to be pedantic.

1600045191
companion_cube
I have no idea :D

1600045206
companion_cube
I mean, are these really GPUs? :) I don't know what this covers

1600045273
pixelherodev
I don't know if they're designed by ARM as well

1600045283
pixelherodev
They might be third-party for all I know

1600045319
Snektron
Personally im still waiting for the mill architecture

1600045504
Snektron
<pixelherodev "companion_cube: companies use AR"> I could see nvidia trying to lock in their gpus in arm chips yea

1600045550
pixelherodev
Ugh

1600045561
pixelherodev
This kind of crap is why I dislike it when people pretend America is capitalist. We're not.

1600045589
pixelherodev
Things like modern CPUs can't really be capitalist though, by design

1600045592
companion_cube
Snektron: augmented reality? makes sense

1600045603
pixelherodev
The barriers to entry are measured in, what, thirteen digits now?

1600045606
companion_cube
nvidia has already pretty locked the deep learning market, afaik

1600045608
pixelherodev
Or has it gone up since the last time I looked?

1600045631
pixelherodev
I'm only slightly exaggerating, but you get the point

1600045645
pixelherodev
I heard someone say that if Moore's Law ever dies, it won't be because of technical reasons, but financial ones

1600045652
pixelherodev
I'm not sure I disagree

1600045691
Snektron
Financial reasons are the driving factor as to why it doesnt die

1600045717
pixelherodev
For now, yes

1600045746
pixelherodev
But the cost of manufacturing is going up at the same rate as the transistor count

1600045757
pixelherodev
The only reason it's "affordable" is the sheer size of the market

1600045771
pixelherodev
Massive fixed costs with relatively small per-unit costs, effectively

1600045785
Snektron
> Snektron: augmented reality? makes sense

1600045785
Snektron
I mean also just generic. Mobile games require decent processing power too nowadays.

1600045795
pixelherodev
Hell, companies like Intel would probably be the worst affected by economic downturns

1600045830
pixelherodev
If the number of people who can afford to get new, fresh-off-the-factory chips goes down, they might not be able to recoup the costs of building the foundry in the first place

1600045854
pixelherodev
Well, if individual consumers were their biggest customers :P

1600045873
pixelherodev
But it also means less money to other businesses, which then can't afford to spend money on new CPUs, so it's the same anyways

1600045915
Snektron
I read that google is prepared to replace their entire hardware for a 10% efficiency improvement in computing power

1600046154
pixelherodev
I wonder what they'll do with the old stuff lol

1600046262
Snektron
Dump in an ocean most likely

1600046393
pixelherodev
I sincerely hope not.

1600046813
andrewrk
that's the danger of optimizing for profit rather than public benefit

1600046881
pixelherodev
Heck, not really.

1600046886
pixelherodev
andrewrk: I daresay this would be neither.

1600046892
pixelherodev
Optimizing for profit would be selling them off.

1600046907
pixelherodev
Even if they sold them at half the price they paid for them, it's still better for them.

1600046917
pixelherodev
They make some money instead of none, they gain in terms of PR, etc

1600046931
pixelherodev
There is literally no benefit to them in destroying it

1600046951
andrewrk
I'm considering moving std.cache_hash into stage2. it's becoming a pretty bespoke API

1600047356
pixelherodev
Is it useful outside stage2>

1600047358
pixelherodev
?

1600047402
andrewrk
bespoke means useful in only specific circumstances

1600047411
andrewrk
so I'm saying that it's becoming less useful outside stage2

1600048148
pixelherodev
Ahh, gotcha

1600049316
andrewrk
I love makeOpenDir

1600049336
andrewrk
oops I mean makeOpenPath

1600049592
andrewrk
on windows it's only 1 syscall

1600051387
pixelherodev
Syscall fusing is neat

1600051392
pixelherodev
Would be neater if there was... huh.

1600051394
pixelherodev
That's an idea

1600051402
pixelherodev
A generic multi-syscall interface or something

1600051429
pixelherodev
so e.g. make + open + write + flush + close could require a single context switch

1600051621
shachaf
io_uring is heading in that direction.

1600056452
daurnimator
already is...

1600056779
companion_cube
isn't bpf going even further?

1600058028
jjsullivan1
would it be fair to say `anytype` is pretty stable at this point in time?

1600058057
jjsullivan1
I ran into a bug that's forcing me to nightly, and it would be convinient for a couple of things I'm trying to do

1600076085
andrewrk
jjsullivan1, yes, but it's been available for a long time. in 0.6.0 I believe it is `var`

1600082881
jjsullivan1
oh, so it's mostly a syntax change? thanks for the tip andrewk :^)

1600082925
jjsullivan1
**andrewrk

1600088899
justin_smith
I've been interested in all the stuff I read about zig, and I'm translating the simple jack audio client example to zig - pretty cool how "weird" errors in C are plainly explained by the zig compiler

1600089098
justin_smith
bigger goal is to make a demo multi thread async client, using await to communicate between the RT audio thread (no allocation or syscalls allowed) and a helper thread (likely including a GUI, allocation allowed, syscalls allowed, showing status of audio thread and letting the user control parameters)

1600089117
justin_smith
I'm laid off, so maybe I'll make it a tutorial :D

1600089284
ifreund
that sounds like it would be super neat

1600089423
justin_smith
it's fun so far, and with no day job to worry about the road is clear :D

1600089471
justin_smith
I'll keep the channel updated if someone could help with review before I publicise - I'd rather not make an instructional document with bad examples for people to copy

1600089499
justin_smith
but for (hopefully obvious) personal and pedagogical reasons do want to do the work myself

1600090106
ifreund
i'd be happy to give it a read before publication

1600090220
justin_smith
awesome, thanks

1600091594
pixelherodev
Seconded!

1600091882
mkchan
hey guys, gotta love Zig. Having finished the first part of porting my old C chess engine to Zig, I have to say Zig is really nice to code with. I have the repo up here if anyone's interested:

1600091921
mkchan
though it's of little use at the moment, only being able to do performance tests

1600091982
mkchan
it's already at performance parity with my old codebase and I haven't even implemented the latest and greatest yet. Not sure if it's the language or better coding in general (or both!)

1600092005
pixelherodev
Both, probably ;)

1600092188
mkchan
interesting part was that i ran into this error: `evaluation exceeded 1000 backwards branches` though i was able to use @setEvalBranchQuota() because I knew roughly how many iterations it was going to be, is there a hard limit to it? I kind of want to experiment making a completely compile-time program just for fun

1600092226
pixelherodev
mkchan: that's basically a hack to avoid the halting problem

1600092246
pixelherodev
You can set it as high as you want

1600092317
mkchan
ok nice

1600092649
pixelherodev
mkchan: I'd point out there can be problems with doing so - primarily (only?), performance

1600092688
pixelherodev
I had a program where marking something comptime increased compile-time from ~5s to ~90

1600092696
pixelherodev
Runtime was maybe 0.5% faster lol

1600092703
ifreund
I wonder how many times faster stage2 will be at comptime stuff than stage1

1600092790
pixelherodev
ifreund: Once we have the basic infrastructure in place, you

1600092794
pixelherodev
;)

1600092816
ifreund
I'm not quite clear how JITing comptime is gonna work

1600092864
ifreund
I guess you need to do some kind of search to determine what code is comptime, and then JIT/run that?

1600092899
pixelherodev
ifreund: same way interpreter works.

1600092908
pixelherodev
That's why I've been emphasizing waiting for now

1600092917
pixelherodev
I have no intent to work on it before there's an interpreter

1600092924
ifreund
makes sense

1600092928
pixelherodev
Any initial JIT would likely generate calls

1600092946
pixelherodev
Which would be a minor boost, but still a boost.

1600092966
ifreund
and yeah there are certainly higher priority tasks for the moment

1600092983
pixelherodev
I still need to finish that CBE patch, and the SPU-2 C ABI

1600092995
pixelherodev
There's some major CBE work that needs doing

1600093006
mkchan
pixelherodev: what i'm planning is to basically offload all the work to the compiler

1600093007
pixelherodev
I'm also considering getting more familiar with astgen and working on struct support

1600093019
mkchan
so essentially runtime is just print(<comptime-calc'd number>)

1600093028
pixelherodev
mkchan: how complex are the calculations?

1600093029
ifreund
didn't vexu already do that? or am I misremembreing

1600093040
pixelherodev
ifreund: ... I need to double-check.

1600093043
pixelherodev
It's not impossible.

1600093054
mkchan
not very, it's a chess game, it increases with how deep you want to go, but a few ply isn't bad at all

1600093160
pixelherodev
ifreund: Vexu's definitely done a ton, but I don't see structs

1600093197
ikskuh
pixelherodev: btw, i patched my cert again, shifting another 3 month cycle. standard calling convention for spu 2 is now cert-safe again :D

1600093209
pixelherodev
lol

1600093211
pixelherodev
nice :P

1600093215
pixelherodev
ikskuh: you saw my comment about kristall?

1600093225
ifreund
pixelherodev: indeed, I think seeing vexu's open PR for @import() confused me

1600093239
pixelherodev
Ah yeah, you're actually right

1600093243
pixelherodev
It's part of that PR IIRC

1600093249
pixelherodev
That's why I didn't see it in commit logs

1600093255
pixelherodev
It's basic struct support, which is critical for imports

1600093272
ikskuh
pixelherodev: where? :D

1600093278
pixelherodev
here, probably

1600093282
ikskuh
then: no

1600093289
pixelherodev
ikskuh: kristall is the only browser I have left on my laptop :P

1600093295
pixelherodev
I wiped my glibc partition lol

1600093315
pixelherodev
It is still technically the second-most-complex browser, but only because I have w3m still IIRC

1600093319
ikskuh
:O

1600093329
ikskuh
crazy

1600093339
pixelherodev
Hey! It wasn't intentional!

1600093344
pixelherodev
Or, well. It was, but it was poorly thought out

1600093348
pixelherodev
I hadn't realized it would happen! :P

1600093353
ikskuh
btw, would be happy to receive PRs when you find/fix stuff ;)

1600093412
pixelherodev
ikskuh: I'm more likely to start competing with you, TBH

1600093420
pixelherodev
I like the UX of kristall, but I dislike QT intensely :P

1600093437
ikskuh
haha

1600093447
pixelherodev
Not to mention

1600093460
ikskuh
hey, that's quite conservative c++ _D

1600093466
fengb
So GTK then?

1600093501
ikskuh
hehe

1600093505
pixelherodev
ikskuh: I know :P

1600093513
pixelherodev
fengb: ... that's not exactly better

1600093514
ikskuh
pixelherodev does trade qt for power consumption probably :D

1600093528
fengb
It’s not C++ ;)

1600093550
pixelherodev
fengb: oh yay, congrats on solving what is obviously my single biggest problem with any package. The *language*. ;)

1600093558
pixelherodev
ikskuh: ?

1600093562
pixelherodev
Wdym?

1600093604
ikskuh
using anything like sokol/sdl/… eats up CPU

1600093624
ikskuh
those toolkits aren't meant for normal UI stuff

1600093626
ifreund
hmm, I wonder if netsurf's engine can be used as a library

1600093631
pixelherodev
ikskuh: I wasn't planning on it

1600093634
ikskuh
good

1600093642
ikskuh
and it's super annoying, we definitly need zig-window better now :D

1600093645
pixelherodev
We already discussed why it'd be a bad fit, remember?

1600093661
pixelherodev
I like Sokol, but that doesn't mean I'm going to use it where it's a bad fit

1600093661
ikskuh
this was even another argument base :D

1600093670
ikskuh
but yeah

1600093681
ikskuh
we need a native ui library for zig soon… :(

1600093688
fengb
I’m assuming because they’re game based, they’re intended to run every frame?

1600093690
pixelherodev
ikskuh: do you know of any genuinely lightweight UI libraries?

1600093692
pixelherodev
fengb: yeah

1600093705
pixelherodev
Sokol can probably be configured to change that, but it's still fundamentally the same

1600093724
pixelherodev
it's not optimized for it

1600093730
pixelherodev
anyways, work to do and all that

1600093740
ikskuh
fengb: yeah, you can't suspend either sokol or SDL, they just do busy-polling events and burn your CPU while doing so

1600093759
ikskuh
pixelherodev: no, sadly not. they are all either based on "do your own drawing" or are shit :D

1600093782
pixelherodev
Wow. That's... that's honestly depressing.

1600093794
ikskuh
yeah

1600093794
pixelherodev
It's been decades and there's still not a single good UI library?

1600093805
ikskuh
i chose Qt, because it's just the best choice by

1600093807
pixelherodev
That doesn't speak very highly of our field, to be quite honest.

1600093811
ikskuh
like … lightyears distance

1600093819
ikskuh
UI ain't trivial

1600093827
ikskuh
and Qt is damn good as a C++ standard library

1600093837
pixelherodev
That's kinda the problem to me ;)

1600093837
ikskuh
"it just works"™

1600093850
pixelherodev
C++ stdlib isn't something anyone should be aspiring to make lol

1600093850
ikskuh
and to my surprise: literally everywhere

1600093866
pixelherodev
I mean, to be fair, I've used other libraries that did a good job at that

1600093874
ikskuh
pixelherodev: Qt doesn't follow any c++ rules, it's a complete ecosystem not based on the STL

1600093886
ikskuh
someone made a Haiku build of kristall even!

1600093887
ikskuh
:O

1600093887
pixelherodev
That makes it at least somewhat better

1600093933
pixelherodev
Still not nearly good enough for me to use it :P

1600093951
pixelherodev
I'd probably rather find a way to get Sokol and ImGui sleeping than use QT ;)

1600094026
ikskuh
you have to write the platform independent code for that yourself

1600094035
ikskuh
and if you do so, just do it in zig and make everyone happy :D

1600094173
pixelherodev
ikskuh: I'd wait for floooh's sokol-zig bindings first :P

1600094177
ikskuh
^^

1600094182
pixelherodev
TBH I've been sticking to C99 over Zig lately

1600094187
ikskuh
ifreund: can you guess how much work it would be to create a basic wayland client?

1600094195
pixelherodev
A metric bleepton.

1600094200
pixelherodev
Use e.g. wlroots.

1600094210
pixelherodev
Ah wait

1600094213
pixelherodev
Client, not compositor :P

1600094221
pixelherodev
Probably not too much?

1600094223
ifreund
clients are pretty easy

1600094227
pixelherodev
Yeah

1600094238
ifreund
there are a couple in zig already using libwayland

1600094240
pixelherodev
I think a client can be done in ten minutes with no prior experience, but I could be wrong

1600094262
ikskuh
yeah i was thinking about

1600094272
companion_cube
10 minutes isn't even enough to understand the terminology

1600094301
ifreund
without libwayland it'd be a bit harder, tdeo started a zig implementation but I don't know what state it's in

1600094309
ifreund


1600094346
ikskuh
oh, neat :)

1600094348
ifreund
and then you have the issue that you need to pass the libwayland stucts to mesa if you want to use opengl

1600094363
ikskuh
> In principle, any system capable of creating buffers and drawing into them should be usable. At present, Wayland only supports a system called EGL. It does so by the four functions

1600094363
ikskuh
dang

1600094395
pixelherodev
Wonder why that is

1600094412
JimRM
Hi, so I am wondering if there is a good way to expose struct offsets to assembly files?

1600094415
ifreund
you can also software render of course

1600094423
daurnimator
JimRM: @byteOffsetOf ?

1600094437
pixelherodev
ifreund: without OSMesa?!

1600094439
pixelherodev
;)

1600094445
ikskuh
ifreund: i have dunstblick atm with software rendering

1600094450
ikskuh
would be a option :D

1600094458
ikskuh
software rendering and OpenGL would be enough anyways :D

1600094476
justin_smith
JimRM: more detailed, I'd imagine a table from index to struct offset and pointer to name? maybe that's more than your assembly needs to implement machine side

1600094477
JimRM
@daurnimator thanks - do you know how I could make the values returned from @byteOffsetOf available inside ASM files?

1600094484
ifreund
pixelherodev: yes, you can just mmap a buffer, put pixels in it, and pass it to the compositor

1600094496
ifreund
my screenlocker in rust doesn't link libwayland

1600094497
pixelherodev
ifreund: I was being sarcastic lol

1600094507
ifreund
whoosh

1600094526
justin_smith
JimRM: @byteOffsetOf is compile time, so the values should be available while creating a data structure, you can pass the data structure to the assembly code, that's how I'd do it

1600094580
justin_smith
more fine grained you can probably template the indexes into an assembly snippet, that sounds harder to me not easier, as an assembly writer

1600094584
JimRM
@justin_smith - that sounds close to what I am looking for, except it sounds like I would need to pass the offset as a parameter? (Instead of being able use static values at compile time)

1600094613
pixelherodev
JimRM: You could make it a build.zig extension

1600094615
JimRM
I wondered if there was a way to do some sort of code gen? I currently use a .h file with a bunch of defines in (which the .S file includes)

1600094619
pixelherodev
Have it generated an asm file at comptime

1600094624
pixelherodev
s/rated/rate

1600094632
justin_smith
JimRM: the full zig language is available at compile time, pre-calculate whatever you want, but I'd rather debug assembly that uses a table than debug a template that injects magic offsets into assembly snippets

1600094635
justin_smith
ymmbv

1600094638
JimRM
so if there was an easy way to generate that during compile time, that would be great.

1600094667
justin_smith
if zig lang can calculate it without using external resources, it can do it at compile time

1600094676
pixelherodev
JimRM: build.zig can produce arbitrary files

1600094700
justin_smith
oh so it can do it using external recources too, cool :D

1600094703
JimRM
OK, that is cool. The only thing then is to ensure that the Header file is generated before the assembly files are assembled

1600094719
justin_smith
sounds like a job for a build tool

1600094771
JimRM
Awesome! Is there a sample that I can use as reference for generating code files during a build?

1600094820
justin_smith
JimRM: btw I am just learning myself, so a link to what ends up working would be really cool IMHO

1600094957
ifreund
well, the build system itself does this to implement build options

1600094969
ifreund
I don't know of any other example off of the top of my head though

1600095018
ifreund
if you just want to see how to make custom steps, this is a pretty good example:

1600095131
JimRM
Thanks!

1600095187
JimRM
Also, is there a way to forward declare structs? Like in C - you can have an opaque pointer declared in a struct without needing to know the full declaration of what it is pointing at?

1600095241
ifreund
zig has @OpaqueType() for this use case, though it's usually only used in C bindings

1600095289
JimRM
Is it not idiomatic to do that in Zig?

1600095289
ifreund
oh I think it's now @Type(.Opaque) on master though

1600095323
fengb
Zig typically has full source available

1600095343
klltkr
ikskuh ifreund: I believe OpenGL without libwayland is possible using dmabufs

1600095357
fengb
And statically linked instead of dynamically linked, so there's not a strong need

1600095364
ifreund
klltkr: yes that's right

1600095373
justin_smith
it seems like it would simplify things a lot to require the struct be compiled before the code using it, within the same build

1600095376
ifreund
though linux-dmabuf is still unstable

1600095405
ikskuh
hmm

1600095545
ikskuh
huh

1600095557
ikskuh


1600095563
ikskuh
this just crashes when compiled :(

1600095630
klltkr
ikskuh what about this one

1600095631
ifreund
ikskuh: this one is the go-to

1600095641
klltkr
Snap!

1600095651
ikskuh
race condition!

1600095651
ifreund
see the various branchs for opengl examples

1600095679
ikskuh
checking it out

1600095735
ikskuh
okay, i have now a cat

1600095740
ifreund
nice

1600095909
ikskuh
yeah

1600095912
ikskuh
and a opengl loop

1600095925
ikskuh
i wonder how much work it is to create a partial update/rendering loop

1600095966
ifreund
no idea, everything I've done client side has been very basic

1600095980
ikskuh
ah okay

1600096029
companion_cube
pixelherodev: are you back into C because of wayland, or by preference>

1600096030
companion_cube
?

1600096068
ikskuh
hm

1600096099
ikskuh
it might be a good idea to do zig-window incrementally, and first depending on external libs, replacing the required functions one by one with a zig impl

1600096129
ifreund
i agree

1600096146
ikskuh
for windows, we already have window creation fully self hosted i think

1600096156
JimRM
OK, so as mentioned above - in my build.zig file I would like to import a .zig file from my src folder which contains a struct I would like the inspect during build. Is it possible to @import a source file in the build.zig file? (Currently I get a error stating: 'error: unable to find 'src/module')

1600096163
ifreund
i actually started work on idiomatic zig wayland bindings last night, but haven't got very far yet

1600096286
ikskuh
:O

1600096289
ikskuh
uuuh, nice

1600096294
ikskuh
ping me when it works!

1600096300
ikskuh
i want to do a version of dunstblick without SDL

1600096461
ifreund
JimRM: I feel like that should work, the path you gave to @import() is relative to the build.zig file right?

1600096529
JimRM
@ifreund - Yes, I just got it working. Didn't have the .zig extension in file module name

1600096541
ifreund
nice!

1600096555
JimRM
Still not sure when and when no you need the extension

1600096587
ifreund
you don't need the extension for "packages"

1600096632
ifreund
e.g. std is a package separate from your project so you do @import("std")

1600096707
justin_smith
a package is a level of abstraction up from a source file surely

1600096725
justin_smith
it's probably already pre-processed by the time I see it

1600096746
justin_smith
(just working from first principles here, I'm a NEWB)

1600096763
justin_smith
but it looks like packages are used as structs (perhaps are simply structs)

1600096784
ifreund
yeah packages are structs, files are structs too

1600096800
justin_smith
where the members of a file would be... characters, or pre-parsed?

1600096827
ifreund
just normal source code

1600096846
justin_smith
so an array of u8 / whatever encoding on top

1600096857
fengb
`@import(file)` will convert the file into a Zig struct. You can do `@embedFile()` to have raw bytes

1600096874
justin_smith
fengb: that helps a lot, thanks

1600096887
ifreund
packages aren't a very fleshed out concept yet as we don't yet have a package manager

1600096915
justin_smith
ifreund: one appeal to me is that they don't need to be fleshed out much and most package managers make terrible counterproductive assumptions

1600096925
ifreund
aside from the "std" and "build_options" packages, you can create your own with Builder.addPackage()

1600096966
ifreund
I agree with you in general, though I have realatively high hopes for the future zig package manager

1600096987
ifreund
assuming the same philosophy that has been applied to the language design is applied to it

1600097022
justin_smith
one of the reasons I decided to go "all in" on learning zig was seeing that a package was used the same way a struct is, so much pointless wheel spinning in other languages (and stupid over-complicated features and guard rails) come from making packages and structs arbitrarily distinct

1600097051
justin_smith
these "features" waste so much developer time

1600097084
justin_smith
see also all assumptions of "installing" (global? local? magic via env? oh my god you're killing me)

1600097119
ifreund
I'd be surprised if packages were to change on a language level, they will likely remain normal structs just like files

1600097129
justin_smith
ifreund: yes, if package management shows the same good taste as the rest of the language I'll be all in :D

1600097158
ifreund
what needs some fleshing out is the the build system handling of packages

1600097218
justin_smith
that makes sense, and my preference of the simplicity of the core language guiding how the build system is used trumps my irate rage at the many terrible build systems I've had to use

1600097455
jjsullivan1
have a technical question: do anonymous structs force all their members to be const?

1600097472
jjsullivan1
I've been getting type errors that suggest as much, wondering why that is?

1600097525
justin_smith
jjsullivan1: what about explicitly deriving a new anonymous struct and using that?

1600097532
ifreund
jjsullivan1: not to my knowledge, could you paste the error message/code somewhere?

1600097547
jjsullivan1
I'll paste up a quick example in godbolt, one sec

1600097678
jjsullivan1
ifreund:

1600097701
jjsullivan1
again im new at this, but I couldn't find much in the docs

1600097705
fengb
Anon structs build comptime only fields when possible

1600097718
fengb
So yeah, that's expected, although it's not particularly nice

1600097733
jjsullivan1
hmm, I think this happens for comptime expressions too though

1600097741
jjsullivan1
becuase that's what I was hoping to use it fr

1600097744
jjsullivan1
**for

1600097923
jjsullivan1
yeah, same problem fengb

1600097988
fengb
Comptime fields are always const afaik

1600097995
ifreund
yep, force it to be runtime and you're fine

1600098035
pixelherodev
companion_cube: not Wayland.

1600098042
pixelherodev
I haven't touched Wayland as a developer

1600098045
pixelherodev
Only as a user :P

1600098049
fengb
There's weird hacks to make it runtime fields... but realistically, we either need to change these semantics or recommend not using anon literals here

1600098060
companion_cube
pixelherodev: so what pushed you back into the black arts? :p

1600098096
fengb
`var my_anon: struct{ .num = u8 } = undefined;`

1600098111
jjsullivan1
fengb: hmmm

1600098115
fengb
This will create an anon struct that has the characteristics you're looking for

1600098128
fengb
Oops bad syntax

1600098138
ifreund
: u8

1600098141
fengb
`var my_anon: struct{ num: u8 } = undefined`

1600098158
fengb
Or even `var my_anon: struct{ num: u8 = 44 } = .{};` if you want that 44 initialized

1600098181
jjsullivan1
yeah, I think that might work for what I need

1600098207
pixelherodev
companion_cube: TBH, I'm probably not going to use Zig for a serious project until stage2 is done at the earliest

1600098209
jjsullivan1
I wanted to compute a type based on a passed anon argument, and then add more fields to it

1600098218
pixelherodev
It's one reason I'm moving Tricarbon 0.2 into C

1600098226
pixelherodev
Zig is just, realistically, not production-ready.

1600098238
ifreund
eh, it works well enough

1600098240
pixelherodev
At the moment, I'd need LLVM + Clang + Zig just to build small applications.

1600098250
ifreund
I've been running river as my daily driver for months

1600098256
pixelherodev
There's no parallelization in stage1

1600098261
pixelherodev
ifreund: I don't mean code quality.

1600098284
pixelherodev
I mean that comparing GCC to Zig stage1 from a user's perspective, GCC is clearly better.

1600098293
ifreund
that's fair

1600098312
ifreund
for me it's worth it for the nicer language though

1600098315
pixelherodev
No need to constantly update code as the language changes, it performs

1600098323
pixelherodev
ifreund: which is why I still use it for small, private stuff

1600098334
companion_cube
ah, silly you for writing production code

1600098343
pixelherodev
"Production" is a poor term here lol

1600098352
companion_cube
"code someone else might rely on" :p

1600098353
pixelherodev
I'm the only one who uses it currently, so that's really not accurate

1600098358
pixelherodev
It's more about the eventual "might"

1600098358
fengb
That's why I only write noobduction code

1600098360
companion_cube
ahah damn

1600098368
companion_cube
for that I do rust right now

1600098424
ifreund
pixelherodev: and do you plan another rewrite into zig when stage2 is done? :P

1600098538
pixelherodev
ifreund: noper

1600098539
pixelherodev
nope*

1600098550
pixelherodev
Tricarbon was always intended to operate over the C ABI, not Zig's.

1600098562
pixelherodev
As long as it works with Zig, there's literally no reason to rewrite it

1600098570
pixelherodev
Worst case, I'd @cImport the .c code if that's possible

1600098579
justin_smith
fengb: re: const in anon structs, as a functional programmer in my other life, I don't see the drawback of the idiom of making a new anonymous struct with the modifications you want

1600098589
justin_smith
it's not ideal for memory or perf, but this is compile time

1600098595
companion_cube
pixelherodev: still… C… :/

1600098608
justin_smith
nice idioms to make it clean and recognizable are nice of course

1600098618
companion_cube
today on HN there's a repost of a post on "C's biggest mistake" (in this case, arrays)

1600098623
companion_cube
always a fun read…

1600098632
ifreund
companion_cube: C is pretty much the only alternative to zig for writing perfect software

1600098659
jjsullivan1
justin_smith: yes to the compile-time thing. I was only using it to add stuff to existing types programmatically

1600098666
pixelherodev
Honestly, I don't dislike C, at all.

1600098668
ifreund
rust doesn't handle allocation failure for one

1600098674
companion_cube
but to be fair, I think I know one "perfect" C program: sqlite.

1600098680
ifreund
that's not perfect software

1600098681
pixelherodev
C99 is probably my fourth- or fifth- favorite language

1600098686
companion_cube
ifreund: irrelevant for my use case.

1600098691
pixelherodev
At least, theoretically

1600098694
pixelherodev
In practical use, it's still #1

1600098702
pixelherodev
Zig as a

1600098703
justin_smith
fengb: to be able to mutate anonymous structs at compile time, I think you'd get into a potential can of worms of back tracking in the compiler to make sure you used the final final final version, just making a new anonymous struct is much simpler to me

1600098705
pixelherodev
Zig the stage1 compiler does not.

1600098720
companion_cube
that makes sense, pixelherodev.

1600098725
justin_smith
jjsullivan1: right, in that case I think it's simpler to make a new struct and use that one

1600098748
justin_smith
but I think I've made my argument, and all the expertise I'm going on comes from other inferiour languages, so I'll let others speak

1600098781
fengb
I mean more that converting everything into comptime feels weird. .{ .a = @as(u8, 0) } looks like I want a u8 field, but it's not

1600098800
pixelherodev
Honestly, there's a few languages I like better than C that are absolutely devastated by their ecosystems.

1600098810
jjsullivan1
also I wasn't meaning to language-lawyer, what I'm actually trying to do might not be the best way

1600098818
pixelherodev
I like Python, but I loathe pip

1600098828
fengb
But then again... anon literals weren't really intended to capture structure like this

1600098829
jjsullivan1
sorry everyone :^)

1600098830
pixelherodev
I absolutely hate language-specific package repositories

1600098906
justin_smith
jjsullivan1: I don't think an apology is called for (unless you're apologizing for triggering some unuseful bs from me)

1600098958
ifreund
exploring the extent of what a language can do is never a bad thing, even if the code is a weird way to do things

1600098976
jjsullivan1
nono, it's all helpful, I just wasn't meaning to say how things should be or if they're wrong

1600098989
jjsullivan1
I started zig like 3 days ago

1600098990
jjsullivan1
lol

1600099024
fengb
It's great for a new person to experiment with things. Helps find holes in documentation and/or design

1600099052
jjsullivan1
my actual program is encumbered by a lot of misunderstanding atm so I couldn't paste it, I'll probably come back here once I have a better idea of what to do

1600099868
leeward
companion_cube: sqlite is a great example of how test coverage does not equal goodness.

1600099872
JimRM
Thanks for the help everyone, I have managed to get my struct offset working:

1600099970
companion_cube
leeward: how so?

1600099981
companion_cube
as far as I know, sqlite has incredibly good coverage… and is also incredibly good

1600099987
ifreund
nice!

1600100016
gonz_
sqlite is indeed extremely good

1600100032
gonz_
Underrated even while it's used in virtually everything

1600100048
ikskuh
yeah, sqlite is really impressive. The API is also really well-made

1600100103
companion_cube
I learnt that its testing is done a lot via Tcl

1600100129
companion_cube
there's an interesting sub-culture of people who like C and Tcl; at least the sqlite and redis authors

1600100146
leeward
I have a friend who does database things, and he has found bugs, differences between spec and implementation (which I guess are bugs), and performance issues. It's better than average, but not perfect.

1600100186
gonz_
sqlite is heaps better than custom file formats, etc., which is what it's competing against.

1600100201
gonz_
It's not supposed to be "Deploy this on a server, scale like you would everything else"

1600100205
companion_cube
leeward: I hope he published that.

1600100214
gonz_
But it's an objectively better choice when one doesn't need a database

1600100227
companion_cube
but otherwise, leeward, what's your example of "perfect" software then? cause I certainly know none.

1600100244
leeward
companion_cube: I do not claim that perfect software exists.

1600100250
justin_smith
JimRM: thanks for sharing, that "write_struct" definition looks reusable enough that I wouldn't be surprised if a) it was already hiding in build.zig somewhere or b) it got included in some form in build.zig in the future

1600100251
companion_cube
ah!

1600100252
justin_smith
at first glance

1600100295
leeward
Also, he did file bug reports. And this was several years ago, so maybe it's been fixed since.

1600100377
justin_smith
JimRM: ahh! arm64, that's the assembly language I'm learning right now as well

1600100460
JimRM
@justin_smith  - yeah, that write_struct def is definitely very rough (ignoring errors etc) - I will rewrite it later when I better know what I am doing with Zig

1600100522
JimRM
Quite an interesting challenge writing zig code - as you and up doing a lot of code spelunking to figure out the way to do something (for example, it took me a while to figure out the proper way to create a new file + writing formatted strings to it)

1600100523
companion_cube
leeward: my candidate for "perfect code", if anything… is compcert.inria.fr/

1600100534
justin_smith
but still seems like something we would want to use frequently (and #define rather than a full jump table is probably the right level of exposure, better than my idea for sure)

1600100535
companion_cube
but it's not perfect in other ways (memory allocs and such)

1600100601
justin_smith
companion_cube: I was trying to recall where I saw your nick - inria.fr - you are/were active with OCaml right?

1600100629
pixelherodev
I second leeward's point

1600100634
pixelherodev
There is no "perfect software"

1600100639
pixelherodev
And I doubt there ever will be

1600100670
companion_cube
justin_smith: I am indeed

1600100689
companion_cube
yeah, you can just get into such or such percentile of "bug free"

1600100722
ikskuh
pixelherodev: `true` and `false` are bug-free i think :D

1600100746
pixelherodev
ikskuh: absence of evidence of a bug is not evidence of absence of bugs

1600100748
pixelherodev
:P

1600100769
ikskuh
i can read the complete assembler source for a program that does exactly a single syscall :D

1600100773
pixelherodev
lol, yeah

1600100779
pixelherodev
I was joking obviously ;0

1600100785
ikskuh
we can verify that the source is valid, but maybe the CPOU is not (but that would be faulty hardware)

1600100843
pixelherodev
It also, arguably, requires validating the assembler

1600100847
pixelherodev
and linker

1600100859
pixelherodev
and while you could disassemble it, that requires validating the disassembler ;)

1600100861
justin_smith
ikskuh: or the alignment in the generated binary is off

1600100863
justin_smith
bus error

1600100871
ikskuh
heh :D

1600100885
pixelherodev
or the entry point is listed incorrectly due to a faulty linker optimization

1600100899
pixelherodev
The worst part is that's probably actually possible

1600100993
companion_cube
and updates to the CPU's microcode…

1600101025
pixelherodev
That's HW.

1600101027
pixelherodev
Technically.

1600101030
pixelherodev
... maybe?

1600101038
companion_cube
fuzzy, I guess

1600101891
justin_smith
if it was hardware, your kernel couldn't update it via software surely

1600102028
pixelherodev
Sure it can

1600102031
pixelherodev
The MMU is hardware

1600102047
pixelherodev
And updating it is arguably one of the kernel's most important jobs

1600102282
companion_cube
does the kernel update the micro code at each boot? or is there ROM in there?

1600102452
pixelherodev
Former, I think

1600102456
pixelherodev
Both, rather

1600102477
pixelherodev
companion_cube: it can be flashed if necessary, but typically an older one is loaded by the BIOS, and the kernel updates it

1600102563
companion_cube
what's the definition of 'software', at this point, is really the question

1600102629
pixelherodev
I'd say everything above the microcode

1600102636
pixelherodev
Anything which passes through the instruction decoder

1600102873
companion_cube
that's a pretty concrete view!

1600102926
pixelherodev
Well, yeah

1600102939
pixelherodev
I don't see any other good definition

1600103110
companion_cube
"anything you can change without a soldering iron" ? :)

1600103119
pixelherodev
Halp, I accidentally wrote a schroedinger program!

1600103124
pixelherodev
:(

1600103131
pixelherodev
It works completely correctly under Valgrind

1600103144
pixelherodev
standalone, or with GDB, it seems to infinite loop

1600103152
pixelherodev
in X11 initialization code!

1600103155
pixelherodev
That makes no sense!

1600103981
leeward
companion_cube: That there is a good definition.

1600103992
leeward
I heard today: "It's the part you can't kick."

1600104074
leeward
pixelherodev: Most data doesn't go through an instruction decoder, and .bss is definitely part of the software.

1600104089
pixelherodev
leeward: ... yeah, definitely true.

1600104116
pixelherodev
leeward: how about this? All data which goes through an instruction decoder,

1600104263
leeward
FPGA images are part of the software package in stuff I've worked on. I mean, I guess it's loaded by software that runs on a different processor if that's included in your definition.

1600104380
leeward
I would also include microcode though. Anything that can be changed without affecting the BOM, really.

1600104393
ikskuh
leeward: i think of FPGAs as emulators for hardware which execute the HW description

1600104408
ikskuh
which means if it runs on a FPGA, it's software, but baked in an ASIC it gets hardware

1600104417
leeward
ikskuh: Yes, agreed.

1600104435
ikskuh
i mean, software is the reason why we invented FPGAs in the first place

1600104440
leeward
If you have to build it in lots of half a million, it's definitely hardware.

1600104445
ikskuh
being able to change things without rebuilding new stuff

1600104510
leeward
Hmm, DIP switch settings can be changed without affecting the BOM and they're not software. My definition needs revision.

1600104532
ikskuh
hm

1600104550
pixelherodev
leeward: "Anything intended to be software."

1600104559
ikskuh
i think it's actually software

1600104573
leeward
Circular definitions are the best kind of definitions.

1600104574
ikskuh
but it's not a program, it's just a n-bit configuration where every switch is one bit

1600104586
pixelherodev
leeward: It's not circular, and I'm partly serious

1600104599
pixelherodev
Microcode isn't intended to be software; thus, it's not.

1600104604
pixelherodev
Ditto to firmware

1600104604
leeward
If you use the word being defined in its definition, it is circular.

1600104606
ikskuh
leeward:

1600104612
pixelherodev
The distinctions are entirely based on intent.

1600104617
ikskuh
so dipswitches may

1600104650
leeward
hmm

1600104704
leeward
Where's the distinction between software and configuration? A purely mechanical system might have some switches that change how it functions. Is their state software?

1600104721
ikskuh
well, there were purely mechanical computers

1600104731
ikskuh
so they definitly had software

1600104733
leeward
Kinda mostly true.

1600104746
leeward
Did they have software? Or were they hard coded?

1600104764
ikskuh


1600104769
leeward
I can build an adder out of relays, but it's not programmable.

1600104774
justin_smith
pdp 10 had switches on the front you could use to bootload

1600104809
leeward
punched tape, sounds like a programmable computer to me

1600104812
ikskuh
leeward: you can build a programmable computer out of metal sheets (no electrical thing)

1600104819
ikskuh
which is what the Z1 is

1600104843
justin_smith
is the graduate student who follows a reference sheet and flips the switches to boot unix a programmer? a config author? a technician? a glorified monkey?

1600104868
leeward
Yeah, I just didn't know people had done it. The window of time where machines were good enough to make mechanical computers but technology hadn't gotten to electronic computers was small.

1600104869
ikskuh
probably just a computer that reads data and executes instructions ;)

1600104881
ikskuh
leeward: Z1 was built by hand afaik

1600104882
leeward
justin_smith: That's a whole different question, but a technician.

1600104891
justin_smith
leeward: fair, thanks

1600104916
leeward
ikskuh: jigsaws haven't always existed.

1600104917
justin_smith
leeward: but still the switches on the front control the bootup, they may or may not be software

1600104918
ikskuh
leeward: i think we have to do this: "{program,configuration} is element of {software}"

1600104965
leeward
Lots of computers are programmed through switches. The software is the information conveyed through them.

1600104974
ikskuh
files are software as well i think

1600104984
leeward
and I think you're right about that ikskuh

1600104986
ikskuh
be back later

1600105029
pixelherodev
So I just rediscovered a joystick driver I wrote :P

1600105038
pixelherodev
I'm 99.9% sure it'll work fine with cImport

1600107379
jjsullivan1
is there a way to print to the console in a compile-time procedure?

1600107458
pixelherodev
jjsullivan1: no

1600107461
pixelherodev
Deliberately.

1600107470
pixelherodev
You can use compileLog, but that fails the compilation

1600107751
jjsullivan1
is there any kind of debug tooling for compile-time code other than compileLog? Just the test fixture?

1600107945
ikskuh
jjsullivan1: just @compileLog and tests

1600108064
ifreund
hmm, it would be neat if the compiler would let you step through it

1600108082
ifreund
it's totally possible, wonder it there's already an open issue

1600108731
ikskuh
i am confused

1600108748
ikskuh
i get simd-code emitted by zig

1600108757
pixelherodev
ikskuh: and?

1600108785
ikskuh
i explicitly set the CPU as 486

1600108830
pixelherodev
Ah.

1600108834
pixelherodev
Yeah, that'd be a problem

1600108843
pixelherodev
RetrOS, I assume? ;)

1600108848
ikskuh
yeah

1600108857
pixelherodev
I remember I had to submit a patch to disable SIMD correctly when I was working on LIMNOS

1600108862
ikskuh
std.zig.CrossTarget{ .cpu_arch = .i386, .cpu_model = .{ .explicit = &std.Target.x86.cpu._i486, }, .os_tag = .freestanding, .abi = .eabi, }

1600108926
pixelherodev
I specified target as i386-freestanding and that was it

1600108929
pixelherodev
I didn't set a model

1600108934
pixelherodev
That's what worked for me

1600109014
ikskuh
weird

1600109056
ikskuh
btw, it's in the memcpy implementation in C.zig??!

1600109060
ikskuh
1661d0:       0f 10 04 3a             movups (%edx,%edi,1),%xmm0

1600109071
ikskuh
let's try the magic fix

1600109078
ikskuh
zig-update-git

1600109083
pixelherodev
lol.

1600109124
JimRM
I had a similar issue last week for AARCH64 - although aarch64 does support simd by default

1600109163
andrewrk
ikskuh, hmm that's strange I'm not aware of any bugs regarding target cpu features

1600109167
JimRM
I disabled it like this:

1600109178
ikskuh
andrewrk: build with current master, same problem

1600109191
ikskuh
it also explodes when i use _i386 as target cpu

1600109194
andrewrk
ikskuh, let me double check that cpu target features are correctly forwarded to c.zig

1600109197
ikskuh
because some llvm stuff select

1600109208
ikskuh


1600109220
ikskuh
why does my 100% zig code use @memcpy anyways?

1600109235
ikskuh
oh, i'm using @memcpy, is that the reason?

1600109283
jjsullivan1
is slicing at compile time not supported?

1600109316
ifreund
sure, as long as whatever you are slicing is comptime known

1600109369
jjsullivan1
hmm, getting some errors, may be that I declared as `var`

1600109373
andrewrk
ikskuh, I don't see any obvious problems forwarding the cpu features to the impl of memcpy

1600109389
andrewrk
when using the llvm backend we are forced to provide memcpy because LLVM codegen assumes it exists

1600109398
ikskuh
ah

1600109404
andrewrk
even just for struct initialization from a constant

1600109666
ikskuh
i'm trying to get a minimal repro for that

1600109918
ikskuh
using

1600109919
ikskuh
zig build-exe src/main.zig --release-small --name kernel -target i386-freestanding-eabi --linker-script src/linker.ld

1600109923
ikskuh
will emit xmm0 access

1600109948
ikskuh
with -mcpu _i486 it … explodes?!

1600109960
ikskuh


1600109962
ikskuh
what is that?

1600110465
andrewrk
ikskuh, can you check --verbose-llvm-cpu-features ?

1600110482
andrewrk
uh wipe the cache first otherwise that won't print anything for the freestanding c functions

1600110527
andrewrk
that paste is what it looks like when LLVM has a codegen bug

1600110863
ikskuh
oh lol

1600110959
ikskuh
lolwat

1600110970
ikskuh
using i686 doesn't gen xmm register access

1600111124
ikskuh


1600111270
ikskuh
using no -mcpu _i386 or similar will compile the code, but enable sse2 and stuff

1600111925
andrewrk
if you can confirm we are passing the correct values with --verbose-llvm-cpu-features then we will know if this is zig bug or llvm bug

1600111945
andrewrk
eyeballing the zig code it looks fine

1600112024
ikskuh
i can tell the same about the features

1600112028
ikskuh
feature list is okay

1600112030
ikskuh
but!

1600112038
ikskuh
using -mcpu baseline-sse-sse2 works?!

1600112159
andrewrk
ok I think we may have some LLVM bug reports to file

1600112165
andrewrk
might be worth testing this in the llvm11 branch

1600112193
andrewrk
they're on rc2 right now

1600112271
ikskuh
hm, i could test that tomorrow

1600112542
ikskuh
ZGS compiles again! :D

1600112552
ikskuh
using now baseline-sse-sse2 instead of i386

1600112971
ikskuh
i'm tracking it down in LLVM

1600112986
ikskuh
i suspect it's cmov

1600112989
ikskuh
which breaks the code

1600113041
ikskuh
yep, it's cmov

1600113273
ikskuh
andrewrk: i found the culprit

1600113293
andrewrk
a bug in how llvm does cmov?

1600113305
ikskuh
it requires cmov to compile our code

1600113308
ikskuh
but i have no idea why

1600117339
andrewrk
hmm it would be nice to delete this code:

1600117378
andrewrk
thinking about dropping support for integrating with msvc libc. there's not really a reason to have it when we ship with mingw-w64

1600117408
pixelherodev
andrewrk: MSVC is apparently adding C11 support now...

1600117424
pixelherodev
Ah right, that was mentioned here earlier I think

1600117432
andrewrk
imagine: MSVC being irrelevant to zig

1600117441
andrewrk
what a wonderful world that would be

1600117441
ikskuh
andrewrk: i think that's actually a good idea

1600117446
ikskuh
reduce dependencies

1600117452
pixelherodev
I like it personally, but I can also see why others might be unhappy

1600117465
andrewrk
why?

1600117507
andrewrk
mingw-w64 ABI is binary compatible with MSVC. you can both use libraries produced by msvc and produce libraries for use by msvc

1600117570
BaroqueLarouche
MSVC libc should be kept for supporting Xbox targets for instance

1600117583
andrewrk
can you elaborate on that?

1600117601
BaroqueLarouche
well it's hard because most of that info is under NDA

1600117605
andrewrk
I don't want to break anyone's use cases but I do want to see if we can solve them with a different dependency chain

1600117623
andrewrk
what info?

1600117643
BaroqueLarouche
anything related to the Xbox SDK

1600117688
BaroqueLarouche


1600117690
andrewrk
hmmmm are you sure that using -target x86_64-windows-gnu would be problematic there? what exactly would go wrong?

1600117756
andrewrk
because it's ABI compatible with MSVC

1600117893
BaroqueLarouche
I dunno what could go wrong but I still think keeping full MSVC compat should stay.  Is MinGW compatible with the Windows 10 SDK ?

1600117927
BaroqueLarouche
let say I install mingw then the Windows 10 SDK, can I use this toolchain to do Direct3D 12 ?

1600117959
BaroqueLarouche
with no MSVC install

1600117991
andrewrk
hmm I guess the question there is header file compatibility, which may be an issue

1600118141
andrewrk
if there were zig bindings available then it would work fine

1600118201
andrewrk
you could produce such bindings easily enough with `zig translate-c --libc libc.txt` if you knew where the libc header file paths were

1600118226
andrewrk
that's a chore, but it may be worth it, to eliminate a default dependency on msvc

1600118413
BaroqueLarouche
MSVC dependency should be optional and the code that find libc, include path for MSVC should stay IMO and enabled only when you want it

1600118416
andrewrk
mingw-w64 provides headers for up to d3dx11_43

1600118467
andrewrk
the code that finds libc is here:

1600118478
andrewrk
maybe someone could be willing to try to port that to zig

1600118656
BaroqueLarouche
every COM header has a C version to it, with some comptime helpers it is way less painful.

1600118675
andrewrk
that's good to know

1600118695
andrewrk
ok what do you think about, mingw-w64 is the default libc for windows, but msvc is an option, with ability to detect paths

1600118705
BaroqueLarouche
sounds good

1600118724
andrewrk
so you would have to do `-target native-native-msvc` to get it to do msvc path detection

1600118780
andrewrk
I think this is a good idea

1600118786
andrewrk
thanks for the discussion BaroqueLarouche

1600118786
BaroqueLarouche
yup

1600118854
andrewrk
this will make the out-of-the-box experience for zig Just Work on Windows when you do not have MSVC installed. I do not think that is currently true

1600118941
BaroqueLarouche
Here's my current state of my D3D12 experiement in Zig:

1600118965
BaroqueLarouche
Some translated headers need to be corrected by hand

1600119489
ikskuh
andrewrk: is there a reason why a call stack might be incomplete in a compiler error message?

1600119538
andrewrk
ikskuh, I think it limits to some set number

1600119546
ikskuh
hm

1600119552
ikskuh
i'm getting a call stack of 2

1600119554
andrewrk
the idea was that you could pass -fno-compile-error-stack-limit or something like that but afaik that's TODO

1600119565
andrewrk
ok 2 is less than that number so never mind that

1600119576
ikskuh
which isn't helpful atm because it's erroring inside std and i cannot find out where something is calling std.debug.warn

1600120184
ikskuh
hm. giving up for today, bed is calling

1600121650
andrewrk
good night

1600121685
andrewrk
ikskuh, a trick you can do as a workaround, is to temporarily edit the std lib to delete the function

1600121717
andrewrk
it's a bug for sure though, to be clear

1600121726
andrewrk
that's not the intended compile error experience

1600124183
justin_smith
I'm writing a tutorial to document writing my first non-trivial zig program, is it better to link to the master docs as I go and count on links no rotting, or link to the docs for the specific version I'm using, which I'd assume are published and frozen?

1600124195
justin_smith
*not rotting

1600124248
justin_smith
eg. I want to link to

1600124265
justin_smith
I guess those match right now and I can edit easily enough later

1600124973
andrewrk
justin_smith, I suggest to link to the 0.6.0 docs for your blog post

1600125067
justin_smith
thanks

1600125142
justin_smith
in other language communities we have had recurring problems with old / early tutorials having too much google juice, so people would try to use out-of-date techniques or libraries

1600125170
justin_smith
so wanting to avoid those issues pre-emptively as much as I can

1600125952
andrewrk
that's really thoughtful of you

1600125962
andrewrk
we are definitely vulnerable to that here as well

1600127631
pixelherodev
Sorry about the delay; CBE basic arithmetic is good to go

