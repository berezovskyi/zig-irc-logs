1588033017
pixelherodev
Plz no templates kthx

1588033025
pixelherodev
Templates are just godawful

1588033036
pixelherodev
I mean, they're nice in terms of code cleanliness

1588033059
pixelherodev
But compile times are long enough as is :P

1588033237
foobles
maybe they just shouldnt be marked constexpr then

1588033245
foobles
because its never const-evaulated

1588033261
pixelherodev
Does it matter?

1588033293
foobles
its just a bit misleading i guess

1588033296
foobles
probably not

1588033389
pixelherodev
Uh

1588033398
pixelherodev
Why do you say it'll never be comptime evaluated?

1588033433
pixelherodev
`since they all require pointers to be called, it will NEVER be evaulated at compile time` [CITATION NEEDED]

1588033461
pixelherodev
`since a constexpr pointer variable must be initialized by an address constant expression, which, by [expr.const]/3, must evaluate to the address of an object with static storage duration, the address of a function, or a null pointer value.`

1588033461
foobles
if a constexpr function is called with runtime parameters it will not be evaluated at comptime

1588033471
pixelherodev
Yes, but comptime pointers are possible

1588033478
foobles
ok i was wrong there

1588033483
foobles
but these pointers are all runtime

1588033493
foobles
all 3 places they are called, they are runtime pointers

1588033535
foobles
to heap objects

1588033566
foobles
but we are only calling this function since it provides an instance of IrInst[src/gen]Id based on the overload

1588033570
foobles
which is purely comptime

1588033590
foobles
so it could be a constexpr function, if it was a template instead

1588033609
foobles
and its already doing overload resolution, so making a template wouldn't change the speed of compilation at all afaik

1588033667
pixelherodev
I don't think there's any situation in which switching to templates

1588034043
foobles
if anything, it will be completely negligable

1588034054
foobles
its doing the exact same kind of lookup

1588034061
foobles
and the template wont be generating any code

1588034123
foobles
i mean the optimization is probably being done anyway

1588034138
pixelherodev
Anyways, I'mma get back to work

1588034146
pixelherodev
I learned more about c++ than I wanted to know :P

1588034842
Snektron
<pixelherodev "I don't think there's any situat"> Its not

1588044179
foobles
is anyone available to talk about generating LLVM ir? I am trying to generate code to unwrap an optional, and I see the logic for doing so actually requires a pointer to an optional

1588044252
foobles
is there an easy way to get an LLVMValueRef that is a pointer to another local value? im learning just by reading the existing code

1588044259
foobles
so i may be way off with even my question

1588044705
foobles
I guess I could just extract the logic of ir_render_ref

1588044731
foobles
but if I use the pointer generated by that, I think that could cause issues with mutating variables when I unwrap it

1588044918
foobles
oh-it looks like unwrapping it if it isnt  a pointer just returns the value directly without doing anything? im very confused

1588044985
dimenus
pixelherodev: even sway can't compensate for xwayland's blurryness

1588045010
dimenus
the good news is wayland native apps are crystal clear

1588045085
pixelherodev
Sure, but that's still an x11 issue :P

1588045129
dimenus
and it's only on my scaled monitor that it looks poor

1588045668
foobles
any ideas for what i was talking about?

1588045773
foobles
wait never mind, i think i have an idea 8)

1588049777
tdeo
now that @Type(.Opaque) and @Type(.Vector) are implemented, should I make a PR to replace all usages of @OpaqueType/@Vector?

1588049808
tdeo
with a possible std.meta.Vector (or std.meta.VectorType to match IntType? i think it should just be std.meta.Int there) because typing out @Type for vector is long

1588060574
mq32
ES REGNET! \o/

1588061104
mq32
oh whey

1588061112
mq32
i'm writing to the wrong channels a lot...

1588061128
mq32
but still: it rains! \o/

1588061560
ifreund
mq32: idk what you're talking about, es regnet nicht hier

1588061666
mq32
heh, at my place it does!

1588061815
cren
I'm learning Zig. How do I pass a slice to a function?

1588061856
mq32
hey cren

1588061864
cren
hello!

1588061867
mq32
do you want to pass something literal or from a variable?

1588061902
cren
from a variable. What I really mean is: what do I put for the type of the parameter in the function definition?

1588061923
mq32
it's either []T for a mutable slice or []const T for an immutable one

1588061928
mq32
replace T with any type :)

1588061934
cren
okay, thanks :)

1588063210
Kingsquee
what's the situation with the inverse trig functions in zig?

1588063230
Kingsquee
I see sin and cos are mentioned, but not tan or anything else

1588063302
Kingsquee
oh wait, it's there

1588063310
Kingsquee
just not in the language overview

1588063453
Kingsquee
..it's in std.math anyway

1588064468
cren
How long should my integer type be? 16? 32?

1588064522
tdeo
i32 is probably the most common, but what is it being used for? if it's an array index, use usize

1588064628
cren
Nah, it's just... an int... it's used as part of the output, which is a bunch of ints in the range 0-255

1588064650
tdeo
if you know it's going to be between 0-255, you can use u8 to save space

1588064743
cren
yeah, I think I'll do that

1588065020
cren
Does Zig have random number generation yet?

1588065048
tdeo
there is std.rand in the standard library

1588065064
tdeo


1588065201
Flaminator
Is there a reason there is no defer that only runs when a non error is returned? We have errdefer when we return with an error and defer that always runs.

1588065396
mq32
Flaminator: there was no reason to have one yet

1588065407
mq32
because all use cased could be solved with defer then

1588073830
l1x
hi folks, is there already a udp socket in zig std lib?

1588073896
mq32
kindaish

1588073935
daurnimator
nope

1588073945
mq32
you can code UDP with the stdlib, but you have to use unix sockets for that

1588073965
daurnimator
mq32: UDP != unix sockets... so that's already a "no"

1588073971
l1x
mq32: do you have a link?

1588073981
daurnimator
but also: there isn't really bindings to udp socket management functions

1588073989
l1x
daurnimator: to be clear i would like to bind to a port and receive UDP datagramms

1588073991
daurnimator
nor is there any facility for message based communications

1588073992
mq32
daurnimator: "unix sockets" as in "berkely socket function API"

1588073996
mq32
not "unix domain sockets"

1588074049
l1x
daurnimator: thanks, i guess it is coming later

1588074054
daurnimator
mq32: most of std.net is based around stream communication

1588074065
mq32
yeah

1588074069
daurnimator
l1x: all that said: we really just need someone interested enough (and with enough time) to implement it all

1588074069
mq32
l1x, give me a second!

1588074133
l1x
mq32: i give your minutes! :)

1588074138
l1x
s/your/you/

1588074154
l1x
daurnimator: i see, what is the scope of this task?

1588074201
mq32


1588074209
mq32
you gave me reason to publish this

1588074218
mq32
it's not yet complete, TCP client sockets are not supported yet

1588074235
mq32
but you can write TCP servers (and accept clients) as well as write UDP communications with multicast support

1588074244
mq32
IPv6 is stubbed atm

1588074302
l1x
nice!!

1588074337
mq32
it's even documented! :)

1588074354
l1x
i am just trying to port djbdns to a sane language zig or rust because I would like to have more control over my DNS infra and non of the current solutions are what i would like to have.

1588074364
l1x
i will check it out!  thanks. )

1588074435
daurnimator
l1x:

1588074820
alexnask
mq32, Nice

1588074865
alexnask
This really reminds me I should add docs to my iface impl and publish it

1588074888
mq32
l1x, alexnask: i would love to receive pull requests fixing the still missing parts, i will probably add windows support some time, but this stuff is usually only updated when i need more features

1588074907
mq32
alexnask: yes, please! zig-interface, tag with zig-package on github :)

1588074935
zigazeljko
what's the situation with dynamic linking in zig?

1588074959
zigazeljko
do you need to have the .so/.dll file you want to link against?

1588074970
l1x
daurnimator: thanks

1588074977
mq32
zigazeljko: yes, that's usually the case

1588074988
mq32
but afaik you can also provide a def-file

1588075139
zigazeljko
mq32: why is a separate def file needed?

1588075173
zigazeljko
is it not possible to generate the import section just from library name and function names?

1588075290
alexnask
I'm pretty sure you can use the `extern "libname" fn FnName(arg: c_int) c_int` syntax for dynamically linked libraries too

1588075388
zigazeljko
alexnask: i know, but it still requires a def-file

1588075510
mq32
zigazeljko: then a typo will yield valid compiling code ;)

1588075521
mq32
and get you runtime crashes

1588075526
mq32
instead of compile errors

1588075621
zigazeljko
mq32: what runtime crashes?

1588075740
zigazeljko
you mean a missing symbol error on startup?

1588076013
mq32
yep

1588076036
mq32
extern "user32" fn GetUser(foo: []u16) BOOL;

1588076041
mq32
^= would not import, but compile

1588076137
zigazeljko
mq32: yes, but that's to be expected

1588076174
zigazeljko
there are many ways a wrong extern declaration can cause runtime crashes, why would that be any different?

1588076221
mq32
because zig prefers compiler errors over runtime crashes

1588076229
mq32
and a def file prevents any runtime crashed regarding imports

1588076449
zigazeljko
but that complicates linking with dynamic libraries

1588076733
mq32
nah, not really

1588076742
mq32
it's not more complicated than on any other platform i've seen

1588076756
mq32
and it is more robust because i don't even need to have the library itself, only the def file

1588076761
mq32
and i can create that from headers or doc

1588076833
zigazeljko
mq32: but why couldn't then the compiler generate it itself?

1588076884
mq32
why should it?

1588076887
mq32
that's my question

1588076907
mq32
it's not really necessary, there are already tools for generating a def file from DLLs/SOs

1588076917
mq32
for unix,  that's objdump/readelf+grep+sed+cut

1588076924
mq32
for DLLs, there's even impdef

1588077021
zigazeljko
okay ...

1588077045
zigazeljko
btw, are you familiar with FASM (flat assembler)?

1588077155
mq32
nope, never heard of it. what does it assemble for?

1588077238
zigazeljko
for x86 (16/32/64-bit)

1588077303
zigazeljko
but the point is that it has nice import handling

1588077381
zigazeljko


1588077426
mq32
ah

1588077433
mq32
that assembler mixed linker and assembler

1588077473
zigazeljko
yes

1588077502
zigazeljko
and i was just thinking that such a feature would also be fitting for zig

1588077549
mq32
nah, i don't think that's a good idea

1588077830
zigazeljko
why not? isn't easier cross compilation one of the goals of zig?

1588077865
zigazeljko
and most of the examples of dynamic linking with zig on the internet complicate it by depending on system-installed libraries

1588077939
mq32
well

1588077947
mq32
dynamic linking is always system-dependent

1588077971
mq32
you cannot just link against a non-existent library on your system

1588077988
mq32
zig style is: if you use dynamic linking, make sure the target system

1588078005
mq32
simplest variant: don't link dynamically

1588078043
mq32
next: for windows/linux, ship the so/dll with your installation and give the dynamic linker somehow a hint which library to use

1588078048
mq32
after that is status quo

1588078065
mq32
first one is a non-problem here, second one is semi-available with the def files

1588078505
zigazeljko
yes, but i also had a different issue in mind

1588078681
zigazeljko
there are already quite a few zig wrappers (on the internet) for native GUI / OpenGL / etc. libraries

1588078755
zigazeljko
and since imports like `extern "libname" fn FnName(arg: c_int) c_int` by default implicitly resolve against natively installed libraries

1588078764
ifreund
anyone have a idea how to work around

1588078799
ifreund
i'm hoping there's some way to make things more consistent across platforms with zig's metaprogramming tools, but haven't really dug into those yet

1588078813
zigazeljko
mq32: such wrappers don't work when cross compiling

1588078857
tdeo
not what you're asking, but i actually did a thing with zig metaprogramming and wl_listeners once

1588078865
mq32
zigazeljko: OpenGL works cross-compatible, as the layout of libGL/OpenGL32.lib is defined

1588078913
tdeo
ifreund:

1588078927
mq32
but yes, still you have several OSes and you need to ship the libraries you use with them

1588078936
mq32
in order to make sure your program works

1588078963
mq32
"depending on system libraries" does not work well for linux, is required for BSD libc, and on windows you can rely on some GUI stuff being available

1588078980
mq32
but i still don't see why we should give up def files

1588078992
mq32
they make your code more reliable and maintainable

1588079057
ifreund
tdeo: neat, i will save this for when I have the time to wrap wlroots/libwayland

1588079200
tdeo
hm, what do you mean by wrapping?

1588079214
tdeo
it doesn't need you to redefine anything from the headers if that's what you mean

1588079324
ifreund
I mean a thin layer over the libraries providing more idiomatic zig bindings that calling into the c code directly

1588079352
ifreund
s/that/than/

1588079375
tdeo
ah

1588079387
ifreund
i'd mainly want this for libwayland since I plan on writing my future clients in zig

1588079413
ifreund
maybe I'll even make something like smithay's client toolkit eventually

1588079440
tdeo
i'm slowly working on a pure zig wayland implementation but i keep throwing out my progress haha

1588079463
ifreund
oh? i've been considering trying that but would rather spend my time on river right now

1588079480
fengb
Oh how is Wayland? Better than X11 I hope :P

1588079493
ifreund
so much nicer to write code for

1588079500
ifreund
and yeah imo it's objectively better

1588079502
tdeo
wayland is pretty controversial but i like it a lot

1588079562
pmwhite
But it doesn't have network transparency.

1588079593
zigazeljko
mq32: what i was trying to say is: as it is currently, cross-compiling requires additional work (in form of def-files or otherwise) compared to compiling for native platform

1588079597
tdeo
neither does modern x11 :)

1588079602
zigazeljko
with my idea, those two would be the same

1588079640
tdeo
see

1588079649
mq32
zigazeljko: no. compiling for native platform also requires you to include the libraries by hand

1588079657
mq32
zig does not depend on your system platforms by default

1588079680
fengb
I don't run a Linux desktop so I might never really play with it :/

1588079723
tdeo
ifreund:

1588079751
tdeo
i like tagged unions over multiple callbacks

1588079782
zigazeljko
mq32: no, doing `extern "mylibrary" fn ...` automatically includes it

1588079892
mq32
well

1588079899
ifreund
tdeo: this looks very promising, I hope you continue work on it!

1588079909
mq32
than that's a bug and it should be fixed somehow in terms of: "you have to provide the lib yourself"

1588080020
mq32
hm

1588080022
mq32
no

1588080031
mq32
i just tested and i really don't understand what you try to achieve

1588080039
fengb
Wow, there's not many good resources discussing Wayland and X11... mostly a bunch of pissing contests

1588080042
mq32
as long as i don't have the library file, i cannot depend on it

1588080050
mq32
and that's how it should work

1588080072
mq32
i cannot import stuff from non-installed libraries, i cannot import stuff from foreign-platform-libraries

1588080128
mq32
i still consider it a bug that i am allowed to link to dynamic libraries in the system path though

1588080143
ifreund
fengb: did you read this page? it's probably a little biased but has good info

1588080184
tdeo
the protocol is

1588080195
tdeo
i've played around with writing client libraries in a few languages now

1588080241
tdeo
still working on the zig one i mentioned, as well as a small rust one, and i finished a go one but didn't really know how to fit it into go's concurrency model well

1588080252
fengb
It'd be really hard to make anything as bad as X11 :P

1588080308
fengb
Hmm, what's the disconnect with Go's concurrency?

1588080376
pmwhite
fengb: the web development world makes stuff as bad as x11 all the time.

1588080416
fengb
I wonder when the web will invent compositing onto canvas directly

1588080425
fengb
I suppose it already did with Flash

1588080440
fengb
But... web pays my bills :P

1588080473
tdeo
well you create protocol objects and you can send requests/receive events with them, and you usually add a callback(s) to receive the events. if you don't add a listener and then you read events from the connection, you just silently lose them, but that's fine since there's usually a single thread and a main loop

1588080518
tdeo
but i wanted the go one's api to not have a main loop, to just act like a network connection you can send and receive stuff from, so you can use multiple goroutines to do stuff with it and not be tied to one thread (because that's just the natural way to do things in go)

1588080531
tdeo
but then you have a race condition between creating a protocol object and setting its listener

1588080567
tdeo
i could just add that as an argument to the functions that can create an object, hm

1588080606
fengb
Hmm... I typically see things to force itself running on the main loop if there's a need, but that's probably not the Go way

1588080683
fengb
Actually... is there a good UI toolkit that doesn't require the main/UI thread doing specific things?

1588080712
fengb
I admit I'm a mobile/web guy, but Android, iOS, and web all have that limitation

1588080798
tdeo
ifreund: check your issue again :)

1588080831
tdeo
the problem wasn't actually the zig issue you linked, that's for types rather than fields

1588080919
pmwhite
fengb: the limitation is more like enforced good practice, right? Unless I'm misunderstanding your complaint.

1588081023
fengb
It's more that the UI rendering requires coordination and most systems I've seen sorta gives up and tosses all the rendering onto the same thread. I don't think it's necessary but I haven't seen a better solution

1588081123
fengb
I dunno if a different architecture can fix this. Maybe just an inherent concurrency problem

1588081478
fengb
What if there's a field named "unnamed_0"? :P

1588081618
tdeo
there are many more common things a c header can do to break translate-c :)

1588081629
tdeo
mostly macros though

1588081993
ifreund
i love you tdeo

1588082087
fengb
We could make it an illegal C identifier! `@"unnamed_0@"`

1588082094
ifreund
hmm, i guess this means i'll probably move to zig master then

1588082096
fengb
`xxStrikeYouDownxx`

1588084197
pixelherodev
Is there a pattern for deprecation yet?

1588084267
mq32
yeah

1588084278
mq32
first stage: function gets marked as deprecated with a comment

1588084286
mq32
second stage: function gets deleted with @compileError()

1588084456
pixelherodev
Okay but that's not what i meant :P

1588084464
pixelherodev
Idea though

1588084495
pixelherodev
Switch the function to require another argument, a tuple which must have `ack_deprecation = true`

1588084542
tdeo
i feel like the point of deprecating something is to avoid breaking code immediately

1588084620
fengb
Do it the Java way. Leave in a comment indefinitely 🙃

1588084653
tdeo
zig could add a @compileWarning but i think zig is anti-warnings in general

1588084805
pixelherodev
tdeo, the idea of this is to allow code to continue functioning, but to require explicitly acknowledging that you should move away from the function ASAP

1588084831
pixelherodev
The underlying thought process is that if you have to change it *anyways*, you're more likely to fix the problem instead of postponing it forever

1588084877
tdeo
but the person building the code isn't always the one that wrote it, i mean

1588084922
tdeo
imo if you're going to do that just go ahead and do @compileError instead

1588084938
fengb
I wonder if there's a middle ground. Warnings will error if it's a direct consumption, and apply a "this package is bad" warning if it's indirectly included

1588084992
pixelherodev
Or

1588085006
pixelherodev
Check build mode

1588085020
pixelherodev
compileError in debug modes, allow it in release modes

1588085077
alexnask
pls dont touch my @compileError, make your own @debugError or smth :D

1588085093
alexnask
@debugCompileError

1588085159
fengb
@yourCodeIsBadAndYouShouldFeelBad

1588085735
pixelherodev
alexnask, I'm not changing anything

1588085770
pixelherodev
I'm thinking of adding a metafunction `deprecated` which uses `std.debug.warn` in release modes and compileError in debug mode

1588086561
yrashk
I had a dream of a FreeRTOS-like project in Zig. I wish Xtensa LLVM was more mature -- ESP32 is my primary microcontroller of interest these days!

1588086618
fengb
Once ZIR becomes more stable, you can write your own backend!

1588087007
yrashk
indeed!

1588087013
yrashk
so, a year or two?

1588087039
TheLemonMan
...if you have the knowledge to write your own backend you're better off helping LLVM finishing their

1588087118
pixelherodev
^

1588087129
pixelherodev
As someone writing a Zig backend, I second that

1588087260
antaoiseach
Hello, all. I tried using the CMakeLists patch for the macOS Homebrew + LLVM issue, but I'm still running into build issues... anyone else face this?

1588087279
antaoiseach
The first error I face is this: "Scanning dependencies of target zig_cpp

1588087279
antaoiseach
In file included from /Users/z0ltan/software/zig/src/zig_llvm.cpp:23:

1588087279
antaoiseach
[ 76%] Building CXX object CMakeFiles/zig_cpp.dir/src/zig_llvm.cpp.o

1588087284
antaoiseach
/usr/local/opt/llvm/include/llvm/Analysis/TargetLibraryInfo.h:53:10: error: unknown type name 'StringLiteral' static StringLiteral const StandardNames[NumLibFuncs];"

1588087312
antaoiseach
The patch I'm referring to is this:

1588087478
alexnask
Are you using LLVM10?

1588087486
alexnask
If you are I have no idea what the issue could be sry

1588087489
antaoiseach
alexnask: yes ... llvm 10.0.0_3 (using Homebrew)

1588087513
antaoiseach
One thing though - I am building from source - the linked Github issue mentions support only for Zig installed from Homebrew. Is that correct?

1588087527
antaoiseach
alexnask: ah, okay... no worries! :-)

1588087580
alexnask
I had the issue with the llvm apt packages myself but compiling llvm+clang+lld myself fixed it (didnt want to patch my cmakelists)

1588087659
antaoiseach
alexnask: Hmmmm... yeah, I was thinking of going that way - but my old laptop doesn't have enough space (or grunt to be honest) to build llvm myself :(

1588087690
alexnask
This doesn't seem to be directly related to this bug anyway

1588087724
antaoiseach
Hmmm

1588087763
antaoiseach
It's most frustrating... still, I could revert to an older commit till this thing is sorted out - just feels weird that it was running smoothly so far and now macOS builds are a mess

1588087821
fengb
Unfortunately LLVM 10 introduced a lot of build crud

1588087888
antaoiseach
fengb: yeah... looks like it... irksome!

1588087924
TheLemonMan
the polly problem has been fixed in the git version

1588087928
antaoiseach
I reverted to 6f10e3fda6ca3ef2846c87b149d308fa461fdbb0, but stil won't build with LLVM 10.0.0_3 .. will try 10.0.0 and see

1588088477
cren
Hi everyone. I'm learning Zig. How should I define a program constant; the sort of thing that might be specified with `#define MYCONST 42` in C?

1588088503
companion_cube
`const MYCONST = 42;` should do

1588088584
cren
Ok. That's what I was doing anyway. Just checking. :)

1588089319
foobles
cren don't use screaming case tho ;)

1588089371
cren
Ah yes, I automatically didn't actually, I didn't really register that the constant had its own case

1588089386
antaoiseach
foobles: `const I_LOVE_PEANUT_BUTTER_JELLY_SANDWICHES = true` :D

1588089417
antaoiseach
anybody in here ever try Ada? I've been learning it of late, and it's quite fun!

1588089435
antaoiseach
(all this while I wait my llvm brew formula to download -_-)

1588089444
cren
What domain is Ada for? Is it maths?

1588089466
antaoiseach
cren: safety-critical stuff and RTOS etc., embedded, avionics et al.. according to the docs!

1588089497
antaoiseach
It's not terribly verbose (as I was made to understand), and the types are quite strong from what I can tell .. .quite enjoyable actually

1588089521
companion_cube
antaoiseach: seemed super verbose to me when I looked, all the `end foo;` for every single construct :(

1588089553
antaoiseach
companion_cube: Haha... yeah, but doing a decade in Java has made me immune to that level of verbosity :-)

1588089631
antaoiseach
the ada docs at learn.adacore.com are superlative - that is how a tutorial should be written IMO (much like the Rust tutorial was before 1.0, and then it strangely went awry)

1588089647
companion_cube
do you use an IDE?

1588089658
antaoiseach
I was hoping for something similar for the zig stdlib... sadly nothing as yet

1588089658
alexnask
I don't know too much Ada but I love their integer types `type Page_Num  is range 1 .. 2_000;

1588089659
alexnask
`

1588089681
antaoiseach
companion_cube: There is an IDE, but I just use the CLI for now... the module system is quite nice and amenable to working on the command line

1588089699
antaoiseach
alexnask: yup, that's brilliant, isnt't it? With very strict type checking as well

1588089703
alexnask
type Byte        is mod 256;

1588089715
alexnask
Yeah from what I've seen it has a very good type system

1588089823
antaoiseach
alexnask: the only irksome part so far was the multitude of string types - but the docs are very helpful and easy to work with, so it's been fun so far! well worth a check out imo

1588089852
antaoiseach
As for Zig, I'm done with the core lang from the master docs, and now should hopefully get my hands dirty on some project! :-)

1588089864
antaoiseach
you guys working on something interesting?

1588089890
pixelherodev
Depends who defines "interesting" :P

1588089895
antaoiseach
hah!

1588089919
BaroqueLarouche
I could use some help on

1588089924
fengb
I'm writing a crappy Gameboy emulator

1588089967
antaoiseach
BaroqueLarouche: interesting project

1588089979
antaoiseach
fengb: that's pretty cool!

1588090005
antaoiseach
how're you guys finding working with Zig on real examples though?

1588090016
fengb
Planning on streaming some more in ~10 hours if you're still around

1588090024
antaoiseach
fengb: where?

1588090042
fengb
twitch.tv/fengb

1588090061
antaoiseach
fengb: btw, your post on reddit about pointers in Zig was quite helpful to me... appreciate it

1588090072
antaoiseach
cool.. will check it out. thanks!

1588090089
fengb
np

1588090152
fengb
In general, I think Zig helps expose low level fundamentals, even more so than C

1588090154
antaoiseach
followed... should be edificational and fun

1588090179
antaoiseach
fengb: can you elaborate?

1588090225
fengb
It works amazingly well for freestanding targets, the stdlib has useful general purpose things but the OS integration can be a bit spotty at times

1588090242
fengb
And the language has been changing every other week... so definitely not stable yet

1588090257
antaoiseach
Hmmm... okay, not much experience in low-level stuff so cannot fully appreciate that, but trying to learn :-)

1588090309
antaoiseach
fengb: yeah, I saw some pretty lively discussion on new semantics for `const` the other day (not sure what the conclusion was though)

1588090310
fengb
Oh for low level stuff... things like alignment, sizing, memory padding, etc. They're pretty hidden in C

1588090376
antaoiseach
Ah, yes indeed... just curious - how do these get translated down.. alignment in particular... or are these purely at the type-level?

1588090388
antaoiseach
Does LLVM itself have support for it?

1588090433
fengb
Yeah it does. C has extensions for it but you sorta need to know where to look

1588090461
fengb
I didn't know it existed and I've been dabbling in C for ~15 years now. Never really low level stuff but still

1588090772
antaoiseach
fengb: that makes sense to me ... very interesting indeed!

1588090804
antaoiseach
well, makes me quite excited to get to that kind of stuff eventually!

1588090848
fengb
Also it's got pretty good support for wasm. There's some functionality that's missing, but overall it works nicely and translates code in an understandable way

1588090881
fengb
Rust is probably the closest alternative there but I didn't have the intelligence / patience to learn Rust :P

1588091205
fengb
Admittedly, Rust's wasm toolchain is pretty incredible

1588091205
companion_cube
still dubious about that fengb

1588091206
companion_cube
rust isn't hard to learn if you know how to think about pointer ownership

1588091206
fengb
What, I talk big. I don't actually know a lot :P

1588091207
companion_cube
tss tss

1588091207
companion_cube
rust isn't conceptually hard, for the most part, if you're not trying to do ultra generic code

1588091208
companion_cube
you just have references whose type indicate what stack frame they're valid for, basically

1588091208
companion_cube
and if the reference escapes that frame, compile error

1588091245
tdeo
is there a way to get a ZigFn from a ZigType?

1588091518
tdeo
actually, that wouldn't make sense

1588091579
cren
Should I be calling `std.io.getStdOut()` more than once per program? I was about to put it in a function...

1588091590
pixelherodev
cren, doesn't matter

1588091594
tdeo
no, call it as many times as you want

1588091596
pixelherodev
It's completely fine

1588091609
cren
No performance penalty? Okay.

1588091663
pixelherodev
Well, no *penalty*, but if you want to improve stdio performance, check out BufferedStreams

1588091702
cren
Cool, alright.

1588091757
cren
While we're here, what does the `try` keyword do?

1588091780
pixelherodev
It's syntax sugar

1588091785
cren
It seems to be something to do with errors and returning? I can't see a chapter for it in the docs

1588091793
pixelherodev
It means `try blob;` == `blob catch |error| { return error; }`

1588091803
cren
Ah

1588091810
cren
That explains quite a lot, thanks

1588091814
pixelherodev
:)

1588091992
andrewrk
cren, getStdOut() (and related functions) are extremely cheap, but have to be function calls because of the way the data is accessed on windows

1588092019
andrewrk
as noted by pixelherodev, the more important performance related concern is making sure you use a buffered stream and don't forget to flush it

1588092100
cren
Okay. I'm just learning, so at this stage I'm more concerned with correctness than optimality. I was thinking about making `const stdout = try std.io.getStdOut()` a global variable, but in trying that I discovered that `try` is not allowed outside of functions

1588092176
andrewrk
the same reason that getStdOut() has to be a function and it can't be a global, is why you can't make it a global. the std lib would have already done that if it was possible

1588092199
cren
That makes sense. Alright.

1588092201
andrewrk
your intuition is correct. it would be nice if it were a global and not a function call

1588092211
andrewrk
if you look at the windows implementation you will see why it cannot be so

1588092244
andrewrk
also just to be sure, I noticed you are using `try` there. that applies to 0.5.0 but not 0.6.0 and I strongly suggest using the latter and not the former

1588092305
cren
Ah, I was using 0.5.0 because when I started learning 0.6.0 was not released yet (it was released about a week later) and when I last checked my distribution hadn't packaged 0.6 yet

1588092310
cren
I'll check again

1588092436
andrewrk
a lot changed:

1588092492
andrewrk
it's also quite easy to use a pre-built tarball if your package manager does not have it

1588092898
tdeo
hmm, can i get a ZigValue function pointer to the function for a ZigValue frame?

1588093095
pixelherodev
Would a std.meta.castable function be useful to anyone other than me?

1588093103
pixelherodev
e.g. `std.meta.castable([]const u8, value)`

1588093121
foobles
like it returns a bool?

1588093128
pixelherodev
Or an optional

1588093133
pixelherodev
e.g. ?T

1588093153
pixelherodev
I think it'd be useful for variable types

1588093163
pixelherodev
e.g. `func("literal");` will pass it as an array

1588093173
pixelherodev
But it

1588093191
pixelherodev
I mean, it's probably better to just require an @as at the callsite

1588093690
antaoiseach
Phew! Finally managed to build commit 448f8c2eb8335e1c8fc0dd76c3ed728b80487a63 ... I do hope this macOS issue gets resolved somehow

1588093740
antaoiseach
fengb: Hahahah... yeah, Rust is fun, but once you get into lifetime hell, it can be quite a bit irritating

1588093792
antaoiseach
companion_cube: what I particularly like about Rust is the ecosystem - cargo and the module system are extremely usable

1588093856
antaoiseach
By the way, what is the idiomatic way of reading numbers/strings etc. from stdin in Zig? The standard documentation doesn't have any examples of I/O apart from the "Hello, world" example...

1588093861
companion_cube
and the enums ♥

1588093910
antaoiseach
companion_cube: that's actually interesting.. though I personally feel Zig's separation of unions and enums made the concept stick better in my mind. Rust's one-in-all enums is certainly very usable though - along with `match`!

1588093965
companion_cube
match is the magic

1588094876
gonz_
Does `stb_image` no longer work via zig?

1588094908
gonz_
Seems it's having issues translating functions, ones you'd access even via basic `stbi_load` usage.

1588095168
cren
Is there a printf equivalent in Zig?

1588095220
ikskuh
cren: OutStream.print or std.debug.warn

1588095234
cren
I need stdout so OutStream it is I guess

1588095244
ikskuh
yep

1588095252
ikskuh
stream.print("foo: {}", .{ value });

1588095277
cren
thank you

1588095282
cren
:q

1588095984
antaoiseach
okay, so I have tried to figure out how to read an i32 looking at std/io/in_stream.zig, but still can't make it work :|

1588096000
antaoiseach
I see a bunch of `read` functions, but something like this does not seem to work: `    const x = try stdin.readInt(i32, builtin.Endian.Big);

1588096003
antaoiseach
`

1588096030
antaoiseach
So how does one read in an i32?

1588096488
tdeo
read a line and parse it into an integer

1588096504
tdeo
(unless you really do want to read bytes, like from a binary file)

1588096572
tdeo
readUntilDelimiter '\n' for a single line

1588097710
pixelherodev
Isn't there a readInt convenience function or something?

1588097741
fengb
There’s fmt.parseInt

1588102598
foobles
what is the best way to unwrap an optional when generating IR?

1588102603
foobles
without any checks

1588102612
foobles
and I know that it isn't an optional pointer

1588102638
foobles
should I still get a ref -> ir_render_optional_unwrap_ptr -> deref?

1588102644
mikdusan
when using dot-access it sure would be nice if keywords were not a factor: `@"type": MyType,` and then `instance.type == MyType`

1588102708
fengb
I'd like that very much

1588102712
foobles
yeah same

1588102732
foobles
i still oppose it tho :v

1588102903
mikdusan
wait. duh. it was only my vim color syntax telling me it's bad. this actually works.

1588102949
fengb
It does?

1588102955
fengb
I've been tricked by Vim too!

1588102964
mikdusan
tricked. duped. bamboozled.

1588103022
mikdusan
ah i think because `type` is not a keyword?

1588103066
mikdusan
doesn't work with `foo.for` but `foo.type` yes

1588103080
mikdusan
I'll take it :)

1588103147
pixelherodev
`type` is a `type`, isn't it?

1588103150
pixelherodev
Not a keyword

1588103154
fengb
Hmm that's weird

1588103166
pixelherodev
@TypeOf(type) == type

1588103167
pixelherodev
I think

1588103335
mikdusan
looks pretty consistent. if it's a type (bool, u32, anyerror) then no problem with dot-access

1588104847
Snektron
<fengb "We could make it an illegal C id"> then just name it anything starting with E or to

1588104879
Snektron
(officially that is undefined behaviour in C)

1588104972
alexnask
what? seriously?

1588105009
Snektron
According to cppreference, yes

1588105043
fengb
C is an undefined behavior language with some systems programming capability

1588105102
Snektron


1588105107
Snektron
"The following identifiers are reserved and may not be declared in a program (doing so invokes undefined behavior): "

1588105111
alexnask
Thanks was looking for it

1588105118
Snektron
5) Identifiers declared as reserved for future use by the standard library, namely

1588105231
Snektron
in practise it works everywhere, but strictly speaking you shouldn't use it

1588105912
mikdusan
how would we describe `anyframe`. "a frame" or "pointer to a frame" ?

1588106202
alexnask
mikdusan, I believe it's a pointer to a frame

1588108896
pixelherodev
What's the simplest way to get the size of an array?

1588108948
fengb
@sizeOf(@TypeOf(array))?

1588108977
gonz_
What's the workaround for stuff that `translate-c` / `cInclude` has started failing at and is outputting TODOs for?

1588109397
foobles
pixelherodev like the length?

1588109404
foobles
or the size in bytes?

1588109878
pixelherodev
foobles, length

1588109903
foobles
just say `array.len`

1588109908
pixelherodev
Wait that's valid?

1588109913
pixelherodev
Thought that was only good for slices

1588109919
foobles
i think arrays have it too

1588109973
foobles
pixelherodev yeah, it works

1588109982
foobles


1588110042
alexnask
also on tuples

1588110229
pixelherodev
Sweet

1588111308
ikskuh
a new project on the zig horizon!

1588111309
ikskuh


1588111511
ikskuh
thanks to fengb for his support with my first wasm steps :)

1588117198
pmwhite
I'm a little confused by the ChildProcess API. Does anyone know the proper way to start child process and be able to pass bytes to stdin while receiving bytes from stdout?

1588118046
mikdusan
pmwhite: maybe this will help. warning: old code from a year ago:

1588118047
mikdusan


1588118056
pmwhite
I think I figured that part out. After creating the ChildProcess, I can call spawnPosix, which should then set the stdin and stdout fields. I didn't understand that it was multiphase.

1588118089
pmwhite
Now I need to figure out how to "read byte if there is one, but don't block if there isn't"

1588118128
pmwhite
mikdusan: ahh, that looks better than what I was thinking, thanks.

1588118222
pmwhite
what happens on `read` call if there are no bytes to read? Is there a way to read all available bytes?

1588118381
mikdusan
so 1. parent spawns child. 2. parent spawns feeder thread. 3. parent read/loops until EOF. 4. parent wait feeder. parent wait child.

