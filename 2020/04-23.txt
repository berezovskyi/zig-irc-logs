1587600118
Cadey
i got the same result from the 0.6.0 release tarball on ziglang.org

1587600204
mikdusan
Cadey: I don't know how far along powerpc64 is for zig. but I get same fault with that target on macos and archlinux

1587600412
fengb
PPC mac?

1587600443
mikdusan
no, host is x86_64-macosx and x86_64-linux

1587600473
Cadey
actually, where is the support tier list?

1587600481
mikdusan
release notes

1587600729
Cadey
aha

1587600742
Cadey


1587601192
Cadey
ah, tier 3

1587601219
Cadey
i filed an issue anyways:

1587601242
mikdusan
also that issue you mentioned a day (days?) back re: alpine and `zig cc` with a shared library... I feel that's a bug with zig right now.

1587607526
fengb
Is it weird that I'm enjoying manually converting LLVM voodoo into Javascript?

1587610943
foobles
hey everyone

1587611304
mikdusan
hey foobles

1587611335
foobles
:D

1587611356
foobles
ok i (re) implemented it at comptime and it's much better now

1587611365
foobles
and also does what the proposal says :v

1587611694
mikdusan
so being that there is only 2 possible actions (?T compare T) and (T compare ?T) where `T` is not literal null, then the only runtime work needed is branchless, and just issue an unwrap?

1587611895
foobles
how is it not branchless?

1587611908
foobles
if null => not equal

1587611914
foobles
else => unwrap and comare

1587611935
mikdusan
are you adding a runtime branch?

1587612110
mikdusan
what I mean is... let's compare to runtime functionality today. that would be runtime(T compare T)

1587612181
mikdusan
after implemented this feature, does it become (runtime(unwrap(exactly 1 operand), runtime(T compare T))

1587612196
mikdusan
[this struff is tricky to word]

1587612606
daurnimator
fengb: don't forget your asm.js derived optimizations

1587612624
daurnimator
fengb: e.g. start your functions with `a = a|0` to declare it as type i32

1587612653
daurnimator
and don't forget my favourite: `a = a <<< 0` -> cast to a u32

1587613910
fengb
I thought most browsers gave up on asmjs annotations

1587614191
foobles
mikdusan yes

1587614204
foobles
andrew said `??T == T` should  not compile

1587614208
daurnimator
fengb: I don't think so? got a source on that?

1587614209
foobles
only unwrap once

1587614245
daurnimator
fengb: I recall some browser didn't care about the "use asm" statement and applied optimizations no matter where it saw `|0` etc.

1587614262
mikdusan
foobles: yup that simplifies things

1587614275
foobles
my code is pretty simple

1587614281
foobles
wait

1587614287
foobles
how do you do it without branching?

1587614421
mikdusan
is your fork stil up?

1587614431
foobles
i made a new one :p

1587614439
foobles
let me send it

1587614454
foobles
one thing I know I forgot to do was check if it's an error union

1587614478
fengb


1587614484
foobles


1587614487
foobles
mikdusan

1587614617
mikdusan
foobles: have you tried to run tests?

1587614629
mikdusan
err let me step back. is this still WIP ?

1587614652
foobles
its just comptime checking

1587614655
foobles
i have run tests

1587614657
foobles
it works

1587614660
foobles
but only runtime

1587614664
foobles
err, comptime i mean

1587614694
mikdusan
ok so what will runtime optional value do?

1587614767
fengb


1587614792
foobles
mikdusan uuuh "this is a bug in the zig compiler" hehe

1587614797
foobles
i just made it unreachable ATM

1587614807
foobles
so it is WIP

1587614809
foobles
but not comptime

1587614856
mikdusan
so for comptime impl, I see no longer using ir_analyze_optional_value_payload_value ?

1587614952
foobles
yeah, i realized it was unnecessary

1587614972
foobles
since the only reason I wasn't directly accessing x_optional was because it might be a pointer

1587614979
foobles
*optional pointer

1587614992
foobles
but I make sure that it isnt before the function is called

1587615001
foobles
so i know that it is the correct place to look

1587615013
foobles
although, like I said, I also need to check if it's an error union

1587615032
mikdusan
when using ir_analyze_optional_value_payload_value did you need to check for error union?

1587615069
foobles
it does that on its own :p

1587615075
foobles
i believe

1587615095
mikdusan
and it probably does more things you won't realize are needed until your tests are expanded

1587615105
mikdusan
my point is, I think you had good instincts to use that fn

1587615149
mikdusan
but the proof would be with more test cases

1587615212
foobles
yeah, maybe

1587615220
foobles
i guess i did that because I wanted a ZigValue

1587615233
foobles
but i could just unwrap -> ir_resolve_const -> zigvalue

1587615243
foobles
yeah, thank you! im not sure why i didn't do that :P

1587615251
foobles
i use that emoji too much

1587615257
mikdusan
right, so let's say that takes care of comptime business.

1587615262
mikdusan
now onto runtime

1587615316
mikdusan
let's see if this makes sense. I recall that just like in comptime, we can't use ir_analyze_optional_value_payload_value when it's a pointer. was that the gist if "attempt to use null" error?

1587615361
foobles
I think the issue was that you werent checking for null at all

1587615365
foobles
you need to insert a branch

1587615384
daurnimator
fengb: I think that's for the "use asm" block having effect. the whole point of asm.js though is that its just JS if the browser doesn't support it

1587615404
foobles
which isnt possible in phase 2 directly, so andrew said to make some kind of new node with a special ir_render function :D

1587615407
foobles
fun fun fun

1587615425
mikdusan
foobles: to clarify I was not checking for null literal in the runtime section

1587615434
fengb
Yeah I know. But I’ve heard very little commitment from Chrome and even less from Safari

1587615455
mikdusan
oh wait, so if it's null literal, that would make it a comptime operand.

1587615456
fengb
I can’t find the post but the Chrome team wanting to focus on general use cases and not asmjs

1587615458
foobles
null literals are handled by some of the special cases that already exist

1587615464
foobles
but if its a runtime null

1587615468
foobles
you werent checking

1587615492
fengb
And then news went dark after everyone hopped on the wasm bandwagon

1587615533
mikdusan
i was checking for

1587615654
foobles
aah

1587615658
daurnimator
fengb: when in doubt... benchmark :)

1587615679
foobles
but yeah, in the runtime section, you just checked if it was an optional type, and if it was, you unwrapped it

1587615689
foobles
i think we definitely need some new type of node

1587615690
daurnimator
fengb: however, note that e.g. `<<< 0` is the only way to cast nicely to u32: it's not only an annotation like `|0` is.

1587615700
fengb
I really wish I could try vectorizing

1587615705
foobles
or at least a new type of IrBinOp to render differently

1587615720
mikdusan
foobles: bear with me, and I could very well just be blind here,

1587615762
fengb


1587615771
mikdusan
foobles: let's assume case (?T == T) and LHS/RHS are runtime

1587615794
daurnimator
fengb: avoid `const` in JS

1587615809
daurnimator
it has a ~3% performance impact....

1587615811
fengb
There’s no difference

1587615823
daurnimator
your overheads may be elsewhere

1587615836
mikdusan
foobles: so today (T == T) handles all the quirks. but what it doesn't handle is a runtime null value

1587615853
foobles
yeah

1587615876
daurnimator
fengb: also use hex literals for at least a little readbility :P

1587615880
fengb
And I don’t mean the const line. The magic numbers are some random LLVM voodoo that I don’t understand

1587615889
fengb
It might as well be Greek

1587615900
daurnimator
fengb: oh also note that if you're using a minifier it might be undoing your optimisations

1587615914
mikdusan
foobles: ok so let me just quickly review regular ir_analyze_bin_op_cmp

1587615936
fengb
Hmm I benchmarked unminified but you might be right here

1587615956
daurnimator
fengb: 255 == 0xff.... 31744 == 0x7C00... you might see why its not greek after al

1587616297
mikdusan
foobles: yeah I agree, for case where an operand is runtime(?T) we need a runtime branch :(

1587616331
foobles
horaaaay

1587616337
foobles
i will try doing some of that tonight

1587616512
mikdusan
I think a while ago I tried to add branches in analysis and all hell broke loose

1587616521
foobles
heh, yeah

1587616539
foobles
wait ok: so here is the issue with branches afaik:

1587616556
foobles
-in phase 2 you cannot modify control flow. thats all in phase 1

1587616564
foobles
-types are only known in phase 2

1587616576
foobles
-we are trying to add control flow based on types

1587616602
foobles
maybe we can create temporary IrInstSrc-s?

1587616609
foobles
and then analyze them on the spot

1587616663
daurnimator
mikdusan: what do you mean a runtime null value?

1587616690
mikdusan
daurnimator: if (?T == null) and ?T is runtime

1587616696
daurnimator
mikdusan: the Null type only has a single possible value (null): how could the value not be runtime-known?

1587616700
daurnimator
mikdusan: ah.

1587616737
foobles
mikdusan is that feasable do you think?

1587616739
foobles
im going to try it

1587616762
foobles
ah wait a second, that isnt going to work :(

1587616776
foobles
you can't get the IrInstSrc from an IrInstGen

1587616795
foobles
so its impossible to do like `ir_build_bin_op`, since you need the IrInstSrc of op1 and op2

1587616825
mikdusan
foobles: "cannot modify control flow" let's harden that definition; is it that we have to maintain a 1:1 basic_block relationship between pass1 and pass2 ?

1587616844
foobles
ahh thanks

1587616855
mikdusan
hey I'm asking, not telling :P

1587616866
foobles
oh, i dont know

1587616872
foobles
:d

1587616886
foobles
i am not completely sure what a basic_block is actually

1587616903
mikdusan
and then this Q. aren't there examples of pass2 eliding blocks because of comptime eval ?

1587616976
mikdusan
so I hope I got this correct: if we maintain 1:1 relationship, then we have analysis to elide a block; thus one possible solution from the frontend (as opposed to the backend codegen),

1587617003
mikdusan
is we insert a maybe-use block for the branch

1587617005
foobles
when you say "analysis" is that phase 1?

1587617012
mikdusan
analysis=2

1587617043
foobles
that could be a solution

1587617054
foobles
andrew has not been online on this chat in days O_O

1587617055
mikdusan
so then analysis of the cmp instruction must guarantee to elide the basic_block if we're not doing ?T == T

1587617063
foobles
yeah that might work

1587617067
mikdusan
foobles: he's busy on a coding frenzy I bet

1587617072
foobles
heh yeah

1587617221
mikdusan
if what I'm thinking is possible, then should be able to find some code example of how to elide a branch in analysis. if not, I'm all hot-air

1587617272
mikdusan
the other thing is like you were suggesting early on- create a temporary IrInstSrc. and THAT is what gets elided.

1587617385
foobles
ill look into how if-blocks are handled

1587617409
mikdusan
summary: we're basically talking about inserting a new maybe-elide-cond-br for purposes of decaying T

1587617834
mikdusan
and the home for that cond-br would be... what.. IrInstSrcBinOp ? new field `IrInstSrc *unwrap_operand`

1587617897
mikdusan
the breakdown there is, to which operand

1587640655
ikskuh
übrigens, lustige Sache mit C++Builder/RAD-Studi

1587640657
ikskuh
*Studio

1587640667
ikskuh
man kann per remote desktop nicht die scrollleisten verwenden

1587640670
ikskuh
außer man hat genug bandbreite

1587640691
ikskuh
oh, damn

1587640693
ikskuh
wrong channel

1587640694
ikskuh
sorry :D

1587647602
BaroqueLarouche
ikskuh:  Je comprends rien! Je parle pas Allemand 😁

1587647632
ikskuh
:D

1587647660
fengb
Ich bin ein berliner

1587647824
BaroqueLarouche
Wir sind die roboter

1587648309
ikskuh
thanks for the earworm, BaroqueLarouche

1587648320
BaroqueLarouche
Kraftwerk <3

1587650683
nephele
is "zig run start.zig" expected to be semantically the same as "zig build-exe start.zig; ./start"? Asking since i expected it to be, and was printing std.fs.selfExePath but got a directory somewhere in my cache in my homedir

1587650712
ikskuh
nephele: the idea is that zig run foo doesn't create an executable

1587650725
ikskuh
but as you require an executable, it's stored in the zig-cache

1587650791
nephele
ah Okay, that doesn't quite match my expectation of what a run command would do :)

1587650799
ikskuh
how so?

1587650804
ikskuh
it runs the content of the zig file

1587650815
nephele
I would expect it to create the executable and run it

1587650820
ikskuh
you didn't say you want an executable file, but you said yu want to run it ;)

1587650855
nephele
That to me means "create the executable file AND run it", seeing as how you said, i do require an executable

1587650894
ikskuh
yeah, but i would also expect a "run source" to delete the exe afterwards

1587650903
nephele
I suppose both choices work in certain usecases, i'm just used to another one

1587650917
nephele
even if that was the case it doesn't do that

1587651052
ikskuh
yeah, as zig caches everything else atm

1587651286
nephele
maybe it needs a build-exe-run target :P

1587651623
fengb
We should just comptime evaluate it and bypass the executable altogether >_>

1587651650
nephele
That atleast won't help my expectations :P

1587652549
svipal
hello.

1587652561
companion_cube
world!

1587652605
svipal
trying to use zig on windows, using glfw as a c lib. I get this message when compiling with ` zig build-exe test.zig --library c -I/d/dev/glfw/include -L/d/Dev/glfw -lglfw3` :

1587652620
svipal
`undefined symbol: __declspec(dllimport) function`

1587652626
svipal
for about every function in glfw lol

1587652643
svipal
DescribePixelFormat,  SetPixelFormat, SwapBuffers, etc...

1587652649
svipal
what could I do ?

1587652654
svipal
using the precompiled zig

1587652654
companion_cube
there's a `/d/Dev` in the -L, is that wanted?

1587652658
BaroqueLarouche
looks like you need a special define in GLFW to change the DLL export macro

1587652688
svipal
it's wanted, I'm specifying where the .lib file is.

1587652698
svipal
ok, I'm not too c-savvy

1587652716
svipal
how would that work ?

1587652882
BaroqueLarouche
@cDefine("GLFW_DLL", ""); before your @cImport

1587653090
BaroqueLarouche
in your

1587653096
BaroqueLarouche
@cImport before @cInclude sorry

1587653171
svipal
how so ?

1587653196
svipal
I've been using @cImport(@cInclude("GLFW/glfw3.h"));

1587653209
svipal
how do I stuff it in ? :')

1587653246
svipal
ok found it in the doc

1587653257
svipal
tried a few times, didn't get the right syntax from instinct

1587653330
svipal
still get the same error

1587653552
svipal
I can try from anotehr angle, is there any way to tell zig to look for .a mingw64 files instead of .lib ?

1587653562
svipal
I have a healthy mingw64 installation

1587653666
BaroqueLarouche
ohhh you're using mingw64 not msvc

1587653685
BaroqueLarouche
try passing -target native-windows-gnu to build-exe

1587653700
BaroqueLarouche
dunno if it will work

1587653707
BaroqueLarouche
but at least it will use the same libc

1587653716
svipal
yeah works

1587653722
svipal
nice and labi

1587653728
svipal
thanks

1587653869
svipal
Okay, very cool

1587654057
svipal
haha guess I was too fast now it builds it

1587654068
svipal
and then at the end of the build gives me the error

1587654074
svipal
will try building zig from source

1587655184
yrashk
is there any way to define functions on structures that make their definitions effectively mutually-dependent?

1587655661
yrashk
the only way I found so far is to do something like this

1587656779
nephele
does a Z after a function in std just mean that it accepts a null terminated string slice?

1587656785
nephele
or should it also return one?

1587656883
ikskuh
nephele: it usually has a only a Z paramter

1587656907
ikskuh
returning something mit Z would require mutation or allocation

1587656919
nephele
Okay, so i should do that myself afterwards?

1587657572
ikskuh
yeah probably

1587657583
ikskuh
or you just look what the functions return

1587657591
ikskuh
using std source is usually better than using te online docs

1587657684
nephele
Well, the online docs for std don't work anyway in links2 :P, so i've been using the std source anyway... just not that knowledgeable about zig yet

1587659016
watzon
When trying to target WASM I'm getting this error: `error: option '-atomics,-bulk-memory,-exception-handling,-multivalue,-mutable-globals,-nontrapping-fptoint,-sign-ext,-simd128,-tail-call,-unimplemented-simd128' cannot be

1587659016
watzon
specified with '-target-feature'`

1587659024
watzon


1587659074
watzon
Any ideas? This is my first go at WASM.

1587660158
andrewrk
hmm I thought fengb had a fix for that already

1587660292
donaldallen
I have a zig variable, foo, of type [:0]const u8 that I need to pass to a (C) gtk routine. The type of the parameter in the zig translation of gtk.h is *c_void. So in the call, I pass that argument as &foo[0]. The zig compiler complains:error: cast discards const qualifier.

1587660322
donaldallen
In C, this would be a warning, not an error, and I could fix it with a cast. Any suggestions for how to deal with this in zig?

1587660403
donaldallen
In this situation, the gtk routine is not going to scribble on my string, but the function definition doesn't say that. A bit of sloppiness common in C.

1587660414
fengb
I don’t. It’s an LLVM issue

1587660429
TheLemonMan
@intToPtr(*c_void, @ptrToInt(&my_ptr))

1587660435
TheLemonMan
or something like that

1587660541
watzon
Hmm so nothing I can do?

1587660548
watzon
Guess I'll have to use emscripten

1587660560
donaldallen
I do have a C file as part of this application that has a few utility function that I need to do in C, e.g., setting up gtk callbacks. I

1587660616
donaldallen
This would be at the expense of an extra function call, but if there's no better way .....

1587660675
fengb
There should be a way to convince Zig to stop passing target features, but you’ll run into other issues like linking with C

1587660732
TheLemonMan
donaldallen, you can drop the const with @intToPtr(*c_void, @ptrToInt(&my_ptr))

1587660756
TheLemonMan
it's not elegant but that's what you get for trying to break the rules

1587660793
donaldallen
The word 'elegant' never entered my mind when reading your suggestion :-)  But I will try it. Thanks.

1587660918
andrewrk
watzon, we need a simple workaround in codegen.cpp to pass the args slightly differently to clang:

1587660920
donaldallen
And I would point out to you that I'm not breaking the rules. gtk is. They defined a function for adding a string to a hashtable. The string will not be written by their stuff, but they don't say it in their function definition.

1587660944
andrewrk
apparently for this one backend, it wants separate -target-feature parameters rather than comma separated

1587660975
TheLemonMan
yeah const in C is a mild suggestion at best

1587660980
fengb
andrewrk: the bigger problem is that we don’t have a wasm libc

1587660991
andrewrk
ah

1587661003
andrewrk
that's what emscripten provides

1587661006
fengb
How difficult would it be to start fleshing out our Zig version?

1587661023
andrewrk
not very difficult. we already have wasm32-freestanding-musl with some string functions

1587661047
andrewrk
you can just add functions that are missing

1587661063
fengb
Ah cool. I might take some time to implement more

1587661074
andrewrk
if it tries to do file system operations, then there's a question of... what did you expect it to do?

1587661083
fengb
At some point, we should have our own ABI right?

1587661091
andrewrk
nah, no need for that

1587661109
andrewrk
at some point, we replace the libc implementations with our own zig code, but keep the ABI the same

1587661121
ikskuh
libzigc?

1587661132
andrewrk


1587661175
fengb
I think file ops should not be defined. Only WASI provides a concept of syscalls

1587661200
andrewrk
I think you can probably flesh out the wasm32 libc pretty quickly for your use case

1587661205
andrewrk
chances are it's only using a handful of functions

1587661210
fengb
Wouldn’t that be true of any freestanding though?

1587661219
donaldallen
@TheLemonMan Your suggestion appears to work. At least it compiles. I do feel that I need to take a shower after writing that :-)  But thanks again.

1587661219
andrewrk
yes

1587661237
ikskuh
andrewrk: how do i link against the zig-implemented libc?

1587661245
andrewrk
you have been doing it the whole time

1587661273
FireFox317
donaldallen, or convince gtk devs that they should have proper c function definitions

1587661298
andrewrk
ikskuh, it's a matter of how much implementations are shared between the libcs we bundle and the zig impl. right now that amount is not very much

1587661303
FireFox317
declaration*

1587661308
ikskuh
andrewrk: Zig is unable to provide a libc for the chosen target 'arm-freestanding-musl'.

1587661320
ikskuh
i know that i brought up this topic a day before to 0.6.0 release :D

1587661356
TheLemonMan
donaldallen, hah that's the spirit

1587661397
andrewrk
ikskuh, ok there does need to be an issue for providing c header files for all freestanding targets

1587661427
ikskuh
do we have one already? I'd like to contribute to this

1587661438
TheLemonMan
a libc for freestanding targets?

1587661463
andrewrk
TheLemonMan, yeah all it really needs is mainly the string manipulation functions, and it unlocks the ability to include .c files in freestanding projects

1587661481
TheLemonMan
we already have special/c.zig ?

1587661487
andrewrk
headers

1587661522
TheLemonMan
I'm not sure freestanding targets want headers

1587661534
TheLemonMan
I mean, you don't even have a libc most of the times

1587661542
andrewrk
don't they want to use int32_t etc?

1587661550
andrewrk
oh that's language headers, not libc huh

1587661576
andrewrk
ikskuh, what happens if you don't pass -lc ?

1587661597
TheLemonMan
no, you usually typedef all the intNN_t yourself

1587661649
TheLemonMan
you can always fallback on the c.zig mini-libc if you need some string/math functions

1587661649
ikskuh
andrewrk: It's a build script, but i call linkLibC

1587661659
andrewrk
yeah what happens if you remove linkLibC

1587661681
andrewrk
anyway we're well-positioned to compile c code for freestanding targets. it's just a matter of working out a few of these details

1587661686
ikskuh
well, the C headers won't be found

1587661693
andrewrk
which ones?

1587661702
ikskuh
stdlib.h

1587661713
andrewrk
what stdlib.h functions does it depend on

1587661762
ikskuh
/home/felix/software/zig-linux-x86_64-0.6.0+986aa42d3/lib/zig/libcxx/include/math.h includes stdlib

1587661765
TheLemonMan


1587661771
andrewrk
TheLemonMan, ^ so here's a use case. we could provide freestanding stdlib.h for all targets no problem and it is implemented by zig's c.zig mini-libc

1587661786
andrewrk
math is a good example

1587661818
TheLemonMan
if only --gen-h worked heh

1587661827
andrewrk
heh yeah

1587661839
andrewrk
that's a good solution once self-hosted is ready

1587661848
andrewrk
ikskuh, I think you would have success if you hacked up some stuff into the zig compiler. after you get it to work, it will become clear how to organize it

1587661860
ikskuh
context for my project: It's an arm-freestanding demo for an embedded platform that uses glm (OpenGL mathematics library) and other header-only c++ stuff

1587661869
ikskuh
do you have me an entry point or something?

1587661888
andrewrk
start with finding that error message that you're getting and delete the check so that it doesn't trigger

1587661944
shakesoda
using glm on embedded arm seems a bit mad

1587661962
andrewrk
TheLemonMan, speaking of, did you see

1587661965
ikskuh
haha okay

1587661976
ikskuh
shakesoda: why? It has a lot of wonderful functions and features

1587661979
shakesoda
like renting a bus to transport your backpack

1587661989
ikskuh
and i'm using it with a custom fixed-point arith instead of float :)

1587661999
ikskuh
so i have vec<3, fixed<16,16>>

1587662015
shakesoda
don't get me wrong, glm is useful

1587662021
ikskuh
which yields damn fast, constexpr-valid code

1587662026
TheLemonMan
andrewrk, yeah I had a quick look, no design docs for the IR?

1587662055
shakesoda
i mostly quit using things like that for how punishing the compile times are though

1587662071
shakesoda
glm isn't the worst offender though, this is an across the board thing

1587662077
andrewrk
TheLemonMan, I could make a design doc if you see that as the next step

1587662084
ikskuh
hey, compile times are totally irellevant when flashing takes 20 minutes :D

1587662096
shakesoda
yuck

1587662109
andrewrk
TheLemonMan, but I do want to play with an SSAT form to understand how it works before knowing what I would put in the design doc regarding control flow

1587662131
andrewrk
my plan was to get something working that felt right, then do the design doc

1587662147
shakesoda
i don't personally live in a world where compile times are ever irrelevant, they are a primary bottleneck to getting things done :(

1587662160
shakesoda
especially since I don't use a fast workstation

1587662185
andrewrk
shakesoda, sounds relevant to the direct-to-elf compilation that I am working on :)

1587662192
shakesoda
andrewrk: absolutely

1587662218
ikskuh
shakesoda: yeah, my laptop is pretty stronk for a mobile workstation

1587662234
andrewrk
anyway, zir design doc is planned, it's just a question of the order of doing things

1587662239
TheLemonMan
andrewrk, my only objection is that a single doc is easier to read than a huge PR :P but some code will work just fine

1587662239
ikskuh
\o/

1587662294
TheLemonMan
going straight from IR to machine code is an interesting decision

1587662327
shakesoda
isn't that a fairly intuitive one?

1587662330
andrewrk
this is for "debug" builds. every symbol is PIC, and there will be a mapping of decl -> set of decls that depend on it

1587662342
andrewrk
every decl will map to a symbol

1587662373
andrewrk
the idea is to figure out only the set of decls to regenerate, and only update those symbols in the elf file. incremental compilation

1587662396
ikskuh
oh crazy

1587662420
TheLemonMan
shakesoda, the intuitive one IMO is to chop the high-level IR into machine-specific block and then pass that low-level IR to the machine-instruction selection pass

1587662448
TheLemonMan
of course you can even go straight from the textual ast to machine code

1587662459
ikskuh
huh. zig doesn't build on arch linux?

1587662467
andrewrk
TheLemonMan, I'm doing the former thing

1587662467
TheLemonMan
but you lose some degrees of flexibility wrt how much analysis you can do on the IR

1587662479
ikskuh
i get linker errors: undefined reference to `clang::driver::getDriverOptTable()'

1587662485
ikskuh
known problem/solution?

1587662495
andrewrk
textual ir -> semantically analyzed ir form -> (optional additional passes, currently none) -> machine code

1587662499
TheLemonMan
andrewrk, so the plan is to transform ZIR to LLVM IR at some point?

1587662504
andrewrk
yes

1587662536
FireFox317
and also regarding multiple targets (x86 - arm) is it an good idea to directly go from semancitcally analyzed ir form -> machine code?

1587662541
andrewrk
eventual plan is that llvm/clang/lld are optional dependencies, which unlock more backends and CLI features (ability to compile C code, @cImport etc)

1587662568
companion_cube
how is ZIR different from, say, QBE?

1587662613
andrewrk
ZIR competes with QBE. ZIR is more bespoke, it's whatever the zig language needs it to be

1587662613
shakesoda
easy: qbe isn't written in zig :D

1587662625
companion_cube
could be a port, that's why I ask

1587662650
TheLemonMan
maybe ZIR is a higher-level representation than QBE?

1587662658
companion_cube
I imagine async does have impact on the IR

1587662669
TheLemonMan
after all we're going to use it during the semantic analisys phase

1587662675
andrewrk
the types and values of ZIR are the types and values of zig

1587662732
andrewrk
oh async is a good point. ZIR is async-function-aware. LLVM IR and QBE are not

1587662767
companion_cube
fair enough, I imagine you have plenty of inspiration from llvm anyway

1587662789
andrewrk
LLVM analysis passes sometimes get stumped by async functions due to limitations of LLVM IR. ZIR analysis passes are not limited by this, and treat async functions the same as functions (as appropriate)

1587663375
FireFox317
TheLemonMan, currently checking how many test fixes pass with D78011 on mips-linux, because without that one quite a lot tests don't pass

1587663422
andrewrk
FireFox317, we can still merge your PR, with those tests disabled (with a link to the zig issue corresponding to D78011)

1587663535
TheLemonMan
FireFox317, cool, I tested with ppc32 and afair the stdlib tests were all fine

1587663655
andrewrk
regarding ZIR, let me iterate on it a bit more and figure out some of these basic questions, such as control flow, multiple architectures, etc and then everybody can look at the design and pick it apart

1587663694
andrewrk
I'm going to have to put it down for a week or two to do these redisconf talks tho

1587663748
companion_cube
waaaa, you go to redisconf?

1587663790
andrewrk
I'm signed up for 2 talks this year

1587663817
andrewrk
unfortunately it's virtual, but at least it means I have full control over the talk video

1587663838
andrewrk
so I can put in sound effects and music! (j/k don't worry kristoff_it)

1587664247
companion_cube
special voice effects? oh boy

1587664256
companion_cube
so basically it'll just be one big twitch session

1587664313
andrewrk
planned, practiced, and edited though. those 3 things make a big difference in quality. my twitch streams are improv

1587664430
Jenz
Why are there so many 404 links in the stdlib docs? E.g.

1587664466
TheLemonMan
404 documentation not found

1587664475
andrewrk
Jenz, the way urls work in the generated docs needs to be reworked. I think there is an issue for it

1587664494
andrewrk
generated docs are still experimental

1587664578
Jenz
Yes it was forewarned.

1587664619
Jenz
Thank you all for the Zig. The 0.6.0 release notes kept me up all night, haha

1587664665
Jenz
Uh, s/for the/for/

1587665174
FireFox317
TheLemonMan, hmm, i can't simply apply your patch against llvm10 right?

1587665233
TheLemonMan
try it and see :P `patch` may be able to apply it anyway

1587665368
FireFox317
yeah i tried, oh actually its only a capitalization change xd

1587665901
yrashk
is this a bug or am I missing something?

1587666208
yrashk
(^^^ @andrewrk )

1587666267
companion_cube
so now we say "the Zig", cool

1587666382
foobles
i have seen too many jokes about Zag

1587666390
foobles
like whenever i tell someone about zig

1587666400
foobles
they always say "oh well have you heard of Zag?"

1587666407
fengb
Sharko

1587666412
foobles
maybe that could be the name of the package manager or something :D

1587666423
fengb
We also get great justice

1587666450
BaroqueLarouche
TAKE OFF EVERY 'ZIG

1587666583
fengb
Wow, Zig is the first real result on Wikipedia now

1587666615
fengb
Just hiding below the crappy non-results

1587667063
foobles
wait really?

1587667072
foobles
i cant find it

1587667388
fengb
Er, sorry on Google

1587667396
fengb
I'm not sure why I said Wikipedia

1587667738
marler8997
I'm working on a generic composable allocator library, potentially for the standard library

1587667761
marler8997
I've created a PR against my own fork if people want to take a look and discuss/leave comments:

1587667807
ifreund
"Zig & Sharko" are still beating us on duck duck go :(

1587667901
fengb
I don't understand what a block is

1587667924
marler8997
it's what an allocator uses to track it's allocations

1587667975
fengb
But every allocator tends to do it differently

1587667981
marler8997
right

1587667987
marler8997
each allocator defines it's own Block type

1587668003
fengb
I guess I don't understand why there's an abstraction

1587668006
marler8997
the only requirement is that it contains a ptr field

1587668022
marler8997
It allows composability and code reuse

1587668073
marler8997
You can compose any number of block allocator, you can wrap them with a logger, wrapper them with an "aligning" allocator, wrap multiple allocators with a fallback

1587668156
fengb
But how is that different from using the current allocator interface?

1587668161
fengb
I don't really get what blocks buy us compared with just slices

1587668181
marler8997
yeah that's a good question to ask

1587668207
marler8997
the first big difference is that this is a compile-time interface rather than a runtime functio pointer interface

1587668241
marler8997
the second is that not all allocators need the same thing

1587668254
marler8997
they all have different memory requirement, they all support different operations, they all have different semantics

1587668308
marler8997
the "block allocator" attempts to capture all the operations an allocator can implement, which allows you to implement efficient abstractions that know exactly how the allocator behaves and how to use it properly

1587668507
marler8997
If you have time, this is a good video by Andrei Alexandrescu that talks about some of the ideas:

1587668539
marler8997
I've taken some of his ideas, but the actualy implementation I've made is pretty different

1587668576
companion_cube
but surely passing allocators at runtime is even more flexible

1587668607
marler8997
runtime allocators is a subset of compile-time allocators

1587668622
marler8997
I can implement any runtime allocator interface with my compile-time allocator interface under-the-hood

1587668642
marler8997
which is exactly what I did in my PR.  I implemented the current allocator interface by composing a few block allocators

1587668683
marler8997
i.e. makeSliceAllocator(makeAligneAllocator(makeMmapAllocator()))

1587668726
companion_cube
I'm not sure I understand why comptime is a superset of runtime

1587668732
companion_cube
what if the choice of allocator is made at runtime?

1587668777
marler8997
instantiating a compile-time allocator is creating a runtime allocator

1587668804
fengb
🤷 I don't really follow what the goal is. I see more operations, but that's more complexity to the implementation

1587668808
ikskuh
marler8997: i don't understand exactly what you're trying to do with the separation of block- and slice allocators

1587668839
marler8997
the "block" level is the low-level view from the allocator's perspective

1587668855
ikskuh
but then i need two layers of mangement

1587668859
ikskuh
one for the blocks

1587668861
ikskuh
and one for the slices

1587668864
ikskuh
→ more memory

1587668886
marler8997
You can use that level to know what the block allocator does, does it track the length? does it support resize in place? Can it deallocate everything at once? etc

1587668903
marler8997
Does it need any extra data per allocation, that's the big one

1587668927
fengb
But... I don't care about most of those, except resize which has a separate proposal / implementation

1587668934
marler8997
This is the information you want to know if you have allocators interacting with each other

1587668949
fengb
I mean, I do but the documentation level seems like a good enough place

1587668954
marler8997
But if you're just an app that wants to use slices, then you don't care about these details

1587668960
ikskuh
marler8997: i still don't see the necessity for two layers of allocation management

1587668977
ikskuh
it's an overhead i don't want to have

1587668987
marler8997
There's no overhead because it's all done at compile time

1587668997
ikskuh
huh?

1587669001
marler8997
That's the beauty of met-programming

1587669008
ikskuh
okay, how i can i comptime-allocate blocks?

1587669013
ikskuh
so

1587669021
ikskuh
all allocBlocks are run at comptime?

1587669034
marler8997
What I mean by comptime is that it's a compile-time defined interface

1587669037
marler8997
it's dynamic at compile-time

1587669070
ikskuh
yes

1587669077
marler8997
sorry did that answer your question?

1587669081
ikskuh
no

1587669092
ikskuh
my problem: for this i need two layers of mangement structures

1587669094
ikskuh
one for blocks

1587669097
ikskuh
one for slices

1587669102
marler8997
actually no

1587669105
ikskuh
why?

1587669111
ikskuh
how does it work then?

1587669117
marler8997
if you're block allocator only needs pointers and lengths, then the SliceAllocator becomes a no-op

1587669135
ikskuh
what do you mean by "needs"?

1587669138
ikskuh
what is a block then?

1587669152
companion_cube
I think it's all in the talk they linked

1587669157
marler8997
"needs" == Block

1587669163
companion_cube
D people do know about comptime :)

1587669166
fengb
Why should I need more than pointer+len?

1587669172
marler8997
The Block type defins what every block allocator needs to track every individual allocation

1587669195
marler8997
For example

1587669204
marler8997
Say you have an allocator that doesn't support alignment

1587669240
marler8997
You can wrap it in an AlignAllocator, which will track both the underlying Block type, and an extra variable to track the length requested by the caller

1587669284
marler8997
Or the SliceAllocator

1587669297
marler8997
which takes a block allocator, but exposes slices

1587669313
ikskuh
are blocks fixed size?

1587669316
marler8997
no

1587669320
marler8997
each allocator defines it's own block

1587669323
marler8997
it can be any size

1587669333
ikskuh
hm

1587669377
marler8997
how this interface came to be was I started with the slice interface, and kept thinking of things that different allocators would need to know about each other

1587669388
marler8997
but this interface was very different from the interface the application cares about

1587669476
ikskuh
i always think in "i don't have enough memory for everything", so i wonder if this all will use any more memory than a trivial alloc/free interface"

1587669489
marler8997
Nope

1587669502
marler8997
The CAllocator is one of the allocators

1587669519
marler8997
It uses less memory than a runtime allocator

1587669530
marler8997
It has no function pointer to track

1587669570
marler8997
It uses less memory than a runtime interface

1587669608
marler8997
You'll want to start using a runtime interface if you have alot of different allocators and want to avoid generic/template bloat

1587669644
marler8997
var callocator = makeSliceAllocator(CAllocator { })

1587669669
marler8997
with optimization that should literally compile to raw calls to malloc/free with no runtime overhead

1587669691
marler8997
and if you want alignment, you would do: var callocator = makeSliceAllocator(makeAlignAllocator(CAllocator { }))

1587669891
ikskuh
hm

1587669899
ikskuh
this still screams for super-generic functions

1587669946
marler8997
keep in mind, this isn't replacing mem.Allocator

1587669969
marler8997
It would allow us to remove most of the code in "heap.zig" with compile time allocator expressions

1587669977
companion_cube
it better be compatible with Allocator tho

1587669982
marler8997
it is

1587669987
companion_cube
otherwise no one will be able to use it

1587669994
marler8997
I already have it working with mem.Allocator

1587670043
marler8997
and applications can choose whether to use a runtime allocator, or use an allocator directly

1587670060
marler8997
I would expect most applications to create an allocator and use it directly, and for functions to continue to use the runtime allocator interface

1587670139
ikskuh
i'm not happy with the current iostream stuff as well

1587670353
TheLemonMan
andrewrk, wrt #5146 are sentinels on any pointer type but [*] forbidden?

1587671915
marler8997
based on your questions/comments, I see how important it is to explain the "why" behind this library.  I've updated the PR with that:

1587671930
marler8997
see "alloc.zig"

1587672907
fengb
Listening to the talk... it's pretty handwavey when it comes to composition. Most allocators that I can think of cannot compose most of these behaviors because there's a lot of subtle edge cases that they need to account for

1587672923
marler8997
yeah definitely

1587672936
marler8997
my interface is much different from him

1587673001
marler8997
I'm working through all the use cases and trying to come up with the best interface, I find that using the "single-responsibility" principle is key, but it's still hard

1587673007
fengb
I'm not sold on standardizing an interface for these details, especially since it's a lot bigger than what we have currently

1587673016
marler8997
We do the best we can, but we also don't need to implement everything

1587673043
fengb
For instance, zee_alloc cannot be broken up at all. I purposely mixed a bunch of operations together and all of them are subtly aware of the internal details

1587673062
marler8997
When I was going through heap.zig, I saw the same functionality implemented over and over again

1587673062
companion_cube
but it's designed to be tiny, right?

1587673081
marler8997
and many implementation had subtle difference and I'm sure I found some bugs

1587673089
fengb
Tiny binary yeah. I had to make concessions somewhere :P

1587673104
marler8997
but rather than having to re-implement the same things over and over, this library allows the same logic to be re-used over and over because everything is composable

1587673129
marler8997
but what's great about this is you can use as much or as little of it as you want

1587673137
companion_cube
comptime composition does sound great

1587673140
marler8997
you pay for what you use

1587673140
fengb
I don't necessarily  believe reusing logic should be a goal in itself

1587673143
companion_cube
(same for channels, actually…)

1587673160
fengb
I'm more concerned in the interface complexity

1587673181
marler8997
I find both to be important

1587673194
marler8997
But your interface can be a simple or as complex as you want

1587673201
marler8997
The fail allocator only implements 1 function

1587673223
marler8997
I should say, your implementation can use as much or as little of the interface

1587673256
companion_cube
fengb: writing an allocator can be at least slightly complicated, right?

1587673264
companion_cube
as long as the user has the same simple interface

1587673442
yrashk
not to pull attention away from composable allocators (I think it might be interesting in some cases!), I wanted to show an early preview of a reference-counted shared pointer I did as a toy project. It's not validated yet (I am am working on that)

1587673444
yrashk


1587673448
fengb
Yeah I just mean the current interface seems decently enough to do everything I want

1587673456
yrashk
(maybe there's something like this already around? I only found something from 2018)

1587673472
fengb
And I don't really see the need of more composability

1587673479
ifreund
what idioms are people currently using to do multiple returns?

1587673499
ifreund
currently as in zig 0.6.0

1587673507
fengb
Return a struct, or use result pointers

1587673516
fengb
Returning tuples will be here soon™

1587673536
marler8997
fengb: I think you need to take a look at heap.zig, and compare it to alloc.zig

1587673579
ifreund
yeah i'm doing result pointers like I would in C, but am wishing for a more ziggy way

1587673598
ifreund
can't wait for tuple returns

1587673603
marler8997
the mmap allocator in heap.zig is 250 lines of complex runaround code, using a composable interface, the MmapAllocator in alloc.zig is probably 10 lines of code with a handful of functions

1587673611
fengb
I see it but that's not compelling to me

1587673632
marler8997
becaue you don't value code reuse?

1587673635
fengb
It's smaller, but there's this other block allocator thing that I don't really understand now

1587673650
marler8997
did you read the updated doc where I explain?

1587673657
fengb
I don't think code reuse is a goal by itself

1587673691
marler8997
the reason for having a custom Block type is so the storage can be decided by the caller

1587673714
marler8997
for example, maybe you want to use a BlockAllocator directly, you could choose to store the Block on the stack if you want

1587673746
fengb
Oh so it's introducing a different interface style as well?

1587673755
marler8997
The more common reason being that you create an allocator that wraps another allocator, and the wrapping allocator can decide where to store the underlying bloc, making it apart of it's own block or putting it somewhere helse

1587673762
marler8997
interface style?

1587673792
fengb
Yeah, heap.Allocator is an "interface". OutStream is an "interface". This block thing is a different type of "interface"

1587673800
marler8997
yes

1587673821
marler8997
passing blocks back and forth is a different interface than passing slices back and forth

1587673882
fengb
Yes I know that. It's just different from doing @fieldParentPtr that I'm used to

1587673897
marler8997
self: @This()

1587673898
fengb
I think there's a few different concepts you're trying to introduce at once :P

1587673904
marler8997
True

1587673920
marler8997
Coming from a decade of D metaprogramming, this is par for the course :)

1587673943
marler8997
But would seem very weird if you haven't done alot of metaprogramming

1587673964
marler8997
Policy-based metaprogramming, now that's something to learn!

1587674034
fengb
I don't mind having something better. I'm not the biggest fan of @fieldParentPtr but I also don't want to have multiple ways of doing the same thing >_>

1587674050
marler8997
well like I said this is not a replacement

1587674072
marler8997
The runtime allocator interface is still useful, especially if your a function that accepts an allocator

1587674077
fengb
So... SliceAllocator is glue that converts BlockAllocator to mem.Allocator?

1587674084
marler8997
Almost :)

1587674096
marler8997
SliceAllocator is glue for a "slice-based" api

1587674120
marler8997
MemSliceAllocator is glue for converting a SliceAllocator to mem.Allocator

1587674150
fengb
I'm also curious how these apis will look with just the resizeFn change

1587674160
marler8997
it's orthogonal

1587674170
marler8997
related, but this can work with or without the resizeFn change

1587674207
marler8997
the only change would be the MemSliceAllocator implementation

1587674214
marler8997
small change

1587674242
marler8997
because all the allocators re-use the same code to implement the runtime interface, I think this speaks to why a composable interface works so well

1587674261
marler8997
today, all the allocators have to change to support that, with alloc.zig, you only have to change one function

1587674325
marler8997
this means the standard library could change the runtime interface, and all BlockAllocators will continue to work, even application defined ones

1587674392
marler8997
although, if you change the blockallocator interface, then you're still in the same boat....so maybe not a fair critique :)

1587675574
dimenus
why would zig stick 'std.target.Arch.isWasm' in the binary for a freestanding aarch64 target?

1587675611
dimenus
however, it is stripped out with release-fast

1587676016
fengb
We should rename that to isNotWasm to stop people from asking 🙃

1587676037
fengb


1587676054
dimenus
sorry :(

1587676074
dimenus
thanks fengb

1587676885
fengb
I'm joking. It comes up fairly regularly :P

1587682798
foobles
andrewrk I posted this on github, but i thought I would ask here too: in the `?T == T` proposal, should it be expanded to `?T == U` if T and U are comparable?

1587682813
foobles
like say you had an optional tagged union, and you wanted to comapre it with an enum literal

1587682828
foobles
that doesnt fall under `?T ==/!= T`

1587683049
Snektron
You could also choose to split it up into seperate pull requests

1587683150
foobles
ah good point

1587683861
foobles
something cool i did notice though: if you allow comparison of `?T and U` where T and U are comparible, then that naturally allows comparison between ?T and ?T

1587683881
foobles
because then, it breaks it down: I have optional T and a ?T

1587683893
foobles
is T comparable with ?T

1587683898
foobles
??  yes it is

1587683912
foobles
it recurses twice, but its a really nice side-effect

