1578615458
adamkowalski
do we have an absolute function which works on both ints and floats?

1578615474
adamkowalski
I'm seeing a std.math.absInt, std.math.absFloat but no std.math.abs?

1578615598
scientes
adamkowalski, write it!

1578615601
scientes
pretty simple

1578615640
scientes
and absInt doesn't really need to exist

1578615676
scientes
and absFloat really should just be private

1578615812
adamkowalski
I just wrote it, I thik it does need to exist, it can actually error out, but the float version can't

1578615817
adamkowalski
absInt might overflow

1578616352
daurnimator
terinjokes: please do send a PR for it :) it should contain: 1. wrappers in os/linux.zig that mainly just provide correct types around the syscall  2. an extern definition in std.c somewhere. 3. a wrapper in std/os.zig that converts the errno-style result to a zig error.

1578616497
terinjokes
daurnimator: i'll try to do that tonight

1578619083
Snektron
daurnimator, are you still on that mixin proposal

1578619110
Snektron
I was thinking, you could strike a balance between that and the current vtable solution

1578619174
Snektron
Basically, instead of the interface calling virtual functions defined by the parent type, it would just call them via @field

1578619230
Snektron
It would look similar to the current implementation, except without the virtual methods

1578619241
Snektron
One drawback though is that it makes renaming harder

1578620325
via
andrewrk: thanks for the detailed writeup. i still have a few questions, but i don't think i'll be able to look much more until the weekend again

1578626044
daurnimator
Snektron: the first mixin PR got rejected. I haven't thought of a good rebuttal

1578627577
pixelherodev
I'm converting from a C single-header array library to Zig (creating an interface for use with C code)

1578627593
pixelherodev
Like many C libraries, it stores integers before the array for size/capacity

1578627624
pixelherodev
It uses `((int *) (ptr) - 2)`, where ptr is of the correct type (e.g. `char*`) to get to those values

1578627643
pixelherodev
e.g. ((int*) (ptr) - 2)[1] to get size

1578627660
pixelherodev
Is this correct Zig wise? `@intToPtr([*]c_int, @ptrToInt(self.ptr) - 2 * @sizeOf(T))[1]`?

1578628948
pixelherodev
Ah, nope; should be using @sizeOf(c_int) not @sizeOf(T)

1578629122
pixelherodev
It works now, yay!

1578629138
pixelherodev
Wrote a working Zig interface to the stb stretchy_buffer

1578629178
pixelherodev
`sb.of(type).from(ptr)` gives a structure with some useful methods; `count()`, `push()`, `free()`, etc... but also `toSlice()` and some more Ziggy ones

1578629330
daurnimator
pixelherodev: zigacious :D

1578629341
pixelherodev
Yeah, pretty neat

1578629365
pixelherodev
Right now, I'm using `for (sb.of(string).from(up).toSlice()) |t| ` to iterate over a sb of strings

1578629385
pixelherodev
(where string is a custom C string type I wrote to make things a bit faster, which I plan on replacing with rapidstring when I have time)

1578629516
daurnimator
I was thinking yesterday how we should have a proper string type in zig: I'd like string literals to be of the type... but have the methods etc in the std lib.

1578629570
daurnimator
Probably the only thing like it (in that the compiler assumes it exists?) is the panic function?

1578629585
daurnimator
It's a sort of weird situation where the language depends on the standard library (but should be overrideable)

1578629645
pixelherodev
I think that if such a thing is implemented, literals shouldn't automatically be that type

1578629652
pixelherodev
They should be able to decay into that type though

1578629658
pixelherodev
Just as they do to e.g. c strings and slices

1578629672
pixelherodev
That would mean that existing code would be unaffected

1578629807
pixelherodev
If a struct member function takes a *This(), and you set that to null, then e.g. `a.free()` would result in a becoming null, correct? (with most details being implicit here)

1578629832
pixelherodev
Rather, with e.g. `fn free(self: ?*@This()) {self.* = null;}`

1578629848
pixelherodev
then `a.?.free()` should set a to null, correct?

1578629850
pmwhite
daurnimator: What's the benefit you have in mind for a proper string type? More safety due to distinguishing between slices and strings?

1578629899
daurnimator
pmwhite: essentially yes: at the moment e.g. std.fmt treats arrays of u8 specially and prints as a string instead of like it does arrays of other things.

1578629915
daurnimator
pmwhite: would also be able to have string methods that don't make sense on arrays.

1578629937
pixelherodev
Ooh, better yet: can convert stretchy buffers directly to Zig array lists

1578629943
daurnimator
pmwhite: and going further: perhaps the string type could e.g. guarantee valid utf8

1578630090
traviss
can anyone spot what's wrong with:

1578630143
daurnimator
traviss: uh.... is there reason to assume the error message is incorrect?

1578630152
daurnimator
traviss: it looks like mpz_init was never defined...

1578630303
traviss
no reason to think its incorrect. i figured i was forgetting to to pass some linker flag.

1578630345
daurnimator
traviss: well does your libgmp.a have a mpz_init function?

1578630356
traviss
i'm verifying that now

1578630378
pmwhite
I assume you would have to include the header that it's defined in too.

1578630400
daurnimator
pmwhite: no hes done that manually in that snippet

1578630432
pmwhite
oh, makes sense.

1578630512
pixelherodev
What's the correct way to pass a function pointer to C?

1578630523
pixelherodev
error: expected type '[*c]extern fn() void', found 'extern fn() void'

1578630534
pixelherodev
Taking the address results in a weird casting error

1578630544
daurnimator
pixelherodev: yeah you just pass in the function; don't take an address

1578630566
pixelherodev
That results in the error I posted

1578630567
daurnimator
pixelherodev: there was a comment on a related issue this morning

1578630590
traviss
ah, the symbol is actually `__gmpz_init`. thanks guys

1578630598
pixelherodev
`const func: [*c]extern fn() void = load_tag;` gives the same error

1578630601
daurnimator
pixelherodev:

1578630642
daurnimator
pixelherodev: WSAOVERLAPPED_COMPLETION_ROUTINE (via WSARecv) is where I ran into it before

1578630675
pixelherodev
Any workaround?

1578630683
pixelherodev
Or do I have to wait until translate-c is fixed?

1578630729
daurnimator
traviss: translate-c/@cImport should handle that for you?

1578630742
daurnimator
pixelherodev: not sure.. I'd have to actually play around myself

1578630792
daurnimator
traviss: sprunge.us/3EOkbC

1578630802
pixelherodev
`widget_t *button_create(const char *label, void(*handler)());` is translated into `pub extern fn button_create(label: [*c]const u8, handler: [*c]extern fn () void) ?*widget_t;`

1578630804
pixelherodev
Is that wrong?

1578630812
pixelherodev
If necessary, I can manually declare it for now or something

1578630836
pixelherodev
What type

1578630849
daurnimator
pixelherodev: I think get rid of the [*c]

1578630855
daurnimator
(before extern)

1578630894
pixelherodev
And of course it's not as easy as editing the cimport.zig...

1578631036
traviss
thanks daurnimator. yes it does except for this get_ui which i need: `pub const __gmpz_get_ui = @compileError("function __gmpz_get_ui parameter has no name");`

1578631076
pixelherodev
Temporary workaround: @intToPtr([*c]extern fn() void, @ptrToInt(load_tag)))

1578631103
traviss
so i'm just messing around trying to learn how to link these in and work around when i can't use translate-c

1578631190
daurnimator
traviss: get_ui actually has an implementation in the header file

1578631234
daurnimator
traviss: seems like there are defines to only optionally have the header-version?

1578631254
daurnimator
traviss: probably worth opening an issue against zig to support them (if there isn't already an issue)

1578632347
pixelherodev
Do the formatting functions zero-terminate?

1578632359
pixelherodev
Because I'm getting behavior that seems to indicate otherwise

1578632379
daurnimator
pixelherodev: no

1578632391
pixelherodev
That's what I figured

1578632392
pixelherodev
Thanks!

1578632398
pixelherodev
If I manually zero terminate it works as expected (`{c}`, 0 in tuple), which is more than good enough

1578632408
daurnimator
yep :)

1578632691
andrewrk
pixelherodev, you can also put \

1578632696
andrewrk
pixelherodev, you can also put \x00 in the format string

1578632849
pixelherodev
Right

1578635055
traviss
daurnimator, this works for using __gmpz_get_ui

1578636196
traviss
here is the issue daurnimator:

1578637649
pixelherodev
What's the "canonical" way to convert a [*c]u8 to []u8?

1578637692
pixelherodev
std.mem.toSlice?

1578638186
traviss
i know this works for [*] if you know the length, ptr[0..len] but not certain about [*c]

1578638234
pixelherodev
Right, but the length

1578638241
pixelherodev
It's coming from C code which could be asking for anything

1578638253
pixelherodev
It's the plugin's "do you support this feature" function

1578638260
pixelherodev
Takes a string and returns a boolean

1578638404
pixelherodev
99% sure toSlice is what I wanted anyways

1578638420
pixelherodev
It has the intended behavior, but I wasn't sure what the idiomatic method was

1578638427
pixelherodev
But it's in zag so it probably counts

1578638978
pixelherodev
I'm passing a function pointer to C, which points to a function which takes a pointer as an argument

1578639001
pixelherodev
If I know that pointer will never be null, is there a way to override translate-c's assumption that the function pointer's parameter needs to be optional?

1578639115
pixelherodev
Alternately, why do function pointers passed to C need to be exported?

1578639208
pixelherodev
Ah, they don't; translate-c

1578639251
pixelherodev
`@ptrToInt(struct {fn func() void {} }.func)` works, interestingly

1578639340
pixelherodev
But only for functions that take no parameters? That's... odd

1578640770
daurnimator
pixelherodev: toSlice is when the length is "whatever strlen returns"

1578641495
pixelherodev
Right

1578641503
pixelherodev
aka a C stringf

1578641506
pixelherodev
s/f//

1578655031
mq32
pixelherodev, can you export function pointers in structs to C?

1578655040
mq32
it didn't work for me yesterday :(

1578656183
scientes
what is the status on anonymous functions?

1578656193
scientes
I run into situations where i could really use them

1578657096
scientes
ahh figured it out

1578657113
scientes
by using a (manual) closure

1578663127
mq32
hey, can someone tell me how to use zig translate-c richt now?

1578663152
mq32
i'm using "zig translate-c sdk/adll.h", which does not output any errors, but otherwise doesn't do anything

1578663169
frmdstryr
Add --verbose-cc

1578663302
mq32
hm, it outputs me a clang call

1578663319
frmdstryr
Now run that

1578663329
mq32
oh :D

1578663336
mq32
fatal error: too many errors emitted, stopping now [-ferror-limit=]

1578663347
mq32
thanks, will try to get it to work

1578663485
daurnimator
Hrm. no zig support in highlight.js :(

1578663507
daurnimator


1578663525
mq32
thanks frmdstryr!

1578666180
mq32
hmm

1578666191
mq32
is there any good pattern for "custom" integer types?

1578666207
mq32
i have a library that uses a 22/10 fixed point type

1578666288
daurnimator
mq32: not really.., not as if you can overload operators

1578666318
mq32
yeah i know, that's a bit of my problem right now :(

1578666341
mq32
i don't want to use C++ for this, but it's not a pleasant experience with zig to work with this without any language support

1578668192
mikdusan
maybe an explicit sigil to indicate overloading: `var r = foo #+ bar;`. I admit it looks odd

1578668232
fengb
foo.@“+”(bar)

1578668248
mikdusan
for that matter, would `var r = foo .+ bar;` work? the space could be optional

1578668766
mq32
mikdusan, i don't think "operator overloading" as in general is required to solve my problem

1578668785
mq32
i would prefer to have an option to define one's own arithmetic types

1578668809
mq32
because that's the only valid use case for operator overloading anyways in my opinion

1578668903
fengb
What, you don't like << for output?

1578668931
mq32
please, i want + and - for booleans!

1578668933
mq32
bool b;

1578668936
mq32
+b; // set to true

1578668939
mq32
-b; // set to false

1578668954
mq32
and yes, there are libraries that do something like this :D

1578668965
mikdusan
ah so you're aiming for clarity

1578669215
mq32
mikdusan, request for comment:

1578669678
mikdusan
mq32: is the idea `arithmetic` is special to the compiler and add/mul/etc have documented mappings to arith operators?

1578669749
mq32
yeah that's the idea

1578669758
mq32
and you can later use fixed_22_10 like i32 or similar types

1578669768
mq32
altough we still have the problem of hidden function calls then

1578669842
Astronothing
is this a proof of concept for operator overloading?

1578669966
leeward
daurnimator: That patch you made for the logging_allocator bug, and I either never knew or forgot that Zig had multiline strings.

1578670019
mikdusan
mq32: I like that operator overloading isn't required and operators keep doing what is expected of them

1578670187
scientes
ahhhhh

1578670209
scientes
if you want operator overloading, just use methods instead of operators

1578670214
scientes
simple

1578670224
scientes
and avoids all the problems of operator overloading

1578670225
mikdusan
()()()()

1578670284
scientes
if that is a problem, then the solution is to write allow to generate zig syntax trees at comptime, and then you can write a comptime interpreter

1578670293
scientes
to create DSLs

1578670379
fengb
Let’s all switch to s-exprs

1578670384
fengb
No more bickering!

1578670389
scientes
hungarian notation

1578670547
mq32
scientes, that doesn't solve my problem

1578670641
scientes
yeah but what the hell is 22/10?

1578670659
scientes
i get its fixed point

1578670663
scientes
but where is the point?

1578670691
scientes
i see the 1024, so 2 ^ 10

1578670751
mq32
22/10 is 22 bit integer, 10 bit decimals

1578670762
mq32
so 32 bit type with 10 bit "precision"

1578670782
scientes
you mean 10 bits after the decimal point

1578670822
mq32
yeah

1578670828
scientes
so your function is actually wrong, you have to divide by (1024 * 1024)

1578670883
scientes
ohhhhh, I see

1578670885
scientes
confusing

1578670887
mq32
no, i don't

1578670901
mq32
if i multiply two values, they have 20 bit precision, so i have to right-shift by 10

1578670905
scientes
yeah I get it

1578670913
scientes
but that would give the number

1578670915
mikdusan
mq32: fwiw I have limited arithmetic needs, but I think your idea has promise. Lots of people have come-and-gone because it's a deal breaker for them to not have some kind of operator support for atypes

1578670932
mikdusan
s/atypes/userland atypes/

1578670957
scientes
fixed point is simple enough that it could just be supported with a new type attribute

1578671013
mq32
yeah, but there are more complex types

1578671016
scientes
however there is both binary and decimal fixed point

1578671026
mq32
like a floating point rational type

1578671050
scientes
mq32, that isn't floating point

1578671054
scientes
that is just a rational type

1578671077
scientes
floating point

1578671090
scientes
*exponent of two

1578671101
mq32
scientes, yeah, right

1578671111
mq32
i'm talking about the type iq described here:

1578671129
mq32
it's a floating rational (which means nominator, denominator are variable width)

1578671177
mq32
scientes, my idea with the "arithmetic types" is to support somethin like the library i use

1578671184
companion_cube
overloadiiiiing

1578671196
mq32
it has 1800 API points where it expects the fixed-point-type

1578671211
mq32
ignoring all struct parameters that use that type too

1578671212
scientes
but seriously, overloading is a bad idea

1578671217
scientes
I presented two alternatives

1578671223
scientes
1) just use methods

1578671225
mq32
"not using zig but c++ for more readable code"

1578671226
scientes
2) create a DSL

1578671241
scientes
or 3) extend zig

1578671280
fengb
const c = magicMath("{} + {}", .{a, b})

1578671306
fengb
I think we could expose the format parser better and have that be reusable somehow

1578671364
scientes
doing a DSL in zig with an comptime interpreter->AST would be a great use case to explore

1578671393
scientes
but comptime really needs a beef up for fancy stuff

1578671398
mq32
but it would not solve my problem, sadly :(

1578671419
mq32
or it would bloat my code by probably size 3 to 4

1578671506
scientes
hell, if we did it right you could write a plugin in zig, just by wrapping

1578671518
scientes
but I don't really want to think about that

1578671569
scientes
mq32, seriously, you are going to spend most of the time thinking about the algorithms and data structures

1578671582
scientes
as always, if you focus on the data structures, everything else will solve itsself

1578671585
mq32
no, as i'm writing a game

1578671587
mq32
so something like

1578671591
mq32
mx.x += 1;

1578671593
mq32
will be

1578671595
scientes
get it written, and then try to make it look better

1578671603
mq32
my.x = fp22_10_add(my.x, to_fp22_10(1));

1578671614
mq32
and pretty much ALL code looks like this

1578671618
scientes
well, as i said, fixed point might belong in the language

1578671640
scientes
it is not an unreasonable thing

1578671649
mq32
yeah

1578671668
mq32
but right now i'm goign to drop that  project for beeing completly undoable in zig

1578671672
fengb
But which fixed point? There's not 1 golden standard

1578671674
mq32
at least when it comes to coding

1578671688
scientes
fengb, at least all binary and decimal fixed point

1578671725
fengb
... so I think you could write a parser that can bind comptime strings to functions and have it work

1578671730
scientes
it is all so similar you can just support it all

1578671786
fengb
My `magicFunc("{} + {} * {}")` might be possible to write generically. I don't think the guts would be pretty but it'd offer something for mq32

1578671790
scientes
and support multiplication and division between them (although i'm not sure what the return type should be)

1578671826
mq32
fengb, i don't think that would help much

1578671848
fengb
`my.x = magicFunc("{} + 1", .{my.x});`

1578671855
mq32
as i would still have to write at least twice the code than just do the fp-math everywhere manually

1578671991
scientes
mq32, that is what we have been saying

1578672020
scientes
you

1578672076
mq32
that's the point

1578672088
mq32
i don't want generic operator overloading, but more/custom arithmetic types

1578672098
mq32
because zig will never be able to handle all use cases of them

1578672137
mikdusan
I guess it still is operator overloading, but restricted to arithmetic operators

1578672138
mq32
scientes: with manually i mean "my.x += 1024 * 1;"

1578673342
Astronothing
@mq32 so you can't finish the game because you cant use fixed floating point with 10 bits of precision?

1578673365
mq32
Astronothing: i would like to code a game with zig and that engine

1578673391
Astronothing
what engine? what's wrong with floating point?

1578673395
mq32
but not having an arithmetic type, i have to do

1578673400
mq32
Astronothing, it's gamestudio a8

1578673409
mq32
it does not have floating point, but fixed point arithmetic

1578673429
mq32
i cannot change that, so i'm bound to that type

1578673486
Astronothing
ouch.

1578673486
mq32
i would LOVE to see that engine with f32 instead of fp22_10

1578673556
mq32
the C api actually exports that type as "long"

1578673562
mq32
and you have to do everything manually

1578673579
mq32
for C++ there is a wrapper class for the "var" type (that's how it's called in the engine)

1578673607
via
you could just wrap any literals in a function that multiples by 2^10, and then use normal arithmetic operations

1578673642
mq32
via: not for multiplication/division

1578673666
via
another function that multiplies/divides by 2^20 instead :p

1578673720
mq32
:P

1578673725
via
i guess you'd have to deal with overflow

1578673734
mq32
yeah but that bloats the code and pretty much hides all actual game logic

1578673734
via
native fixed point would be cool

1578673738
mq32
and makes the code unreadable

1578673853
fengb
Just port the game engine to Zig :troll:

1578673860
fengb
This isn't Slack

1578673885
mq32
fengb, i would love to, but it's closed source

1578673886
rageoholic
Hello! Been a while since I used IRC so sorry for any ettiquete breaches! I've been learning zig and having a lot of fun

1578673899
tgschultz
some kind of native support for fixed point might be generally useful for embedded dev too

1578674043
fengb


1578674052
mq32
yeah that would solve my problem as well :D

1578674099
mikdusan
welcome rageoholic

1578674150
tgschultz
I'm still hopeful that zig can someday be used on retro hardware as well, where fixed could come in handy.

1578674223
fengb
Tangential, how should Zig work on Intel 8080 / Z80 when it comes to usize? u8 to match registers, or u16 to match memory

1578674249
tgschultz
usize is the size of a pointer, so 16.

1578674280
mq32
that's a question i want to make as a issue some time

1578674284
tgschultz
though segments would make that kinda....

1578674304
mq32
how to handle something like 8086 with 2 different kind of "usize" types

1578674337
mq32
where you have sizeof(uintptr)=3 and sizeof(size_t)=2

1578674388
mikdusan
is it 20 bits for addr?

1578674407
mq32
yeah :D

1578674442
mq32
that's why there is a differnece in C between uintptr_t (a type that can store a pointer uniquely/comparable) and size_t (the maximum size of an object in basic units)

1578674520
mikdusan
but explain why the naming is inconsistent: should be usize_t :)

1578674531
mq32
yeah :D

1578674537
mq32
also on AVR we get even more crazyness

1578674549
mikdusan
(ssize_t is just bad)

1578674559
mq32
8 bit register size, 16 bit data bus size, 24 bit code bus size

1578674577
BaroqueLarouche
tgschultz: yes me too, I'd love to use Zig for Sega Genesis and Neo Geo projects

1578674587
tgschultz
well, the model will just never quite fit archs that aren't similar to the currently predominant model I guess.

1578674628
fengb
There's also some old 36-bit architectures :P

1578674636
tgschultz
same as zig will probably not ever work on esoteric arcs with non-po2 alignments

1578674643
mq32
there are a lo of crazy architectures

1578674649
mq32
19 bit? go for it!

1578674692
tgschultz
For a project I'll probably now never get around to, I designed a 12-trit balanced ternary architecture.

1578674730
fengb
... I didn't know PDP-7 was 18 bits

1578674734
mikdusan
(I can't resist) why use "tr" for the prefix instead of "t"

1578674752
tgschultz
for the obvious reasons

1578674780
fengb
Because it'd be ambiguous with thirteen?

1578674829
mikdusan
pretty sure zig will support PDP-7 when LLVM does

1578674921
fengb
Hey if we want to replace C, we need to retroactively remove it from history too

1578674934
rageoholic
Could always write an x86_64 to PDP-7 transpiler

1578674948
rageoholic
Actually wait didn't they do that for like the commodore 64?

1578674961
mq32
rageoholic, yeah but that doesn't work really well

1578674970
rageoholic
It's a fair cop

1578674975
mq32
pretty much only for the showcase he did with it

1578674988
mq32
you cannot really model a one-register-arch with a many-register-arch

1578675006
rageoholic
Yeah that whole talk felt artificial as all hell

1578675087
fengb
Wow only 1 register? So math was directly from memory?

1578675098
mikdusan
accumulator

1578675111
mq32
fengb, yeah 6502 is an accumulator mcahine

1578675117
mq32
so you operate with memory all the time

1578675137
mq32
so "add addrX to ACC"

1578675183
tgschultz
6502 assembly is pretty nice

1578675203
BaroqueLarouche
yes but not very suited for C style languages

1578675207
tgschultz
there's a reason the arch is still widely used

1578675224
tgschultz
that's true

1578675240
fengb
Back when memory wasn't balls slow :P

1578675251
BaroqueLarouche
the 65816 has stack-relative adressing for some opcodes

1578675263
tgschultz
it's not that memory is so slow, it's just that processors are so ludicrously fast

1578675309
scientes


1578675349
tgschultz
if you designed a more modern 6502, it would operate from an on-die cache primarily and you'd use a different opcode to populate the cache from bus memory.

1578675354
tgschultz
I love Spaceballs

1578675365
scientes
"light speed is too slow"

1578675383
rageoholic
This but unironically

1578675464
mikdusan
rip John Candy

1578675528
tgschultz
I find it interesting and somewhat hope-inspiring that more people seem to be questioning long-held ways of doing things in computing. Jon Blow recently asked the same question I did a while ago about if we should really still be doing primarily pre-emptive multitasking in the age of multicore.

1578675566
scientes
tgschultz, what do your guys means by that?

1578675581
scientes
seL4 just implemented mixed-cricality real-time/non-real-time scheduling

1578675589
scientes
but still pre-emptive of course

1578675632
scientes
it is not like everyone has a 128-thread AMD chip

1578675666
tgschultz
well, it used to be that cooperative multitasking had the problem of one program freezing and stopping the universe. With multicore, you can ensure that at worst it only freezes other programs on the same core and the OS can terminate it, or move programs to other cores to accomodate.

1578675685
companion_cube
but why would cooperative multitasking be better?

1578675698
tgschultz
it's much simpler

1578675705
companion_cube
if you're not implementing a server that has to handle millions of connections

1578675707
companion_cube
is it, though?

1578675710
tgschultz
yes

1578675711
rageoholic
cooperative multitasking is more efficient but less reliable

1578675726
tgschultz
right, but we can mitigate the reliability problem now

1578675727
companion_cube
I find it a lot more complicated, it even requires language support to be ergonomic…

1578675732
rageoholic
In that if you don't yield you're starving out other tasks

1578675758
scientes
tgschultz, people are already doing that. CPU pinning is very common in big data to overcome limitations in the scheduler

1578675776
scientes
including reserving those CPUs so that the kernel doesn't schedule there

1578675781
rageoholic
I would say losing a core for... let's put the timeout at 15 seconds.... is a huge deal

1578675782
tgschultz
yeah, but I'm wondering if that shouldn't be more the norm

1578675821
scientes
tgschultz, it has a DoS problem, if you don't stack with pre-emptive

1578675832
scientes
just like locking memory

1578675848
rageoholic
Within a process I would agree cooperative would be better

1578675852
scientes
its breaks the abstraction of pretending that a machine has infinite resources

1578675857
tgschultz
I can make computers unusable by abusing resources today too

1578675860
mikdusan
adaptive scheduler. if it learns there is a thread that doesn't yield, put it in the doghouse

1578675860
scientes
which is a very useful abstraction

1578675878
rageoholic
But between processes I still want a preemptive scheduler

1578675888
tgschultz
I question if it is a useful abstraction

1578675906
tgschultz
certainly zig doesn't seem to think that pretending there is infinite heap is a good idea

1578675931
scientes
I am kinda of the mind that it should just implement an infinite heap

1578675936
scientes
which is quite possible on 64-bit systems

1578675939
scientes
with swap

1578675955
scientes
*infinite stack

1578675960
tgschultz
I'm certainly not saying it is for sure a good idea, but I'm happy to see people questioning it. I think it is healthy to revisit old ideas and question your assumptions.

1578675990
scientes
tgschultz, well in places like seL4 all this stuff has to be not only thought about, but proven

1578676008
companion_cube
if you go full cooperative, at least do it in a clean way, like erlang

1578676023
companion_cube
(where it looks like it's preemptive!)

1578676032
scientes
companion_cube, yeah but if you are on top of an OS you still have the problems of preemptive

1578676043
scientes
at least if you want to target Linux (and who doesn't)

1578676045
companion_cube
such is life

1578676065
fengb
Let’s write our own OS. With blackjack and hookers

1578676077
companion_cube
at some point you'll be preempted, that's inevitable, be it by interrupts or by an angry user

1578676083
companion_cube
fengb: in fact, forget about the blackjack

1578676124
tgschultz
Been thinking about it. But today writing an OS is a fools errand unless you're targeting a very limited set of hardware (and even then, good luck trying to keep up with GPU).

1578676159
mikdusan
serial I/O. 115,200 baud.

1578676164
rageoholic
I s2g hardware vendors have been trying to ensure it's impossible to write an os

1578676166
tgschultz
So instead I've been thinking of trying to build a new userspace on Linux instead. Not ideal, but at least get drivers for free.

1578676216
fengb
Yeah, drivers can still barely work in Linux. Good luck getting a 4th party :P

1578676245
tgschultz
well, I'm still hopeful that if you build something people want to use, they'll want to develop for it too.

1578676291
tgschultz
and I think that wouldn't be too hard (for certain scales of hard), because the big three modern OSs are garbage fires in my opinion.

1578676330
fengb
What about one of the BSDs?

1578676389
tgschultz
I don't like certain aspects of BSD philosophy, similar to how I don't like some aspects of UNIX philosophy in general. Particularly, BSD has no stable ABI at all. At least Linux has that.

1578676400
scientes
tgschultz, if you tried to do it you would also end up with garbage

1578676403
scientes
its called making it work

1578676426
scientes
the "lets remake it to make it simpler and easier to understand" line has problems

1578676445
fengb
Ah that's the secret. To keep my OS great, I can't make it work 🙃

1578676456
tgschultz
possibly, but maybe it could be a lot less garbage, at least for the personal desktop computer usecase.

1578676465
mikdusan
I like how the millcpu team revisted things a bit and came up with a single-address-space model for their design

1578676479
scientes
mikdusan, the belt is super cool

1578676486
mikdusan
indeed

1578676500
scientes
except that writing a register allocator for it is kinda difficult....

1578676529
scientes
and it hasn't gone far in the last 8 years

1578676533
scientes
still vapor wear

1578676541
rageoholic
Single address space? Like no registers or no virtual memory

1578676555
rageoholic
Because virtual memory is a really good thing to  have in a modern OS

1578676605
mikdusan
it can still swap but all "processes" share a 60-bit address space.

1578676644
scientes
what? that isn't true, mill cpus also have MMUs

1578676882
rageoholic
Having an MMU doesn't preclude having a flat address space

1578676896
pixelherodev
That's definitely true

1578676917
scientes
i still don't see what you are talking about

1578676920
rageoholic
But having a shared address space sounds..... eugh. I like my apps not being able to step on each other

1578676922
scientes
isn't x86_64 flat these days?

1578676926
tgschultz
Is there an argument against flat memory space other than ASLR?

1578676928
scientes
segmented was just a stupid idea

1578676929
rageoholic
I meant shared, not flat

1578676947
mikdusan
rageoholic: they have an extensive protection model to adress threads/processes stepping on eachother

1578676954
rageoholic
Fair enough

1578676957
scientes
but MMU is the opposite of a shared address space.....????

1578676960
mikdusan
it's quite neat. I'd love to see it materialize into real hardware

1578676976
rageoholic
MMU just means that physical memory doesn't map to memory as seen by processors

1578676992
rageoholic
/s/processors/processes

1578676999
scientes
whatever, I'm pretty sure mikdusan is just talking about the very low end version without MMU

1578677027
mikdusan
afaik their entire line/architecture is based on SAS model

1578677364
scientes
mikdusan, there are also scratch registers

1578677382
scientes
but SAS is the fastest part

1578677636
mikdusan
the scratchpad is a neat idea. I guess there are instructions and code indicates importance to cache a value which means no guessing by hardware

1578677707
scientes
SAS is way better because it can be reasoned about in a pipeline

1578677714
scientes
while registers really do not work well with pipelines

1578677720
scientes
as they requires gazillions of rename registers

1578677727
scientes
and complicated dependency analysis

1578677742
scientes
because of SAS, the mill does not need to be OOO

1578677746
mikdusan
that's a repeated message from mill: "rename registers" are bloat

1578677760
scientes
yeah, it doesn't have to be OOO to get similar performance

1578677800
scientes
which means way less transistors

1578678207
pixelherodev
Link?

1578678210
pixelherodev
I'm really interested suddenly

1578678237
scientes


1578678378
mikdusan
from a '2013 talk by Goddard (mill computing) he mentions Haswell architecture they blow 50% of the power/circuit budget for (I think) rename-registers

1578679720
pixelherodev
That's... that sounds implausible

1578679722
pixelherodev
But then again

1578679724
pixelherodev
This is Intel.

1578679774
mikdusan
to be fair I think this was not including the cache circuitry. basically everything between what he called "sources" and "sinks"

1578680041
andrewrk
fengb, usize is defined to match pointer size

1578680076
pixelherodev
Thinking about it, a static analyzer (like cppcheck) that identifies ways to optimize code for a specific architecture would be really really neat

1578680141
rageoholic
THe thing is if you can statically recognize how to optimize the code why not just go ahead and put that pattern into the optimizer

1578680145
pixelherodev
Obviously, compilers already do a looot on that end (at least with `-march=native`esque options

1578680162
pixelherodev
But I'm more interested in a program that goes into

1578680189
rageoholic
Fair enough, I do wish optimizers were more... transparent with what they did and why

1578680194
tgschultz
well, it might not be a wise idea for the compiler to optimize things in such a way that it nolonger works how you think it does.

1578680216
rageoholic
True, although please tell the C++ compiler writers that

1578680227
pixelherodev
Nah, I disagree

1578680243
pixelherodev
As long as the

1578680248
pixelherodev
see e.g. -O3 on gcc

1578680262
pixelherodev


1578680280
pixelherodev
If your code *isn't*, -O3 will make different assumptions about your code than you do

1578680294
pixelherodev
Hence I only ever use it with `-pedantic -Wall -Wextra -Werror`

1578680330
pixelherodev
When using those with -O3, I've yet to have a single issue where the compiler messed up

1578680331
pixelherodev
Not one

1578680353
pixelherodev
Anyways, I wasn't really talking for optimization purposes

1578680374
pixelherodev
I'm interested in a tool that goes into architectural details and explains

1578680562
scientes
-O3 isn't that bad on llvm either

1578680567
scientes
gcc's -O3 is insane

1578680587
scientes
the vectorizer will mash your code into a nasty mess that isn't any faster

1578680660
scientes
pixelherodev, the compiler has such notes if you bother to read the code

1578680743
aperezdc
fun trivia: when targeting some small (for 2020) 32-bit ARM systems the code generated with -Os can sometimes be faster at runtime than -O2/-O3

1578680766
pixelherodev
aperezdc, Not surprised

1578680773
aperezdc
because less loop unrolling and more compact code reduces instruction cache pressure

1578680775
companion_cube
knowing if your code is valid is hard, though

1578680786
scientes
companion_cube, zig helps alot

1578680789
pixelherodev
scientes, right, but that's not convenient to look through if your goal is learning about the architecture and not the compiler

1578680794
aperezdc
and the branch prediction still does a decent job at keeping the i-cache well filled

1578680801
companion_cube
oh for sure, I was thinking about C and C++

1578680802
pixelherodev
companion_cube, like I said, `-Wall -Wextra -Werror -pedantic`

1578680826
pixelherodev
I've enabled those on code I'd thought was valid and fixed dozens of latent bugs in a matter of hours

1578680827
aperezdc
yeah, good code will be fine with any -Ox

1578680828
companion_cube
pixelherodev: does it tell you about all the places it assumes a pointer is null? :p

1578680840
pixelherodev
?

1578680845
companion_cube
I'd rather have a language that isn't full of footguns

1578680856
aperezdc
the hard part is knowing well all the pitfalls of C (and undefined behaviors)

1578680861
pixelherodev
Sure, but *when working with C*, those are pretty good

1578680873
companion_cube
sure, that's still a very terrible experience :)

1578680880
pixelherodev
You know what would be neat? One of those learning site thingies that specifically tests you on language-specific footguns

1578680885
pixelherodev
Also, I disagree

1578680888
pixelherodev
It's not as nice as Zig

1578680892
pixelherodev
But it's better than most languages I've used

1578680925
companion_cube
in my taste, C is the worst (of the at least vaguely typed langs)

1578680938
pixelherodev
That's because it all comes down to personal preferences

1578680951
pixelherodev
The parts you hate and the parts I like can very possibly be the same, and that's completely okay :)

1578681043
shakesoda
zig happens to offer many of the things i like about c and fixes many of the things i hate, how nice :)

1578681076
pixelherodev
Precisely!

1578681098
shakesoda
tentatively, i intend to move many of my projects to zig in the future

1578681104
shakesoda
i've only used it for toy projects so far

1578681111
andrewrk
makes sense given the instability

1578681144
shakesoda
yeah, language instability and translate c is a bit rough in cases i need still

1578681843
andrewrk
the recent self-hosting of translate-c was a major win though

1578681856
andrewrk
it's exciting that contributions to translate-c are now benefiting both stage1 and self-hosted

1578682365
watzon[m]
Can I just say how happy it makes me that the zig documentation is dark?

1578682591
andrewrk
watzon[m], it's not always dark, it's respecting your preferences :)

1578682617
andrewrk


1578682623
watzon[m]
Oh nice 😂 well thank you Firefox then

1578682654
watzon[m]
I've been away from front end dev too long I guess. I didn't know that media query existed.

1578682657
andrewrk
yes thank you firefox for implementing prefers-color-scheme correctly, and thank me for bothering to make both light and dark themes

1578682682
Astronothing
andrewrk I don't know how many sites implement it, but thank you for it!

1578682692
andrewrk
I'm happy with this css thing, it's finally something that makes sense and is good for users

1578682700
mikdusan
github are you listening? :)

1578682725
andrewrk
allowing users to express their preferences in one canonical location, and then allowing software to respect it. this is how it should be

1578682786
watzon[m]
Yes thank you very much andrewrk for the color scheme and everything else. Didn't realize you'd be active in here.

1578682802
watzon[m]
And I wholeheartedly agree

1578683352
terinjokes
one day I'll figure out how to enable it in Chrome on Linux

1578683382
companion_cube
I didn't find it in firefox :(

1578683392
terinjokes
fortunately, there's a toggle in the developer tools to temporarily enabling it for testing

1578683468
terinjokes
i added support for dark mode my zig project site earlier in the week

1578684017
watzon[m]
I'm watching the stream from last week with the TranslateC tests. Cool feature to have in Zig.

1578684039
watzon[m]
I'm sad I missed yesterday's stream. Decided to get started with Zig too late.

1578684187
andrewrk
watzon[m], actually didn't do a stream yesterday, might do one today if I can get to a nice checkpoint with this branch I'm working on

1578684239
terinjokes
adding a function to os.zig, is there a recommended practice for what to do if the numbers of parameters differ across OSes?

1578684256
watzon[m]
Oh nice, so I didn't miss it! Well if you do one today I'll definitely tune in.

1578684267
andrewrk
terinjokes, what function is this?

1578684329
terinjokes
sendfile, i have a PR open for adding it on Linux (takes 4 parameters), but if I were to extend it for FreeBSD it takes 7

1578684427
Astronothing
andrewrk where are the streams announced? where do I join?

1578684520
terinjokes
(and 6 on macOS)

1578684525
andrewrk
Astronothing, if you subscribe to

1578684585
Astronothing
thank you!

1578684657
andrewrk
terinjokes, glancing at the freebsd man page, it looks possible to define an os.zig function API that is compatible with all the OS's

1578684700
andrewrk
e.g. you could code a shim for the hdtr arg on non-bsd systems, and document on which systems the headers/trailers are written atomically

1578684723
terinjokes
so accept the wider numbers of options drop the unused options based on builtin.os?

1578684749
andrewrk
not necessarily drop the unused options; e.g. I'm suggesting to make the headers/trailers work on all systems

1578684791
andrewrk
the flags argument is unused on freebsd and macos, looks like you can simply omit that parameter

1578684882
terinjokes
that makes sense, I can probably call out to writev on linux

1578684944
andrewrk
yes and then document on what systems the headers/trailers are atomic with the body

1578684976
terinjokes
the freebsd man page suggests flags is used, but I'm not currently looking at the source

1578684985
andrewrk
oh where do you see that?

1578685006
andrewrk
on

1578685035
terinjokes
i'm looking at

1578685046
andrewrk
ah that is a better authority

1578685074
terinjokes
which has four flags defined. the macOS man page does have the "must be 0" language though

1578685096
andrewrk
ok, yeah so take a flags parameter then, and rely on the caller to supply the correct value

1578685135
terinjokes
I can leave my PR for linux open in the meantime, I probably won't have a chance to extend it until this evening

1578685135
andrewrk
if someone accidentally uses a freebsd flag on macos, they will get error: struct 'std.os' has no member 'SF_NODISKIO'

1578685238
andrewrk
that SF_SYNC flag looks rather important

1578685248
andrewrk
I wonder if that is the default behavior of other operating systems

1578685831
terinjokes
interesting, I'll have to look and find out

1578686766
watzon[m]
So structs can have default values for properties, but functions cannot currently, correct?

1578688072
mikdusan
watzon[m]: yes, fn params cannot have defaults

1578688102
hryx
watzon: there was a (rejected) proposal

1578688449
watzon[m]
Hmm interesting. I understand the reason for not having default arguments, but it would be nice to have something similar. I know that structs can be used and provided as values to somewhat imitate that functionality, but in my opinion that doesn't make for very friendly APIs, nor does having multiple functions with different names that take differing numbers of arguments but all do the same thing

1578688488
watzon[m]
Having a well defined overload syntax could solve the same problem but maybe in a more friendly manner

1578688872
mikdusan
andrewrk: do you happen to remember which Visual Studio compiler version was used to produce:

1578689723
adamkowalski
watzon[m]: If you want default parameters you can simulate them quite easily

1578689742
adamkowalski
Just pass a struct to the function instead, give the struct field a default value

1578689762
fengb
Re overloading:

1578689808
adamkowalski
instead of overloading, you can accept a parameter by var and use reflection to determine features about it and then do something different for the different scenarios

1578689813
fengb
With anon functions, you can get almost keywords + almost defaults: `foo(.{ .arg = 1})`

1578689907
adamkowalski
I came from C++ so I loved overloading/template specialization, default parameter values, variadics. But Zig taught me that you don't need them, and you can write code which is easier to understand because of it

1578689933
adamkowalski
If you have a function name and you know what module it came from, you can go to the definition and you KNOW that will be the entry point

1578689953
adamkowalski
you don't have to reason about the rest of the file, everything must be scoped inside that function, that's where all the work happens

1578690305
andrewrk
mikdusan, I believe the wiki is in sync with that

1578690322
andrewrk
mikdusan,

1578690481
mikdusan
I was just looking into the `/Ob2` inlining bug and found it still exists with

1578690519
mikdusan
I'll just build my own llvm+clang and see what happens...

1578690609
mikdusan
(TIL editing an issue comment re-opens the issue)

1578691388
andrewrk
mikdusan, I think it was open already, since it's still an issue

1578691456
mikdusan
ah sorry 'bout that. re-opened

1578691834
andrewrk
no worries

1578691840
andrewrk
thanks for looking into it

1578692601
hryx
silly idea: rename `[*c]T` to `[*ambiguous]T` or `[*autotranslated]T`

1578692643
hryx
that is all. Doesn't affect me, just reading over the thread in #2984

1578692683
andrewrk
that's not a bad idea

1578692717
hryx
I can make a comment on the issue

1578693083
fengb
`*or[*]or?*or?[*]` 🙃

1578693138
hryx
`[whatevenisthis]T`

1578695385
marijnfs
whats going on with 'warn', can't I use it anymore for a single string? warn("something\n") doesn't compile

1578695425
frmdstryr
it requires args

1578695434
frmdstryr
warn("somthin\n", .{})

1578695759
marijnfs
ah ok, what does .{} stand for?

1578695776
frmdstryr
An empty tuple

1578696083
marijnfs
why was it changed to a tuple? So you can directly output a whole struct or whatever?

1578696146
marijnfs
btw how do I print say an integer now?

1578696207
mikdusan
marijnfs: `warn("hello {} I am {} years old\n", .{"world", 9});`

1578696282
marijnfs
hmm, that's quite a change

1578696398
hryx
marijnfs: it was removed because varargs were removed entirely from the language:

1578696402
companion_cube
ah yeah, varargs were removed

1578696469
marijnfs
ah interesting

1578696525
mikdusan
marijnfs:

1578696590
marijnfs
ahyeah, might wanna make it more prominent? Wouldn't have figured out without IRC

1578696608
marijnfs
also i used to be able to cast like f64(10)

1578696612
marijnfs
can't do it anymore?

1578696689
mikdusan


1578696690
fengb
@as(f64, 10)

1578696693
hryx
marijnfs: That was also changed recently:

1578696722
adamkowalski
marijnfs: I recommend going over the docs. The very first example demonstrates the new warn syntax

1578696745
fengb


1578696776
adamkowalski
It's a fast moving language so I browse their regularly. The doc examples get tested with each push

1578696801
adamkowalski
If there is another place to post news like that i'm curious where'd you'd want to see them?

1578696813
marijnfs


1578696819
marijnfs
thats even after the struct change

1578696820
fengb
The more comprehensive changelog gets written for the next version's release notes

1578696830
mikdusan
we don't really have a running changelog which is what I think marijnfs is wanting

1578696851
marijnfs
I would also make a big post somewhere on zig website maybe? latest big changes

1578696852
adamkowalski
that's not a bad idea, would that be on the homepage or just on github

1578696856
fengb
Yeah I think that'd be helpful but it is a lot of extra work

1578696861
marijnfs
yeah

1578696882
marijnfs
but some example place that is prominent, and checked that it compiles

1578696899
adamkowalski
fengb: well we can maybe have something like the arch homepage. mostly quiet, but when there is a breaking change that requires intervention we can post there?

1578696917
fengb
Hmm, maybe just exposing the documentation diff would be helpful

1578696942
fengb
adamkowalski: there's been breaking changes almost every week since September. It's really crazy

1578696945
adamkowalski
marijnfs: the doc examples are compiled. I think that's the source of truth. Blog posts are unreliable for such a new language

1578696954
marijnfs
yeah

1578697003
adamkowalski
fengb: Yeah but I would rather have them now while we are before 1.0. And I think it would be simpler if the author of the breaking change added to the changelog as it happens? That way it's not a chore to do in bulk later?

1578697037
fengb
andrewrk's time is limited and docs are hard. He's more motivated with a writeup ~1 month before actual release

1578697052
adamkowalski
We could probably have an automated system that every time the doc examples break, we keep a diff between the two examples for 1 or 2 weeks?

1578697087
fengb
I think having a doc diff is pretty useful and minimally intrusive. Even if it's just to keep a simple git log since previous release

1578697145
adamkowalski
yeah thats a good idea! I also think this is one of those things we shouldn't even have to bother andrew with. we could run it by him, but we should start delegating to the community for non essential projects

1578697158
fengb
I don't want to pretend to speak for him, but I've asked for it in the past before and that was his response then :P

1578697277
marijnfs
A breaking changes history would be quite useful, although almost everything is a breaking change in some way.

1578697477
adamkowalski
fengb: is there a way to run a zig compiler on a file but not emit output? Just check for errors?

1578697492
adamkowalski
I want to write a plugin for emacs to lint on save

1578697530
mikdusan
adamkowalski: maybe `-fno-emit-bin` ?

1578697597
adamkowalski
thanks! i'll try that. has anybody already done something like this btw? I don't want to duplicate efforts if there is an existing project. I know zig-lsp exists on github but it stopped working with a lot of the latest zig features like anonymous tuples

1578697610
adamkowalski
ideally we would just use the compiler for the source of truth

1578697725
fengb
I think detecting merged issues might be better than documentation, since it links to "why" instead of just "how"

1578697750
mikdusan
adamkowalski: there's also `cat foo.zig | zig fmt --stdin` which exits with error status

1578697785
adamkowalski
wait really? that would be perfect since I wanted to run zig fmt on save anyway haha

1578697822
mikdusan
adamkowalski: andy's vim pack runs zig fmt when the file is written

1578697848
adamkowalski
yeah I might have to get inspired by that

1578697874
adamkowalski
There's no love for emacs yet though haha

1578697878
mikdusan
heh

1578697904
frmdstryr
wtf, does zig search for build.zig if it's not in the current folder?

1578697964
mikdusan
yes

1578697971
frmdstryr
it seems to, confused mre for like 30 minutes as to why it was loading the wrong code only to find out it built into a different folder

1578697979
mikdusan
it goes up the dir tree

1578698026
frmdstryr
can I make an output dir relative to the build file?

1578698073
frmdstryr
using setOutputDir(".") put's  it in whatever folder you run build in

1578698086
frmdstryr
so if you happen to be in some nested folder it puts it in there

1578698151
mikdusan
hmmm... build_root ?

1578698260
frmdstryr
that works

1578698262
frmdstryr
thanks

1578698411
frmdstryr
it still puts the cache folder in the nested dir

1578699771
mikdusan
I'm not sure setting output relative to a build.zig is a good idea. eg, `cd work; zig build --build-file /somwhere/build.zig` and putting a cache/artifacts in pwd is reasonable

1578700570
Snektron
The Zig ast works in a really weird way

