1587082359
r4pr0n
how do you give argument to a program when doing `zig build run`? specifying after -- doesn't really work

1587082978
mikdusan
r4pr0n:

1587083269
r4pr0n
thanks :D

1587086169
andrewrk
I found a way to proceed with #1717 and feel good about it

1587086225
mikdusan
excellente üçª

1587086311
foobles
=D =D =D =D =D

1587086717
pixelherodev
Another Zig kernel? :D

1587086749
pixelherodev
:(

1587086783
foobles
what?\

1587086905
pixelherodev
Sorry, got distracted by a pm

1587086907
pixelherodev
It barely supports more than mine does

1587086918
pixelherodev
I really really want to work on a common kernel

1587086930
pixelherodev
Instead of making an ambitious project myself, make a simple framework others can use

1587087205
pixelherodev
Different ambitious project though, instead:

1587087222
pixelherodev
After a bit of work the past few days, I now have two mostly working components: LLVM IR parser and tree builder, and a low-level x64 code emitter

1587087228
pixelherodev
I wonder what happens when I put the two together? :D

1587087240
fengb
A spectacular event

1587087247
pixelherodev
Yep

1587087255
pixelherodev
Both will implode in a beautiful manner

1587087260
pixelherodev
Uh, that is, everything will turn out fine always

1587087898
andrewrk
sorry got distrated by a situation at home, meant to follow up that with a proposal. give me 15 min

1587088015
hryx
I am dying to know.... obviously ^_^

1587088313
pixelherodev
Funtime project: implementing an interpreter for the system I have a JIT for

1587088322
pixelherodev
Interpreter is simpler to debug, and can then be used to debug the JIT automatically

1587088345
jwmerrill
Is there a convention in zig about when a struct should have a create function vs an init function?

1587088351
pixelherodev
`while (addr != 0xDEADBEEF) { jit.execute(N); intepreter.execute(N); std.testing.expectEqual(jit.state(), interpreter.state()); }`

1587088352
fengb
Most people go the other way around lol

1587088364
pixelherodev
I know :P

1587088376
pixelherodev
But, well, I was in the process of writing a complex testing framework

1587088384
pixelherodev
when I realized I have the entire ROM embedded in memory

1587088393
pixelherodev
Even better, it's embedded at comptime

1587088419
pixelherodev
I could have a comptime interpreter and compare the results at runtime

1587088433
pixelherodev
So that debug mode can verify on a per-block basis that the result is correct

1587088458
pixelherodev
No no no, that's overkill.

1587090395
foobles
andrewrk how do you generate a short-circuiting boolean and/or expression directly in analysis?    I tried doing `ir_build_bin_op_gen`, but that didn't seem to work :p

1587090431
foobles
(also i understand if you are busy, i have just asked this around in several places and noone has had a direct answer)

1587090451
foobles
i assume the short-circuiting logic is somehow generated in the 1st pass?

1587090526
andrewrk
foobles, yes - all the generation of control flow logic happens in pass 1. the second pass performs the control flow during analysis

1587090540
andrewrk
so to do short circuiting logic, you would simply not analyze the dead branch

1587090580
andrewrk
pass 2 is

1587090592
foobles
how is the analysis doing control flow if all of that is determined at runtime?

1587090603
foobles
(unless its comptime known)

1587090610
andrewrk
I see, I thought you meant a comptime branch

1587090637
andrewrk
can you zoom out a bit? what are you trying to do?

1587090650
andrewrk
err I mean what are you working on?

1587090674
foobles
the optional comparisons still =#

1587090679
foobles
i got comptime working!

1587090694
foobles
i was trying to do this transformation: x == y becomes

1587090711
foobles
`(x is null == y is null) and (x is null or x.? == y.?)`

1587090723
foobles
and x != y becomes

1587090736
foobles
`(x is null != y is null) or (x is not null and x.? != y.?)`

1587090774
andrewrk
you can always invent a new Gen instruction, and then do that logic in codegen.cpp with llvm ir directly

1587090787
foobles
ooh that would work

1587090789
foobles
i hadnt thought about that

1587090797
andrewrk
it might even be more efficient

1587090814
foobles
but wouldn't that also require knowing the types at pass 1?

1587090828
foobles
because this should only be generated when the operands are options

1587090840
foobles
and i thought pass 1 didnt know the types

1587090866
andrewrk
how is pass1  related?

1587090980
pixelherodev
If I embedFile the same file twice, it'll only appear in the binary once, correct?

1587091035
foobles
andrewrk I thought pass 1 was the gen-instructions

1587091041
foobles
and didnt do type checking

1587091053
foobles
while pass 2 evaluates comptime and does typecheckng stuff

1587091071
andrewrk
pass1 is src, no type checking. pass2 is gen, all semantic analysis

1587091091
andrewrk
pass1 input src, output gen

1587091105
andrewrk
sorry. pass1 input ast nodes, output src

1587091111
andrewrk
pass2 input src, output gen

1587091117
andrewrk
codegen.cpp input gen, output llvm ir

1587091130
andrewrk
hryx,

1587091166
mikdusan
`drop const` in global. nice.

1587091177
foobles
right. so if I write my own gen-instruction (which is pass 1 right? all of them are labelled ir_gen_x), I would need to know during pass 1 that the operands are optionals

1587091196
foobles
but typechecking is only done on pass 2

1587091198
foobles
right?

1587091220
foobles
so how would i know in pass 1 which gen instruction to call?

1587091225
andrewrk
foobles, IrSrcGen corresponds to pass 2

1587091234
andrewrk
argh. sorry. IrInstGen

1587091287
andrewrk
I think the confusion here is that the pass1 functions have "gen" in them

1587091297
foobles
oooh thats what i thought ok

1587091308
foobles
i thought you were saying a `ir_gen_*` function, meaning pass 1

1587091331
andrewrk
"gen" is a bit overloaded here

1587091334
foobles
heh

1587091356
foobles
so I would create a new type of IrInstGen node, with its own codegen as well

1587091362
foobles
?

1587091381
andrewrk
yes. that's probably the most straightforward way to do it

1587091396
andrewrk
unless an existing IrInstGen already does what you want, which does not appear to be the case

1587091725
foobles
awesome

1587091742
foobles
cool thats super clear, ive been stuck for a few days '=D

1587091746
foobles
tysm

1587091967
andrewrk
no problem, good luck

1587093070
pixelherodev
What's a good way to access a structure as a `[]const u8`? `@bitCast`?

1587093094
andrewrk
slice a pointer

1587093153
pixelherodev
You mean std.mem.toSliceConst(u8,...) it?

1587093350
shakesoda
ptrcast to u8[*] and slice to sizeof the type?

1587093368
shakesoda
that's what i would try first

1587093379
pixelherodev
@bitCast seems to work, even if it's not the best option

1587093415
andrewrk
pixelherodev, oh, does std.mem.asBytes do what you want?

1587093424
pixelherodev
Ohh, probably

1587093427
pixelherodev
I'm currently using std.testing.expectEqual(@bitCast([@sizeOf(@TypeOf(recompiler.state))]u8, recompiler.state),@bitCast([@sizeOf(@TypeOf(interpreter.state))]u8, interpreter.state));

1587093440
shakesoda
that line is terrifyingly long

1587093442
pixelherodev
(assuming I typed that correctly in IRC)

1587093443
pixelherodev
Yeah

1587093894
pixelherodev
Easier solution: splitting it up into multiple comparisons

1587094204
pixelherodev
`error: expected type 'dynarec.ebus.struct:9:16', found 'dynarec.ebus.struct:9:16'`

1587094205
pixelherodev
Ah, generics

1587094534
pixelherodev
Okay, now it works :)

1587094547
pixelherodev
Just made the State struct separate from the generic type

1587094553
pixelherodev
Also works as a testing framework :D

1587095409
fengb
Doh, mikdusan commented right befor me

1587095415
mikdusan
yaay

1587095417
fengb
Now I look schizo

1587095616
mikdusan
I think .field is superb; and commas be gone; but I know this line of thinking is much wider in scope than the proposal

1587095683
fengb
Yeah I like the pretended dot too

1587095692
andrewrk
mikdusan, what's the .c := 10; do in your example?

1587095724
mikdusan
oh it shouldn't be comptime. one sec.

1587095768
mikdusan
changed rhs to bool literals

1587095790
andrewrk
what does the .c := true; do?

1587095800
mikdusan
.c: bool = true;

1587095801
fengb
Default value I presume

1587095823
mikdusan
inferral syntax

1587095835
andrewrk
ah ok, this would introduce type inference of fields

1587095843
mikdusan
yes. sorry I get so ahead of myself

1587095851
andrewrk
it makes sense to show the full vision :)

1587095857
fengb
Hmm so we have `comptime foo = bar` as well?

1587095864
andrewrk
yes we have comptime fields

1587095879
fengb
Hey you stole my old inferred field proposal ü§®

1587095901
andrewrk
comptime foo = bar is not meaningful. all globals have comptime initialization expressions

1587095915
fengb
Oh right

1587096303
mikdusan
andrewrk: is #498 destructure to mean `:=` fails like go-syntax does for distinguishing between init and copy?

1587096349
andrewrk
I'm not sure what you're asking

1587096404
mikdusan
ah yes. you clarified before me.

1587096406
mikdusan
thanks

1587096411
andrewrk
the #498 plan is multiple lvalues on the LHS and then `=` and then a tuple with matching len on the RHS

1587100067
daurnimator
feels odd that globals and args are const-by-default but pointer-values are not

1587100084
foobles
hmm true

1587100109
daurnimator
if we have a general attitude of const-by-default then `*T` should mean pointer to const T, and you need e.g. `*var T` for a non-const pointer.

1587100463
foobles
I agree with that

1587100473
foobles
however, andrew said no

1587100506
andrewrk
just a sec...

1587101056
andrewrk


1587101868
foobles
Interesting

1587101873
foobles
i like the idea

1587101991
hryx
I love me a good syntax discussion

1587102075
hryx
mikdusan: I added my own suggestion inspired by yours

1587102098
mikdusan
ideas. I seee everyone has ideas within ideas. Andrew lit a firestorm. some real neat stuff coming out.

1587102105
mikdusan
being suggested

1587102130
foobles
i like this :)

1587102147
foobles
0.7.0 is going to be like C++11 was to '98 :P

1587102149
foobles
even more!

1587102153
foobles
becasuse breaking changes!

1587102156
hryx
o no mikdusan did I actually just repeat what you said? Maybe I misunderstood :(

1587102161
hryx
(in the GitHub comment)

1587102189
mikdusan
hryx: looks very similar

1587102193
foobles
I think you just didnt see his link to what he posted in the other issue

1587102240
hryx
Dang, I thought you were suggesting actually using the := operator. so that's not the case?

1587102330
foobles
I am now :)

1587102345
foobles
but he originally was, but modified his propsal

1587102545
mikdusan
i knew someone was going to flip `:=` to mean reassignment

1587102568
andrewrk
if you look at your own code, and try modifying it to my latest proposal there, it's pretty surprising few rarely you actually need the `mut` keyword for reassignment

1587102576
andrewrk
s/few/how/

1587102591
mikdusan
andrewrk: when I heard that I said what? waaat? but then yeah I can believe it.

1587102615
andrewrk
it was

1587102620
hryx
I like the mut quite a bit, but the disconnect with += and family might be a gotcha/surprise

1587102633
hryx
the low impact is nic3e

1587102638
hryx
*nice

1587102650
foobles
I also dont like how it's inconsistent with other types of reassignment

1587102692
andrewrk
it's impossible to mess up. any mistake leads to a really straightforward compile error

1587102710
andrewrk
someone could learn this syntax without reading language documentation

1587102718
mikdusan
foobles: what I like about your flip `:=` idea is this; consider andrew mentioned that reassignment is few compared to decl. so that relaxes the amount of `:` required in destructuring!

1587102755
daurnimator
andrewrk: I see the merit in your proposal.... but it makes things very unfamiliar

1587102796
foobles
mikdusan oh yeah! Maybe if I mix mine and your proposal: a `:` after something means a redeclaration

1587102802
daurnimator
--aprochability

1587102807
foobles
s/redeclaration/assignment

1587102931
kenaryn
Hello you C/C++ programmers who dream of a Zig job all nights. Please is there a simple method to remember when do I have to use `std.debug.assert` or `std.testing.expect`?

1587102964
andrewrk
kenaryn, yes. is it in a test block? expect. otherwise, use assert

1587102979
kenaryn
Thank you sir.

1587103164
mikdusan
foobles: I think inverting `:=` makes an ambiguity in destructuring (as I styled it)

1587103174
foobles
yeah, you are right

1587103180
foobles
especially with explicit types

1587103205
hryx
mikdusan:

1587103206
foobles
i think the best way to go is how andrewrk said, but with something other than a keyword, and make it consistent for all reassignment

1587103240
foobles
like a prefix-operator you put

1587103244
hryx
oops, mikdusan, with a destructuring example, would yours and mine look the same?

1587103253
kenaryn
In Backus-Naur form (a logical-mathemathical expression), you have `::=` notation to express 'defined as the following'.

1587103294
kenaryn
Not sure if it fits with your context.

1587103340
mikdusan
hryx: looks

1587103351
mikdusan
so maybe do a convert

1587103490
hryx
I see now, I was looking in the wrong place. Sorry about that foobles, I'll correct my comment

1587104201
andrewrk
foobles, I like the way your latest comment addresses the consistency issue

1587104237
foobles
:)

1587104291
andrewrk
let's see if we can improve it even more, with the use case of someone who does not know zig, but knows other programming languages, reading zig code

1587104307
andrewrk
and they see reassignment syntax (in context)

1587104327
andrewrk
I feel that ~ might be a bit of a red herring with bitwise not

1587104415
andrewrk
that's a really good point, what this really comes down to is, what is the syntax sugar for (&x).*

1587104548
foobles
I agree, ~ is weird. I do think it should be `.something` though

1587104556
foobles
what about `.mut`?

1587104591
foobles
eeeh, the more i look at that the more i dislike it

1587104607
foobles
especially since it will look like a member

1587104612
foobles
i do think it should be postfix though

1587104633
foobles
and start with a `.`

1587104655
hryx
x._

1587104701
shakesoda
I feel like there are several proposals (some accepted) for the compiler just erroring out on style issues that seem... a bit ridiculous

1587104727
shakesoda
in terms of "why on earth is this an error and not just a cosmetic fixup for zig fmt"

1587104798
foobles22
I like `._` its definitely not as weird as `.~`

1587104859
shakesoda
also, i actually like the const foo = fn syntax :(

1587104873
kenaryn
`|~`

1587104877
hryx
foobles22:  if you want a dot-something glyph you could also consider `.@` which kiiiinda suggests something about a variables "self property"??

1587104880
andrewrk
shakesoda, you like it better than foo = fn syntax ?

1587104918
andrewrk
field access syntax is a bit problematic because in the reassignment, the lvalue could be a struct type

1587104948
andrewrk
shakesoda, re: style issues - which proposals are accepted?

1587104981
kenaryn
`@_`

1587104994
foobles
so like `x@_ = 10;`?

1587105015
hryx
problematic, true. `@=` ? It is sort of in line with += and familly

1587105043
foobles
we can't just add another operator, since that gets wonky with multi-assignments

1587105058
foobles
also im really loving this conversation but i have some stuff to get done

1587105063
foobles
hopefully ill be back soon

1587105071
kenaryn
See ya=)

1587105073
andrewrk
what was the problem with `mut a = b;` ?

1587105101
hryx
sorry all, I'm probably too wound up by the topic and repeating things others have said. I'm going to leave this to the experts for now :)

1587105135
hryx
andrewrk: I really like the `mut` but my concern was it's disjointed from other reassignment ops like +=

1587105143
hryx
But probably a non-zig user should be the one to chime in on that like you said

1587105204
shakesoda
andrewrk: yeah, I like const foo = fn() more with the const than without, and if it's only a global scope thing then it's just inconsistent. further, suddenly I have to @as at global scope to actually write a type in or something? that just... doesn't seem desirable. also, if this affects declarations in structs then the difference between = and : is suddenly severely harmful to legibility

1587105220
shakesoda
I had to read some of the example posts mentioning that several times to even get it

1587105244
shakesoda
I don't want that problem in my code, it feels... frustrating

1587105246
andrewrk
shakesoda, the latest iteration of the design, it's both global and local

1587105286
andrewrk
can you help me understand why you would rather start typing an extra keyword for all function declarations?

1587105297
andrewrk
as opposed to not start typing an extra keyword for all function declarations

1587105315
mikdusan
andrewrk: global `mut i = 5;` would be error correct?

1587105319
shakesoda
because then I don't need special rules depending on typing them inside of a function or outside of it

1587105325
mikdusan
err `mut i: u32 = 5;`

1587105337
shakesoda
the const assignment syntax is identical everywhere, no special rules here

1587105341
andrewrk
mikdusan, correct

1587105380
andrewrk
shakesoda, did you see the part where I wrote, "I realized that this proposal has one really big downside: it makes it no longer possible to cut+paste constant declarations from global to local scope, and vice versa." and then changed the whole proposal?

1587105380
shakesoda
if it's both global and local then you also add a new problem of it being hard to actually see where first declarations are

1587105425
shakesoda
andrewrk: no, just getting to that one now

1587105562
shakesoda
mut on reassignments feels even worse than just keeping the consts

1587105628
shakesoda
it solves the problem of initial declarations being hard to spot, though

1587105655
shakesoda
but I don't think it's an

1587105689
andrewrk
mikdusan, your tuple syntax is off

1587105712
andrewrk
also s/default value// for the globals

1587105725
mikdusan
yeah i nuked default global already

1587105810
mikdusan
I don't know how to say it clearly; I wanted tuples on RHS to just show the types

1587105842
andrewrk
I see

1587105855
mikdusan
ie: indicate first lhs gets first type, 2nd lhs gets 2nd type

1587105892
foobles
my only issue with `mut` is that it looks too much like `var`

1587105904
foobles
and therefore looks like a declaration

1587105912
andrewrk
I see

1587105925
foobles
maybe if mut just came afterwards?

1587105931
foobles
`x mut = 10;`

1587105939
foobles
then it looks like `mutation assignment` even :)

1587105956
shakesoda
andrewrk: the other accepted style issue i was thinking (which I believe to be zig fmt's domain and not a reasonable error) is #35

1587105960
andrewrk
var a, x mut, c = .{1, 2, 3}

1587105971
shakesoda
i.e. "error on bad indentation"

1587106005
andrewrk
wait really you have a problem with that? but it prevents a footgun

1587106040
shakesoda
the only footgun I'm thinking of is brace omission errors, and brace omission is a feature I don't like either :\

1587106050
shakesoda
despite it being currently how ternary works

1587106055
Xavi92
Hi there :)

1587106068
foobles
hello

1587106080
Xavi92
Just reading #5076 as well

1587106133
Xavi92
andrewrk: "The keyword const is then only used for pointer attributes, and it would set the stage for a follow-up proposal that deleted the const keyword altogether and used mut to annotate mutable pointers." -> does that mean Zig would finally switch to '[]T' and '[]mut T'?

1587106154
andrewrk
yes

1587106179
shakesoda
naked const assignments have some benefits but I don't feel like it's good for consistency or legibility, and even with the added mut on reassignments (which resolves the ambiguity) I'm really hesitant to think it'll make my code better to read

1587106195
Xavi92
andrewrk: well, that's a relief after seeing my issue closed down :)

1587106206
foobles
:-)  i was worried about that too

1587106209
shakesoda
especially when historically it hasn't actually been a problem in other languages I write that accept function definitions in the proposed form of 1717

1587106253
shakesoda
ymmv, of course

1587106275
Xavi92
shakesoda: I agree. IMHO local scopes would be the only place where 'const' makes sense to me, making more readable than e.g.: a special syntax for reassignments

1587106319
shakesoda
I'm all for const being allowed everywhere

1587106322
Xavi92
andrewrk: OTOH, I like the decision to drop 'const' on struct and enum definitions. I already felt that the first moment I started learning Zig

1587106325
shakesoda
as is the status quo

1587106345
shakesoda
although  I wouldn't complain either if const were shorter... perhaps let ;)

1587106359
foobles
how about `c`

1587106360
shakesoda
(or even... set)

1587106365
foobles
:p

1587106380
mikdusan
it's too bad this word is so bloody common; `reset` to reassign, and `mut` to mean mutable in both values and pointers

1587106435
shakesoda
feels very strange to be the one not in favor of removing some syntax i have to say

1587106444
foobles
I think if `mut` is added, it should be equivalent to `(&x).*`, and thus usable as an expression

1587106444
shakesoda
since i'm almost always in favor of such things

1587106448
foobles
heh

1587106475
foobles
like some kind of "assignable identity"?

1587106479
mikdusan
honestly this topic has stolen. STOLEN. 4 hours of my life. I thought it was just 1 hour lol

1587106497
shakesoda
it's kind of a big deal that would affect all zig code, all of it.

1587106537
shakesoda
1717 would too, but i think in a more trivial way

1587106647
foobles
hmmm

1587106661
foobles
well one thing could be interesting: sort of like rust, if we add prefix mut like that

1587106669
foobles
we could have `&mut x` for a mutable pointer

1587106675
foobles
and `&x` is always constant

1587106691
foobles
but then that sets a precedent for prefix-mut

1587106699
foobles
which is bad looking on assignments

1587106749
andrewrk
mikdusan, your , ; thing affects enums too. it looks weird with enums

1587106795
andrewrk
thejoshwolfe suggested that zig fmt could auto-fix between , and ; for struct fields and switch cases

1587106886
foobles
wait a second, this might be just terrible

1587106898
foobles
how about `x. = 10` for assignment

1587106906
foobles
postfix `.` :))))

1587106912
mikdusan
oh if it's just about enum decl, yeah, that's a special case that needs thought

1587106915
foobles
no, maybe not ....

1587106980
shakesoda
i was thinking briefly about a .<symbol> for reassign but I can't think of any that are actually any good

1587107002
shakesoda
some of the issue for me is that I specifically read code by looking for the initial assignment keywords

1587107028
mikdusan
here's a slight rework to make `mut` both for values and pointers. `mut i: u32 = 0 //init;` and `reval i = 1;`

1587107074
foobles
i like that

1587107087
foobles
how about `ass` for "assign"

1587107092
foobles
:v

1587107099
mikdusan
brilliant

1587107105
kenaryn
`::=`

1587107113
mikdusan
i think you've been reading too much anal .cpp code

1587107119
kenaryn
lmao

1587107128
foobles
the issue with having a dedicated assignment operator is that it gets weird with multi assign

1587107142
andrewrk
I like ass

1587107156
mikdusan
:P

1587107163
shakesoda
were this my channel you'd have that quote in the topic already

1587107285
shakesoda
i'm a bit less sure about what i think of 5077

1587107310
shakesoda
i don't feel like it's really the compiler's business to care about field ordering as long as the syntax isn't ambiguous

1587107347
shakesoda
fmt would fix it and i could see a warning over it, it just seems bizarre that "this is on the wrong line in the struct" is a syntax error

1587107380
shakesoda
especially when if your struct has some big functions or something there's a really high chance you'll keep a var near you so you can still see it

1587107462
shakesoda
it's easy enough to argue against writing code that way, but it just seems like overreaching for not much benefit

1587107548
andrewrk
mikdusan, I think you meant to post that on the other issue

1587107560
mikdusan
yup fixing now

1587107608
mikdusan
SpexGuy just comment-bombed me on the auto-reload lol

1587107693
foobles
he basically says what you said :-)

1587107700
foobles
but also explains some more stuff

1587107716
foobles
i actually think this should be the distinction, if we go this route:

1587107741
Xavi92
I like 5077, actually

1587107777
Xavi92
Matches Zig's one possible way to make things IMHO

1587107798
andrewrk
set is pretty good

1587107814
andrewrk
I have to admit set is better than ass

1587107822
mikdusan
yes 5077 is nice esp with SpexGuy relaxing it a bit to mean "no non-fields between fields" ... so NNFBF

1587107880
andrewrk
you can read `set b = 4;` without any context and any docs

1587107920
Xavi92
andrewrk: if `let` isn't an option, I also prefer `set`

1587107930
andrewrk
let looks like a decl

1587107954
mikdusan
well set and let are both tennis words. but let is really a tennis word to me.

1587107978
shakesoda
let is a difficult to understand math paper word to me

1587107985
Xavi92
andrewrk: Just to ensure I understood it correctly, would `set`be used in place of `const` or used for reassignment?

1587107990
shakesoda
i'm not massively opposed to spexguy's .~ reassignment although i still hold that i think the proposal isn't an improvement

1587108023
andrewrk
one thing to remember is that big syntax changes feel very strange when they first happen and it's difficult to overcome the cognitive bias that we all share for status quo

1587108024
Xavi92
shakesoda: I'm against introducing new operators, or at least .~ looks like an operator to me

1587108024
shakesoda
i think it pulls zig further from being simple and consistent (just more terse), rather than closer

1587108045
shakesoda
Xavi92: it's at least not something alien if you've seen a .*

1587108056
shakesoda
i.e. it's in the same form as other things already are

1587108079
Xavi92
shakesoda: .* was also alien for me :) At least as soon as I realized *foo triggered a compile error

1587108110
andrewrk
shakesoda, I agree with you that my proposal makes the language bigger

1587108188
Xavi92
andrewrk: referring to 5077 you mean?

1587108202
andrewrk
sorry, I'm referring to 5076

1587108204
shakesoda
5076

1587108239
shakesoda
5077 (no ungrouped fields) is one i'm against being a compile error but in full support of being an fmt fixup

1587108276
andrewrk
shakesoda, I noted on that issue about zig fmt at the end there, not sure if you caught that

1587108300
shakesoda
andrewrk: I think it's a strong point for a warning or for fmt, I don't feel like it's strong enough for an error though.

1587108319
shakesoda
andrewrk: leaves me a bit on the fence about it, really

1587108361
shakesoda
in general, I don't feel anything which is fundamentally just bad style should be an error

1587108404
andrewrk
5077 is small fish, hard for me to even care about it when 5076 is on the table

1587108422
shakesoda
5077 is indeed a small fish

1587108727
shakesoda
heh, I was thinking of set as replacing const instead of mut.

1587108741
foobles
After looking it over from a bunch of perspectives, I think `set` is the best in this case

1587108760
shakesoda
but set is also a lot better than mut in this context

1587108858
Xavi92
I'm also convinced on `set` and `var` (unless I got something wrong all out of this)

1587108877
shakesoda
Xavi92: the proposal is something else entirely right now

1587108926
shakesoda
unless you happened to just read the comment on 5076

1587108987
Xavi92
shakesoda: I was expecting that somehow :P

1587108999
Xavi92
So what's the current status?

1587109003
mikdusan
the very first line of 5076 still stands, so it shortens ALL imports. it shorts new #1717. the rest is just attempt at consistency

1587109032
mikdusan
and addressing ambiguity

1587109076
foobles
I am really liking `set` now

1587109078
shakesoda
we could also shorten everything just by swapping const with set, without changing the rules

1587109109
mikdusan
but that's longer than functions as I see it in 5076

1587109149
foobles
i just posted a new comment

1587109162
foobles
i think `set` should be used in all reassignments, just for consistency

1587109171
shakesoda
I rather think it's trivial if the cost of anonymous functions is two more characters.

1587109173
Xavi92
mikdusan: I agree with the first line from 5076. I'd just replace `const`by `set` on local scopes, and `var` by `mut`

1587109196
mikdusan
foobles: i think that is idea. you cannot mutate an existing value without a `set` ?

1587109197
shakesoda
when you can reclaim both characters by shortening const, lol

1587109226
foobles
mikdusan the original proposal had stuff like `x[0] = 5;` being allowed without mut

1587109242
foobles
only direct `identifier = expr;` needed `mut`

1587109278
foobles
but since thats inconsistent, I think reassignment even when it isn't ambiguous should use `set`

1587109284
foobles
like `set x.* = y;`

1587109289
mikdusan
foobles: oh right i see that now. "assignment that do not look like a = b; are unchanged"

1587109312
andrewrk
foobles, what about +=

1587109363
foobles
I think those should be left alone. you arent directly "setting" them as I see it, those are more so "modification operators".

1587109370
foobles
they wouldnt work in multi-assign anyway

1587109419
foobles
like they "adjust" instead of ignoring the old value

1587109447
mikdusan
probably limiting the `set` idea to just disambiguate "a = b" is good. it shouldn't go viral

1587109465
foobles
so what do you think of `set x[0] = y;`?

1587109474
mikdusan
close but no cigar

1587109497
mikdusan
can x[0] be confused with a decl?

1587109497
shakesoda
oh, i goofed my thinking about lengths

1587109501
shakesoda
too late for me

1587109516
mikdusan
shakesoda: hours stolen. HOURS!

1587109563
andrewrk
I think the remaining issue is the point made by fengb, shakesoda, and torque: "variable declarations be specifically highlighted by keyword usage (const, var) is valuable for code comprehension"

1587109582
andrewrk
it's tempting to say syntax highlighters can look for `a = b` and make it bold, but I think that's a cop out

1587109600
andrewrk
although I will show what that looks like just for fun

1587109672
Xavi92
andrewrk: that makes code comprehension depend solely on the editor, though. A keyword is a good balance when no syntax highlighter (or a bad one) is present

1587109699
foobles
yeah, i dont like depending on IDE features

1587109708
andrewrk
agreed

1587109726
shakesoda
the amount of actual brain space my function declarations take up is almost none compared to everything else, fwiw

1587109753
shakesoda
I changed the form of functions in a file I've got open here, it looked funny for a couple seconds, and then I stopped noticing.

1587109926
Xavi92
shakesoda: could you provide an example on a pastebin? Just for curiosity

1587109938
mikdusan
amazing how every decent operator with `=` in it is gobbled out

1587109940
mikdusan
up

1587109998
kenaryn
`=:=`

1587110009
kenaryn
`<~>`

1587110030
shakesoda
Xavi92: one moment

1587110052
foobles
`<-`

1587110059
foobles
:)

1587110063
mikdusan
and as soon as an op is attempted for "reassign" it makes multi-lhs look messy

1587110070
foobles
yep

1587110080
shakesoda
Xavi92:

1587110097
shakesoda
(snektron's radix sort)

1587110195
shakesoda
the largest difference for me right now is "my syntax highlighter is a bit confused so the names aren't yellow now"

1587110240
kenaryn
here is the font i'm using in sublime text, someone may be inspired for a operator assignment without a key-word:

1587110260
Xavi92
shakesoda: that function declaration style is probably not my cup of tea (I guess because of my background in C and later Rust), but makes it more consistent with how enums and structs are defined, I must admit

1587110274
shakesoda
i certainly like the existing function syntax of just `fn`, but I don't hold it so close to my heart.

1587110277
shakesoda
the total consistency is nice

1587110343
shakesoda
if zig were more the type i'd say just make the current form sugar for it, but that's inconsistent with zig's philosophy and a separate discussion to duke it out over

1587110344
Xavi92
shakesoda: totally agree with that. Being consistent is as important (if not more) as being simple

1587110416
mikdusan
also consider for a momement how much syntax complexity andrew avoided by designing comptime with as much as the same syntax as possible. every other language fails at that. macros, annotations, weird brackets, templates

1587110442
foobles
thats certainly true :)  i was amazed when i saw generic types :D

1587110479
foobles
but i guess `const foo = fn() void {` is OK.....

1587110520
foobles
my only gripe is that const is slightly too long, but it seems that has already been discussed at length

1587110522
torque
yeah, I think the main thing that is sticking for me is `const foo = fn() void {}` actually reads really well to me. Maybe I'm damaged by having written a bunch of lua/moonscript/javascript where all functions are all "anonymous" and you end up with something like `local foo = function(bar, baz) end` every time you declare a function anyway

1587110549
kenaryn
`~@`

1587110592
Xavi92
torque: `const foo = fn() void{}`, `const bar = enum {}`, `const baz = struct {}`. Looks pretty consistent to me

1587110614
torque
I agree with that

1587110615
shakesoda
point of interest: lua is my all-time favorite language by miles

1587110617
andrewrk
consistency is a given, that's why the proposal to drop const in the global scope has so much fall out

1587110621
shakesoda
in large part because it is relentlessly simple

1587110687
Xavi92
Maybe replacing `const` by `set`, `let` or any 3-character keyword would be preferrable. I'm sold on `ass` too :P

1587110718
andrewrk
forget about `set` outside the context of reassignment

1587110746
foobles
apparently `let` is off the table too

1587110748
shakesoda
I don't actually expect const/var to change, given older issues

1587110752
foobles
yeah

1587110833
Xavi92
shakesoda: I also prefer `const` tbh. I said it would be preferrable since `const` seems to have some friction among some developers e.g.: after reading #181

1587110860
Xavi92
But I'm totally fine with it, after all

1587110921
foobles
so this also drops any possibility of const-by-default for pointers?

1587110925
foobles
andrewrk

1587110928
torque
from a more pragmatic standpoint this also seems like a huge amount of effort to solve something that isn't actually a problem. I actually only commented on the issue because it felt like people were being much to eager make sweeping changes to the language and there didn't seem to be a strong contrarian opinion.

1587110965
andrewrk
int main() {}

1587110965
andrewrk
pub const main = fn() void {}

1587110978
andrewrk
zig is losing pretty hard to C here.

1587110990
torque
losing in what metric, though?

1587110993
mikdusan
I find the more fundamental a syntax change, the more you have to explore universal consistency

1587111004
torque
*metrics

1587111021
shakesoda
I don't think zig's going to be beating C at IOCCC style contests either, which isn't specifically a flaw

1587111022
Xavi92
foobles: I think both are still possible. *Foo, *mut Foo, const main = fn(){}

1587111043
andrewrk
functions are the foundational abstraction of the language

1587111074
Xavi92
foobles: *const Foo wouldn't just make sense if `const` is only used to declare things.

1587111085
torque
I mean status quo is `pub fn main() void {}` anyway, right? you're already losing anyway, so lean into it

1587111097
Snektron
<andrewrk "int main() {}"> You meant `main(){}` ;)

1587111404
shakesoda
kinda feel like if we're gonna put in weird exceptions it'd be a lot simpler to just syntax sugar fn

1587111448
shakesoda
this, however, is not an issue which will keep me from going to sleep. night

1587111481
foobles
even lua did that :p

1587111571
andrewrk
nah no weird exceptions, no syntax sugar for fns

1587111620
foobles
andrewrk so any final thoughts about `*var T?`

1587111631
foobles
or was that closed the moment yoy closed the issue

1587111636
foobles
s/yoy/you

1587111646
andrewrk
what is your argument in favor of `*var T` over status quo?

1587111678
shakesoda
pointer args being mutable implicitly goes against the constness of parameters

1587111685
foobles
thats one thing

1587111685
shakesoda
wasn't that the idea

1587111699
foobles
and in general, I think const-by-default should be a goal of the language

1587111723
foobles
i find myself, in C++/C, just forgetting to put `int const&`, since its so much easier to read without it

1587111734
foobles
even though almost all of the time my references and pointers should be const

1587111765
foobles
I think rust is a good example of how const-by-default syntax for pointers works in the language's favor

1587111797
andrewrk
rust's relationship to const-by-default is deeper than zig's because of the borrow checker

1587111801
shakesoda
rust is also a good example of how enough obsession can turn it frustrating

1587111805
foobles
true

1587111810
foobles
but just syntactically

1587111815
foobles
its a warning sign in the signature: "the value will change when you pass it to this function"

1587111831
andrewrk
zig's pointers are unambiguously mutable or const with status quo

1587111837
andrewrk
so the warning sign is the same

1587111875
foobles
but its so much easier to just say `*T` and forget about it. having 2 or 3 `const`s in a function signature makes it a lot harder to read i think

1587111900
foobles
C has the same problem, someone else mentioned how much easier it is to make things not const-correct

1587111909
foobles
and just have all pointers be mutable

1587111920
foobles
well i guess the story is better than C, since locals have to be `const` or `var`

1587111931
andrewrk
there's a sub-movement in the C community who think `const` is a bad language feature and eschew it entirely

1587111940
foobles
D:

1587111946
foobles
oh dear

1587111955
foobles
well its not the biggest issue for me

1587111963
antaoiseach
is this a discussion about having `const` explicitly in type signatures as opposed to implicit?

1587111986
antaoiseach
If so, I, as a beginner to Zig, quite like the explicit const-ness in type signatures

1587111987
Xavi92
andrewrk: yes

1587111991
foobles
this is about pointer types not allowing mutation of the object they refer to, unless specified as `var`

1587112000
antaoiseach
Ah, okay

1587112000
foobles
i like it to

1587112004
foobles
s/to/too

1587112012
foobles
and it sets a precedent for const-by-default

1587112020
foobles
so i feel like `*T` should be a pointer-to-const

1587112027
foobles
especially since that is what i want 90% of the time

1587112032
mikdusan
this would be C++ using consistent style for main: `auto main = []() -> int {};`

1587112036
Xavi92
foobles: totally agree

1587112049
antaoiseach
Isn't that becoming kind of Rust-ish?

1587112059
kenaryn
`zig zen | head -n2`

1587112070
Xavi92
antaoiseach: isn't default mutability becoming kind of C-ish?

1587112090
antaoiseach
I thought that was the point of Zig?

1587112091
Xavi92
antaoiseach: I'd prefer Rust over C a million times in that sense

1587112095
andrewrk
foobles, I don't think your 90% experience is representative

1587112101
antaoiseach
I like Rust, but that's just one way of doing it

1587112105
foobles
ok, 90% may be hyperbole

1587112109
foobles
but i just mean generally

1587112121
foobles
its far safer to assume const, and then decide to change it later

1587112131
andrewrk
I believe you - but mutable state is also a valid way to code

1587112135
Xavi92
foobles: totally

1587112149
Xavi92
andrewrk: we never said it was invalid. It's just risky, and thus should be explicit

1587112153
antaoiseach
Indeed... sometimes it's just a pain (in Rust) to keeping having to dump `mut` all over the place, I find

1587112161
foobles
right, so I think `*var T` isnt too frustrating to type

1587112162
antaoiseach
especially when doing heavily imperative code

1587112203
antaoiseach
that's just my experience though

1587112222
foobles
right but how often are you specifying pointer types in zig? mostly in function signatures

1587112253
andrewrk
in std.ArrayList nearly every pointer in the function signature is correctly mutable

1587112254
Xavi92
andrewrk: default immutability favors assigning variables only once, rather than modifying them at several places. That causes code hunting

1587112267
Xavi92
antaoiseach

1587112315
torque
I don't think calling mutability "risky" is a reasonable argument. the only time it is "risky" is in badly written code, which the compiler will not fix

1587112329
andrewrk
zig programmers are already encouraged to use const rather than var for variable declaration

1587112330
antaoiseach
torque: agreed

1587112354
andrewrk
however since `var` is easier to type, I have noticed people incorrectly choosing it over const

1587112361
shakesoda
I think mutability is a lot more dangerous in languages where you can hide stuff in places that look benign

1587112364
Xavi92
andrewrk: then encourage zig programmers to use const for immutable pointers and var for mutable pointers. That's what my proposal was all about

1587112381
shakesoda
zig's no hidden control flow dramatically reduces the potential there

1587112398
foobles
well take this piece of the self-hosted zig compiler: `fn genCall(irb: *Builder, suffix_op: *ast.Node.SuffixOp, call: *ast.Node.SuffixOp.Op.Call, scope: *Scope) !*Inst {`

1587112399
antaoiseach
Xavi92: that sounds reasonable to me, but what exactly is your proposal? Is it an issue on Github?

1587112416
foobles
from what it looks like, suffix_op and call should both be *const

1587112423
shakesoda
risk in c++: extreme, likely lethal, you will screw up. risk in zig: well i guess if you try you can do bad things

1587112429
andrewrk
I think the main argument in favor of #5076, despite the problems pointed out by torque, is that it actually modifies the language in a way that makes it favorable to make const decls rather than variables

1587112439
Xavi92
antaoiseach:

1587112448
antaoiseach
Xavi92: thank you. will check it out

1587112507
foobles
andrewrk so why not enforce that with pointers as well?

1587112546
mikdusan
thinking about it, I don't know why I

1587112547
torque
what's the primary use-case for passing an immutable pointer to a function anyway? aren't pointers generally used as an inout parameter because passing parameters directly can silently optimize to pass-by-reference when appropriate?

1587112605
foobles
needing to return a pointer to a member is one

1587112621
andrewrk
I'm not convinced with the self-hosted compiler function arguments foobles. I remember writing that code, and I vaguely recall trying to make something const, and then spending a bunch of time dealing with mutability of things, an hour goes by, and I realized, "I'm just playing with the type system. I'm not actually being productive." and then made everything mutable and actually got done what I wanted to get done

1587112649
foobles
fair enough

1587112666
foobles
i dont want to get into too much of an argument over this

1587112670
andrewrk
I'm not on the side of that sub-movement of C people. I think const is a good tool

1587112678
foobles
yeah

1587112680
torque
at least in C const is usually not worth the hassle

1587112693
foobles
i just think it should be easier to make pointer-to-const, and should be easier to declare variables as const

1587112697
torque
e.g. prevents you from initializing a struct after allocating it

1587112699
foobles
and also i think i should go to bed

1587112704
foobles
good night everyone

1587112708
Xavi92
foobles: night!

1587112712
andrewrk
good night foobles

1587112737
andrewrk
torque, I can give you a really clear example: it lets you know that you can pass a string literal as a parameter

1587112745
andrewrk
otherwise you will get a segfault at runtime

1587112761
Xavi92
andrewrk: so, to sum up and despite all of the discussion, this means everything stays as is?

1587112793
andrewrk
no decisions have been made, no "accepted" label has been applied or "close" button has been clicked

1587112817
antaoiseach
Having read the Github issue, I really don't know what to think - it feels kind of subjective... almost everyone's going to have different opinions I think. While I like the explicitness having something like `*var T` or `*mut T` would bring, the default being immutable and not requiring `const` still appears a bit of magic to me. Why not simply have no defaults, and make everything explicit at the cost

1587112823
antaoiseach
of extra typing - `*mut T` and `*const T`?

1587112850
antaoiseach
g'night foobles

1587112858
Xavi92
andrewrk: the "close" button was pressed on #5056

1587112860
antaoiseach
It's broad daylight here... hahaha

1587112882
mikdusan
?

1587112892
mikdusan
shows open to me

1587112918
andrewrk
Xavi92, oh, 5056? yeah that's closed. so it's not planned

1587112928
antaoiseach
shows closed for me (5056 that is)

1587112939
mikdusan
hahah  5056 != 5076

1587112940
shakesoda
mikdusan: not 5076!

1587112942
Xavi92
andrewrk: I have the impression you changed your mind several times during this dicussion.

1587112966
andrewrk
this is what it feels to argue with someone who has an open mind

1587112967
Xavi92
andrewrk: some lines ago you said `*Foo` and `*mut Foo` would prefer

1587112986
shakesoda
if it were decided already, the labels on the issue would be different

1587112999
Xavi92
andrewrk: Now you say you don't, as you said for #5056

1587113019
andrewrk
Xavi92, the thing you might have missed is

1587113056
andrewrk
specifically because it would mean the removal of the `const` keyword entirely

1587113103
antaoiseach
ohh... but I like the explicitness of `const` ;(

1587113110
Xavi92
andrewrk: if `const` was removed, then pointers would be immutable by default, right?

1587113112
andrewrk
5076 is a big change. it has the potential to piss off a lot of people who are currently happy and also attract people who currently are put off

1587113184
Xavi92
andrewrk: it definitely is. But if one likes C, then stick to C. Zig should be meant (among other thing) to provide an alternative to C

1587113194
andrewrk
Xavi92, it would flip things, yes, so  `*T` would be immutable, `*var T` would be mutable

1587113208
antaoiseach
:|

1587113216
shakesoda
Xavi92: you don't do better than C just by alienating all the C users

1587113229
andrewrk
change is not automatically better

1587113232
shakesoda
it's a little more involved than that

1587113241
Xavi92
andrewrk: alright, that's what we discussed a few hours ago, and it's what I would also prefer

1587113285
shakesoda


1587113285
Xavi92
shakesoda: I don't think default immutability would alienate all of the C users. It didn't alienate me, writing in C for a living

1587113318
shakesoda
Xavi92: right, I was poking at the logic of the statement, not the point being made

1587113376
Xavi92
shakesoda: I used that logic since I feel the impression const-correctness is not given proper importance since some C programmers just don't care about it (e.g.: the submovement andrewrk pointed out)

1587113395
daurnimator
FWIW I don't like destructing assignment.

1587113407
Xavi92
But I'm glad Zig moves towards default immutability

1587113427
shakesoda
const correctness in C isn't something I personally give much a crap about either

1587113442
shakesoda
but it's not because I don't give a crap about it, it's more because of how much of a hassle it is in C and C++

1587113505
Xavi92
shakesoda: that's why zig should make const-correctness easier

1587113521
shakesoda
zig already makes it so much better that I const nearly everything

1587113537
antaoiseach
Is there a consensus here? It's a bit confusing...

1587113557
daurnimator
I like that it requires a keyword to introduce a new variable

1587113593
shakesoda
daurnimator: I like destructuring just for effectively letting you have multireturns

1587113599
shakesoda
one of the lua features I really like

1587113621
daurnimator
I've learned that local-by-default is wrong; global-by-default is a foot-gun but required if you want to be config-language-like; so explicit new variable declaration with a keyword is the best option left

1587113637
andrewrk
torque, will you humor me? try converting 1 file from your project over to the proposal of #5076 and re-read the file, with an open mind to the new syntax

1587113639
daurnimator
shakesoda: lua

1587113653
andrewrk
and then tell me your honest opinion

1587113675
shakesoda
daurnimator: I know lua doesn't have it, I just mean that this in zig means we can have something vaguely similar

1587113698
antaoiseach
Where can I see this destructuing syntax? 5076?

1587113710
antaoiseach
destructuring*

1587113732
torque
andrewrk, I need to go to sleep (2am here). I will take another look at this tomorrow morning, though

1587113747
andrewrk
torque, good night and thanks for your thoughts

1587113951
shakesoda
andrewrk: I changed one of my files this way and I'm having trouble actually finding my variables

1587113959
shakesoda
the functions read fine

1587113989
andrewrk
when you say "find", can you elaborate?

1587114000
andrewrk
if it's a literal search, you can do `foo =`

1587114002
shakesoda
I mean I can't scan for my const assignments in blocks

1587114035
andrewrk
I experienced that feeling too, but I wonder if it is because we are used to using certain visual cues

1587114035
shakesoda
I can search for =, but I can't see the things among other code as I could the keyword

1587114048
andrewrk
or if something is actually now worse

1587114060
shakesoda
I've also had  this problem in, say, python.

1587114071
shakesoda
it's one of the things I don't like about it

1587114155
shakesoda
if I highlighted all my = signs as magenta or something I'd probably be able to mitigate it

1587114199
andrewrk
it is regexable

1587114218
andrewrk
but I'm not sure that's enough. I wonder if we can quantify the problem

1587115251
kenaryn
Please what purpose does a sentinel-terminated array serves?

1587115284
kenaryn
Is it useful when not dealing with any C code base?

1587115297
andrewrk
it's the type of string literals, makes it so you can cast string literals to both []const u8 and to null terminated pointers

1587115364
kenaryn
Thanks again andrewrk.

1587115922
nmeum
Hi, I am currently working on the Alpine Linux Zig package. As part of that package I would like to run the test suite using `./zig build test`. All tests seem to pass but `./zig build test` fails with an `unable to spawn ‚Ä¶` error message

1587115967
mikdusan
someone suggested `def` keyword, I interpreted it to mean `const` for decls:

1587115969
mikdusan


1587115991
mikdusan
meh i forgot it of course for the Foo :(

1587116204
Xavi92
mikdusan: why the `.` or `def` prefixes on struct members?

1587116303
mikdusan
`def` means immutable decl. `.` prefix identifies fields and drops use of `,` after field and uses `;` . this was another suggestion. I'm combining suggestions that seem to work together

1587116379
mikdusan
that combo is obviously a backtrack on the no-keyword = const decl + `set` for reassign

1587116562
Xavi92
mikdusan: unfortunately I don't understand the difference between, for example, `.a: u32;` and 'var a: u32;`

1587116611
Xavi92
mikdusan: I see one means 'field' whereas the other means 'decl rw', but I don't get the difference. Probably it's just me

1587116679
andrewrk
nmeum, I think you could do just fine with a subset of the tests

1587116741
andrewrk
nmeum, but perhaps that is an upstream issue we could look at

1587116796
mikdusan
nmeum: quick question: how much memory does alpine have?

1587116821
afontain_
what does that mean?

1587116861
nmeum
we have different builders with different resources available to them but it probably make sense to run a subset of the test suite, yes

1587116894
mikdusan
any idea how much? 4 GiB is likely not enough. 6 GiB is comfortable.

1587116899
mikdusan
RAM.

1587116981
nmeum
most builders should have more than that iirc, but the limiting factor is probably build time anyhow

1587117287
nephele
For compiler-rt, the input and output have to be C-values, but inside i can use zig values, is that correct?

1587117636
kenaryn
There're 3 occurences of 'const variable' in the docs, which is semantically insane. Wouldn'it be relevant to replace those by 'const identifier' or even 'const unit storage'?

1587117693
antaoiseach
exit

1587118231
ifreund
woah, a lot went down while I was sleeping

1587118306
ikskuh
ifreund: I thought the same right now

1587118312
ikskuh
reading some syntax change github issues :D

1587118320
ikskuh
the community was on fire!

1587118449
Xavi92
:)

1587118833
ikskuh
i wonder why nobody proposed "let x = 1" for mutation

1587119730
ifreund
honestly i'm totally fine with the more verbose `const foo = fn (bar: i32) bool {}` syntax

1587119839
ikskuh
yeah

1587119856
daurnimator
yeah I didn't find it the most objectionable

1587119861
ikskuh
after reading the whole thread, i think keeping `const f = fn() u8` is totally worth it

1587119865
daurnimator
just rules zig out for code golf ;)

1587119874
ikskuh
daurnimator: so? :D

1587119878
ikskuh


1587119892
daurnimator
if you can't win golf what sport

1587119913
ifreund
code golf isn't important, text editing golf is :D

1587119960
ifreund
honestly though, this may be an "avoid local maxima" thing, i'm interested to see what comes of it and will keep an open mind

1587119999
ikskuh
code golf is won by hq9+ by definition :D

1587120002
ifreund
right now though i feel pretty strongly that `const f = fn () u16` makes a lot more sense

1587124290
Xavi92
ifreund: so do I. As I said before, this syntax makes it consistent between functions, structs and enums

1587125357
ifreund
hmm, i think i might be beginning to come around to something like the proposed change, default immutability everywhere would be great and it does reduce visial noise

1587125427
ifreund
perhaps `const/var everywhere` is a local maximum and the new proposal is the global one we've been waiting for

1587125443
ifreund
super interested to see where this goes and what andrewrk decides in the end

1587125474
ifreund
this is a big change for sure, but it's

1587125515
ikskuh
ifreund, i don't think it will increase readability though

1587125519
ikskuh
imagine this:

1587125542
ikskuh
struct { foo : i32, bar = 10; }

1587125690
ifreund
ikskuh: i don't think that syntax would be accepted for that reason, there have been many differing proposals of how exactly the new declaration syntax would work

1587125712
ikskuh
yeah

1587125726
ikskuh
and honestly i don't think any of them is more readable without having to explain it first

1587125733
ifreund
all i'm saying is that we should keep an open mind and not let attachment to the status quo syntax influence our opinions

1587125821
ikskuh
yeah

1587125843
ikskuh
but i'm struggling with coming up with a better idea than status quo

1587125856
ikskuh
i posted it in discord earlier, but using operator semantics is a bad idea in general

1587125869
ikskuh
pascal: := assigns a variable, <= is less-equal, = compares for equality, == is a syntax error

1587125870
ikskuh
vhdl: := assigns a variable, <= assigns a signal, = compares for equality, == is a syntax error

1587125870
ikskuh
go: := declares a constant, <= is less-equal, = assigns a variable, == compares for equality

1587125870
ikskuh
c/c++: := is a syntax error, <= is less-equal, = assigns a variable, == compares for equality

1587126057
ikskuh
it really depends on what context you come from on how you interpret your operators

1587126071
ikskuh
so having a keyword is definitly the better option

1587126088
ikskuh
maybe something like pub/pri instead of "pub const" and "const" would be an option for global scope

1587126188
ikskuh
i really don't like "set" being a keyword, this is such a common function name

1587126464
Xavi92
ifreund: private should be implicit IMO. Similarly to default immutability, it is also safer to assume the most restrictive case here, and only specify 'pub' when needed

1587126936
Snetry
Well this doesn't seem good `Unrecognized glibc version: 2.31.9000'

1587128555
betawaffle
uhh, is the name `merge_anal_dumps` supposed to be a joke?

1587128568
xackus
anal = analysis

1587128580
betawaffle
i know, but still

1587129255
ikskuh
betawaffle: i giggle every time i read that :D

1587129274
fengb
Unleash your inner 12 year old

1587129353
ikskuh
yiss!

1587129608
ifreund
reminds me of the blood analysis bionic in CDDA which has the id `bio_blood_anal` of course

1587130886
Xavi92
betawaffle: sounds like the name of a brutal death metal band

1587134344
Cadey
ikskuh: `:=` in go creates a variable, it doesn't create a constant

1587134605
pixelherodev
It's amazing how much work you can get done when you don't have access to your compiler :P

1587134621
pixelherodev
Implemented about half the ISA in thirty minutes because I didn't have the option of testing every minor tweak

1587135729
ikskuh
Cadey, oh thanks. but same difference in the end

1587135742
ikskuh
pixelherodev: lul

1587135797
Cadey
constants are immutable at runtime, variables are mutable at runtime

1587135810
fengb
And it'll take 5 hours to debug now because nothing actually works? >_>

1587138755
fengb
‚ÄúThat was an impressive flood of pent-up bikeshedding‚Äù he‚Äôs not wrong :P

1587138801
ifreund
hah

1587139647
dimenus
fengb: what are you referring to?

1587139677
fengb


1587144282
kenaryn
Please does the expression `dereference a pointer` means 'unwrap the value pointed to' or 'cease to track the address location'? or does it account for something else?

1587144361
ikskuh
dereference is usually used to describe accessing the memory location stored in a pointer

1587144396
foobles
yeah. if you have a pointer to an int, dereferencing the pointer accesses int that is refered to by the pointer

1587144543
kenaryn
thank you both! I never fully grasp the concept of pointer until now.

1587144552
kenaryn
grasped*

1587144569
ikskuh
kenaryn: pointer are pretty simple in what they are

1587144586
pixelherodev
There a way to have std.testing return an error code instead of panicking?

1587144603
pixelherodev
I wanted to use errdefer to print a message on test failure

1587144708
pixelherodev
Nope.

1587144711
pixelherodev
Drats

1587144718
pixelherodev
Going to have to do a custom solution then

1587144737
ikskuh
kenaryn: give me a minute, i'll make a nice explanation :)

1587144749
kenaryn
You're kind!

1587144763
fengb
Back in my day, we only had peek and poke ü¶ñ

1587144769
fengb
Ints everywhere!

1587144802
kenaryn
In fact, I always thought 'deferencing something' was undesirable behaviour leading to memory leaks.

1587144877
ifreund
a pointer is just a type that stores memory addresses

1587144894
pixelherodev
Pedancy:

1587144896
pixelherodev
A pointer is just a number

1587144898
ifreund
these memory address happen to "point" to other variables usually

1587144900
fengb
Dereferencing hanging pointers and malformed pointers leads to security bugs

1587144913
pixelherodev
A pointer

1587144917
fengb
But it's not the dereference or pointer that causes it. It's a bad pointer value

1587144931
ifreund
pixelherodev: ok yeeees but that's pretty pedantic :D

1587144963
shakesoda
I think it's an important point though

1587144975
shakesoda
never to forget that types are a lie and memory is just bytes ;)

1587144977
pixelherodev
ifreund, like I said, pedancy

1587144982
pixelherodev
`<shakesoda> never to forget that types are a lie and memory is just bytes ;)` Seconded.

1587144996
ifreund
wise words :D

1587145007
antaoiseach
tell that to the haskell guys! :D

1587145010
shakesoda
I like to describe pointers to people unfamiliar as bookmarks

1587145021
fengb
At the end of the day, it's all bits

1587145031
fengb
So we might as well switch to 0s and 1s for everything

1587145061
shakesoda
types may be a lie but they are a useful lie for our mortal minds

1587145177
ikskuh
kenaryn:

1587145195
kenaryn
ifreund, when you said 'usually', does it imply that pointers can point to another kind of symbols? like a trait, a pragma, or even a function? or it just pointless? (i.e. useless).

1587145200
ikskuh
<pixelherodev> A pointer is just a number

1587145203
ikskuh
this is pretty much true

1587145211
kenaryn
lol

1587145223
kenaryn
nice one. Ready for the official doc!

1587145225
ikskuh
my image doesn't even use data types for exactly that reason

1587145225
ifreund
kenaryn: they can be danling and point to uninitialized memory if you screw up :D

1587145235
fengb
Anything in a computer is just a number üôÉ

1587145243
ifreund
and yeah function pointers are a thing, functions are types

1587145248
fengb
Technically true but functionally useless, just like my life

1587145265
ikskuh
fengb: but in the end it boils down to this

1587145284
ikskuh
everything we see, use and hear coming from a computer is just a huge amount of plain numbers :D

1587145310
ikskuh
kenaryn: on my example: I have four variables here: ptr_a, ptr_b, struct_a and struct_b

1587145314
fengb
There‚Äôs also translating into the analog world

1587145332
shakesoda
storing offsets in pointer types isn't that unusual

1587145333
fengb
One day we can directly consume digital information. One day...

1587145338
shakesoda
and those don't directly point to anything

1587145347
ikskuh
as you can see, each struct holds three values in our memory and the pointers both hold a single value

1587145350
mikdusan


1587145371
mikdusan
everything is just bits and bytes

1587145376
fengb
Array indexes are equivalent to pointer offsets

1587145386
fengb
Which is why C got so brain dead >_>

1587145404
shakesoda
fengb: this is one of the things I actually like about C

1587145409
shakesoda
the sheer simplicity of that

1587145413
ikskuh
but we can access the structs through the pointers: we look up the address of the pointer (this is done by the compiler), then we read the memory from this address (&ptr_a = 3) then read that memory (yields 10) and we can now access memory address 10 (which is where struct_a is in memor)

1587145429
shakesoda
but it is an improvement to be able to express more specifically what is pointed to

1587145449
fengb
It‚Äôs simpler for the computer yeah. But it‚Äôs semantically opposed to how people think about things

1587145486
fengb
Like passing arrays implicitly passes the pointer instead

1587145505
fengb
But it doesn‚Äôt do it for structs

1587145511
shakesoda
I don't specifically agree but I'm practically disqualified

1587145533
kenaryn
nice sheet ikskuh thank you for your time :)

1587145568
fengb
Or maybe it‚Äôs the other way around that‚Äôs the problem. Treating any pointer as indexable >_>

1587145583
shakesoda
fengb: it should be :D

1587145608
shakesoda
you can't tell me what to do! i'll scan all the ram i feel like!

1587145651
foobles
i just proposed yet another syntax for removing const :P

1587145659
shakesoda
smh

1587145680
fengb
My point is, I like that Zig distinguishes single and multi pointers, even if they‚Äôre the same number :P

1587145684
shakesoda
fengb: my mental model is far too computery by now maybe

1587145696
ifreund
yeah zig pointer are amazing

1587145705
ifreund
s/ter/ters/

1587145726
kenaryn
ikskuh, is the value 10 is a readable information for the end user (i.e. the programmer) or it is a "result location"? I'm not sure to follow.

1587145758
ikskuh
yes, it's readable

1587145764
kenaryn
my bad, didn't see your last explanation

1587145770
ikskuh
ptr_a = @intToPtr(*StructType, 10);

1587145780
ikskuh
would create the same pointer as well :)

1587145789
kenaryn
i'm subject to overhead overflow

1587145804
kenaryn
but the analysis cognitive semantic didn't catch it :D

1587146302
ikskuh
foobles: you're user00e00?

1587146359
foobles
ikskuh i am `theInkSquid`

1587146408
ikskuh
ah!

1587146410
kenaryn
Maybe he's a Nim guy who doesn't dare to admit he has switched towards Zig since Andrew told to his github community that they henceforth compile with `zig cc` :p

1587146444
ikskuh
i'm not sure if zig really needs destructuring

1587146475
kenaryn
theInkSquid? he's the buddy who hide his face in a black hood on his picture?

1587146503
foobles


1587146508
foobles
yeah

1587146511
foobles
thats me

1587146515
ikskuh
i decided against it most of the time when i could've used it because it's clear when you write the code, but not that much anymore if you change code later

1587146537
kenaryn
lol what is the anime's name already? isn't that Evangelion ?

1587146571
fengb
Yeah I‚Äôm not a big fan of destructuring

1587146586
foobles
I actually haven't seen it, I picked the image because it was used as cover art for an Internet Club album. I think the anime is Mobile Suit Gundam

1587146588
fengb
But I also don‚Äôt like aliasing in general. Full namespaces for me!

1587146609
kenaryn
exactly, thanks for remembering.

1587146658
kenaryn
Agreed, aliasing defeat the purpose of `Only one obvious ways to do things` and we end up with a coding guideline style for each programmer.

1587146668
antaoiseach
kenaryn: I tried liking Nim, but the language was madness beyond the basics... couldn't make much sense of metaprogramming

1587146697
companion_cube
macros are for advanced use, right?

1587146709
antaoiseach
I am a Zig newbie and I quite like Zig - I just hope the language manages to remain as simple as possible with as less magic as possible - explicitness is always nice

1587146730
antaoiseach
companion_cube: yes, I suppose so

1587146733
kenaryn
Yes something verbosity is for the greater good.

1587146736
kenaryn
sometimes*

1587146742
shakesoda
full namespaces everywhere just makes code needlessly long

1587146748
shakesoda
sometimes by a disgusting amount

1587146749
antaoiseach
nothing better than Common Lisp's metaprogramming for me personally... smooth as butter

1587146762
companion_cube
except CL isn't typed‚Ä¶ ü§∑

1587146764
fengb
I don‚Äôt agree it‚Äôs needless

1587146766
shakesoda
now sure how that came up here though

1587146767
companion_cube
anyway so far I like nim

1587146780
antaoiseach
companion_cube: hahaha, yeah, that's why its metaprogramming is so flexible!

1587146795
kenaryn
Do you have Nim full-time jobs offers in Canada?

1587146810
shakesoda
bold of you to assume full time jobs still exist

1587146818
kenaryn
or is it considered too "exotic" like in west europe

1587146828
antaoiseach
companion_cube: I worked through the Nim tutorials a year back (or so) - part was great... part 2 is when I quit

1587146845
kenaryn
yeah boldness shall be added to zig zen.

1587146859
antaoiseach
bold concurrency?

1587146863
antaoiseach
Hahaha... just kidding

1587146864
companion_cube
antaoiseach: you don't have to learn everything at once though :D

1587146911
antaoiseach
companion_cube: that's true.. I had even bought dom96's book... maybe someday again

1587147014
antaoiseach
btw, do we have a bot that compiles Zig code here? I remember the Haskell IRC had a bot like that...?

1587147120
TheLemonMan
kenaryn, status.im has a team of Nim programmers

1587147170
TheLemonMan
Nim metaprogramming is the absolute bomb

1587147435
dom96
antaoiseach, what in part 2 made you quit? :)

1587147515
antaoiseach
dom96: It was a year ago so can't give specifics, but the whole metaprogramming bit (I'm referring to the official tutorial, of course) just went over my head...

1587147533
shakesoda
metaprogramming stuff frequently has that problem as a whole

1587147534
antaoiseach
Maybe it's just me! :D

1587147587
shakesoda
(along with the other enemy: oop)

1587147627
companion_cube
sometimes it can make code simpler, if you use codegen for openapi or parsers or the likes

1587147686
shakesoda
metaprogramming helping anything is the edge case

1587147701
shakesoda
not to be confused with me having problems with a language having good tools for it

1587147725
companion_cube
every language with metaprogramming has warnings that say "only reach for that if you don't have a choice" :D

1587147738
shakesoda
and people reach for it when they DO have a choice :(

1587147758
shakesoda
maybe I should take a harder stance on this

1587147765
shakesoda
just say no!

1587147767
companion_cube
yeah but people abuse all available things

1587147774
ifreund
i tend to agree with shakesoda

1587147794
ifreund
when you have to write code to write your code for you, you're shit is too complex

1587147803
ifreund
s/you're/your

1587147805
shakesoda
you also no longer have any idea how much code you truly have

1587147835
shakesoda
won't someone please think of the compile times

1587147871
shakesoda
current project I'm on at work certainly did not think of the compile times, so a lot of my time is spent just waiting around for the damn thing to build

1587147912
shakesoda
& this is a direct result of opting for designs far less simple than they could be

1587147947
shakesoda
complaining aside, anyone doing ludum dare (maybe even with zig)?

1587147965
fengb
My first job we had some amazing idea to do code generation in Java

1587147968
companion_cube
what if you generate bindings to other projects?

1587147984
fengb
So the project ended up generating code to half compile to generate more code

1587147992
shakesoda
companion_cube: I'm all for writing code generators that spit out a file once and you just use it.

1587148007
fengb
It took hours to setup the dev machine

1587148008
shakesoda
doing that stuff at build time on the other hand

1587148008
companion_cube
if you commit the generated code, yeah

1587148020
shakesoda
i had this problem with the opengl bindings with rust

1587148040
companion_cube
well it's that or not having bindings‚Ä¶

1587148042
shakesoda
they're build time generated from the specs or some crap and it adds +30 seconds to even touch anything that comes near GL

1587148077
shakesoda
which was a cost so unacceptable that I scrapped the project and brought in my C library to do all that stuff

1587148104
companion_cube
probably from the xml description of the API

1587148169
shakesoda
I'm all for one-time code generation though, I have written a few of those to do things like generate my haxe bindings (for love and lovr)

1587148184
companion_cube
and then you edit the generated code?

1587148188
shakesoda
yeah

1587148195
companion_cube
kind of makes sense I guess :D

1587148215
dom96
There is a fine balance between too much complexity and too little

1587148220
dom96
Go is far too little

1587148231
dom96
Rust just on the edge of too much

1587148233
shakesoda
too little is the side I'd rather be on, because it's a lot easier to deal with.

1587148242
dom96
Not sure where Zig stands, but Nim is pretty perfect in the middle for me :)

1587148251
shakesoda
too much makes things utterly incomprehensible (and ***slow***)

1587148270
shakesoda
nim isn't my flavor but not for any kind of technical reasons

1587148284
shakesoda
it's just not my flavor in the same way python isn't

1587148655
foobles
alright here is another proposal

1587148658
foobles
good god

1587148663
foobles
6 hours of my life...

1587148693
fengb
Same lol

1587148697
TheLemonMan
too many proposals and not enough code

1587148722
shakesoda
the sheer level of activity on the proposals right now should be enough reason for pause

1587148787
shakesoda
foobles: I actually like the .= proposal (as much as I'll like any of them in that thread...), it seems the simplest one

1587148821
fengb
I don‚Äôt like .= because it makes field assignments look different from variable reassignment

1587148841
shakesoda
damn you, multiple assign proposal

1587148850
fengb
Unless it‚Äôs .= everywhere in which case I‚Äôm really not liking it >_>

1587148866
shakesoda
I like it in the sense of "I hate it the least"

1587148885
mikdusan
yeah multiple assign is the pita

1587148920
mikdusan
one suggestion was that it only be used during decl

1587148930
shakesoda
also I really don't even want multiple declaration to exist for any case other than destructuring a tuple

1587148959
shakesoda
multiple declaration/assignment hurts legibility severely in basically all cases other than destructure and multireturn D:

1587149004
fengb
How about === for declaration? üôÉ

1587149005
shakesoda
I've been removing code like that constantly over in this c++ mess

1587151363
kenaryn
Please does `is_test` check for the presence of a `test` block? Is it not documented yet and appears here:

1587151413
TheLemonMan
no, it's a boolean that's only set when you `zig test` something

1587151454
kenaryn
Ah allright, thanks for the explanation.

1587151558
kenaryn
When a void value is returned, does the semantic analyser compute something? (i.e. use time and/or space), or does it deal with it like a human mind? (i.e. doing nothing).

1587151665
vlad9
I'm trying to build tetris on mac and getting this error: `unable to create target: 'Unable to find target for this triple (no targets are registered)'`; any pointers how to fix this?

1587151953
vlad9
I'm guessing my target is `x86_64-apple-darwin18.2.0`; how do I register it?

1587152509
andrewrk
vlad9, I'm not able to reproduce this issue

1587152522
andrewrk
let's figure out what is different on your system than mine

1587152679
mikdusan
s/apple/macosx

1587152716
mikdusan
err not this is a clang target?

1587152755
andrewrk
ok I have reproduced this issue. Homebrew has modified the default configuration llvm/clang to disable targets. Zig cannot use it as a dependency

1587152772
mikdusan
wow that is a build option?

1587152890
mikdusan
oh sorry you mean actual targets

1587152900
companion_cube
andrewrk: so what's your next target? :)

1587152961
vlad9
andrewrk: is it possible to configure clang somehow?

1587152979
andrewrk
homebrew zig package is fundamentally broken. homebrew has to be convinced to change their llvm/clang package

1587153003
vlad9
alternatives?

1587153010
andrewrk


1587153013
andrewrk
Your options are to build llvm/clang/lld from source, download a prebuilt tarball, or convince homebrew to improve their packages

1587153095
mikdusan
i feel that packagers try too hard to make evertyhing share. sometimes a dependency is rightfully explicit and private for a package.

1587153175
fengb
Oof

1587153177
andrewrk
really feeling the weight of llvm as a dependency right now

1587153232
BaroqueLarouche
we'll do our own backend, with blackjack and hookers

1587153256
TheLemonMan


1587153316
andrewrk
TheLemonMan, what about clang

1587153345
TheLemonMan
that variable is valid for llvm and clang

1587153439
andrewrk
echo "void foo(void) {}" >test.c && ./zig clang -c test.c

1587153452
andrewrk
error: unable to create target: 'unable to find target for this triple (no targets are registered)'

1587153518
andrewrk
we have

1587153765
mikdusan


1587153860
TheLemonMan
maaaaybe we should call LLVMInitializeAllTargetInfos and friends?

1587153915
andrewrk
we do that for zig code. but why should we call that before calling clang's main() ?

1587154000
foobles
andrewrk going back to last night's discussion, do you really think it's a good thing to have mixed assignment/declaration in the same statement? I think that would be a monster to read in some cases, and it would just be better to declare a temp variable and assign on the next line.

1587154027
foobles
I have a  new proposed syntax too, for the last comment on #576

1587154037
andrewrk
the only point of multiple assign is to avoid declare and assign on separate lines

1587154065
foobles
whats wrong with doing that?

1587154072
andrewrk
TheLemonMan, it doesn't solve the problem, just tested it

1587154101
andrewrk
I have a feeling this is some more B.S. having to do with c++ static initializers

1587154118
foobles
I think it would be easier to learn, for multi-assign to be all-initialization or all-assignment

1587154125
andrewrk
foobles, because it involves a variable + undefined instead of a constant

1587154136
TheLemonMan
just declare osx as a whole as a tier4 platform and be done with it heh

1587154152
foobles
andrewrk not necessarily, look at this example

1587154159
foobles
wait i didnt mean to hit enter

1587154239
andrewrk
TheLemonMan, I'm working on a stage2 IR proposal / first passing test case. hopefully will have that available for you to provide some feedback on within a few days

1587154281
pixelherodev
Stage2 IR stuffs?!

1587154288
andrewrk
oh yeah, pixelherodev is going to be all over this too

1587154325
foobles
@ande

1587154331
foobles
andrewrk

1587154340
pixelherodev
Okay I really ought to get back to work on ZiggIRat

1587154341
foobles
you wouldn't need var+undefined given what i am proposing

1587154353
pixelherodev
If there's self-hosted IR handling, I can just pass that straight through to a treegen

1587154360
pixelherodev
and skip the LLVM stage entirely

1587154384
pixelherodev
If I clean up my JIT emitter and add ELF generation, I can get an (inefficient) x64 backend pretty easily

1587154385
TheLemonMan
noice

1587154388
pixelherodev
hmm

1587154435
andrewrk
foobles, I see

1587154509
andrewrk
let me consult my crystal ball

1587154777
mikdusan
foobles: `:=` for assign and destruction syntax reworked

1587154779
mikdusan


1587154808
TheLemonMan
andrewrk, the DIEnumerator patch got approved, thanks for pushing the llvm devs to review it

1587154829
andrewrk
thanks for the patch. glad to hear it's going in

1587154915
foobles
mikdusan my only gripe with using `:=` for reassignment, is that `:` currently is only used in declarations. My syntax does propose taking the `:` out of type-specifiers, but I feel like there is already a precedent for `:` being used with declarations only (variables/members/parameters)

1587154928
foobles
so I think `=` should be reassignment, even though it is less common

1587154975
fengb
Are we planning on keeping = for field assignment?

1587154982
foobles
that I what I think

1587154986
foobles
because they are declared in the struct

1587154990
fengb
I think it makes sense for field assignment to match var reassignment

1587155010
fengb
And at that point, it's not apparent to me that declarations would be more common

1587155016
foobles
so field default should use `:=`, but field assignment/initialization should use `=`, since the member is already declared in the struct

1587155024
foobles
yeah

1587155081
andrewrk
I wonder if I would get murdered if I simply removed reassignment syntax entirely

1587155092
andrewrk
(&x).* = new_value;

1587155123
fengb
I'm actually fine with that

1587155143
andrewrk
I thought you wanted to see `const` in front of const decls

1587155185
mikdusan
the main crash with `:=` was multi-lhs. so solving multi-lhs with making it "uniform" (no mixing) pretty much removes the sole reason andrew vetoed `:=`... I guess my last gist could just as easily be `:=` for decl, and leave `=` to always mean assign

1587155216
andrewrk
I think foobles's latest suggestion to simply disallow anything but const decls for multi-assignment recovers the viability of :=

1587155217
fengb
I like status quo the most, but I mostly want to keep declarations greppable

1587155222
fengb
And scannable

1587155244
andrewrk
declarations are even more greppable with dropping const: search for `foo =`

1587155267
fengb
But it'll also be mixed with reassignment with the current semantics

1587155273
foobles
true, but with `:=` you could just search for `:=` :)

1587155287
fengb
And needing to follow context to understand the difference isn't great

1587155317
andrewrk
since the whole point of multi assign is to avoid `var` and `undefined`, it's reasonable to restrict it to only const decls

1587155358
foobles
did you see my proposal

1587155374
companion_cube
wait, what's := about? is this becoming Go? :s

1587155375
foobles
I think it would be pretty nice to read and write

1587155424
TheLemonMan
companion_cube, or ocaml's ref :)

1587155432
foobles
also even though declaration is more common, a bigger operator for it makes it easier to scan for with your eyes

1587155433
companion_cube
yeah well, not the best part of the language

1587155464
companion_cube
`.x i32 := some_default` waaaa

1587155474
companion_cube
getting further from ML :(((

1587155527
BaroqueLarouche
we should rather use :: than := if we want to go that route

1587155554
companion_cube
good modern grammars prefix declarations with something‚Ä¶

1587155561
companion_cube
a = 1 is python

1587155582
TheLemonMan
what's wrong with the status quo?

1587155589
mikdusan
foobles: one thing if we don't invert. that is, if `:=` is used for decl... `var i: u32 = 10;` or `var i: u32 := 10;` . the former makes search/scan less obvious. the latter lots of `:`

1587155620
foobles
mikdusan did you read my proposal? I suggest getting rid of `:` for type specifiers

1587155627
companion_cube
please don't

1587155633
foobles
so it would be `var i i32 := 10;`

1587155637
foobles
i think thats fine

1587155643
andrewrk
TheLemonMan, how do you feel about using `const foo = fn ...` for every function with #1717 ?

1587155655
companion_cube
why is 1717 such a big deal anyway? :/

1587155678
andrewrk
status quo is viable. just to be clear

1587155687
foobles
because now almost every single thing at global scope will be prefixed with const, decreasing readability imo

1587155691
foobles
its just noise

1587155693
companion_cube
imho status quo is 10,000√ó better than this Go-like stuff

1587155706
companion_cube
foobles: not noise, it clearly shows where declarations are

1587155713
TheLemonMan
andrewrk, eh I don't really mind

1587155723
torque
I don't think that declarations being prefixed is "noise"

1587155741
andrewrk
TheLemonMan, that's good to know. one thing I learned from this hot topic is that many people are happy with status quo, even given extra typing for function decl syntax

1587155747
companion_cube
(`let` at toplevel might be shorter than  const, as someone points out in the issue)

1587155752
fengb
Let's have a 1 character wide keyword. How about üí©

1587155769
companion_cube
`let f = fn() ‚Ä¶` is ok I guess

1587155777
mikdusan
foobles: yes I see it now

1587155804
torque
I am still boggled by people seeming to care about number of keystrokes

1587155821
torque
if we really wanted to minimize keystrokes, all variable names would be 1 letter long

1587155832
fengb
One thing that I would like is making const easier to declare

1587155851
companion_cube
cst x = 1

1587155859
foobles
keystrokes arent the matter for me, its visual noise. almost everything at top-level will be easily discernable even without the word `const`, and so I think `const` becomes noise

1587155875
companion_cube
foobles: `const x = ‚Ä¶` makes it regular and clear that this declares `x`

1587155879
companion_cube
same for `var x = ‚Ä¶`

1587155880
andrewrk
const is clearly noise at the global scope. but it's a given that the syntax for decls will be the same in global and local scopes

1587155894
companion_cube
just having `x = ‚Ä¶` makes it less clear if it's assignment or declaration (die, python, die)

1587155906
andrewrk
I think foobles understands the tradeoffs at stake

1587155933
andrewrk
I'm curious if torque and fengb would consider := to adequately denote const decls

1587155947
torque
If the goal is to force programmer behavior through language expression, I think rust's approach of forcing mutable variables to have an additional keyword is the way to go, though `const var` probably isn't going to work for us

1587155960
companion_cube
I find it not regular to have some declarations be keyword free, though

1587155970
fengb
I didn't like := at first but it's grown on me. At the very least, it's sufficiently different from =

1587156000
fengb
And it

1587156025
fengb
it offers an easier path towards const, which I'm generally in favor

1587156037
companion_cube
why not `let` then?

1587156041
mikdusan
ahhhh

1587156045
foobles
`let` was rejected long ago

1587156048
foobles
apparently

1587156061
torque
I'm generally not a fan of adding new symbols to the language and I prefer a prefix keyword (I think I'd consider := to be noisier than `const`, since my brain primarily reads english, not bizarre punctuation constructs)

1587156076
fengb
Just saying in general, I like const the most but := is okay too

1587156077
andrewrk
let is not better than const, it's the same or worse

1587156095
companion_cube
it's as short as var

1587156095
torque
well, if the argument is that "const is harder to type than var", that's not true

1587156096
shakesoda
it's only better if your interest is saving a few characters

1587156104
andrewrk
saving a few characters is not the point

1587156122
fengb
shakesoda: unfortunately some people default to var

1587156136
hryx
Just catching up. That idea of restricting a destructure to either declare or reassign (not mixing) seems smart. I dunno when one would want to mix those

1587156142
fengb
Which removing the const keyword might convince them to const by default

1587156157
torque
I don't think a language should bend to try to fix one person's sloppy code

1587156168
fengb
hryx: Go does it really often, but it's also a byproduct of its design >_>

1587156178
foobles
yeah, we have error unions

1587156179
companion_cube
Go's syntax is truly awful, though ü§∑

1587156180
andrewrk
zig's design is 100% benst around making it harder to write sloppy code

1587156192
andrewrk
wow look at me turn that "bent" into a "const"

1587156195
fengb
I think if a language can offer saner defaults that aren't too intrusive, we should consider them

1587156206
hryx
fengb: in Go, that has actually caused me bugs

1587156212
torque
I mean, it's kind of weird seeing this discussion so immediately after the "pass pointers const by default" was rejected so decisively

1587156239
andrewrk
the two are related

1587156260
companion_cube
(ah, there's also "val" if you feel like writing scala)

1587156284
torque
yes, I agree, but the bigger thing is that it seems like the arguments in favor are essentially the same

1587156305
fengb
Let's make all constants be prefixed with k üôÉ

1587156312
andrewrk
I want to note that zig does create local automatic temporaries on behalf of the programmer. plenty of expressions will have hidden

1587156338
companion_cube
I mean, as soon as you write `f(g(x))` it happens, right?

1587156348
andrewrk
yes depending on the type of g(x)

1587156358
companion_cube
I don't think it's really related to syntax issue

1587156365
andrewrk
creating a named constant local declaration is one of the safest, cleanest, most readable things you can do

1587156378
andrewrk
I like that `a = b;` as a const decl rewards this

1587156380
companion_cube
and it should be clearly indicated with a keyword ü§∑

1587156387
andrewrk
zero syntax overhead

1587156392
companion_cube
a = b; means assignment in 99% of languages :/

1587156403
torque
<andrewrk> zig's design is 100% benst around making it harder to write sloppy code <-- I disagree with this to a certain extent. I think if you do this, you end up with rust. at a language level zig does not try to remove the ability for the programmer to make memory or concurrency-related mistakes

1587156419
shakesoda
not being able to actually identify decls based on furthest left is not good

1587156428
companion_cube
^

1587156432
foobles
andrewrk thats why I feel that `:=` is a happy medium for declaration. It's big enough to be disinct from reassignment, and also sort of pops out to the eye

1587156440
foobles
and it has precedent

1587156449
companion_cube
well, ugly precedent

1587156451
companion_cube
:)

1587156452
andrewrk
torque, on the other hand, the borrow checker can force a programmer down a path of unnecessary heap allocation / reference counting to make the compiler happy, whereas zig programmers are free to pursue more resource-optimal code

1587156461
shakesoda
torque: rust takes it to an obsessive extreme

1587156470
torque
now there's arguably a threshold for "reasonable problems to mitigate" and I think zig has so far struck a happy medium there

1587156471
companion_cube
not that obsessive, they have `unsafe`

1587156488
shakesoda
which itself is obsessive

1587156493
karrick
One of the frustrating things about Go to newcomers is the subtle differences between using `var foo int; foo = 3;` and `foo := 3;`

1587156524
torque
If I were absolutely forced to make a decision, I would definitely take `:=` over having to use a keyword to perform normal (re)assignment

1587156553
shakesoda
i'd be okay with `:=`

1587156559
karrick
it is pretty straightforward, but in golang slack, lots of golang newbies struggle with understanding when each could be used.

1587156561
shakesoda
but I don't like it

1587156577
companion_cube
I'd rather pick the status quo, tbh

1587156582
shakesoda
me too.

1587156590
companion_cube
not having `a = b;` be an assignment will alienate all these C programmers :D

1587156598
companion_cube
(and java, and C++, and‚Ä¶)

1587156610
andrewrk
we have a lot of votes for status quo, which I will remind everyone still remains the null hypothesis

1587156614
fengb
They're already pissed off that we have backwards type signatures >_>

1587156634
companion_cube
yeah but they know they're wrong on that one, function pointer types are known to suck

1587156655
companion_cube
(and it blends better with type inference)

1587156655
torque
But I'm still trying to wrap my head around the actual high-level goal here: is it increased use of `const` to reduce problems associated with mutability? is it reduced use of `const` to remove line noise of the code (which I think is a very subjective claim)?

1587156659
ifreund
status quo or `:=` both seem like good options to me, I'm really not a fan of the new keyword to reassign though

1587156680
foobles
My proposal still uses `=` for reassign

1587156691
shakesoda
backwards types have all kinds of nice properties about them

1587156692
foobles
i agree, a keyword for reassign is bad

1587156701
companion_cube
shakesoda: they're forward, not backward ;)

1587156703
shakesoda
and they're good for consistency, etc

1587156709
shakesoda
companion_cube: relative backward :)

1587156713
andrewrk
ifreund, at this point I'm even more a fan of requiring `(&x).* = new_value;` than a new keyword for reassigning

1587156727
companion_cube
:D

1587156729
ifreund
:D

1587156736
shakesoda
I'm used to zig's type syntax anyways, I write a lot of haxe

1587156737
companion_cube
so I guess we're safe on this one

1587156755
andrewrk
"why is reassignment so awkward?"  "why are you reassigning stuff?"

1587156761
fengb
How about a new mutation postfix operator

1587156770
fengb
x.! = value

1587156780
andrewrk
you're like 18 hours behind in the issue comments

1587156780
ifreund
please no

1587156781
shakesoda
why reassigning? perhaps because i'm programming

1587156784
shakesoda
:D

1587156788
fengb
Doh

1587156789
torque
why is reassignment suddenly The Great Evil

1587156796
fengb
There's a million comments

1587156801
ifreund
it means your code is too complex

1587156806
andrewrk
because it's between the rock and the hard place

1587156814
companion_cube
wow, so we won't have loops anymore? :D

1587156815
fengb
I feel like I miss half an hour and I can't catch up

1587156820
ifreund
you should be able to do everything without reassignments if you're big brained enough

1587156860
karrick
Is there a GitHub issue discussing this issue so I can see the thing being resolved?

1587156872
karrick
not resolved, but discussed.

1587156883
companion_cube


1587156891
torque
the SNR in the github issue is about the same as it is here

1587156900
karrick
gracias

1587156939
andrewrk
I recommend to read SpexGuy's summaries and nothing else

1587156950
ifreund
^

1587156954
ifreund
SpexGuy rules

1587157044
pixelherodev
I'm guessing there's no way to specify a slice's

1587157068
pixelherodev
As an optimization for emulated ROM access, I'm subtracting the virtual base from the pointer

1587157079
pixelherodev
So that e.g. `buffer[0xFFFE0000]` gives the first byte

1587157087
pixelherodev
Except that's, quite reasonably, out of bounds

1587157095
shakesoda
clear solution to all kinds of syntax concerns, just remove all rmw operators

1587157108
shakesoda
goodbye, +=!

1587157114
pixelherodev
Eh, I'll just up length by 0xFFFE0000 as well

1587157118
pixelherodev
That's a brilliant solution.

1587157120
foobles
i remember you saying you liked lua :P

1587157121
shakesoda
let the lua flow through you

1587157129
pixelherodev
Oh wait, just turn it to a normal pointer-to-unknown

1587157159
shakesoda
lacking rmw operators is both a nice simplification and an annoying and error prone inconvenience in lua

1587157168
companion_cube
btw lua has `local` which is also super long :D

1587157177
shakesoda
zig also has local, to be sure

1587157181
shakesoda
it just means something completely different

1587157193
companion_cube
I mena, in lua, `local` should be the default, right? but it's verbose

1587157194
mikdusan
foobles: this one is `:=` back for decls (I left `:` for type spec.. it actually doesn't bug me). imo `:=` is pretty easy to parse for decls:

1587157197
mikdusan


1587157218
mikdusan
^ wrong link. correct:

1587157233
foobles
yeah, that might be fine

1587157234
companion_cube
mikdusan: not for me, since `:=` is in the middle of the line, whereas let/const/def is at the beginning

1587157235
shakesoda
companion_cube: it should be the default, but lua has global by default due to intent to be usable as a configuration lang etc

1587157241
companion_cube
ü§∑

1587157250
shakesoda
companion_cube: which is... one of the things in it I don't really like

1587157392
companion_cube
what's the benefit of 1717 already?

1587157405
companion_cube
cause one of the two issues pointed to in its preamble is closed ("closures"?)

1587157418
mikdusan
anon functions

1587157422
companion_cube
and I independently thought Zig wasn't going to have closures

1587157422
shakesoda
anon functions!

1587157429
companion_cube
that would not be closures?

1587157429
shakesoda
they're useful without being closures.

1587157433
companion_cube
I don't see why

1587157442
mikdusan
no closures are different. they capture values

1587157443
shakesoda
I almost never actually need variable capture

1587157444
companion_cube
I've never seen anonymous functions without closure semantics

1587157490
ifreund
anon functions are super useful even wihout closure stuff

1587157491
karrick
reading the GitHub issue... holy cow this discussion is years old!

1587157508
shakesoda
it's useful immediately for passing functions (sort functions and such), little one-off things you'll need in a block... etc

1587157515
shakesoda
I use them a fair bit

1587157521
ifreund
idk if closure style capturing even has a place in zig tbh, it can lead to hard-to-follow code

1587157526
companion_cube
well, for sort functions, I'll most likely need some closure state

1587157531
shakesoda
why would it?

1587157536
shakesoda
they can have arguments.

1587157558
shakesoda
again, I use these all the time without doing captures.

1587157570
shakesoda
in languages that

1587157574
companion_cube
and I use them all the time (in OCaml) with closure capture :/

1587157577
companion_cube
like, a lot

1587157583
companion_cube
but then it goes with having map, filter, etc.

1587157605
shakesoda
captures are useful, but they're not required to make anon functions useful

1587157616
companion_cube
I mean, ok

1587157619
shakesoda
you get a lot of utility independently

1587157647
fengb
Besides, we already have anon functions already. They're just really kludgy and not-at-all obvious to a newcomer

1587157655
companion_cube
(hey if anonymous functions are a thing, why not have `fn (x:i32) i32 { x+1 }` work? it's more readable :p)

1587157658
companion_cube
(oops)

1587157666
shakesoda
the struct hack for them is nasty enough to want to never actually use it

1587157688
shakesoda
you can also do that in pre-c++11 c++, and it's gross there too :P

1587157729
mikdusan
companion_cube: aside from missing `;` why wouldn't it work?

1587157736
shakesoda
companion_cube: not much a fan of implicit returns like that

1587157743
mikdusan
oh

1587157745
companion_cube
mikdusan: because blocks are not expressions right now

1587157747
mikdusan
you mean no return. agh.

1587157754
companion_cube
or they only are with a weird syntax

1587157766
shakesoda
that said, in my haxe code I do sometimes use that kind of function form for little stuff

1587157769
companion_cube
it's interesting where different people want shortcuts at different places

1587157778
companion_cube
(like toplevel const, vs block expressions)

1587157779
shakesoda
the (x, y) -> x+y shortcut

1587157794
companion_cube
the `{x;y;z}` returning `z` shortcut

1587157817
companion_cube
(

1587157821
shakesoda
I just think that "the last thing in a block without a semicolon is returned" is WAY too subtle

1587157831
shakesoda
that makes me scan for damned semicolons

1587157834
mikdusan
and to return nothing? end with void?

1587157842
foobles
end with semicolon

1587157846
companion_cube
^

1587157852
companion_cube
`a; ` is short for `a; void`

1587157853
shakesoda
semicolons are already visual noise that I reduce the visibility of with my highlight colors...

1587157867
companion_cube
well it doesn't seem to be a problem in reason or rust

1587157873
companion_cube
but I guess the crowd here doesn't like that

1587157875
foobles
yeah, i thought it would be

1587157878
shakesoda
I don't like them in rust either

1587157886
shakesoda
it's one of my annoyances with it, heh

1587157925
companion_cube
oh really?

1587157930
fengb
How about we revive the comma operator

1587157934
companion_cube
I'm just too used to having expressions everywhere

1587157944
mikdusan
ok `|x| { x+1 }` <-- when using pipes means block is expression-syntax. but then that is opposite of our current unwrap blocks.

1587157950
shakesoda
fengb: to do what

1587157973
fengb
Return the last thing üôÉ

1587157975
companion_cube
fengb: oh yeha, I'd write `(a, b, c)` instead of `{a;b;c}` üòç

1587158022
shakesoda
fengb: D:

1587158071
shakesoda
that sounds like code I'd gaze upon in horror before refactoring to not do that

1587158122
shakesoda
or in high volume I'd just cut my losses and jump ship from

1587158300
Snektron
nothing like putting `template <typename A, typename B> A operator,(A a, B b) {return a;}` in someones code

1587158383
shakesoda
Snektron: I might actually consider no longer working with someone over a few instances of that

1587158393
karrick
FWIW, when I do some JavaScript programming, I do something very similar to this expression on #1717: `pub const main = fn() void {` and I quite like it.

1587158401
shakesoda
as nothing good can come of it

1587158427
shakesoda
karrick: yeah, I use the form a fair bit in lua.

1587158448
Snektron
i'd also like to point out that defining functions as `name =` makes it really easy to find a declaration with grep

1587158463
foobles
yeah

1587158474
foobles
here is an example translated to the syntax suggested in my proposal:

1587158476
foobles


1587158497
companion_cube
almost at `public static void main`!

1587158539
karrick
What I do not get is how in some of the structure examples I have seen, properties are declared with colon syntax, but methods are bound using an equal sign in the same structure declaration.

1587158555
shakesoda
foobles: and as for vars?

1587158556
karrick
companion_cube: yeah, that's what I thought too... /shrug

1587158559
companion_cube
:D

1587158614
foobles
karrick that is because defaults are put with the _declaration of the member_, so they should use `:=`, while field initialization is external to the declaration, meaning `=` should be used

1587158630
foobles
shakesoda `var x := y;` is my goto

1587158631
fengb
We could replace the pub keyword with exposing anything starting with a capital letter üôÉ

1587158635
foobles
NO

1587158639
foobles
GO GOT THAT WRONG

1587158647
companion_cube
go got everything wrong :p

1587158697
karrick
such hatred... ;)

1587158755
shakesoda
foobles: ok

1587158760
pixelherodev
Gah

1587158762
companion_cube
well they NIH'd some parts uselessly (like the syntax), and stayed in 1970 for other things ;)

1587158767
pixelherodev
Where's the default Zig linker script??

1587158793
andrewrk
pixelherodev, I've been meaning to figure that out. I think that is currently determined by LLD's code

1587158808
pixelherodev
Noooooo

1587158812
pixelherodev
:(

1587158817
pixelherodev
Trying to adjust it for

1587158817
pixelherodev
uh

1587158820
pixelherodev
totally legitimate reasons

1587158847
pixelherodev
Definitely not trying to map the entire 32-bit address space

1587158976
pixelherodev
So we use the default LLVM one?

1587159037
pixelherodev
Idea!

1587159040
pixelherodev
`find / -name \*.ld 2>/dev/null`

1587159069
pixelherodev
Nothing. (nothing relevant at least)

1587159151
ikskuh
pixelherodev: pacman -Ql llvm

1587159176
pixelherodev
Not on arch

1587159210
ikskuh
damn

1587159254
companion_cube
:DDD worth a try

1587159266
ifreund
who else isn't on arch, raise your hands

1587159270
marijnfs


1587159286
marijnfs
definitely investing related

1587159290
ikskuh
nope, nothing in there

1587159305
pixelherodev
`equery f lld` doesn't give anything

1587159310
pixelherodev
I think it might be embedded in the binary

1587159318
pixelherodev
... `strings /usr/bin/lld` maybe

1587159347
ikskuh


1587159402
pixelherodev
...

1587159405
pixelherodev
that's the parser...

1587159434
ikskuh
yeah, true

1587159455
pixelherodev
Suspicion: they might not have one

1587159466
pixelherodev
They might use defaults for if no script is specified

1587159514
ikskuh
yeah probably

1587159556
pixelherodev
Which is just ugh

1587159660
ikskuh


1587159693
ikskuh
there isn't much sectioning going on at all

1587159708
pixelherodev
Yeah...

1587159877
pixelherodev
If I remove stuff from the GCC binutils one it works

1587159893
pixelherodev
but then if I try moving it above the 32-bit layer it's right back to `relocation R_X86_64_32S out of range`

1587159924
ikskuh
well that's probably true

1587159940
ikskuh
don't compile with fPIC

1587159972
pixelherodev
I'm not?

1587159978
pixelherodev
Oh wait, it's on by default I think

1587160004
ikskuh
this relocation only allows 32bit offsets

1587160008
ikskuh
more:

1587160049
pixelherodev
Still happens with force_pic=off

1587160051
pixelherodev
s/off/false

1587160229
pixelherodev
ikskuh, yeah, checked with --verbose

1587160233
pixelherodev
It's compiling with -fno-PIC

1587160238
pixelherodev
still happening :(

1587160258
pixelherodev
Oh and

1587160261
pixelherodev
I have that PDF already :P

1587160270
pixelherodev
Newer version though I think

1587160274
pixelherodev
Needed the ABI for the JIT

1587160328
ikskuh
hmm

1587160526
Xavi92
I can't believe the discussion is still on fire :)

1587160545
ikskuh
what discussion? linker scripts?

1587160749
Xavi92
ikskuh: no, the ':=' thing

1587160749
companion_cube
the issue seems stable

1587160760
ikskuh
oh no

1587160773
pixelherodev
idea

1587160782
pixelherodev
is it possible to use LD with Zig?

1587160783
Xavi92
companion_cube: how did it stabilise finally? It's been such a long discussion

1587160785
pixelherodev
Instead of lld?

1587160791
ikskuh
pixelherodev, probably is?

1587160809
Xavi92
pixelherodev: other tools from the GNU toolchain worked for me, so I guess ld will also do

1587160936
pixelherodev
right but

1587160943
pixelherodev
it's a matter of setting it in e.g. build.zig

1587161076
pixelherodev
AFAICT the answer is non :(

1587161087
Xavi92
:/

1587161105
Xavi92
companion_cube: what's the current status of the proposal?

1587161145
pixelherodev
Zig probably uses LLD as a library

1587161208
companion_cube
idk, there are several summaries in that thread

1587161243
ikskuh
i'm still in favour of the old way

1587161269
companion_cube
the status quo + 1717 + shortcut for `fn f()‚Ä¶` still being allowed seems to be the most pragmatic to me

1587161284
ikskuh
companion_cube, yeah, this

1587161305
ikskuh
yes, its against "one way to do things", but it increases readability by a lot compared to all operator/syntax based approaches

1587161322
companion_cube
tbh even

1587161324
companion_cube


1587161328
ikskuh
:D

1587161342
companion_cube
(define (f x y) ‚Ä¶) as an alias for `(define f (lambda (x y) ‚Ä¶))` iirc

1587161425
ikskuh
i could even live without the syntax sugar

1587161461
Xavi92
companion_cube: which shorcut for 'fn'?

1587161471
ikskuh
fn foo() void { }

1587161474
ikskuh
instead of

1587161478
ikskuh
const foo = fn() void { }

1587161508
Xavi92
ikskuh: I'd prefer the latter, tbh

1587161521
ikskuh
the second one?

1587161525
ikskuh
¬Ø\_(„ÉÑ)_/¬Ø

1587161532
ikskuh
better than using obscure operators :D

1587161550
Xavi92
Regardless 'const' is used or not. It keeps consistency with how structs and enums are defined

1587161558
ikskuh
yep

1587161569
ikskuh
also const is totally okay for reading code :)

1587161579
ikskuh
i don't like having "invisible" declarations

1587161589
Xavi92
ikskuh: people seem to have lots of different opinions on `const` though

1587161593
andrewrk
hryx, it might be nice for #1717 to mention what will become of `export`

1587161614
ikskuh
andrewrk, shouldn't export just keep the same, though?

1587161628
shakesoda
it doesn't seem like export would change

1587161631
ikskuh
export const x : i32 = 10; // exports a symbol "x" with 4 byte size

1587161646
ikskuh
export const foo = fn() callconv(.C) void { }

1587162182
fengb


1587162331
Xavi92
Is there any example of the most current proposal?

1587162345
ikskuh
well, there is no definite option

1587162454
Xavi92
ikskuh: it's just for a quick overview of the most voted features, even if not definite

1587162480
ikskuh
"const foo = ‚Ä¶" gets to "foo := ‚Ä¶" or just "foo = ‚Ä¶"

1587162504
ikskuh
but then you have mutation be something like "mut foo = ‚Ä¶" or "foo .= ‚Ä¶"

1587162532
fengb
SpexGuy has a nice summary:

1587162638
Xavi92
ikskuh: so there seems to be two main approaches: one based on new operators (`:=` and `.=`) and one based on changing existing keywords

1587162662
ikskuh
yeah

1587162744
Xavi92
ikskuh: hrm. If I haid to say my opinion on this, I'm more for keywords than operators.

1587162767
Xavi92
Operators add a barrier for newcomers IMO, more than keywords

1587162811
Xavi92
For example, GNU Make is all about operators and is often considered very cryptic

1587162821
companion_cube
Xavi92: and one based on keeping the current state of things

1587162898
Xavi92
companion_cube: status quo much likely means default immutability won't be achieved

1587162992
ikskuh
Xavi92: why? there's a proposal that will enforce immutability when not needed

1587162994
shakesoda
operators tend to make things cryptic

1587163004
shakesoda
i'd like to avoid cryptic

1587163009
shakesoda
as i think most of us would

1587163017
Xavi92
shakesoda: I think so too

1587163054
Xavi92
companion_cube: from all that has been discussed, as long as the `const` keyword is there, pointers and arrays will be kept mutable by default to avoid things like `*const *const Foo`

1587163068
Xavi92
ikskuh *

1587163122
companion_cube
ü§∑

1587163165
Xavi92
ikskuh: Or that's what I read yesterday, but since so many things have been discussed recently, that might have changed already

1587164086
Xavi92
After reading

1587164152
Xavi92
After all, functions inside structs are also struct fields, aren't they?

1587164235
companion_cube
they're comptime fields, I think?

1587164288
Xavi92
companion_cube: exactly, but fields after all

1587164305
Xavi92
Also enum fields are getting a `.`

1587164642
Xavi92


1587164652
Xavi92
Well, for "some" fields

1587164896
ikskuh
<Xavi92> After all, functions inside structs are also struct fields, aren't they?

1587164897
ikskuh
<companion_cube> they're comptime fields, I think?

1587164900
ikskuh
no, they are struct members

1587164910
foobles
in the compiler, should I refer to `?T` as an "option" or an "optional"?

1587164919
foobles
just for consistency's sake

1587164928
Xavi92
ikskuh: exactly, so they (at least) have the `.` prefix, if it had to

1587164979
Xavi92
ikskuh: Using it only for variables looks a bit inconsistent IMHO

1587165038
hryx
andrewrk: thanks, I will see about revising that tonight or tomorrow

1587165043
companion_cube
ikskuh: but they're not fields at runtime

1587165045
hryx
1717 needs a refresh anyway. it's so old that it uses the pre-PEG grammar

1587166183
Xavi92
BTW, if multiassign is complicating language design, why not just get rid of it? There are several other ways to achieve multiassign

1587166410
foobles
yeah im not a fan of multiassign in the first place

1587166411
companion_cube
rust does it well, btw: `let (mut x, y) = ‚Ä¶;`

1587166418
foobles
yeah

1587166420
companion_cube
(destructuring with multiple bindings)

1587166435
companion_cube
gotta say rust picked it syntax pretty well ü§∑

1587166437
companion_cube
at least for expressions

1587166439
foobles
and its just a natural result of a big emphasis in pattern matching syntax

1587166439
foobles
yeah

1587166449
foobles
patterns are great in rust

1587166462
companion_cube
and sum types

1587166472
companion_cube
(well, it's basically ML with the memory model of C)

1587166477
companion_cube
(or C++, rather)

1587166535
Xavi92
Would Rust's syntax for multiassign help us out in Zig?

1587166544
Xavi92
I mean, simplify language design

1587166581
foobles
no

1587166592
foobles
that would probably need a completely seperate issue

1587166632
companion_cube
it's not multiassign, it's just pattern matching

1587166639
companion_cube
rust functions all return exactly one values

1587166644
companion_cube
value*

1587166660
foobles
yeah. multiple return values is just done with tuples

1587166665
foobles
which i hope zig could do actally

1587166691
Xavi92
Then I'd just get rid of it, unless Zig uses tuples (which I'd also prefer)

1587166708
Xavi92
In fact, I though Zig was attempting to use tuples for this. How is it done instead?

1587166942
greaser|q
as someone who's done a fair bit of Python, i'd like to stress that making sure you can't make a tuple by accidentally having a comma on the end of a value is a worthwhile thing. sure, it's less of a problem when you've got static type checking as it tends to catch that stuff, but the fact that it's a thing in Python makes me not really able to use the language without throwing mypy at everything

1587167191
GreaseMonkey
also i'm currently on 0.5.0 until void updates LLVM to version 10

1587167368
Xavi92
Hey GreaseMonkey :)

1587167392
GreaseMonkey
sup, started picking up the language a couple of days ago

1587167398
Xavi92
Cool :)

1587167404
companion_cube
well tuples are already much more explicit than in python

1587167435
GreaseMonkey
whereas with Python tuples the only explicit language comes from the programmer ;)

1587167442
Xavi92
THE PSX HOMEBREW SCENE SHALL INVADE ZIG. RESISTANCE IS FUTILE

1587167479
GreaseMonkey
i'm actually looking forward to the day i can get away with using Zig at work, it's not going to be on my current project, and probably not on the next project lined up, but the project after that is probably where it'll be a good option

1587167513
companion_cube
GreaseMonkey: üòÇ indeed

1587167515
Xavi92
GreaseMonkey: then you must be in a very open-minded company

1587167516
GreaseMonkey
memcpy(&dst, &src, sizeof(dst)); is pretty much the one antipattern i want to see the end of

1587167548
GreaseMonkey
i am in an open-minded company but as it stands, for embedded stuff, C is really the only option for something w/ 20KB of RAM

1587167605
Xavi92
GreaseMonkey: Zig sounds interesting for such targets though. Which microcontrollers are you using BTW? 8051?

1587167610
Xavi92
STM8?

1587167613
GreaseMonkey
STM32

1587167615
GreaseMonkey
so ARM-based

1587167622
Xavi92
So LLVM support :)

1587167643
GreaseMonkey
i'd love to move the thing over to Clang because i'm so sick of GCC's thumb-1 optimiser bugs

1587167677
GreaseMonkey
but, well, i'm not sure how to get the cross-compilation stuff into Ubuntu 18.04

1587167689
Xavi92
GreaseMonkey: oh, did you really get compiler bugs? Never happened to me on GCC

1587167690
GreaseMonkey
GCC interprets thumb-1 as meaning "the multiplier on this chip is the slowest thing in the world"

1587167743
GreaseMonkey
Xavi92: they're bugs in the optimiser. it'll optimise power-of-2 division just fine, but anything else and it'll defer to __aeabi_u?[il]div(mod)?

1587167753
GreaseMonkey
instead of doing magic multiplication

1587167760
Xavi92
Ouch

1587167784
GreaseMonkey
also, multiplication will quite happily spew out 12 ops of shifts/adds/subs even though it's got a 1-cycle multiplier

1587167845
GreaseMonkey
i also recall a case when i was grinding a tight loop where sometimes it'll do UXTB (good) instead of two shift ops (bad), but it's a bit arbitary as to whether it'll opt for UXTB

1587167857
GreaseMonkey
or was it UXTH, or was it a MOV and an AND

1587167913
GreaseMonkey
either way, GCC has issues which can result in slowdowns esp. in cases where timing is already tight. but enough about compilers that have weird issues.

1587167942
Xavi92
GreaseMonkey: thought GCC was well-polished for ARM targets

