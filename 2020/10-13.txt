1602548089
ryuukk_
prior to zig, i tested rust, it lasted 5 minutes lol, so far zig feels much nicer, a bit rough to start due to the difference with C++/D, but i like the simplicity, if i were to rank the getting started experience, D would be #1, next is zig, and last one C++, rust is disqualified

1602548104
ryuukk_
the build.zig is a little bit confusing

1602548126
g-w1
I like rust a lot, but also zig. I had never done heap allocation before so it was cool to learn it.

1602548419
ryuukk_
well i'm still beginner, i can only judge the getting started experience for now

1602549856
andrewrk
rust is 10 years old, D is 18 years old, zig is 5

1602551569
nikki93
zig's time-to-lsp-working on all platforms i try (linux, macos and win) feels like the quickest of any lang i've tried so far

1602551627
nikki93
nim is also p good while being not as mature as the others

1602551747
nikki93
(as /most/ others -- maturity maybe comparable maybe slightly more than zig)

1602551749
g-w1
I find that zls only works half the time for me. Is this the case for you?

1602551793
nikki93
oh yeah it doesn't cover a lot of based. but i like that it just clearly doesn't work when it doesn't. rust's has just literally hung my editor before lol

1602551801
nikki93
*lot of bases

1602551808
nikki93
nimlsp has seemed good

1602553147
ryuukk__
exe.linkSystemLibrary("../libs/glfw3"); i try to link the glfw lib, but it doesn't seems to work: error: unable to generate DLL import .lib file: Unexpected

1602553165
ryuukk__
i am on windows

1602553257
ryuukk__
i'm trying this one:

1602554067
ryuukk__
ok i found out:  exe.addLibPath("../libs"); then  exe.linkSystemLibrary("glfw3");

1602554676
ryuukk__
hmm, what does this mean?

1602554676
ryuukk__
self.gfx.init(&self.config);

1602554676
ryuukk__
.\src\main.zig:86:22: error: expression value is ignored

1602554752
ryuukk__
oh i get it, if function return something,i need to be excplicit var result = self.gfx.init(&self.config);

1602554849
waleee-cl
ryuukk__:  you can throw it away with _ = self.gfx.init(&self.config); (use at own peril)

1602554910
ryuukk__
thanks waleee-cl

1602554933
ryuukk__
something random, why do i need to add the .{} here: std.log.info("on_init", .{}); ?

1602554951
ryuukk__
if i remove it, it complains

1602555017
waleee-cl
it's an anonymous struct (in this case used for formatting &c)

1602555117
ryuukk__
but why do i need to add it if i don't do formating? what do you mean by &c?

1602555179
waleee-cl
the function is defined as such is the boring answer (&c is short for et cetera)

1602555222
ryuukk__
it adds confusion, if it is optional it should be removed in my opinion

1602555239
waleee-cl
ryuukk__:  formatting was perhaps a bad wording, it's for splicing in values in the string

1602555248
ryuukk__
because here need to learn another concept when just wanting to print something

1602555268
waleee-cl
if no values == empty anon.struct

1602555596
ryuukk__
rust have same issue, to print something you need add the !

1602555613
ryuukk__
1st thing come to mind when you get started is why this function has ! but not other

1602555619
ryuukk__
it add frictions

1602555649
ryuukk__
std.log.info("on_init"); is all i should have to write

1602555650
waleee-cl
all languages have frictions of some sort

1602555708
waleee-cl
ryuukk__:   yeah, but zig doesn't do overloading, so you'd need a std.logSpliceValuesIn too

1602555855
ryuukk__
std.log.infof

1602556117
waleee-cl
wouldn't it look weird from a  beginners pov to have a std.log followed by a std.log.infof too?

1602556176
waleee-cl
at least something to look up in the same way as .{}, but with a more searchable name

1602556215
ryuukk__
probably

1602556235
ryuukk__
but it would be explained in the doc

1602556264
ryuukk__
if you see examples that uses std.log.info("hi") it's easy to see what it does

1602556341
waleee-cl


1602556356
waleee-cl
not specifically std.log but std.debug.print

1602556389
waleee-cl


1602556462
ryuukk__
now i need learn difference between std.log and std.debug.print xD

1602556509
waleee-cl
this explain in great detail the statements with .{}

1602556554
ryuukk__
well the thing is .{} is kinda annoying to type

1602556573
ryuukk__
so when just wanting to print a message, you have to type the annoying stuff extra

1602556590
ryuukk__
if not needed, u shouldn't write it

1602556616
ryuukk__
when things are annoying, people tend to avoid them

1602556623
ryuukk__
so this creates side effect

1602556661
ryuukk__
same for exceptions, in C++ i didn't bother because it is annoying all the try catch stuff, so i skip it

1602556799
ryuukk__
is there an official reasoning behind having to type it no matter what?

1602556831
ryuukk__
i'd send pr to create functions with f prefix, but that would be breaking change

1602556863
ryuukk__
andrewrk: what do you think?

1602557077
lunamn
ryuukk__: see

1602557263
ryuukk__
that still doesn't anwser the why it couldn't be 2 different function

1602557317
torque
you could write your own simple wrapper around it if it is a real sticking point for you

1602557334
torque
like "log" and "logFmt" or something

1602557407
ryuukk__
it's not just about me, it's the confusion it adds, if you want to print a message, you don't want to print a message with arguments

1602557663
torque
sure, but you have to tell it to explicitly print a message with no arguments

1602557695
torque
it sounds like your expectations are geared around languages with either varargs or function overloading

1602557722
torque
though I would guess the bigger problem here is the very rough state of the documentation

1602557743
ryuukk__
no, that's your assumption, the point is to distinguish between a call that wants to print a message and a call that wants to print a formated message

1602557770
torque
why should that distinction be made?

1602557791
ryuukk__
because the empty anonymous is passed when you want to print a message

1602557802
ryuukk__
struct *

1602557825
lunamn
doesn't that already exist in the writer interface? write() vs print(), except I don't think write() is exposed as something like std.debug.write

1602557885
torque
yes, I would say the interface is optimized around the assumption that you might want to expand your logging to include formatted data with as little change as possible

1602557899
torque
which seems like a reasonable choice to me

1602557986
ryuukk__
if it ask for a struct, the function is meant to pass a formated message, not a plain message

1602558003
torque
that's not true, though

1602558017
ryuukk__
why pass a struct then?

1602558096
torque
the tuple being passed in is the list of variabls to format

1602558125
torque
if you wanted to format something you would have to call std.log.info("my data: {} {}", .{data1, data2})

1602558198
ryuukk__
but i want to pass a message, not a formated message

1602558206
torque
so if you wanted to print an empty struct/tuple you would have to call std.log.info("empty: {}", .{.{}})

1602558239
ryuukk__
why do i need to pass a message with an empty struct?

1602558248
torque
yes, by providing nothing to format inside the list of things to format, you are explicitly telling it there is nothing to format

1602558276
ryuukk__
than the function should be called info_formated()

1602558302
torque
you are disagreeing with the api designer at this point, which is a qualitative argument rather than a quantitative one

1602558324
torque
I think it's simpler to have one API call that is consistent between messages without formatting and with

1602558381
ryuukk__
i am trying to clear confusion, not disagreeing with the api designer

1602558395
torque
I do not understand what the confusion is

1602558415
ryuukk__
the confusion, is why do i need to pass an empty struct if i just want to print a message

1602558465
ryuukk__
i understand the struct is meant to format the message, but i just want to print a message, not a formated one

1602558466
torque
the answer is that there is no syntactic sugar to hide the empty tuple at the call site and the API designer has elected not to draw a distinction between messages that format variables and those that do not

1602558501
ryuukk__
i don't want to hide the empty struct

1602558503
torque
which is why I am saying that you are arguing with the API. I think you have a good understand of how it works, but not why the API is designed the way it is

1602558506
ryuukk__
i want to pass just a message

1602558525
ryuukk__
hiding the struct = hiding the intent of the function, that's not what i'm asking

1602558598
torque
the variable formatting is managed at compile time and not runtime, which may help you to understand why the API is the way it is

1602558639
torque
there is no runtime penalty for not making a distinction between formatting and and not formatting

1602558664
ryuukk__
i understand that, you still miss my point, i expect info to take my message and print it

1602558705
torque
which it does when called std.log.info("my message", .{})

1602558734
ryuukk__
no, it asks for a message and a struct, not just a message

1602558744
ryuukk__
std.log.info, asks you to format a message

1602558763
torque
I will say one last time: you are arguing about the API design and I cannot help you there. If you want add more functions to the API you are welcome to make a proposal to do so

1602558777
torque
but this conversation isn't going anywhere

1602558781
ryuukk__
that is the point!!

1602558801
ryuukk__
discussion about a confusion that lead to solution

1602558844
ryuukk__
my proposal: infof(string, struct)  info(string)

1602558985
torque
proposals are normally presented as issues on the github issue tracker:

1602559054
ryuukk__
i am new i thought it'd first discuss about it with advanced users first to see why i have the confusion and what are the solutions before trying to make changes

1602559083
torque
Well, I don't think such a proposal would be likely to be accepted given the history around the subject

1602559125
torque
though I am certainly not an expert, and it doesn't hurt to make one

1602559125
ryuukk__
well if it is a common recurence then maybe there is a real problem

1602559136
torque
but as I tried to explain my perspective on why the API design makes sense and you consistently disagreed, I have no other suggestions for you

1602559163
ryuukk__
i didn't disagree, i just tried to clear confusions

1602559181
torque
you were not able to express why you are confused

1602559198
ryuukk__
you didn't want to understand :)

1602559263
torque
as far as I can tell, your "confusion" came down to "why are there not two separately named functions to perform these things" and my answer was "the API is not designed to treat those two things as distinct special cases"

1602559292
torque
you did not particularly explain why you think they should be treated separately

1602559310
ryuukk__
no, my confusion was why do i need to pass an empty struct if i want to just print a message

1602559324
torque
good luck

1602559354
ryuukk__
you don't want to understand, instead you extrapolate what would be my confusion

1602559602
ryuukk__
look, what i said initially: [4:08:53 am] <ryuukk__> something random, why do i need to add the .{} here: std.log.info("on_init", .{}); ?

1602559661
andrewrk
no need to defend yourself. everybody respects you here

1602559696
andrewrk
you asked me about changing .{} syntax? that's stable at this point, not planned to change

1602560065
ryuukk__
no, i was suggesting renaming that function, since it requests for a formated message (msg + struct), and use the original name for passing just a plain message, but i hear the reasoning behind it, still it's confusing for me, maybe because i'm used to the info/infof split with other language

1602563738
andrewrk
llvm11 branch merged into master

1602566458
andrewrk
ugghh ci broken because llvm-config on macos has a dynamic dependinc on libstdc++ that is somehow broken on the CI server

1602566487
andrewrk
this is such an unnecessary problem yet it's a showstopper

1602569949
andrewrk
wait a minute... there's a really obvious solution to this

1602573346
andrewrk
I'm updating freebsd and macos CI to take advantage of zig-bootstrap instead of the current system. This will have 2 benefits:

1602573353
andrewrk
(1) it will work instead of not working

1602573391
andrewrk
I'm being cheeky, what I mean is that we won't be at the mercy of gcc's libstdc++ being unreliable which is making the CI fail right now

1602573421
andrewrk
(2) freebsd and macos tarballs will have a dynamic link against the system libc instead of incorrectly static linking the system libc

1602573439
andrewrk
that was always the goal, but without zig cc it wasn't possible to get the desired result

1602573722
ikskuh
advantage (1) sounds like a game changer :D

1602573830
andrewrk
maybe the gcc team will take inspiration from (1) and apply it to their own software too ;)

1602574558
ikskuh
let's hope so

1602582487
daurnimator
ccccccevclvkieedkjricbghiltledfventbehrvvhib

1602582516
ifreund
woah there

1602582568
daurnimator
oops

1602582790
ikskuh
daurnimator, you either need a new password or more sleep

1602582807
daurnimator
ikskuh: it's a one-time-code from bumping my yubikey

1602584487
ifreund
so zig's bool is a c_int when used in a extern declaration right?

1602584702
ifreund
or no, I guess it's probably _Bool?

1602584912
earnestly
I'd hope so...

1602584956
earnestly
Considering the use of an int to store a bool has already been used in the underhanded c contest to deliberately construct an AES encryption that can be transparently toggled

1602584977
earnestly
By storing additional information in the space available to the type

1602585064
ifreund
i think zig's bool has to be _Bool, we have c_int already for the other option

1602592466
ryuukk__
is it possible to have a generic struct and not a function that return anonymous generic struct?

1602592532
ryuukk__


1602592558
ifreund
why do you need a struct not a function?

1602592579
ryuukk__
so it can be typesafe

1602592592
ryuukk__
and it anonymous struct dosn't work with zls

1602592620
ifreund
a function returning a struct doesn't make things non-typesafe

1602592646
ryuukk__
how do i past a generic List to a function?

1602592658
ryuukk__
it needs be a struct

1602592698
ifreund
you can do e.g. fn foo(comptime T: type, list: Arraylist(T)) void {}

1602592718
ryuukk__
what is arraylist?

1602592736
ifreund
std.ArrayList

1602592746
ryuukk__
what about my type?

1602592748
ifreund
a generic dynamic array

1602592764
ryuukk__
i want create my generic structure

1602592792
ifreund
assuming your type is a function returning a type (link ArrayList) you would just call your function as I called ArrayList() in the example

1602592817
ryuukk__
i don't understand

1602592825
ifreund
you may want to take a peek at the arraylist code

1602592857
ryuukk__
it uses anonymous struct too

1602592919
ifreund
well, it's not totally anonymous, the return type has the type ArrayList(T)

1602592931
ryuukk__
why i can't make a struct generic in first place?

1602592942
ifreund
this is how you make a struct generic

1602592967
ifreund
adding a second way to do the same thing would be uneeded complexity

1602592968
ryuukk__
const MyStruct(T) = struct { data: T} why complicate with anonymous struct?

1602592992
ifreund
the struct isn't anonymous, you have a name for it

1602593006
ryuukk__
to me using function is adding 2nd way to do the same thing..

1602593016
ryuukk__
i don't want anonymous struct

1602593077
ifreund
the struct returned by e.g. ArrayList(T) is not anonymous, it has type ArrayList(T)

1602593114
ryuukk__
why is it different for struct?

1602593120
ifreund
e.g. ArrayList(u8) is one possible type

1602593121
ryuukk__
this is wha is weird

1602593141
ifreund
all that zig does is let you use types as first class values as comptime

1602593198
ifreund
s/as/at/

1602593203
ryuukk__
i'm not sure i like this, it doesnt make sense

1602593343
ryuukk__
this is uneeded complexity

1602593433
ryuukk__
everylanguage it's this way MyStruct<T> { data: T} that's it

1602593448
g-w1
its more simple in zig

1602593449
ryuukk__
compiler genrate what ever it needs to

1602593458
g-w1
no need for macros

1602593469
ryuukk__
well, not simple for me

1602593511
ryuukk__
user become the macro generator

1602593552
ryuukk__
pub fn ArrayList(comptime T: type) type

1602593557
ryuukk__
this is a function, not a struct

1602593559
ryuukk__
it as fn

1602593570
g-w1
in zig functions can return structs

1602593573
g-w1
all structs are anynomus

1602593575
ryuukk__
saying it is a struct is mistleading people and add friction

1602593676
layneson
std.ArrayList itself is a function, yes. However, as soon as you evaluate it, it becomes a struct type. std.ArrayList(u8)

1602593709
ryuukk__
why not use same syntax for creating a normal struct?

1602593720
ryuukk__
this is asking for confusion

1602593755
ifreund
no, this is what you get when you remove everthing unecessary

1602593763
ifreund
this requires no new syntax or semantic

1602593778
ifreund
this is the natural outcome of comptime

1602593808
ryuukk__
even go is same syntax for creating struct and generic struct

1602593842
ifreund
there's no such thing as a "generic struct" in zig

1602593845
ryuukk__
well if the goal is to not create language feature i sould just write asm

1602593857
ifreund
you merely have the ability to create your own types at comptime

1602593885
g-w1
the goal of zig is not to be the same as other languages

1602593890
g-w1
then there would be no point to it

1602593891
ryuukk__
> there's no such thing as a "generic struct" in zig

1602593891
ryuukk__
that is an anwser i can understand

1602593933
ifreund
there is of course an equivalent pattern solving the same problem as generic structs without introducing new syntax or semantics

1602593938
ryuukk__
not being the same as other language shouldn't be a goal

1602593941
ifreund
as demonstrated by std.ArrayList

1602593948
ryuukk__
i want solve problems, not be different than others

1602593962
ifreund
being different isn't a goal

1602593968
ifreund
being the same isn't either

1602594002
ifreund
I'm not really sure what you're issue with how zig does this is, where do you find it limiting?

1602594011
ifreund
*your

1602594042
ryuukk__
it's a different way to do the same, so far language taught me to write struct this way: const MyStruct = struct{}

1602594053
ryuukk__
to make it generic now i need learn how to do it an other way

1602594064
ryuukk__
this is working against me

1602594078
ryuukk__
instead of empowering me to write less and be more effective

1602594107
ryuukk__
i'd rather what const ArrayListI32 = struct {}♥

1602594110
ryuukk__
write*

1602594122
ifreund
well, you aren't writing a struct, you're writing a function that returns a type

1602594133
ifreund
of course that's different from writing a struct

1602594144
ifreund
but it's not complicated either

1602594162
ryuukk__
maybe not for you, but for me it is

1602594174
ryuukk__
jungling between 2 syntax to do the same thing

1602594181
fengb
I don’t think zig if for you

1602594184
ifreund
there aren't 2 syntaxes

1602594206
ryuukk__
fengb: that's what i start to realize

1602594254
ryuukk__
wich is sad because otherwise i like the language

1602594430
ryuukk__
also saying "i don't think zig is for you" is bad..

1602594460
ifreund
ryuukk__: does this example help at all?

1602594521
ryuukk__
ifreund: i understood what it does, the problem is it is different syntax to do the same thing

1602594562
ifreund
it doesn't do the same thing though

1602594622
dutchie
i'd say it's actually less syntax than other languages' ways to do generics: everything's just a function

1602594625
ryuukk__
it is, the end is the same, it creates an anonymous struct

1602594672
ryuukk__
i have this in go: const ArrayListI32 = struct {} to make it generic const ArrayList(T) = struct {} that's it

1602594696
ifreund
that's new syntax

1602594704
ryuukk__
but it makes life easier

1602594747
ryuukk__
now i have to change it to make it a function, and i have to make it return an anonymous struct

1602594750
ryuukk__
it's step backward

1602594751
ifreund
that's where I disagree, it may make trivial cases shorter to write but is nowhere near as flexible

1602594776
dutchie
also every struct in zig is an "anonymous struct"

1602594793
dutchie
const Point = struct { x: i32, y: i32 }

1602594808
ifreund
^

1602594832
ryuukk__
so why not make function here, but a function for generic?

1602594846
ifreund
you can if you want :D

1602594862
ryuukk__
should be valid for the opposite then

1602594873
ifreund
fn Point() type { return struct { x: i32, y: i32 } }

1602594883
ifreund
no, that would require new syntax

1602594901
ryuukk__
what is new syntax in language in development?

1602594926
ifreund
a major goal of zig is to be as simple and consistent as possible

1602594937
ifreund
uneeded new syntax goes against that goal

1602594957
ryuukk__
so i stand correct, having 2 different way to achieve the same thing goes against that goal

1602594984
ryuukk__
you said it, both are anonymous struct

1602595011
g-w1
everything is a value. there are no generics in syntax constructs

1602595022
ryuukk__
(im not language designer, so i might see things differently than you)

1602595024
dutchie
yeah, the key insight is that types are first-class values

1602595051
ifreund
and zig doesn't need anything more than that to have "generics"

1602595074
ifreund
having generics is just a byproduct of comptime

1602595076
dutchie
this immediately made sense to me because i went to a type theory class once

1602595095
dutchie
"oh it's just dependent types if you squint right"

1602595103
ifreund
yep

1602595136
ifreund
a function taking a type and returning another based on that argument is basically the definiton of dependant types

1602595151
ryuukk__
the problem is the 2 different way to achieve the same

1602595173
ryuukk__
const MyType = struct and fun MyType(comptime T) type { .{}}

1602595186
ifreund
ryuukk__: are you saying that a non dependant type is the same as a dependant type?

1602595197
ifreund
cause I don't agree that those are the same

1602595212
ryuukk__
both creates anonymous struct

1602595243
ifreund
the later is a type dependant on T, the former is a type dependant on nothing

1602595295
ryuukk__
the anwser i got so far is: it' to not not add new syntax

1602595323
ryuukk__
but new syntax was added to achieve this: const MyStruct = struct {}

1602595328
kristoff_it
ryuukk__, maybe you and the others are enjoying the exchange, but to get to the point: comptime "ducktyping" over types is one of the defining characteristics of Zig. If you don't like it, my first suggestion is to read more code (from the stdlib for example), write some of your own, and try to understand what are the advantages of this approach, since it seems to me you might be missing some of the implications when saying that "it's the same thing".

1602595328
kristoff_it
After that, if you still consider the approach flawed, you have two options: go on GitHub, read past issues on the topic and open a new one where you argue your case why we should have angle brackets; while the second option is to just leave Zig be. I heard Rust has a pretty sophisticated type system with tons of safety. Complaining about that approach here on IRC won't really convince people because that's the path the language has been following for a

1602595329
kristoff_it
while now and short IRC messages probably won't be enough for you to properly structure a counterpoint to that.

1602595339
ryuukk__
instead of fun Mystruct : type { .{} }

1602595361
ryuukk__
fun MyStruct : type { .{} }  and const MyStruct = struct {}

1602595378
ifreund
no, const MyType = struct {}; is not new syntax

1602595385
ifreund
that's a normal variable declaration

1602595388
ifreund
like const x = 5;

1602595399
ryuukk__
ah good point

1602595414
ifreund
types are first class values remember? :P

1602595462
ryuukk__
kristoff_it: remember i am new to zig, this is my experience as i write zig code

1602595525
ryuukk__
kristoff_it: i'm not confidering approach flawed, all i am askign is arguments so it clear my confusions

1602595626
ryuukk__
now it's becoming a little more clear

1602595707
ryuukk__
> while now and short IRC messages probably won't be enough for you to properly structure a counterpoint to that.

1602595707
ryuukk__
what do you mean?

1602595750
kristoff_it
you've also complained about it being different than what you're used to :) anyway, all is good

1602595756
ifreund
And I for one am totally happy to continue trying to explain my views on why zig is the way it is :)

1602595790
dutchie
i'm a few days past reading through the docs for the first time and it seems really cool so far

1602595813
ryuukk__
kristoff_it: i said because it's not using a function, not because that's what i'm used to

1602595822
dutchie
now if i could just work out why it's telling me the thing (I think) I only want at runtime is not available at comptime...

1602595839
kristoff_it
dutchie, have you seen ziglearn.com? that's also another good resource

1602595845
ifreund
happy to take a peek if you have a link :)

1602595847
dutchie
.org?

1602595860
ifreund
yes

1602595861
kristoff_it
ah yes .org sorry

1602595881
dutchie
ifreund: yeah, i was going to try to make a minimal reproduction after work today if i get a chance

1602595901
dutchie
slacking off on irc is one thing, hacking on personal projects is another :)

1602595910
kristoff_it
dutchie, whenver that happened to me in the beginning is because I forgot to explicitly say that my loop index var needed to be of type usize

1602595932
kristoff_it
not specifying the size makes the compiler think that `i` should be a comptime var that I'm trying to modify at runtime

1602595936
dutchie
i tried adding a bunch of type annotations but it still was complaining about comptime_int

1602595943
dutchie
it's a switch

1602596015
ryuukk__
kristoff_it: and they replied with it's to not create new syntax, wich i was confused because i had the impression const MyStruct = struct {} was already a new syntax, but i was wrong, and realized it when ifreund mentioned the variable declaration syntax, wich helped clear my confusion

1602596048
Michcioperz
dutchie: might you be switching on a variable you assigned an int literal to but without saying what size of int it is? like `var x = 2;`

1602596060
Michcioperz
ah, you tried adding annotations, sorry

1602596064
ryuukk__
kristoff_it: not wanting to understand people's problem and saying "complaining about it on IRC wont convince people" i'm not trying to convince anyone, i want to clear my confusions

1602596085
Michcioperz
i misread

1602596185
ryuukk__
and don't be like rust people, don't just say "read the book" or "the language is not for you" or "you don't understand", because that kind of issues i didn't have with other languages

1602596207
kristoff_it
ryuukk__, that was not the impression I got by reading the messages, but yes I might have misread/misunderstood what you said. That said, statements like "i'm not sure i like this, it doesnt make sense", "this is uneeded complexity", "everylanguage it's this way MyStruct<T> { data: T} that's it" can be seen as something more than just clearing your confusion, in my opinion.

1602596279
ryuukk__
kristoff_it: because to me using function to create a new type is what confused me

1602596351
ifreund
it's understandable that that's confusing at first, Zig's the only language I know of that lets you do it

1602596415
dutchie
i guess lisps maybe?

1602596472
ifreund
I've never gone deep into lisp world

1602596569
kristoff_it
well if you go into higher level languages, you can pass around types in quite a few of them. In python is not even that uncommon to do it

1602596643
earnestly
ifreund: The scrollback is too convoluted; which feature are you refering to?

1602596655
dutchie
decided that slacking off on irc was functionally comparable to making an example:

1602596665
ifreund
types as first class values at comptime

1602596666
earnestly
iGOD, nice slug

1602596717
earnestly
ifreund: Ada would be one iiuc

1602596761
kristoff_it
dutchie, you probably just need to give a type to your enum, enum(usize), for example. Somebody please correct me if I'm wrong.

1602596779
ifreund
dutchie:             .February => @as(u8, if (isLeap(self.y)) 28 else 29),

1602596790
ifreund
this is enough to make zig's type inference happy

1602596808
ifreund
I think you shouldn't need it though, the compiler should be able to figure things out

1602596879
dutchie
huh, ty

1602596888
ifreund
kristoff_it: nothing related to the enum :P

1602596911
dutchie
should i file a bug?

1602596956
ifreund
wouldn't hurt, probably won't ever be implemented in stage1 though

1602597029
dutchie
not sure why the test fails now

1602597040
dutchie
it type-checks at least, i have probably done something dumb

1602597044
ifreund
oh yeah I saw that but didn't look into it :D

1602597084
ifreund
well the months aren't all 31 days long, some are 30 no?

1602597129
ifreund
wouldn't matter for that test case though :/

1602597132
dutchie
yeah i couldn't be bothered to put all of them but i'm only testing february

1602597141
dutchie
lol i see the problem

1602597155
dutchie
i have the 28/29 the wrong way round

1602597178
dutchie
now it's fine :

1602597180
dutchie
:)

1602597214
ifreund
nice :)

1602597300
ifreund
earnestly: I'm not an ada user, but I don't think you can store types in variables and pass them around?

1602597347
ifreund
at least I can't find any docs on such a feature

1602597523
ifreund
dutchie: heh, this is actually all you need: .February => if (isLeap(self.y)) @as(u8, 29) else 28,

1602597538
ifreund
i think the issue is with the if statement

1602597617
earnestly
ifreund: It depends on what you mean by "storing types"

1602597663
ifreund
yeah at compile time only of course, they have no representation at runtime or in the resulting binary

1602597719
ifreund
but zig lets you handle them similarly to e.g. integer values in comptime code

1602597725
earnestly
Yeah, compile time features are pretty rare in other languages and often depend on compilers being "smart enough"

1602597758
earnestly
Probably because it makes compilation non-deterministic

1602597800
ifreund
if you keep the inputs the same, why should it be non-deterministic?

1602597822
earnestly
ifreund: The halting problem, much like C++'s templates and constexpr and co.

1602597871
ifreund
indeed, we have an arbitrary max branch quota to avoid solving the halting problem

1602597900
earnestly
I think eBPF did a similar thing, combined with not allowing loops

1602597907
ifreund
this can be overridden and raised in in user code if needed

1602597956
earnestly
I hope zig will get fixed point arithmetic as standard, if it doesn't.  (I consider anything which doesn't to be a toy language)

1602597995
earnestly
ifreund: You reminded me of safety critical applications and how they might have to assess compiler paths with more compile time features

1602598028
earnestly
Which reminded me about the story of how Ada got fixed point as standard, and that story is quite harrowing

1602598050
companion_cube
are all languages toy languages, earnestly? :p

1602598059
ifreund
earnestly: you may want to subscribe to this issue:

1602598086
earnestly
companion_cube: Mostly, but that's usually fine, because you can get a lot more done with them, more rapidly :p

1602598103
companion_cube
ah, are you a ada user? (scrolling back)

1602598138
earnestly
Not quite, but have done a fair bit of mucking around with it.  Mostly looking for actual systems languages

1602598183
companion_cube
fixed point arith seems like a super niche feature :)

1602598189
companion_cube
(not saying it's useless, though)

1602598211
earnestly
ifreund: In Ada you don't use "float" or "double".  You specify the needed precision and the compiler will find the most efficient representation for you

1602598247
ifreund
that sounds cool and also potentially complicated

1602598263
earnestly
companion_cube: Fixed point was added to Ada as a direct result of a floating point error resulting in a missle defense system failing to detect an attack that resulted in 31 dead marines

1602598288
companion_cube
the patriot missile?

1602598291
earnestly
Yep

1602598310
earnestly
Although then they had Ariane 5, so lol

1602598312
companion_cube
interesting, didn't know that was the solution

1602598329
companion_cube
fixed point solved it because the errors are rounded differently, I imagine

1602598332
earnestly
Wait, Ariane 5 was prior to that

1602598379
ifreund
fixed point is much more consistent and deterministic than floating point

1602598382
earnestly
companion_cube:

1602598408
companion_cube
ifreund: interesting

1602598417
companion_cube
the use case I thought fixed poiint was for is money

1602598430
companion_cube
but even then you can just use fractions of cents in int64 or something like that, probably

1602598432
ifreund
yes, that's certainly a good use case for it

1602598438
earnestly
ifreund:

1602598590
ifreund
there are certainly enough knobs to turn there :D

1602598590
earnestly
ifreund: Does zig have range types?

1602598610
ifreund
no, though there's an open proposal for that as well

1602598623
earnestly
I think Rust also has an rfc for it

1602598630
earnestly
Not sure if it was merged/implemented

1602598674
ifreund
we currently have u0 through u128 and i1 through i128 which work well, everything over 128 bits may hit llvm bugs

1602598679
earnestly
companion_cube: A lot of these systems are hard real-time so performance of float/double isn't that important

1602598700
earnestly
ifreund: Yeah I like that feature

1602598735
Snektron
if > u128 is so buggy why does llvm even provide it

1602598750
earnestly
"Threading" in Ada is also based on essentially CAS with a rendezvous; which is also nice

1602598769
earnestly
With what is essentially message passing for communication

1602598777
companion_cube
but synchronous, right?

1602598808
earnestly
Nope, that's what rendezvous is for

1602598810
earnestly
E.g.

1602598892
companion_cube
I mean, the message passing blocks sender/receiver until the other party is there?

1602598964
earnestly
companion_cube: Yes (but you don't have to block)

1602599028
companion_cube
right, so that's like synchronous channels?

1602599121
companion_cube
I'm a bit curious why no one did ada tasks as a library in rust

1602599135
companion_cube
people seem more aware of Go-like channels

1602599142
earnestly
companion_cube: It's more like Erlang

1602599228
earnestly
protected types act as a mutex if you have multiple threads trying to access something like counter, e.g.

1602599252
companion_cube
hmm so you have a mailbox of incoming messages?

1602599265
companion_cube
(your code snippets don't have colors, that's a bit sad :p)

1602599365
earnestly
companion_cube: Hm, I think mailbox is a fair description

1602599423
earnestly
The weird thing is that tasks start the moment you declare them

1602599479
earnestly
companion_cube:

1602599496
companion_cube
does look like erlang

1602599514
companion_cube
except messages are not values, or something

1602599520
companion_cube
interesting indeed

1602599535
companion_cube
(but you can get something similar with channels + select, I think?)

1602599613
earnestly
companion_cube: Yeah, afaiui it's essentially an Actor Model with named channels

1602599655
companion_cube
fu ntimes

1602599707
earnestly
ifreund: I like the zalgo'd "operator overloading"

1602603598
ifreund
earnestly: zalgo?

1602603669
justin_smith
ifreund: it's a meme where strange unicode is exploited as an element of horror fiction

1602603713
justin_smith
ifreund: I think this is the canonical example if you read to the end

1602603790
ifreund
ah TIL the name for the messed up meme text

1602603811
ifreund
and yeah I love that zig doesn't have operator overloading

1602603881
justin_smith
ifreund: following from the general language design idea "make things you want clean and elegant, and things you want to discourage ugly and clumsy", we could use zalgo for neccessary but highly suspect zig features :D

1602604001
ifreund
so basically what the operator overloading equivalent is in zig: foo.add(bar);

1602604413
wilsonk
ls

1602604416
wilsonk
woops

1602604813
ryuukk__
for @cInclude("GLFW/glfw3.h"); how to tell specific path? i'm on windows

1602604836
ryuukk__
i tried to put header on the same folder, it doesn't work

1602605082
ryuukk__
oh there is  a exe.addIncludeDir

1602605199
ifreund
ryuukk__: by the way, you're right that functions are inconsisent with the rest of zig syntax currently. This is planned to be fixed though:

1602606550
ryuukk__
.\src\main.zig:66:9: error: expected type 'bool', found '@typeInfo(@typeInfo(@TypeOf(.glfw.src.main.init)).Fn.return_type.?).ErrorUnion.error_set'

1602606550
ryuukk__
try glfw.init();

1602606580
ryuukk__
i don't understand what i should do here, n init(self: *Gfx, config: *Config) bool i'm supposed to return a value, but i don't know how to do it with try

1602606608
ryuukk__


1602606669
ifreund
you'd need to make your function return an error set to use try

1602606691
ifreund
I think the "idomatic" think to do here would be to make the return type `!void`

1602606706
ifreund
i.e. return an error on failure or nothing on success

1602606708
ryuukk__
i just want to handle the error with a bool for simplicity

1602606714
justin_smith
ryuukk__: another way of saying that: zig doesn't do error jumps, it returns error types

1602606726
ifreund
then do glfw.init() catch return false;

1602606733
ryuukk__
thanks

1602606759
ifreund
though that's not terribly idiomatic, you are of course free to do what you want :P

1602606795
ryuukk__
well i'd use the error if there was more than 2 cases of failure, here i just want to tell if success or no

1602606849
ryuukk__
now i only need to fix undefined symbols everywhere in the glfw lib lld: error: undefined symbol: __declspec(dllimport) TranslateMessage

1602606926
ifreund
you are linking it right?

1602606932
ifreund
and libc?

1602607073
ryuukk__
yes

1602607143
ryuukk__
full log

1602607159
ryuukk__
looks like window library missing

1602607239
ifreund
Afraid I'm pretty useless when it comes to windows :/

1602607247
ryuukk__


1602607255
ryuukk__
that fixed it

1602607286
ifreund
nice

1602608645
earnestly
ifreund: The only point of concern about operator overloading is that mathematicians essentially need it for anything actually complicated but I don't know the details

1602608657
earnestly
It's just what I've been told

1602608741
justin_smith
yeah, I think that's a case where the preferences of a domain conflict with good language design

1602608755
justin_smith
DSLs for math are definitely a thing

1602609229
ryuukk_
var primaryMonitor = glfw.Monitor.primary() catch return false;  <= here, is there a way to get a Monitor, and not a ?Monitor ?

1602609270
ryuukk_
because here: glfw.Monitor.getVideoMode(primaryMonitor) it complains about receiving a ?Monitor

1602609286
ryuukk_
error: expected type '.glfw.src.monitor.Monitor', found '?.glfw.src.monitor.Monitor'

1602609308
ryuukk_
searching for ? is hard with google

1602609336
justin_smith
ryuukk_: I usually use if (foo.bar()) |v| foobar = v; to unwrap optionals

1602609341
g-w1
a orelse false;

1602609348
justin_smith
oh that's nicer

1602609371
ryuukk_
i don't understand

1602609396
ryuukk_
where should i put orself false?

1602609403
g-w1
orelse unwraps optionals. const b = a orelse return false; means that if it is not null then b is a otherwise the function returns false

1602609442
g-w1
does that make sense?

1602609484
ryuukk_
.\src\main.zig:78:54: error: expected optional type, found '@typeInfo(@typeInfo(@TypeOf(.glfw.src.monitor.Monitor.primary)).Fn.return_type.?).ErrorUnion.error_set!?.glfw.src.monitor.Monitor'

1602609484
ryuukk_
var primaryMonitor = glfw.Monitor.primary() orelse return false;

1602609516
g-w1
it seems like it expected an optional

1602609567
justin_smith
it looks like you need to wrap the catch and the orelse around it at the same time

1602609578
g-w1
yeah

1602609579
justin_smith
it might be clearer if you did it in two steps via a temporary varialbe

1602609616
ifreund
what, this isn't clear enough? :P (glfw.Monitor.primary() catch return false) orelse return false;

1602609626
justin_smith
lol

1602609642
ifreund
i personally would just do that and not pollute my scope

1602609676
ryuukk_
how do i store the monitor if it it between () ?

1602609677
justin_smith
ifreund: as a beginner I split them out, and assume the compiler is smart enough not to make my code worse when I do it

1602609707
ifreund
ryuukk_: you're storing the value of the whole expression I pasted

1602609713
ryuukk_
oh i see, it works

1602609721
ryuukk_
the line is kinda long

1602609726
ifreund
i agree

1602609726
ryuukk_
var primaryMonitor = (glfw.Monitor.primary() catch return false) orelse return false;

1602609761
ryuukk_
there is no cleaner way to do it?

1602609780
ifreund
you can put line breaks after the binary operators or use a temporary variable

1602609797
ifreund
there's intentionally no way to unwrap both "layers" at once

1602609838
ryuukk_
hmm :/

1602609863
ifreund
the right fix here would be to tweak the glfw bindings to get rid of the optional

1602609869
ifreund
just make it another error

1602610314
ryuukk_
is there a way to hide this when i compile?

1602610327
ryuukk_
it makes it hard to just look at the actual error message

1602610352
g-w1
I think that is your shell?

1602610385
ryuukk_
i use the terminal in vscode

1602610398
g-w1
what is ark?

1602610453
ryuukk_
zark is the name of the engine

1602610485
g-w1
oh

1602610490
ryuukk_
the terminal uses bash

1602610540
ryuukk_
oh i see the ark at the beginning

1602610561
ryuukk_
const exe = b.addExecutable("ark", "src/main.zig");

1602610563
ryuukk_
i forgot the z here

1602610577
ifreund
the first part is from zig and there's not currently a way to hid it

1602610620
ryuukk_
it gets in my way everytime i want to read the error message

1602610656
ifreund
nvm, that's all from zig

1602610673
ifreund
ok you can totally pipe the output through something to get rid of it though

1602610781
ifreund
the dumb way would be zig build 2>&1 | head -n -4

1602610801
ifreund
actually you're on windows, I dont know how to use windows

1602610863
ryuukk_
it is the git bash shell it works

1602610868
ryuukk_
but it removes the colors now :p

1602610882
ryuukk_


1602610899
ifreund
ah yeah, i'm not sure if we have a way to force zig to output color when it's not writing to a tty

1602611018
ifreund
oh we do for build-exe and build-lib but not for build

1602611037
ifreund
we could fix this though, it's extreemly important

1602611038
ryuukk_
it should stop here: zark...The following command exited with error code 1:

1602611080
ryuukk_
is there a way to do build-exe run?

1602611086
ifreund
zig run

1602611130
ryuukk_
it asks for a file

1602611152
ryuukk_
if i point main it won't find libs that i put in build.zig

1602611158
u0jQx9gPyrYg
zig build run

1602611184
ryuukk_
you didn't read above :p

1602611221
ifreund
zig build run is what you want if you want it to use your build.zig

1602611230
g-w1
zig build; ./zig-cache/bin/whatever

1602611237
ifreund
zig build-exe and zig run will not use your build.zig

1602611239
ryuukk_
that is what i use, but i want remove

1602611290
ifreund
which I showed you how to do, but then you lose color

1602611296
ryuukk_
why you told me zig build-exe?

1602611314
ifreund
zig build-exe has an option to force color

1602611325
ifreund
I'll just add it to zig build real quick

1602611327
ifreund
brb

1602611334
ryuukk_
oh i see

1602611377
ryuukk_
but wait, the goal is to not have what's at the end, i tried with dub and rust, and it stops at process exit, it doesn't print the full command

1602611440
ryuukk_


1602611461
ryuukk_
see? ir doesn't print the command

1602611521
ifreund
yeah? dub is a different program from zig..

1602611549
ryuukk_
i know, i said it gets in my way when i want read the error message, so it is usability annoyance

1602611565
ryuukk_
i have to scroll up

1602611591
ryuukk_
or i need to make the terminal panel large enough, wich reduce size of the text panel

1602611705
ifreund
the full command run can be very useful for debugging

1602611715
ifreund
looks like I use a smaller font and larger terminal than you though

1602611722
justin_smith
ryuukk_: I don't know how your tools work, but I can run zig from inside my editor, and the error messages turn into clickable links to the file locations

1602611745
ryuukk_
maybe there could be a normal and a verbose mode

1602611800
ryuukk_
more info is not always the best choice

1602611806
ifreund
I too have a similar setup to justin_smith

1602611838
ryuukk_
even if terminal is fullscreen, eye need to do movement from where you type the command, to where the message is located

1602611847
ryuukk_
is you build, and tehre is an error, you want see the error message first

1602611853
ryuukk_
if*

1602611859
ryuukk_
not the command u typed/generated

1602611960
ryuukk_


1602611994
ryuukk_
what you want to see is error message, not C:\dev\kingdom_zig\zark\zig-cache\o\5d125da8c009f6f5286d7710ca64dd57\build.exe for example

1602612051
ryuukk_
that would be helfull if you want to debug the zig build tool, not your program

1602612075
ryuukk_
i'm pretty sure cargo / dub don't show that for this specific reason, usability

1602612108
ifreund
sure, they're also both post 1.0

1602612141
ifreund
if you want to propose changes open an issue or pull request

1602612147
ryuukk_
that is why i talk about it, maybe it should be considered for up to 1.0

1602612217
ryuukk_
i don't want spam the repo if something is already planed, never discussed or not wanted

1602612225
ryuukk_
that is why i discuss about it first

1602612250
ifreund
yes, usability of the tooling will definietly get more focus when 1.0 is close and there is less other, more critical work to be done

1602612393
ryuukk_


1602612396
skuzzymiglet
is there a zig version manager

1602612396
ryuukk_
1.3k issues..

1602612409
skuzzymiglet
i feel tempted to write one

1602612423
g-w1
like rustup?

1602612445
skuzzymiglet
not familiar with that but i do know nvm xists

1602612452
ryuukk_


1602612463
ryuukk_
how many people are reviewers?

1602612550
ryuukk_
anyways, i get distracted too much, i forgot about my actual error..

1602612564
ifreund
skuzzymiglet: there are several afaik, but don't let that stop you

1602612567
ifreund


1602612596
skuzzymiglet
it's like the polar opposite of go, versions are extremely breaking

1602612604
skuzzymiglet
but that's to be expected

1602612613
g-w1
wow zigup is pretty cool

1602612618
skuzzymiglet
does make learning more difficult tho

1602612638
companion_cube
that's just the life pre 1.0

1602612641
TheLemonMan
yo, any windows user willing to check out #6411 and see if it crashes there?

1602612665
TheLemonMan
move fast and break things, that's how we roll

1602612684
TheLemonMan
scrap that, we just move and break things

1602612699
ifreund
only until 1.0 though, then nothing ever changes :P

1602612713
companion_cube
roll fast and break things, that's how we move

1602612749
jabb
Heyo, getting these errors when trying build against HEAD on arch:

1602612764
tdeo
do you have llvm 11?

1602612769
g-w1
its because llvm11

1602612781
g-w1
try switching to like a day ago

1602612819
g-w1
before llvm11 branch got merged

1602612820
TheLemonMan
no llvm11 in arch yet? pfft, even debian has it

1602612831
jabb
yeah that's surprising

1602612838
jabb
checking why i don't have llvm11 haha

1602612844
g-w1
heres the tracker i think

1602612851
jabb
thanks!

1602612921
jabb
i'm unfamiliar with the internals but what's the selling point of llvm11 over llvm10?

1602612933
ikskuh
TheLemonMan: i'm disappointed as well

1602612942
ifreund
jabb: AVR support for one

1602612949
TheLemonMan
jabb, faster! better! less bugs!

1602612975
jabb
nice

1602612977
tdeo
jabb:

1602612979
TheLemonMan
it fixes a few long-standing issues with Zig's weird-ass vectors being spilled in memory

1602613086
jabb
thanks for this information

1602613095
TheLemonMan
ikskuh, I spent way too much time playing with cg-workbench, I love it

1602613132
ikskuh
heh, that's nice to hear :)

1602613139
ikskuh
but it definitly needs a heavy rewrite

1602613143
ikskuh
it has so many hidden problems

1602613158
TheLemonMan
RIIZ!

1602613163
ikskuh
RIIZ?

1602613171
TheLemonMan
Rewrite It In Zig

1602613174
ikskuh
ah, sure

1602613179
ikskuh
that's the plan

1602613189
ikskuh
but i need to see how a semi-comptime type registry might work

1602613243
ikskuh
current core problem is that you cannot simply create new edge types

1602613330
ifreund
ryuukk_: --color support for zig build (I got distracted so it took more than a minute):

1602613375
ryuukk_
it's ok ifreund, i am looking into add an option in RunStep to not print the command

1602613442
ikskuh
TheLemonMan: btw, i'm happy about github issues for cg-workbench, even with just improvements

1602613521
TheLemonMan
ikskuh, what do you mean with different edge types?

1602613596
TheLemonMan
ikskuh, I was thinking of sending a PR lowering the required GL context to 4.2 as that's what my mesa version supports atm

1602613604
ikskuh
ah, sure

1602613624
ikskuh
we can probably go even further down and just disable features at runtime

1602613632
ikskuh
only GL_ARB_direct_state_access is a hard requirement

1602613661
TheLemonMan
negotiating an opengl version is harder than it should :\

1602613668
ikskuh
heh, true

1602613677
ikskuh
"try 4.5, try 4.2, try 4.0, try 3.3"

1602613678
ikskuh
:D

1602613713
ikskuh
edge types: edges transport data between nodes, "f32, vec2, vec3, texture, …"

1602613736
ikskuh
and even if you can't see it right now (as it's disabled), the project is actually fully plug-in capable

1602613747
g-w1
in zigup, it seems that it automatically uses /home/user/bin/zig I use .local/bin/ as my go to path, is there a way to do this, or should i file an issue?

1602613748
ikskuh
extending with new node types like audio, including FFT

1602613784
TheLemonMan
oh I see

1602613805
g-w1
never mind

1602613865
ryuukk_
hmm i made changes to `C:\zig\lib\zig\std\build\run.zig` but it doesn't seems to work

1602613914
ryuukk_
do i need to do something specific for changes to apply?

1602614297
ifreund
nope

1602614301
TheLemonMan
it should pick them up automagically

1602614304
ifreund
try a print statement or something

1602614341
ryuukk_
oh changes must be made in build.zig

1602614349
ryuukk_
C:\zig\lib\zig\std\build.zig

1602614460
ifreund
well std/build.zig @imports std/build/run.zig

1602614883
ryuukk_


1602614889
ryuukk_
straigth to the point

1602614920
ryuukk_
there was options in the builder for verbosity, i added a new verbose_build

1602614978
ifreund
that's cause verbosity should be set on the command line not in the std.build API

1602614986
ifreund
see zig build --help

1602615035
ifreund
oh wait, I read what you wrote wrong

1602615046
ifreund
ignore me

1602615572
ryuukk_


1602615585
ryuukk_
the last one is on compiled in the zig.exe

1602615601
g-w1
I just installed nix. In some of his streams I saw andrew using some nix files in nix-shell. Are these avalible?

1602616006
ryuukk_
1st contribution

1602616048
TheLemonMan
you didn't run zig fmt over the files you changed!

1602616157
ryuukk_
i follow same code style, is something wrong?

1602616167
g-w1
if(self.verbose_build)

1602616172
TheLemonMan
^^^ yep

1602616176
ryuukk_
oh my bad

1602616188
earnestly
Wait, your PR removes the invocated command-line and its flags?

1602616243
g-w1
I think it adds a flag

1602616276
earnestly
Oh good, it's like all those Makefiles that removes the actual command-line and hides it behind a useless 'CC' so that I have to hope it has some VERBOSE flag so that when I rerun the command I get /real/ information

1602616331
earnestly
I just love it when tools tell me "Sorry, I failed.  You should have run me with some verbose flag so I actually give you useful diagnostics"

1602616349
ryuukk_
it is now an option, it is only usefull when you debug the build tool in my opinion, you have your commands in the build.zig file

1602616387
ryuukk_
maybe i have wrong assumption and it shouldn't be even an option, it's possible, but i find the ouput cleaner now

1602616390
earnestly
How a command expands is not reflected in a build.zig

1602616407
ifreund
yeah I'm not sure this should be disabled by default

1602616425
ryuukk_
the verbosity adds clutter and hides actual error message in your program

1602616427
earnestly
This kind of crap is something that has wasted hours of my life

1602616438
ryuukk_
it would if it wasn't an option

1602616450
earnestly
ryuukk_: Make it not default, include a 'be quiet' flag rather than a 'be verbose' one

1602616461
ryuukk_
looking for error message each time you build actually might waste u more hours

1602616469
earnestly
Tools should always fail loudly, but otherwise be silent

1602616471
earnestly
(ideally)

1602616490
earnestly
ryuukk_: Fortunately we have tools that make searching through textual information a doddle

1602616523
earnestly
It's not so much fun when that information isn't there in the first place

1602616567
earnestly
And ensuring path location hasn't gone ary is one of the most /key/ pieces of information I need, especially when integrating into wonky systems

1602616636
ryuukk_
why would everyone pay price of verbosity by default? when all care about is looking for compiler output when build your program

1602616649
earnestly
It gets even worse in CI systems, where fortunately things like cmake do allow me to use `make VERBOSE=1' but that it's not the default is just anti-user

1602616684
earnestly
ryuukk_: There's no price, verbosity is only used in diagnostics, i.e. when you need it to be verbose

1602616693
earnestly
It's the "rule of silence"

1602616711
ryuukk_
exactly, diagnostic, you must be explicit for more informations

1602616739
ryuukk_
it's not silence, you get the error message about your program

1602616748
ryuukk_
that's the main information you need

1602616749
earnestly
Yours removes part of that message

1602616751
ifreund
he means verbosity only on failure, your PR removes much of the verbosity of failure

1602616753
ryuukk_
no

1602616763
ryuukk_
.\src\main.zig:80:70: error: expected optional type, found '*const .glfw.cimport:6:5.struct_GLFWvidmode'

1602616768
ifreund
on success it should always print nothing

1602616770
ryuukk_
is all i care about when i want build my code

1602616781
ifreund
but that's not what people packaging your code care about

1602616798
ifreund
or at least potentially not

1602616804
ryuukk_
do you package code more often than build your code?

1602616809
earnestly
ifreund: It's part of it yeah

1602616845
ifreund
no, but packagers shouldn't need to be familiar with all the zig command line options to get useful diagnostics on failure

1602616864
earnestly
ryuukk_: Yes

1602616869
ifreund
zig developers however should be capable of passing an extra flag if they want quieter output

1602616891
ryuukk_
packagers should knock at door and ask for more informations

1602616911
ifreund
earnestly definitely does, I don't but I do maintain a handful of packages

1602616924
ifreund
ryuukk_: that's exactly what we don't want

1602616927
earnestly
ifreund: This kind of thing is what makes me want to stop doing it

1602616947
ryuukk_
what would be packager job if there would be no developpers to write and build the code?

1602616948
ifreund
we want packaing zig code to be as easy and intuitive as possible

1602616971
ryuukk_
but is clutter the job of developper to build and debug the code

1602616988
Nypsie[m]
What problem does this solve if we have multiple errors, with multiple stacks?

1602616990
ryuukk_
zib build pacakge, and put the verbose option there

1602617000
ryuukk_
zig build package

1602617010
earnestly
ryuukk_: Why not a quiet flag instead?

1602617014
ifreund
^

1602617027
ryuukk_
what is a quiet flag?

1602617044
ifreund
the opposite of what your PR does

1602617045
g-w1
zig build --quiet

1602617057
ifreund
keep it verbose by default, add a flag to make it less verbose

1602617082
ryuukk_
i know what it is i wanted you to explain me, what quiet in context of build?

1602617102
ifreund
less verbose

1602617197
ryuukk_
why have build.zig then?

1602617216
ryuukk_
printing commands = i want to debug the build.zig

1602617218
ryuukk_
not my program

1602617258
earnestly
So use quite flag to not print them?

1602617432
TheLemonMan
build.zig may contain complex pipelines and you want to know exactly where it got messed up

1602617466
ryuukk_
it's not always the case, when specific needs, use verbose flag

1602617478
TheLemonMan
defaults matter

1602617502
ifreund
especially for distro maintainters who are not zig developers

1602617534
earnestly
It's no good trying to debug a transient error when faithful error reporting can only be requested after the fact

1602617552
ryuukk_
for specific needs, specific options

1602617584
ifreund
exactly. Hiding output is a specific need

1602617616
TheLemonMan
wait, I'll side with ryuukk_ so we can have a healty 2vs2 fight

1602617619
ryuukk_
it is not hiding output

1602617644
alva
+1 for quiet instead of verbose flag :-þ

1602617922
ryuukk_


1602617925
ryuukk_
path of zig?

1602617931
ryuukk_
just type where zig afterward

1602617940
ryuukk_
path of cache? it's in the current folder

1602617953
ryuukk_
this folder? 5d125da8c009f6f5286d7710ca64dd57\build.exe why?

1602617966
ifreund
that's the full zig build-exe command line generated by your build.zig

1602617967
ryuukk_
path of the project you compile? you are in it already

1602617999
Piraty
argh i hate backslash. so glad i didn't had to touch a windows machine in months

1602618025
ryuukk_
cann't say this is usefull, on first sight, can't decode 80% of it because weird paths

1602618040
ryuukk_
if need more info, read build.zig

1602618045
ifreund
which may be non trivial to determine based on reading the build.zig

1602618048
ryuukk_
if suspect bug, add verbose

1602618068
ryuukk_
all it does is hide error message of your program

1602618089
ifreund
this isn't really going anywhere, I'll paste a log as a comment on the PR and let the andrew decide

1602618104
ifreund
though he probably has better things to do in the last 2 weeks before a release

1602618143
ryuukk_
there is IRC log, not need put specific comment, full context is better

1602618176
ifreund
yes I will link to the logger

1602618335
ryuukk_
I added it

1602618787
ryuukk_
that information only needed once, when you change build.zig

1602618791
ryuukk_
then never again u need it

1602618821
KernalWayne
Having done build engineering in the past, verbose output should definitely be the default, IMO.

1602618849
ryuukk_
provide arguments why you need information that doesn't change everytime you build program?

1602618929
ifreund
it may not change in your specific environment with simple build.zig, but it may very well change once you introduce build options and have people compiling on different OSes

1602618951
ryuukk_
specific need, only needed once, when you package it once

1602618953
ifreund
I don't feel like this is going anywhere though, I'm going to go be productive

1602618975
ryuukk_
why stop when i ask for arguments?

1602618975
ryuukk_
> I don't feel like this is going anywhere thoug

1602619067
ryuukk_
maybe packager need the time, so we should print the date when it built, otherwise he can't type in read me when it built? (of course this is a troll, but this is relevant)

1602619112
ryuukk_
maybe should also print all environment variable, because it can impact build?

1602619134
ryuukk_
maybe OS name / ketnel version in case he forgot it

1602619175
ifreund
none of that information is related to zig

1602619230
ifreund
well, printing a message when an environment variable affects the build is a great idea and what sane build systems do

1602619241
ifreund
but that's orthagonal to the issue at hand

1602619245
ryuukk_
the point is it's information that doesn't change and is needed only once

1602619318
ifreund
it can and will change depending on the build environment and options passed to zig build

1602619471
KernalWayne
The info may be needed potentially every time the code is built.

1602619488
KernalWayne
Maybe not by you during development, but by package/distro maintainers, etc.

1602619520
KernalWayne
Or in a team setting, other developers.

1602620200
ryuukk_
ok so let's rewind a little bit and examine the issue:

1602620200
ryuukk_
[7:32:08 pm] <ryuukk_> it makes it hard to just look at the actual error message

1602620225
ryuukk_
maybe reordering the output would help?

1602620232
ryuukk_
1st the command, the the stack trace?

1602620254
ryuukk_
maybe still print the command, but ommit the rest?

1602620361
KernalWayne
As long as the diagnostic info remains present. Code isn't always built by someone sitting in front of a terminal.

1602620379
KernalWayne
Think about automated builds that may be diagnosed after the fact by examining logs.

1602620403
KernalWayne
Nobody in that situation wants to rerun a build and add a flag to get more info.

1602620413
KernalWayne
They want to fix the problem with the info at hand.

1602620441
ryuukk_
reordering the ouput then is the way to go?

1602620484
ryuukk_
no matter how long the ouput is, people can see it, and the error message is easier to read, not more scroll up

1602620522
KernalWayne
Perhaps. I just don't think it's a good idea to make things "quiet" by default.

1602620537
KernalWayne
A lone developer my find that case useful for the reasons you suggest.

1602620563
KernalWayne
But in just about all other cases, verbosity is more valuable.

1602620629
ryuukk_
i don't like quiet word, that imply something is noisy or print constant and lot of uneeded information, i'm not saying the command like is unneeded information, all i'm saying is it's not needed everytime

1602620707
ryuukk_
imagine you link ton of libraries, becomes 10 lines of information, your program error message will be way above, out of the actual context

1602620752
ryuukk_
long path + long library names, enough to make stuff even more clutered

1602620798
ryuukk_
so i think, reordering the info would be a fair change

1602621094
KernalWayne
That's reasonable. Nothing wrong with examining how the output is ordered/presented and making it more useful for everyone.

1602622816
jabb
looking at old zig code, can't remember what `param: var` means in new zig

1602622839
TheLemonMan
param: anytype

1602622843
jabb
ahh yes

1602623080
ryuukk_
how does it know its size of anytype, it is a comptime feature?

1602623101
ifreund
it is comptime only yes

1602623112
TheLemonMan
hm? the anytype is replaced by the actual type on instantiation

1602623134
ryuukk_
what would be use case? it is not what generic do?

1602623171
ikskuh
ryuukk_: that's how generics work in zig

1602623194
ikskuh
you either specialize params on a previous type parameter or you use anytype params

1602623197
ifreund
TheLemonMan: last I checked you could put comptime anytype fields in structs, which is kinda weird

1602623210
ifreund
almost made building tuples possible

1602623306
ikskuh
ifreund: tuples are just structs

1602623315
TheLemonMan
I guess it's just a missing check in stage1

1602623318
ikskuh
anytype fields in structs are the same as in tuples

1602623395
ifreund
ikskuh: this is what we were trying:

1602623424
ikskuh
std.meta.ArgsTuple

1602623467
ikskuh


1602623502
ikskuh
is that what you are searching?

1602623526
tdeo
anytype fields are intentional, they're used in TypeInfo

1602623586
ifreund
ikskuh: awesome, we can close that issue then

1602623596
ifreund
we didn't have @Type back then

1602623608
ikskuh
heh, you can thank tdeo for that function :)

1602623619
ikskuh
they implemented @Type, and i just made the logic followup :D

1602623653
ikskuh
there's also std.meta.Tuple([]const type) if you want to create tuple from a known array

1602623743
ifreund
daurnimator: \o/

1602623751
ifreund
very nice

1602624435
ryuukk_
reordering messages seems like a more daunting task, i'm not familiar enough with zig to make that change yet

1602625097
ryuukk_
how to read output from ChildProcess ?

1602625146
ifreund
ryuukk_: you could set stdout_behavior to .Pipe

1602625179
ryuukk_
it is already to .Pipe, i want store it, then to be able to print it after the command in build.zig

1602625182
ifreund
(and then read from ChildProcess.stdout)

1602625207
ryuukk_
command is print after process is launched, on error

1602625224
ryuukk_
so need to read output before, and print it in the error handling place after print the command

1602626340
daurnimator
ifreund: oh cool; I'll give it a try with autolua and if it works close it

1602627441
ifreund
:)

1602631512
ryuukk_
i try to use this library:

1602631525
ryuukk_
.\src\glad.zig:10:27: error: invalid token: 'extern'

1602631525
ryuukk_
pub const GLADloadproc = ?extern fn ([*c]const u8) ?extern fn () void;

1602631538
ryuukk_
i can't find documentation about that

1602631545
ryuukk_
does anyone have an idea?

1602632108
waleee-cl
ryuukk_:

1602632155
waleee-cl
ah, it wasn't the same error

1602632451
ryuukk_
i removed the whole zig part and kept the cimport, i'm gonna use c api directly it's ok

1602632659
waleee-cl
Anyone got an explanation of 'extern?' ? I haven't seen it before and it's absent from docs and absent in the zig repo

1602633058
waleee-cl
oh, right, it might be productive to grep for the right keyword (misplaced '?')

1602633177
waleee-cl
... but didn't yield any matches either

1602633530
justin_smith
waleee-cl: wouldn't it mean an optional extern function?

1602633585
justin_smith
that is, the compiler lets you pass an extern function or null, and forces you to null check before using it as applicable

