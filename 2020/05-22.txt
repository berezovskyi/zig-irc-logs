1590105888
dimenus
optional pointers prevent so many bugs

1590109123
stripedpajamas
having a tricky time creating [][]u8 programmatically from a SplitIterator. i was trying to use ArrayList([]u8). is there a better way?

1590111298
ifreund
well you could do an ArrayList(ArrayList(u8))

1590111314
ifreund
depends on your use case really

1590111907
fraktor
Is there a way to do something like a comptime if?  I basically want to ensure that a pair of constants add up to 16.

1590111978
andrewrk
fraktor, comptime assert(x + y == 16);

1590112071
fraktor
I'm getting an error that says "unexpected token" at the '('.

1590112211
andrewrk
global scope? use a comptime block

1590112217
andrewrk
comptime { ... }

1590112247
fraktor
I did not realize.  Thank you

1590112252
andrewrk
no problem

1590113017
fraktor
Also, is there a built-in way to turn a SegmentedList into an owned slice?

1590113044
fraktor
If not I can just write a quick function out of an iterator.

1590113048
andrewrk
that would require a copy since the elements are not contiguous in memory

1590113108
fraktor
That's true.  I'm okay with a copy in my case, but I understand why that's not advantageous to have in the API.

1590113191
andrewrk
it would make sense to have an API function for copying a range

1590113217
andrewrk
it would break it down into a small number of memcpy calls rather than iterating over each index with at()

1590130748
opDispatch
what's better for zig ? vim or emac ?

1590132854
wilsonk
opDispatch: if you want auto completion then vscode is probably best with zls at this point. Otherwise vim vs emacs is probably pretty similar

1590132996
opDispatch
ok understood, so no auto completion in vim nor in emac.

1590135053
daurnimator
wilsonk: why not ZLS with some vim language server plugin?

1590138448
ifreund[m]
ok kak-lsp

1590138458
ifreund[m]
s/ok/or/

1590142863
wilsonk
daurnimator: I am just stating that vscode already has the 'plugin' so there is no extra setup required to get the auto completion. Maybe I should have been more specific about that. I think you could use emacs with the company-backends to get autocompletion working also, just not sure how much work that is

1590142939
wilsonk
I am not a vscode fanboy (actually prefer emacs in evil mode) but I am using vscode because of the ease of setting things up

1590151519
fengb
wilsonk: can you add Zanic to the store? I need another mug :)

1590151542
wilsonk
fengb: sorry Zanic?

1590151574
fengb


1590151649
wilsonk
fengb: you just want that exact pic on a mug? Or are there other items I should make with that design?

1590151682
fengb
I just want a mug. Curious if anyone else cares >_>

1590151800
wilsonk
Ok, I can leave an open invite here in case anybody else wants some other design. I don't have any Ziggy designs but was thinking of adding them so I can do that at the same time (I will probably do a full kit-out with Ziggy, I suppose, since I think I remember a request a while ago for that design on some shirts or something).

1590151873
alexnask
Ziggy tshirt yould be cool yeah

1590151874
wilsonk
fengb: do you need it right away? Or can we leave this open for a few hours...I will be going to sleep soon is why ;)

1590151891
wilsonk
alexnask: ok, noted

1590151905
fengb
Gottagofast

1590151912
alexnask
Didnt realize you were the one running the store btw :-)

1590151913
fengb
Of course it isn‚Äôt urgent :P

1590151914
wilsonk
Lol

1590151918
alexnask
Thanks for that

1590151930
wilsonk
no problems

1590151941
fengb
Might want to ping Discord too. Maybe get some buyers

1590151947
wilsonk
Ok

1590151963
fengb
Thanks!

1590152030
ifreund
hmm, it'd be nice to update the shirts to the new logo as well

1590152104
wilsonk
ifreund: sorry which new logo? Or do you mean Ziggy?

1590152177
ifreund
wilsonk: it was updated a little while ago, new font and slightly cleaned up design

1590152226
ifreund
and the original issue

1590152514
wilsonk
ifreund: I guess I could if it is really necessary, but it is such a small difference that I might have to delete the original store to update to that logo...otherwise one probably couldn't tell the difference on the storefront. Adding Ziggy merch in a different store should work fine and a Zanic item or two (or new storefront also) would work too, but the slight difference of the new logo might be an issue.

1590152567
ifreund
wilsonk: I'm sure you know better than i do what the practical way to handle things would be :D

1590158765
cren
what's the rule for the letter case of builtin functions? @import is... that, and @TypeOf has UpperCamelCase. Shouldn't it be @Import?

1590159065
ifreund
in general is it returns a type it should be TitleCase, which means you're technically right about @Import being correct

1590159067
cren
looking at the docs, I can see that most of the builtins are lower camel case, but some seem to be upper camel for some reason

1590159084
cren
oh, if it returns a type? that makes sense

1590159101
ifreund
yeah that's the idea

1590159112
ifreund
@import seems inconsisent now to me though

1590159134
cren
it doesn't always return a type though. std is a struct, right? Not a type.

1590159147
cren
`@import("std")`

1590159167
ifreund
oh i'm being obtuse

1590159198
ifreund
yeah it makes sense as is

1590159252
ifreund
this is documented here:

1590159345
fengb
structs are types though

1590159607
alehander92
oi

1590159646
alehander92
i will try to learn a bit more zig with some example programs(main xp : nim/c/go lately)

1590159700
alehander92
i am thinking of `grep` and all kinds of cli

1590159710
alehander92
or generic stuff: i am very interested in writing dsl-s

1590159717
alehander92
what would be a good example of dsl

1590159732
alehander92
typical for zig? i guess something returning new types based on declarative code?

1590159957
ifreund
fengb: indeed, maybe it should be @Import...

1590160217
cren
a `const` string of type `[]u8` is really a `const` pointer to the first item of a slice (and the length of the slice), right? So that makes the string mutable, right?

1590160261
alexnask
[]u8 is mutable yes, []const u8 is immutable

1590160820
cren
How do I read a file from the filesystem with Zig?

1590161026
nycex
there are multiple ways

1590161028
fengb


1590161030
nycex
look at the std.fs namespace

1590161062
cren
I found std.fs

1590161071
cren
just now

1590161387
alehander92
guys

1590161410
alehander92
do you usually loop around command line args with `for(std.os.argv)`

1590161555
ifreund
i use std.process.args() and getNextPosix()

1590161579
ifreund
*nextPosix()

1590161663
alexnask
std.os.argv is not set on windows iirc

1590161707
ifreund
and nextPosix() doesn't work on windows but i don't really care :D

1590161750
alexnask
T_T

1590161922
fengb
I think `std.process.argsAlloc` only exists because of windows >_>

1590161922
alexnask
andrewrk, Have you had an opportunity to look at #5151 yet by any chance? Just curious about your general thoughts on it, the concept looks really cool to me and I wonder if I should build upon it and add some more allocator types that could potentially make it to std some time

1590161962
andrewrk
I haven't looked yet

1590161996
alexnask
üëç

1590163590
alehander92
what do you guys use for strings?

1590163601
alehander92
and lists: just `[]u8` and ArrayList ?

1590163672
ifreund
depends on if the string will change size or not, if it will, then ArrayList(u8) otherwise a []const u8

1590163715
ifreund
ArrayList should be your default resizeable container, though i also use a lot of linked lists in my project due to the need for pointer stability

1590163856
betawaffle
didn't the repo have a shell.nix (or something like that) in the past?

1590163857
alehander92
ok

1590163872
betawaffle
andrewrk: you still run on NixOS?

1590163918
alehander92
so in this case function like `grep` which takes all kinds of strings would take ArrayList

1590163956
ifreund
only if grep needs to resize the strings

1590163964
ifreund
if not a slice is all that's needed

1590164004
alehander92
but i get expected []u8 got [7]u8

1590164017
ifreund
you need to take the adress of your array then

1590164026
ifreund
grep(&my_array(

1590164037
ifreund
(with the proper parentheses)

1590164066
andrewrk
betawaffle, yes

1590166921
alehander92
global_allocator

1590166930
alehander92
leads to OutOfMemory to me

1590166937
alehander92
after only 593 additions to a list

1590166941
alehander92
of string slices

1590166951
alehander92
should i tweak its size

1590167163
andrewrk
global_allocator? that was removed a long time ago

1590167363
alehander92
huh it's just a big array

1590167367
alehander92
yeah i use 0.6 man

1590167376
alehander92
from the downloads in the website

1590167415
alehander92
huh its 0.5.0

1590167476
alehander92
anyway, is there a good allocator to use for common CLI apps? i guess a global one based on a big array

1590167480
alehander92
ones*

1590167496
alehander92
but probably that's naive (always edge cases)

1590167497
andrewrk
0.5.0 is unsupported

1590167515
alehander92
sorry yeah, my question applies to 0.6

1590167516
leeward
If you want easy and functional, C's allocator works well (though you have to link libc)

1590167532
andrewrk
alehander92,

1590167567
alehander92
huh i must ve seen that before: sorry, ty

1590167646
leeward
Hmm,

1590168036
fraktor
alehander92: If it's an application that will have a short run time and is okay with not deallocating things in the middle of operation, wrapping std.heap.page_allocator in an ArenaAllocator should give decent performance.  Otherwise the c allocator would be a good choice.

1590168077
fraktor
andrewrk: Is the general-purpose allocator project still active?  The latest commit is 6 months ago.

1590168090
alehander92
thank you!

1590168098
alehander92
my `grep` is now halfway there

1590168110
alehander92
i can just leave it be a `tree` command

1590168120
alehander92
but in zig 0.6 it seems just passing &"" doesnt work

1590168170
satchmo_
I have a question about the Allocator interface (pre-#5064). Is it correct to say that reallocFn and shrinkFn are the only functions that require implementations, while the rest can be optionally overridden?

1590168171
andrewrk
fraktor, it needs to be revived, but yeah I'm pretty sure it'll happen soon because the self hosted compiler (which is a big focus of this release cycle) needs it

1590168204
andrewrk
alehander92, string literals are already pointers

1590168254
andrewrk
satchmo_, yes reallocFn and shrinkFn are the only functions that require implementations. The rest will always be provided and cannot be overridden

1590168280
alehander92
ok! so `[]const u8` !

1590168307
alehander92
hm, this syntax seems a bit confusing tho because the error message uses `*const [7:0] u8`

1590168316
andrewrk
alehander92,

1590168331
andrewrk
you should check out the release notes :)

1590168375
alehander92
yeah, sorry

1590168418
alehander92
so in this case what i didnt get was the difference between `*const [stuff] typ` and `[]const typ` syntax : e.g. why slices dont just use `*const [] typ`

1590168429
alexnask
5151 with some more composable allocator parts => 1 liner allocator definitions is my dream

1590168430
satchmo_
andrewrk: does that mean the only differences between allocators is how they realloc/shrink? Sorry if this is obvious, I'm a bit new to allocators.

1590168443
alehander92
it seemed inconsistent from outside, but probably there is an obvious reason

1590168468
alexnask
satchmo_, realloc and shrink also do the allocation and deallocation ;)

1590168485
andrewrk
allocation is just reallocation with an old size of 0

1590168496
andrewrk
freeing is reallocation with a new size of 0

1590168505
andrewrk
the only reason there are 2 functions is that one of them is not allowed to fail

1590168531
fengb
But we‚Äôre gonna split out resize in place right?

1590168551
andrewrk
alexnask, I'm excited to check it out. I'll be sure to do that after landing the branch I'm trying to finish up

1590168555
satchmo_
ahhhhhh, I see now. Thanks!

1590168585
andrewrk
yeah something is going to change to the allocator interface

1590168586
alexnask
Marler is literally allocator Jesus

1590168589
andrewrk
lol

1590168593
alehander92
i see its more similar to `array` type

1590168634
andrewrk
alexnask, maybe some of that code will be useful in allocating .text segment blocks for self-hosted incremental compilation :)

1590168652
andrewrk
it's the same problem, after all

1590168661
alexnask
I feel like Ive overhyped this PR

1590168687
andrewrk
if it doesn't cure cancer I'm going to reject it

1590168694
alexnask
It just happened to fit my bias like a glove

1590168706
fengb
But... #1717 cures cancer

1590168707
alehander92
so why not just implementing `shrink` as a wrapper around reallocate

1590168731
alehander92
and ignore any error inside (asserting it cant possibly error for its args)

1590168742
fengb
realloc can fail. Shrink cannot

1590168746
satchmo_
alehander92: I think andrew said one of them never fails

1590168747
ifreund
we can have both 1717 and 5064 though, cancer cure and alexnask's glove

1590168759
alehander92
yeah but usually the implementation can be shared

1590168772
alehander92
and shrink can be just a call to realloc which expects no fail anyway

1590168778
fengb
Although there‚Äôs a separate task to make free optional

1590168813
fengb
I think the latest accepted proposal is: alloc / resizeInPlace / free

1590168838
fengb
And the last two are optional. So it‚Äôll streamline these implementations

1590168949
satchmo_
despite being relatively new to Zig, even I was excited after reading that proposal lol

1590168954
satchmo_
it just seems so nice

1590168988
alexnask
The talk linked is quite good too

1590169001
alexnask
Although I think there is a better version in DConf or smth

1590169741
alehander92
i reached unreachable code!!

1590169745
alehander92
seems cool

1590169764
andrewrk
check your front door, the police are outside

1590169800
alehander92
i got `EFAULT` from write

1590169826
andrewrk
you passed a bad pointer to the kernel

1590169865
alehander92
hm, i print stuff i got from `split`

1590169914
alexnask
as in std.debug.warn?

1590169932
alehander92
eh, yes , it has a limit?

1590169951
alehander92
i shouldn't just warn so much

1590169978
alehander92
or i might get into a global warning discussion

1590170036
ifreund
no, calling warn isn't the problem

1590170053
ifreund
it's whatever you're passing to it (if that's really the line that's triggering this)

1590170078
alehander92
yeah i just got it with stdout print too

1590170599
fraktor
By the way andrewrk, should I make an issue and pull request for adding a way to copy portions of a segmented_list into contiguous memory?  I've got some working code that's passing tests, but I'm not sure if the API is what we want.

1590170645
andrewrk
feel free to put it up, let's take a look

1590170737
andrewrk
I'm guessing it would look like:  pub fn copy(self: Self, dest: []T, start: usize, end: usizee) void { ... }

1590171184
fraktor
andrewrk: The only difference is that I didn't add an end, and just assumed you wanted to fill the slice.  I can easily change that though, since I just say `const end = start + dest.len`.

1590171281
pixelherodev
Is a tuple of tuples valid?

1590171326
alexnask
I dont see why not

1590171347
pixelherodev
Neither do I, the syntax just feels weird :P

1590171484
pixelherodev
I wish there was a way to have an import return an enum instead of a structure

1590171495
pixelherodev
Single-file enums should be just as easy to use as single-file structures

1590171505
pixelherodev
s/ingle-file/elf-contained/g

1590171523
fraktor
I mean, can't you just do `const MyEnum = @import("myenum.zig").MyEnum;`?

1590171530
pixelherodev
Yes, but you can do that for structures too

1590171541
pixelherodev
My point is that it shouldn't be less convenient to do it for enums

1590171551
pixelherodev
With a struct, it's just `const MyStruct = @import("mystruct.zig");`

1590171561
fengb
export default enum üôÉ

1590171566
pixelherodev
?

1590171578
fengb
Steal inspiration from JS

1590171589
fraktor
I thought that const mod = @import("mod.zig"); would import the whole namespace, not just the struct.

1590171604
pixelherodev
fraktor: namespaces

1590171618
fengb
Files are structs. Namespaces don‚Äôt exist at a technical level

1590171621
pixelherodev
^

1590171626
pixelherodev
Yeah, that's more accurate

1590171641
pixelherodev
"Zig's namespacing is provided via structures" would be a better way to put it

1590171653
pixelherodev
My point, I mean, not fengb's :)

1590171668
pixelherodev
When you import std, std is a struct

1590171670
fengb
The docgen simply treats empty struct field as a namespace

1590171695
pixelherodev
You can have fields and such at the root of a file

1590171704
pixelherodev
and if you use @This(), you can use it as a proper struct

1590171713
pixelherodev
But you can't have an

1590171724
alehander92
guys

1590171725
pixelherodev
The problem is, I don't think there's a good way to do it

1590171736
ifreund
yeah there really isn't

1590171743
pixelherodev
Even if there was e.g. @importEnum, you'd need a new way to specify the file was an enum

1590171744
alehander92
i hit a strange issue in next in walker in fs.zig

1590171747
alehander92
/ `top` becomes invalid after appending to `self.stack`.

1590171748
alehander92
happens

1590171748
pixelherodev
Well, no you wouldn't...

1590171755
pixelherodev
Because the import method

1590171759
pixelherodev
Actually, I think it can be done

1590171762
pixelherodev
Not sure it's worth it though

1590171764
alehander92
and indeed it appends, after that tries to return entry based on top which segfaults

1590171777
alehander92
should i try to debug that more

1590171783
ifreund
enums/unions also have things like tag types and and ordinal values

1590171786
pixelherodev
Can't help with that, sorry

1590171790
pixelherodev
ifreund: true

1590171799
fengb
@import(‚ÄúFoo.enum.zig‚Äù)

1590171800
pixelherodev
Tags and ordinals are the only blocker that I can think of though

1590171817
alehander92
what i mean is, is it a bug in fs function to have a segfault or does it depend

1590171818
pixelherodev
Actually

1590171826
pixelherodev
ifreund: `@importEnum(path, ordinal)`

1590171842
pixelherodev
The problem there is it breaks the standard encapsulation

1590171849
pixelherodev
You shouldn't be able to define the ordinal outside the enum

1590171852
ifreund
pixelherodev: that's not a solution imo

1590171857
ifreund
yeah waht you said

1590171858
pixelherodev
That's what I'm saying :)

1590171866
fengb
I know

1590171882
pixelherodev
... why not just have top level be a `return` for @import?

1590171885
ifreund
basically it would be neat if there was a way to do it that isn't full of problems

1590171886
pixelherodev
I mean, yes Node does it

1590171889
pixelherodev
which is a strike against it

1590171901
fengb
@import(‚ÄúFoo: enum(u8).zig‚Äù)

1590171904
pixelherodev
plus I do like it as is...

1590171905
ifreund
hmm, that could help the generic types thing too

1590171914
ifreund
top level functions?

1590171917
fengb
Nodejs way is terrible

1590171920
pixelherodev
Yeah exactly ifreund

1590171932
pixelherodev
fengb: I'm looking for technical reasons that apply to Zig though

1590171935
pixelherodev
Node is terrible

1590171937
pixelherodev
That's a given

1590171950
pixelherodev
I'm looking for a reason that a specific feature it has is bad in a specific context though :P

1590171960
alehander92
i have to open an issue

1590171972
fengb
Their default export got worse in ES6

1590171973
pixelherodev
Node has addition; we shouldn't avoid ideas just because horrible projects use it

1590171975
ifreund
i think toplevel functions would be blocked by 1717

1590171978
alehander92
probably , sorry for no time now

1590171981
pixelherodev
Yeah exactly

1590171984
pixelherodev
alehander92: that's a good idea

1590171992
pixelherodev
Open an issue, so people can see it and provide help when they have time

1590172006
pixelherodev
IRC is more meant for immediate discussions

1590172011
alexnask
Lets just use different file extensions for different types of files

1590172014
pixelherodev
There

1590172015
fengb
No I mean imports and exports are crappy

1590172020
alehander92
yes, no problem just wondered if there is like a policy

1590172028
pixelherodev
alehander92: Not that I'm aware of

1590172030
alehander92
(e.g. segfault in stdlib function always an issue vs not)

1590172035
pixelherodev
Just open an issue

1590172037
pixelherodev
It's fine

1590172051
alexnask
.zig -> struct, .zit -> enum, .zif -> functions, .ziu -> unions

1590172054
alehander92
ok, thanks !!

1590172055
pixelherodev
Worst case, you find out you were using a function wrong and you feel dumb for a few minutes

1590172059
pixelherodev
It's happened to all of us probably :P

1590172070
pixelherodev
alexnask: doesn't really help

1590172074
pixelherodev
See discussion above re ordinals

1590172075
alehander92
yeah, no worries :D i

1590172087
alexnask
pixelherodev, Yes I was obviously trying to help all along /s

1590172098
pixelherodev
lol

1590172106
pixelherodev
Seriously though

1590172112
fengb
alexnask: we have room for only 1 troll here

1590172114
pixelherodev
Can someone give me a specific reason why top-level returns would be bad for Zig?

1590172146
pixelherodev
Or at least, why they wouldn't be better than status quo

1590172153
ifreund
pixelherodev: i'm not quite clear on the syntax you're proposing

1590172162
ifreund
where do you specify the function signature?

1590172177
pixelherodev
In the file

1590172181
pixelherodev
Top of the file would look like this:

1590172195
pixelherodev
`return fn(arg_list) func_attrs return_type {};`

1590172202
pixelherodev
This would of course require #1717

1590172236
pixelherodev
Existing structures become `X` -> return struct {X}`

1590172241
pixelherodev
and so on

1590172244
ifreund
hmm, imo if that's implemented it should replace the current thing

1590172247
pixelherodev
That's the idea

1590172253
fengb
How about @This() = fn () {

1590172262
ifreund
i like that

1590172276
pixelherodev
fengb: how's that better than tlrs?

1590172279
pixelherodev
(top level returns)

1590172293
fengb
Because it‚Äôs not a return

1590172295
pixelherodev
I'm not opposed, just curious

1590172296
pixelherodev
So?

1590172297
fengb
There‚Äôs no control flow

1590172299
ifreund
it feels a little more explict

1590172310
pixelherodev
Ahh

1590172318
pixelherodev
Just to clarify then

1590172327
pixelherodev
fengb: the idea was never to allow control flow

1590172328
ifreund
it's more intuitive to me than a random return and implicit file-level function scope

1590172332
pixelherodev
it wouldn't be e.g. return if() else

1590172335
pixelherodev
but yes I do like that

1590172341
fengb
Then I‚Äôm not sure why it‚Äôd be return

1590172345
pixelherodev
You want to open the proposal, since it's your idea?

1590172356
pixelherodev
fengb: because it's

1590172376
fengb
It‚Äôs more of an export default

1590172377
ifreund
hmm, what happens to the other stuff in the file?

1590172394
ifreund
also this kills my lovely toplevel fields

1590172399
ifreund
rip indentation

1590172400
fengb
Yuck back to ES6 crap

1590172438
fengb
Well we can‚Äôt auto export if we want top level functions

1590172444
fengb
Since functions aren‚Äôt namespaces

1590172451
fengb
But what if they were? ü§î

1590172467
ifreund
that sounds really weird

1590172474
fengb
Containers*

1590172496
fengb
Nah it‚Äôs fine. Just like JavaScript

1590172525
fengb
Actually it‚Äôs solve a few things for me, like tagging

1590172527
pixelherodev
okay please stop the trolling :P

1590172535
pixelherodev
I can't tell what's real and what's not anymore

1590172549
fengb
I‚Äôm always trolling

1590172556
fengb
That 1% of brilliance is pure luck

1590172568
fengb
I‚Äôm a walking 1 million monkeys

1590172603
pixelherodev
ugh

1590172616
pixelherodev
Actually

1590172622
pixelherodev
everything-as-a-namespace isn't necessarily a bad idea

1590172665
pixelherodev
That allows static variables in functions, userspace union tags and ordinals (instead of in the language itself), and probably a few other neat tricks

1590172685
pixelherodev
still doesn't solve the imports issue though

1590172689
fengb
Are you agreeing with my trolling?

1590172690
pixelherodev
Actually, yeah, it does

1590172705
pixelherodev
fengb: that's the wrong question

1590172719
pixelherodev
The right question is, how do you deal with a troll?

1590172731
fengb
Fire and acid

1590172748
fengb
Gotta melt them limbs

1590172847
pixelherodev
lol

1590172858
pixelherodev
Anywho

1590172860
pixelherodev
jokes aside

1590172868
nephele
pixelherodev, give them so much authority they cant troll anymore, obviously

1590172877
pixelherodev
I do think there should be a way to import enums, functions, etc

1590172879
pixelherodev
The problem is

1590172882
pixelherodev
s/hoh/ho

1590173295
torque
@import('file.zig').myenum

1590173305
torque
plus using the shift key as appropriate

1590173335
pixelherodev
torque: yes, of course, that already works

1590173338
pixelherodev
that misses the problem

1590173339
torque
I don't even understand the problem you're trying to solve here but overloading "return" to mean "export" is a very bad idea

1590173349
pixelherodev
I'm not saying return is a good syntax

1590173366
pixelherodev
raw structs can be imported directly

1590173379
pixelherodev
`@import("Type.zig")` can be used instead of `@import("type.zig").Type`

1590173383
pixelherodev
but

1590173398
pixelherodev
I think that it makes sense that enums should be importable in the same way

1590173411
torque
I'd argue that that's a coincidence of structs being used for namespaces

1590173420
pixelherodev
Sure, but it does also have advantages of its own

1590173425
fengb
We should switch to unions instead üôÉ

1590173425
torque
such as?

1590173430
pixelherodev
e.g. with #1717

1590173436
pixelherodev
Look at std.array_list

1590173458
pixelherodev
that's implemented currently, std.ArrayList == array_list.ArrayList

1590173473
pixelherodev
s/currently/currently such that

1590173483
pixelherodev
With this, the root of the file could be the generic type

1590173493
pixelherodev
`@import("array_list.zig")(T)`

1590173506
pixelherodev
instead of `@import("array_list.zig").ArrayList(T)`

1590173515
pixelherodev
Which is a tad simpler

1590173523
torque
it's a lot uglier and less clear imo

1590173549
torque
either way it seems like you're mainly interested in subverting namespaces

1590173566
pixelherodev
Namespaces would be unaffected

1590173578
pixelherodev
I'm not trying to make it so namespaces can't be imported, but so that imports aren't definitionally namespaces

1590173582
torque
no, I mean from a usage standpoint

1590173587
pixelherodev
How so?

1590173595
torque
what you actually want is to be able to ignore namespaces on import

1590173599
pixelherodev
Well, sort of

1590173601
torque
to avoid doing a single unwrap

1590173617
pixelherodev
The idea is that when there's only a single value in the namespace the namespace shouldn't exist

1590173643
torque
I think I generally disagree with that

1590173652
alexnask
I find this feature nice with structs as it removes 1 level of indentation from a whole file

1590173665
pixelherodev
^ yes, exactly

1590173667
alexnask
But its not the biggest of deals either way

1590173672
pixelherodev
^ that too

1590173734
pixelherodev
BUt hyeah, it doesn't matter all that much

1590173735
torque
I don't like file-as-instantiable-object for reasons I can't really describe, but I think it's because it smells too much like java

1590173769
pixelherodev
To me, I care more about it on its own merits than how it compares to other langs

1590173777
pixelherodev
If it's bad, it's bad; if it's good, it's good

1590173788
pixelherodev
The fact that Java/Node/whoever may have done it doesn't make it bad

1590173795
pixelherodev
That's like... programmer's godwin's law

1590173799
torque
it's not bad because of the comparison

1590173816
pixelherodev
"Any discussion on programming language development will inevitably draw a comparison to Node.JS"

1590173847
pixelherodev
torque: that's why I want to have the discussion on the underlying merits, or lack thereof

1590173852
torque
it's bad because generally speaking it's ugly and not easily extensible to couple your software datastructures and affiliated data to a rigit filesystem heirarchy

1590173872
pixelherodev
Sure, but you could make that argument about structures too

1590173886
torque
the allusion to java being moreso that there has been a lot of discussion of the (lack of) merit of one-class-per-file in that domain that I can't articulate

1590173890
pixelherodev
By that logic, we should make it so that the root of a namespace shouldn't be allowed to have fields

1590173903
pixelherodev
Plus, we have one-class-per-file already

1590173906
pixelherodev
This wouldn't change that at all

1590173917
pixelherodev
All it would do is give the same treatment to enums and generics

1590173941
pixelherodev
This doesn't affect "classes" (structs)

1590173946
pixelherodev
Just the opposite

1590173952
torque
I am drawing a semantic difference between struct-as-namespace and struct-as-data even though from an implementation standpoint they are identical

1590173964
pixelherodev
Right, but from real usage there's no difference

1590173979
pixelherodev
There are many examples already in usage of namespaces-as-structures

1590173991
pixelherodev
struct-as-namespace+data, if you prefer

1590174001
pixelherodev
Again, this won't change that in any way

1590174006
pixelherodev
It won't encourage or discourage it

1590174024
pixelherodev
From the sound of it, you want to argue the opposite of what I'm saying

1590174034
pixelherodev
I'm saying enums, functions, etc should be able to be file roots

1590174040
pixelherodev
You're saying structs

1590174070
companion_cube
what's the usage of having a file being exactly one function/one enum?

1590174084
torque
no, I think that structs being the root of a file is a simplicity tradeoff that works in favor of the language even if it has side effects I don't agree with

1590174092
fengb
One function can be nice for generics like ArrayList.zig

1590174104
pixelherodev
torque: except that again, you can get both of those at once if you wnt

1590174112
pixelherodev
want*

1590174124
torque
how so

1590174138
pixelherodev
You could argue that structures-as-namespaces and structures-as-data should be distinct in the lang

1590174151
alexnask
torque, Im curious, would you rather we reverted into a different Namespace type returned by @import (with different TypeInfo etc).

1590174151
pixelherodev
And that namespace structures shouldn't be allowed to have fields or member functions

1590174155
companion_cube
fengb: oh. good point.

1590174166
fengb
Very occasionally :P

1590174184
pixelherodev
Yeah, exactly; what alexnask is saying

1590174191
alexnask
I dont see what the difference is except for using fields at top level and the file-as-struct pattern

1590174192
pixelherodev
Structures are currently namespaces

1590174203
pixelherodev
YOu could argue it should be one or the other

1590174321
pixelherodev
Unrelated: ZLS bug report: `@import("file.zig").` should work directly

1590174327
torque
I'm not arguing that zig needs to reintroduce distinct structs from namespaces

1590174332
pixelherodev
wait, I should just open an issue

1590174353
alexnask
hm that feels like it should work :P

1590174359
alexnask
I mean, currently

1590174366
pixelherodev
exactly

1590174369
pixelherodev
It's so weird

1590174377
pixelherodev
`const a = @import; a.` works

1590174382
pixelherodev
but `@import.` doesn't

1590174386
alexnask
aaah

1590174404
alexnask
Yes its the same bug as func calls not getting field access completions

1590174408
torque
however, from a philosophical design perspective, I also am not in favor of introducing more behavior that blurs that line

1590174434
pixelherodev
torque: what you're basically saying is that you dislike it when it comes to structures but think it's worth it, but that same logic doesn't apply to other types?

1590174443
pixelherodev
I can understand that

1590174507
torque
I'm primarily saying that I personally would always treat a file as a namespace and declare structs/constants/enums/unions within it, as I think it's a cleaner separation of concerns

1590174561
pixelherodev
That does raise an interesting point though

1590174568
torque
and to a large degree eliminates the "seam" that you want to eliminate, just in the opposite fashion

1590174573
pixelherodev
` * Only one obvious way to do things.`

1590174582
alexnask
I agree it can be abused I just like it for system-level structs that use some children types etc

1590174586
pixelherodev
torque: yeah, that's what I was getting at earlier, though I probably phrased it poorly

1590174595
pixelherodev
I think that you have a point, actually

1590174604
pixelherodev
There's only supposed to be one obvious way to do things

1590174616
pixelherodev
As is though, there's two here

1590174633
fengb
I like the organization of toplevel structs but dislike how the definitions look

1590174654
pixelherodev
I like the organization because it makes life easier, but I think that I actually have to agree with torque here

1590174654
fengb
In almost every project, I've been doing `const Foo = @import("foo.zig").Foo`

1590174662
fengb
And I much rather just hoist it to the top

1590174681
pixelherodev
I prefer it at the top when writing, but I'm honestly not sure how I'd want to proceed here

1590174705
pixelherodev
I really like top level structs, and I don't think they're any harder to read than explicitly defining them within the namespace as a separate type

1590174722
pixelherodev
But I'd rather give that up in exchange for consistency

1590174743
pixelherodev
some people

1590174763
pixelherodev
Whereas disallowing fields and member functions in top-level structs does make some sense...

1590174767
pixelherodev
Gah

1590174774
pixelherodev
I'm just going to get back to work

1590174793
pixelherodev
Status quo is probably fine, there are two ways to do things but both are similar enough that it doesn't really matter

1590174812
pixelherodev
Nobody's going to be confused by one more than the otehr

1590174827
fengb
Prior to toplevel structs, I had silly things like `const op = @import("op.zig"); var thing = op.Op.init();`

1590174841
fengb
And getting rid of the wrapping namespace was just better

1590175146
stripedpajamas
if I'm getting "error.OutOfMemory;" while running some unit tests, is that an indication that I've written shitty code? or is there a memory limit when running tests? if the former, what should I be looking for?

1590175200
pixelherodev
Is there a better way to add to an enum than @intToEnum(@enumToInt + offset) ?

1590175351
alexnask
stripedpajamas, What allocator are you using?

1590175356
stripedpajamas
testing.allocator

1590175397
alexnask
testing allocator uses a 2 mb buffer

1590175472
stripedpajamas
hmm i see

1590175489
andrewrk
I believe it's planned for testing.allocator to use GeneralPurposeDebugAllocator after it lands in std

1590175501
andrewrk
which would not have the 2 MiB buffer limit

1590175520
stripedpajamas
does that mean allocations whose sum that exceed 2mb in `zig test` will cause OutOfMemory?

1590175528
stripedpajamas
just making sure i'm understanding

1590175535
andrewrk
that is currently the case, if you use std.testing.allocator

1590175560
andrewrk
the workaround is pretty straightforward, use a different allocator if you need more mem than that

1590175575
fengb
Yeah it was picked to run the stdlib tests at that point. Super scientific‚Ñ¢

1590175583
andrewrk
maybe put a "todo" in there to switch it back once GeneralPurposeDebugAllocator lands in std

1590175601
fengb
I thought I have a todo somewhere

1590175609
fengb
Might not be in the right place

1590175685
stripedpajamas
got it, thanks so much

1590176093
pixelherodev
I documented the register enum in Lightzing, where I adjust the IDs by adding 16 (64-bit -> 32-bit form), and figured I'd port that back to stage2 :)

1590176200
pixelherodev
andrewrk: if I add utility functions to the Register enum (e.g. isNative), should I add those to Zig even if they're not immediately needed?

1590176221
pixelherodev
s/Zig/stage2

1590176345
andrewrk
I think they should be added only if they are used

1590176352
pixelherodev
That makes sense

1590176359
pixelherodev
Anything I can do to help with x64 backend?

1590176409
andrewrk
pixelherodev, how about implementing function parameters and return values?

1590176432
pixelherodev
Sure :)

1590176442
pixelherodev
Just did a version of that for lightzing, so the details are mostly fresh in my mind

1590176444
andrewrk
that will unlock the ability to implement math

1590176460
andrewrk
and other binary operations

1590176473
pixelherodev
Consider it done :)

1590176489
andrewrk
then you can probably put your use case for isNative :)

1590176536
andrewrk
regarding function parameters and return values, my suggestion is to make all the other calling conventions besides "auto" a compile error for now

1590176552
andrewrk
the nice thing about "auto" calling convention is that we don't have to match any particular ABI

1590176564
pixelherodev
What should auto use?

1590176578
pixelherodev
I was thinking of just implementing callconv(.C)

1590176581
pixelherodev
and using that for now

1590176584
andrewrk
that would be fine too

1590176630
pixelherodev
Proposal: enum_literal keyword, similar to comptime_int

1590176637
pixelherodev
This would avoid needing to use @TypeOf(.Lit)

1590176647
pixelherodev
s/keyword/comptime type

1590176659
alexnask
std.meta.EnumLiteral ?

1590176659
andrewrk
that's a good proposal, mind typing it up? (might have been already proposed, I don't remember)

1590176696
andrewrk
it makes sense to be consistent though, why would we have one and not the other

1590176708
ifreund
yeah, i'd be a fan of a keyword

1590176725
andrewrk
you can also define comptime_int as @Type(.ComptimeInt)

1590176732
alexnask
Hmm good point

1590176749
andrewrk
maybe the actual answer is to also remove comptime_int :)

1590176754
ifreund
hmm, i should probably finish up the std.log PR, got the scope thing working as I want with enum literals just need to decide between the current minimalism or the syslog protocol

1590176766
alexnask
Vector is the odd man out

1590176771
fengb
std.meta.comptime_int

1590176781
fengb
ComptimeInt

1590176783
pixelherodev
Hm

1590176794
pixelherodev
I almost always prefer userspace over language

1590176797
ifreund
i'm kinda leaning toward the syslog levels daurnimator linked since it seems like it would scale better, and Zig is intended to be useable for truely massive code bases

1590176800
pixelherodev
But this is one case where I feel that doesn't make sense

1590176813
pixelherodev
@TypeOf(.E) works, sure

1590176823
pixelherodev
And defining it in stdlib is an option

1590176833
alexnask
@Type(.EnumLiteral) is cleaner but yes :-)

1590176836
pixelherodev
but I feel like this, definitionally, is

1590176846
pixelherodev
The reality is, this is part of Zig

1590176857
pixelherodev
It's not an extension or a userspace addon

1590176860
pixelherodev
It's a core part of the language

1590176867
ifreund
a keyword would make it more clear that that is the case yeah

1590176875
fengb
So are vectors but they're userland now

1590176889
alexnask
Vector takes 2 args which makes it difficult

1590176891
andrewrk
@Vector isn't userland

1590176893
pixelherodev
^

1590176898
pixelherodev
Vector is defined by a builtin

1590176900
fengb
std.meta.Vector

1590176906
pixelherodev
Comptime integers are enum literals aren't

1590176911
pixelherodev
Those are fundamentally language constructs

1590176920
fengb
@Type(.{ .Vector = stuff })

1590176922
pixelherodev
Not builtins, not user types

1590176925
pixelherodev
They're

1590176939
pixelherodev
We

1590176941
pixelherodev
But it makes no sense

1590176947
andrewrk
oh right, I forgot we took steps recently to phase out @Vector in favor of @Type(.{.Vector = ...})

1590176953
fengb
They are. std.meta.Int

1590176955
pixelherodev
Every zig compiler should be

1590176958
fengb
>_>

1590176959
pixelherodev
fengb: yes, but as a wrapper

1590176962
pixelherodev
Not std.meta.u8

1590176970
pixelherodev
`uN` is part of the language, rather

1590176975
fengb
Hmm, should we deprecate uXX now?

1590176977
alexnask
vector->(4, usize) when?

1590176987
alexnask
(jk)

1590176991
pixelherodev
This isn't a "meta" part of the language, not really

1590176993
andrewrk
alexnask, I'm definitely open to vector type syntax

1590176994
tdeo
should u8 and comptime_int be defined in an implicit prelude rather than keywords?

1590176995
pixelherodev
It's fundamental

1590177006
pixelherodev
I'm arguing the opposite

1590177012
pixelherodev
I really really don't like that idea

1590177020
pixelherodev
If nothing else, it'll push people away from Zig

1590177029
pixelherodev
Nobody's going to want to have to define every single integer types

1590177031
pixelherodev
s/types/type

1590177041
pixelherodev
`const u8 = std.meta.Int(false, 8);`

1590177045
andrewrk
usingnamespace std.meta.ints;

1590177046
fengb
@import("stdint").u8

1590177046
pixelherodev


1590177048
fengb
üôÉ

1590177064
pixelherodev
Even if we can do it, the question is, what are the *merits*?

1590177065
pixelherodev
andrewrk: true

1590177071
pixelherodev
but that doesn't really alleviate the underlying issue

1590177080
pixelherodev
Fundamentally, integers are part of the language

1590177083
andrewrk
I do think it's pretty weird that i386 is a primitive integer type and not an available identifier

1590177087
pixelherodev
Not the

1590177092
fengb
lol

1590177110
pixelherodev
andrewrk: proposal to rename iN -> sN?

1590177117
pixelherodev
unsigned and signed, instead of unsigned and integer?

1590177128
pixelherodev
That frees up i386 as an identifier ;)

1590177132
fengb
s32 looks so weird

1590177137
fengb
Maybe it's just familiarity

1590177143
fengb
ssize

1590177147
fengb
That's familiar

1590177148
pixelherodev
i32 looked weird initially too

1590177159
pixelherodev
We're

1590177171
fengb
Yeah I know, but i32 is used in a lot of other languages too

1590177174
pixelherodev
The question shouldn't be what do we *prefer*, it's what is better for the future of the language and the ecosystem

1590177178
fengb
s32 would be pretty foreign

1590177187
pixelherodev
Sure, but it's also more accurate

1590177190
pixelherodev
signed 32-bit

1590177193
pixelherodev
unsigned 32-bit

1590177195
pixelherodev
s32 and u32

1590177196
andrewrk
I think i/s ints is a closed issue

1590177201
fengb
All ints are signed, except when unsigned

1590177212
andrewrk
time to move on to other decisions now

1590177212
pixelherodev
Yeah, and all ints are unsigned except when signed

1590177215
pixelherodev
That's a tautology

1590177216
fengb
I'm the sphinx from Mystery Men

1590177220
pixelherodev
andrewrk: that makes sense

1590177247
fengb
std.meta.Sint(32)

1590177271
andrewrk
@Type is a relatively recent addition to the language. It makes sense to do a design pass over the syntax with it in mind

1590177284
companion_cube
you could have Int(‚Ä¶) + a few standard aliases like i8, u32, etc.?

1590177297
pixelherodev
companion_cube: but that defeats the purpose

1590177302
tdeo
i think that's how it used to work

1590177306
pixelherodev
u7 is very, very useful

1590177314
pixelherodev
Having to define any custom integer type to use it would be a pain

1590177320
pixelherodev
s/7/N

1590177323
alexnask
^

1590177324
pixelherodev
That was just a generic example

1590177332
pixelherodev
It removes the whole advantage

1590177360
companion_cube
:D

1590177362
companion_cube
what

1590177367
companion_cube
why is u7 useful

1590177375
pixelherodev
uN

1590177377
companion_cube
I mean, for the average program

1590177378
fengb
u(32)

1590177379
fengb
i(32). Let's claim all the single letters

1590177381
pixelherodev
Custom bit-widths

1590177389
pixelherodev
companion_cube: enum ordinals for starters

1590177397
pixelherodev
If I have an enum with 8 entries, I can define it as u3

1590177405
fengb
Packed data

1590177409
pixelherodev
Indices

1590177414
pixelherodev
Actually

1590177414
companion_cube
it'll be padded to one byte, anyway, won't it?

1590177426
pixelherodev
companion_cube: not from the language's perspective it won't

1590177430
pixelherodev
In the backend, sure

1590177432
andrewrk
combined with the align(0) proposal, you can conveniently express extremely compact data structures, with the usage code remaining the same

1590177432
pixelherodev
But safety checks remain

1590177436
pixelherodev
Optimizations too

1590177439
fengb
Also, sometimes it's nice to have type narrowed values just to match the data

1590177456
pixelherodev
It catches stupid mistakes more easily

1590177457
companion_cube
pixelherodev: but then, go for range types, not just powers of two

1590177458
alexnask
Yes, it nicely expresses the actual values you want it to take

1590177466
companion_cube
like what Ada and Pascal have done for decades

1590177467
pixelherodev
companion_cube: .... that

1590177470
pixelherodev
But I was going to say

1590177475
pixelherodev
"Actually"

1590177478
andrewrk
companion_cube,

1590177480
companion_cube
it forces you to have a range [0‚Ä¶2^{n-1}]

1590177481
pixelherodev
Ranges do kind of remove the use case of indices

1590177483
fengb
I think he means actual ranges

1590177494
pixelherodev
But other use cases remain

1590177496
companion_cube
heh, well payed andrewrk

1590177499
companion_cube
played*

1590177507
pixelherodev
and we shouldn't ever make decisions based on average programs

1590177519
companion_cube
I'm sad that Ada has such a poor syntax, cause otherwise it looks freaking

1590177520
pixelherodev
If we did that, we should remove vector types too; average programs don't need them

1590177522
pixelherodev
and so on

1590177525
fengb
Yeah, we should use my stupid emulator as the baseline üôÉ

1590177532
pixelherodev
github is down

1590177535
pixelherodev
Again

1590177540
ifreund
lol

1590177553
pixelherodev
(obligatory sr.ht mention)

1590177668
companion_cube


1590177672
companion_cube
why did C win‚Ä¶

1590177679
andrewrk
look at my gotta-go-fast zig code handling the error correctly first try:

1590177683
andrewrk
it's printing this once every 60 seconds

1590177715
pixelherodev
companion_cube: syntax

1590177718
companion_cube
yeah

1590177720
pixelherodev
you already said that :P

1590177721
companion_cube
that's so sad

1590177725
alexnask
malloc()?

1590177727
pixelherodev
Syntax matters

1590177739
companion_cube
also, I guess, proprietary compilers

1590177749
pixelherodev
andrewrk: that's neat, but also

1590177752
pixelherodev
Shouldn't be a concern :(

1590177793
andrewrk


1590177813
fengb
But, how will I get free downtime

1590177904
pmwhite
Isn't that the case with a centralized VCS, too? I mean, you obviously can't check anything in while offline, but you still have the code, right?

1590177910
afontain_
you can't play with branches

1590177913
companion_cube
but you can't even commit

1590177918
companion_cube
or, with svn, get the log

1590178007
fengb
Oh boy, I remember when I created my own adhoc local VCS

1590178011
pmwhite
Yeah, I guess that's not ideal. It's not too catastrophic though if something is just offline for a few hours or something.

1590178014
fengb
Just because the central server was down

1590178026
pmwhite
alias git=cp

1590178082
pixelherodev
oof that's evil

1590178092
pixelherodev
`alias cd='rm -rf'`

1590178126
ifreund
that's liable to get you punched or something

1590178154
pixelherodev
It's a security measure :P

1590178161
pixelherodev
If you log in but don't unalias it, it fails

1590178165
pixelherodev
wipes data

1590178166
pixelherodev
Better yet

1590178176
pixelherodev
set up more complex aliases to zero out each file before removing them

1590178186
pmwhite
what if your filesystem is copy-on-write? copying the whole tree is not so bad in that case, right.

1590178865
alehander92
range types

1590178874
alehander92
sound good !

1590178899
alehander92
and not only because of optimizations: but because of correctness

1590181254
ifreund
anyone else bothered by the fact that zig fmt doesn't put a space between `error` and the following curly but does for struct/union/enum?

1590181399
pmwhite
No, I think I agree with that choice.

1590181605
alexnask
It only does this for single item sets I think

1590182094
ifreund
alexnask: does it for this for me

1590182117
ifreund
i don't hate it, just think it's a little inconsistent

1590182132
alexnask
Ah good point

1590182148
alexnask
It seems to follow the initialization style rather than the type declaration type

1590182565
fengb
Time to fork zig fmt

1590184430
ifreund
hmm, think I've found a bug, need to narrow down my minimal reproducer though

1590184453
ifreund
InvalidDirection error isn't in the Error set but this compiles

1590184486
ifreund
note that if you change fooey to return Error!Barrr it doesn't compile

1590184510
ifreund
so I'm pretty sure something weird is going on but not quite sure what

1590184817
pixelherodev
Finally

1590184827
pixelherodev
Ported my stage2 registers definition over to lightzing (and thus Thor)

1590184831
pixelherodev
Had to fix a bunch

1590184876
pixelherodev
`187 insertions(+), 221 deletions(-)` Much cleaner though

1590184877
pixelherodev
:)

1590184923
ifreund
i love diffs that remove code while maintianing all the functionality

1590184927
alexnask
^

1590185179
pixelherodev
ifreund: even better actually

1590185186
pixelherodev
It removes code and

1590185191
ifreund
awe yeah

1590185198
pixelherodev
And I'm willing to bet it's more efficient too

1590185201
pixelherodev
Going to measure shortly

1590186121
pixelherodev
More than 14% faster in release-safe mode :)

1590186253
ifreund
solid

1590186273
fengb
Wow

1590186288
pixelherodev
I'm not too surprised

1590186296
pixelherodev
It changed a structure into an enum

1590186308
pixelherodev
Since the values are comptime-known, it was probably able to optimize and inline a lot more

1590186418
fraktor
andrewrk: I don't know if you saw but I have a pull request up.

1590186613
pixelherodev
It also made, now that I think about it, e.g. reg.id(), where reg is comptime known, into a constant

1590186631
pixelherodev
No unwrapping, no safety checks needed (since it's no longer possible for it to be optional)

1590186828
pixelherodev
About 12% faster in release-fast, which stacks up with what I expected

1590186836
pixelherodev
(than it was before, not compared to release-safe)

1590187470
pixelherodev
ifreund: maybe double check that issue you just opened?

1590187489
pixelherodev
The "if you change X to Y", X and Y are identical AFAICT

1590187497
pixelherodev
might be a typo in one of them

1590187609
alexnask
Havent looked through the issue but the godbolt example was broken for sure

1590187733
pixelherodev
Oh, and just for context about how slow emulation is:

1590187745
pixelherodev
`Instructions executed to print Hello World normally`: 595

1590187758
pixelherodev
`Instructions executed with Thor`: ~40k

1590187785
pixelherodev
The real curious number is how Thor compares to just using the JIT directly...

1590187822
gonz_
Which platforms support evented IO more or less completely atm?

1590187863
gonz_
`io_mode = .evented`, that is.

1590187865
pixelherodev
None, as I understand it

1590187874
pixelherodev
All of them have varying degrees of support

1590187879
pixelherodev
But nothing is fully integrated with it yet

1590187883
gonz_
Ah, ok.

1590187924
pixelherodev
Hmm, I could probably speed up that example by ignoring errors, but that's not a valid comparison anyways

1590187929
pixelherodev
Since that would be improper usage of the library

1590190018
fraktor
I'm attempting to build Zig on Linux and running into #4799, but adding the proposed fix gives me: c++: error: unrecognized command line option ‚Äò-W1,/usr/lib/llvm-10/lib/LLVMPolly.so‚Äô

1590190520
alexnask
It should be Wl instead of W1

