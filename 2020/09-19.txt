1600475288
nikki93
zls through vim works for me on both windows and macos :o this might be the 'newest' a language has been while having all of these things work ever

1600475315
nikki93
it's really refreshing and heartwarming that these things are such good quality while just being worked on in wholesome ways

1600475379
nikki93
i just looooove that zig executable just knows where its libs are, and when i zls-goto it just goes to them etc.

1600476883
andrewrk
:)

1600483189
andrewrk
alexnask[m], you know what would be really super useful semantic highlighting? if it did liveness analysis of a variable and highlighted the final usage of each variable

1600483205
andrewrk
so you could see with a color that the variable is dead after a certain point

1600483222
andrewrk
maybe it could put a tombstone emoji after it

1600484130
mkchan
MFW

1600484158
mkchan
std.json.stringify... LLVM ERROR: out of memory during Code Generation

1600484194
mkchan
I thought I could short circuit encoding my network nicely into a file with JSON and boom

1600484368
mkchan
Any chance I can specify how much memory to allocate it during compilation?

1600484515
mkchan
Actually NVM about json it can't even generate the NN structure when I finally initialize it

1600485460
mkchan
Tried building it on Linux, the zig-cache folder went >2GB in 10seconds and cancelled it lol

1600485624
mkchan
If I reduce the input layer size by 10x then it works with 200MB zig-cache and a 2.5KB json file as output. I obviously can't reduce the input layer size so yeah

1600485775
mkchan


1600486031
pixelherodev
mkchan: comptime is more PoC in stage1 than anything

1600486037
pixelherodev
It's not really production-ready until stage2

1600486040
mkchan
Dammit

1600486046
pixelherodev
It's usable, don't get me wrong

1600486050
pixelherodev
But it's not going to be performant

1600486177
mkchan
Yeah it spit out a 6.3GB .o file and then failed to compile anyway because of lld it seems

1600487075
fgenesis
04:40 < andrewrk> maybe it could put a tombstone emoji after it

1600487080
fgenesis
i do hate emojis a lot

1600487085
fgenesis
but i must say this idea is genius

1600487126
fgenesis
maybe even annotate particularly smelly code with the poop emoji

1600487174
mkchan
Imagine putting a hundred tombstones after } because of all the defer kills

1600487206
andrewrk
mkchan, nah it would be after a variable name is used

1600487233
andrewrk
e.g. `const a = foo(b, c);` if `b` is no longer referenced after this, it would have the tombstone after the `b` and before the `,'

1600487237
mkchan
That makes much more sense lol

1600487286
andrewrk
you could do this with zig code without any semantic analysis

1600487328
mkchan
What about loops

1600487376
fgenesis
as long as nobody goes like

1600487616
mkchan
Ok another question: why can't I define a comptime var (that I'm going to use in an inline while) as []anytype

1600487734
mkchan
Or just anytype

1600488142
tdeo
anytype is not a type

1600488173
tdeo
well, you can have a struct field as anytype though, so not sure

1600488555
andrewrk
yeah the workaround there is `comptime var x: struct {data: anytype} = .{.data = 1234};`

1600492918
nikki93
andrewrk: have you considered maybe making it so sth like @Self could mean @This() in any type or is it always better to be a function for some reason

1600492957
nikki93
like it seems like `const self = @This();` happens a lot, but i also haven't explored enough in the lang to know if it should just stay that way

1600492965
nikki93
like it seems like `const self = @This();` happens a lot, but i also haven't explored enough in the lang to know if it should just keep being that way

1600492968
andrewrk
the only difference that would make would be introducing a new syntactical construct

1600492973
nikki93
sorry for copied msg

1600492988
nikki93
i see

1600493014
andrewrk
I think it used to be a keyword but then it was nice to not take up the identifier space

1600493023
nikki93
Self you mean?

1600493030
andrewrk
I believe it was `this`

1600493033
nikki93
what if there are keyword identifiers like @Self

1600493037
andrewrk
I may be misremembering

1600493052
nikki93
oh interesting, a lowercase keyword that is a type. i guess `type` itself and the builtin types are kinda like that

1600493194
nikki93
in your experience do you tend to just end up doing `const Self = @This()` a lot or do you just  keep  doing`fn foo(self: @This(), ...)`

1600493304
andrewrk
I prefer the former

1600493332
andrewrk
I also have a new opinion that it's better to use a different short variable name than `self` because it makes it easier to refactor code without renaming stuff

1600493351
andrewrk
e.g. you could lift entire sections of code out of a struct and put it in a different file (which I've done several times in self-hosted)

1600493374
nikki93
oh yah i agree, for the parameter name yeah

1600493416
nikki93
wait did you mean the parameter name or the parameter type

1600493683
andrewrk
for the name

1600493703
andrewrk
type too, actually

1600493712
nikki93
cool

1600493724
andrewrk
well for generics Self can be useful but for not generic types I prefer the actual type name

1600493725
nikki93
yeah there's no need to weirdly lexically but dynamically scope this the first param i guess haha

1600493745
nikki93
yeah it seems nice in anonymous structs

1600494850
kandinski
hi all

1600494868
andrewrk
hello kandinski

1600494938
kandinski
I'm reading about ziglang and about to start a short project to try it out. One question I have is about the printf example, which requires the format strings to be compile-time known. How does that comport with a program loading formatting strings at runtime, e.g. for internationalisation?

1600495035
andrewrk
if you want text substitution at runtime you'll have to use a different API

1600495060
kandinski
also hi andrewrk good job on the language. Thanks particularly for lowering the bar for getting into systems programming.

1600495066
andrewrk
:)

1600495108
andrewrk
I think it makes sense to have one API for comptime text substitition and another for runtime text substitution

1600500432
pixelherodev
kandinski: does it make sense to embed various language files and generate each one at comptime, then select which to use at runtime?

1600500437
pixelherodev
The downside is code bloat though

1600500445
pixelherodev
Probably pretty bad, too, so that's probably a bad idea

1600501046
andrewrk
oh you could have your format strings in a translations.zig file and pull them from there

1600501054
andrewrk
as long as you generate your translations at compile time

1600501063
andrewrk
I think I just repeated pixelherodev

1600502651
marler8997
I got the "reloader" to work...yay!

1600503173
pixelherodev
andrewrk: the difference is that I said "no wait don't do that" afterwards ;)

1600503176
pixelherodev
marler8997: :O

1600503178
pixelherodev
that's amazing!

1600503244
marler8997
yeah, I can make an ELF exe with no interpreter, and with so dependnecies, invoke it, and it will reload itself with any linker it wants to find

1600503270
marler8997
only C version working so far (using zig cc):

1600503893
pixelherodev
That's honestly amazing.

1600503924
pixelherodev
I'm currently generalizing the build.py DarkUranium and I wrote so that it can be left alone for any project, and have deps / sources / name / version / etc specified in a separate file

1600504677
pixelherodev
ugh. andrewrk, marler8997: why is the reloader supposed to solve the issue of static game builds?

1600504683
pixelherodev
Asking for a friend.

1600504710
pixelherodev


1600504727
marler8997


1600505357
pixelherodev
marler8997: ... here's the thing. libg... uh what's it called. one sec.

1600505364
pixelherodev
libgcompat.

1600505386
pixelherodev
`ls /lib/ld-* | wc -l` -> 2

1600505397
pixelherodev
I have both the musl loader

1600505410
pixelherodev
IIRC this is a normal pattern in e.g. Alpine as well

1600505431
pixelherodev
reloader definitely fixes the issue of "unknown interpreter path"

1600505437
pixelherodev
But there's other issues with shared libraries as well.

1600505478
marler8997
the issue was that we couldn't implement our own mechanism in our program to locate the loader, reloade aims to solve that, so you can use any tehnique you like to find the loader

1600505502
marler8997
are you talking about solving how to find so's as well?

1600505560
pixelherodev
not quite

1600505574
pixelherodev
I've had issues in the past (and present) in which so's are found but *don't work*.

1600505583
pixelherodev
ABI incompatibilities.

1600505597
pixelherodev
Most frequently with GLX, I believe.

1600505684
marler8997
That's why I use Nix, to solve those issues

1600505730
marler8997
Every distribution implements their own solution to solve so compatibility issues

1600505749
marler8997
I should say, usually it's the "package manager" that tries to handle that

1600505757
pixelherodev
Yes, that wasn't my point

1600505778
marler8997
lol...ok try to explain again :)

1600505786
pixelherodev
My point is that fixing this is only one step of the way towards making dynamic builds on par with static ones.

1600505801
pixelherodev
And, frankly, static builds will probably still be better.

1600505826
marler8997
their are pros and cons to static/dynamic builds

1600505829
marler8997
neither is "better"

1600505870
marler8997
there are techniques to solving issues with dynamic builds... For nix, they are all pretty much solved except this last one

1600505892
marler8997
for other distributions, they will still have issues, and yes, more work would need to be done to solve issues there as well

1600505904
nephele
dynamic builds are just JIT linked static builds ;) /s

1600505991
pixelherodev
marler8997: I disagree that nix solves them at all.

1600505996
bfredl
an ELF file is just a JIT forcefully frozen in time

1600505998
pixelherodev
nix simply pretends they aren't there.

1600506000
pixelherodev
It

1600506006
pixelherodev
It fixes the *symptoms*.

1600506010
marler8997
what issues hasn't it solved?

1600506024
nephele
"maximum symlink depth reached"

1600506028
pixelherodev
... what actual underlying issues

1600506061
marler8997
you ready for the list :)

1600506066
pixelherodev
Like, serious question, name one! I looked into it a while back, and I was honestly put off when I realized that its entire design goal was to hide problems with other distros instead of solving them properly.

1600506070
pixelherodev
Go for it!

1600506087
marler8997
Here are all the problems that other package managers that nix solves:

1600506092
marler8997
* Dependency specifications are not validated, leading to incomplete deployment.

1600506096
marler8997
* Dependency specifications are inexact (e.g., nominal).

1600506101
marler8997
* It is not possible to deploy multiple versions or variants of a component side-by-side.

1600506105
marler8997
* Components can interfere with each other.

1600506109
marler8997
* It is not possible to roll back to previous configurations.

1600506115
marler8997
* Upgrade actions are not atomic.

1600506120
marler8997
* Applications must be monolithic, i.e., they must statically contain all their dependencies.

1600506132
marler8997
* Deployment actions can only be performed by administrators, not by unprivileged users.

1600506133
pixelherodev
... uhh

1600506137
marler8997
* There is no link between binaries and the sources and build processes that built them.

1600506143
marler8997
* The system supports either source deployment or binary deployment, but not both; or it supports both but in a non-unified way.

1600506148
marler8997
* It is difficult to adapt components.

1600506153
marler8997
* Component composition is manual.

1600506159
marler8997
* The component framework is narrowly restricted to components written in a specific programming language or framework.

1600506163
marler8997
* The system depends on non-portable techniques.

1600506165
pixelherodev
A lot of these are technically solved on Gentoo lol

1600506175
marler8997
that's the list I wrote down after going through the creator's PHD thesis

1600506239
pixelherodev
Nix is a shiny wrapper that covers them up IMO

1600506239
tdeo
i feel like

1600506250
marler8997
so what issues doesn't nix solve?

1600506259
earnestly
symlink farming

1600506260
pixelherodev
marler8997: fundamentally, it's that nix

1600506265
pixelherodev
Nix is an

1600506275
pixelherodev
"Distros are incompatible" Solution: *let's make a new distro*.

1600506279
marler8997
nix is a package manager that can run on most distributions, even mac and bsd

1600506283
pixelherodev
(Yes, I'm aware it can run on others)

1600506284
marler8997
nixos is a distribution

1600506295
pixelherodev
But running it on others misses the point

1600506300
earnestly
Yes, I used nix on a different distro for awhile

1600506305
pixelherodev
I think I can make a better analogy using reloader, actually

1600506307
earnestly
As it can do per-user installs

1600506315
marler8997
what issues doesn't nix solve though...I'm still wanting to understand that point

1600506347
pixelherodev
I'd say that a better solution that reloader would be to remove the interp section entirely. That is, have the

1600506350
earnestly
Symlink farms, elfhacks, need for patching hardcoded paths

1600506353
pixelherodev
Instead of pushing the job off into the executable

1600506369
pixelherodev
marler8997: fundamentally, the SOs on a Nix system are *still incompatible*.

1600506381
earnestly
E.g. Use of dlopen needs to be patched under nix

1600506384
pixelherodev
You just don't notice because Nix plays with paths.

1600506386
marler8997
what does that mean? "still incompatible"?

1600506397
pixelherodev
You still require disparate versions to be installed.

1600506406
pixelherodev
ABIs are still a problem.

1600506426
marler8997
I'm not understanding...

1600506438
marler8997
You still require disparate versions to be installed?  What does that mean?

1600506471
marler8997
Nix doesn't require multiple versions of things to be installed

1600506473
pixelherodev
e.g. package a

1600506479
marler8997
Yes

1600506483
marler8997
What's the problem?

1600506495
pixelherodev
Fundamentally, it misses the real issue.

1600506502
pixelherodev
The issue isn't, "hey, I need to install both." That's the symptom.

1600506502
marler8997
Which is?

1600506529
marler8997
When libraries change, not all apps update, and some apps require updates

1600506535
pixelherodev
That.

1600506537
marler8997
How do you handle that issue?

1600506540
marler8997
That's what nix solves

1600506542
pixelherodev
"Apps require updates when libraries change."

1600506562
pixelherodev
That's still an issue with Nix. It just hides it by continuing to use an out-of-date library.

1600506571
marler8997
It's a solution to that problem

1600506581
pixelherodev
IMO a better fix would be to e.g. make it so that ABIs don't exist.

1600506587
pixelherodev
Not literally, of course.

1600506592
marler8997
Sure, but having a solution doesn't mean it's hiding a problem

1600506596
marler8997
that's not a solvable problem

1600506600
pixelherodev
Sure it is.

1600506603
marler8997
it's an issue that will always occur

1600506607
marler8997
Libraries get updated

1600506611
pixelherodev
The only unsolvable problem is that people think problems are unsolvable ;)

1600506612
marler8997
some apps will update, some won't

1600506619
pixelherodev
But my point is that they shouldn't

1600506624
marler8997
if you want your old software to still work

1600506627
marler8997
you need to solve the problem

1600506634
pixelherodev
Except that's just my point.

1600506637
pixelherodev
*That problem shouldn't exist*.

1600506652
marler8997
You're saying that we shouldn't use old software

1600506654
pixelherodev
no.

1600506663
marler8997
if it isn't kept up-to-date every time something changes, then we shouldn't suppor tit

1600506664
pixelherodev
I'm saying that old software should be able to "just work" even with library updates.

1600506682
pixelherodev
I'm saying that a better solution is to figure out, I dunno

1600506684
marler8997
you're saying that all libraries should be 100% backwards compatible?

1600506687
pixelherodev
Maybe, a linker format which hides ABI differences.

1600506709
nephele
If you ignore the ABI differences you might then gain just normal incompatibilites :g

1600506713
pixelherodev
Maybe, a program which automatically goes over two different SOs and generates a wrapper over the new one that exposes the older ABI or something

1600506725
pixelherodev
Maybe, change the way engineers think so that they don't create these issues.

1600506733
pixelherodev
I'm not pretending to have the answer

1600506744
pixelherodev
I'm saying that we shouldn't give up just because it's an insanely complex task.

1600506746
marler8997
That would result in an exponential explosion of cases to test

1600506752
marler8997
you now have to test every version with every other version

1600506760
pixelherodev
Maybe with the library wrapper.

1600506761
marler8997
and a solution like that is orthogonal to what nix is doing

1600506766
pixelherodev
But that's one

1600506776
marler8997
you can still do that with tnix

1600506782
pixelherodev
Maybe replace ELF with something which allows code multi-versioning in a way that exposes old ABIs

1600506785
pixelherodev
I'm not saying it doesn't.

1600506790
marler8997
it's just that nix also let's you have cryptographically hashed dependencies that you know won't change

1600506799
nephele
that's what symbol versioning is trying to do

1600506801
pixelherodev
And I consider that an anti-feature.

1600506804
marler8997
essentially reducing your binary to the functional equivalent of a static executable

1600506806
pixelherodev
nephele: I was about to bring that up :)

1600506827
pixelherodev
marler8997: IMO, exact dependencies are a *problem*, not a *solution*.

1600506834
marler8997
then don't use them

1600506838
pixelherodev
I don't :P

1600506847
marler8997
nix doesn't force you to use them, if you have other solutions, you can still use all the other features of nix

1600506856
marler8997
it's just a feature that you have the option to use

1600506863
pixelherodev
Hell, my latest solution to C dependencies is to have the upstream repo's master branch embedded in lib/$LIBNAME

1600506878
tdeo
now that's a "solution"

1600506881
marler8997
you should read the phd thesis

1600506881
pixelherodev
I've actually started doing dev work on the libraries from within the main package

1600506884
pixelherodev
:P

1600506897
marler8997
it's a good read actually, easy and understandable

1600506903
pixelherodev
tdeo: I never said it was a generally applicable solution lol

1600506954
marler8997
When I deploy an application, I want all my dependnecies to be as fully-specified and as possible

1600506955
pixelherodev
tdeo: It works in the specific projects I'm working on now because the libraries are either a) maintained by me anyways, because the original maintainer stepped down, b) update infrequently, or c) don't break on updates.

1600506964
marler8997
Nix allows me to do that

1600506984
pixelherodev
Whereas I want to fix the entire engineering culture so that that stops being necessary :P

1600506987
marler8997
It gives me the best of both worlds, a dynamic executable that behaves like a static executable

1600506990
pixelherodev
I think the key difference here is that you're practical ;)

1600506996
marler8997
but it's not even the culture

1600506998
pixelherodev
Also, I don't consider that the best of both worlds

1600506999
marler8997
there are old programs

1600507008
pixelherodev
marler8997: but the library updates shouldn't cause those to break.

1600507015
pixelherodev
That's what I've been saying the *whole time*.

1600507019
marler8997
why?

1600507027
nephele
pixelherodev: heh, fixing engineering culture might be a bit out of scope

1600507029
marler8997
how do you prevent a library update from breaking an application?

1600507031
pixelherodev
Because there's no legitimate unsolvable technical reason for it

1600507040
pixelherodev
nephele: Yeah, I know :P

1600507046
pixelherodev
marler8997: that's the question I'm asking.

1600507047
marler8997
any change within the library could potentially break any user of it

1600507051
pixelherodev
Why?

1600507061
nephele
dependency hell bleeding over is always nice and annoying :3

1600507073
marler8997
why what?

1600507077
marler8997
why can a change break an application?

1600507079
pixelherodev
Why can a library change break a user?

1600507090
pixelherodev
Not literally "Why"

1600507098
pixelherodev
I know why that's the case now.

1600507105
marler8997
not sure what you're asking

1600507115
pixelherodev
Why can't we devise a system that prevents that?

1600507119
pixelherodev
Why should we accept that?

1600507122
marler8997
it's literally impossible

1600507134
nephele
it's always the case, no? bugs can be in, or unexpected differences between what users thought the function does with what it actually does

1600507141
earnestly
Well, you could design a system that no longer depends on ABI stability

1600507145
pixelherodev
^

1600507147
marler8997
in fact, even with hashed dependnecies, you still don't solve the problem

1600507147
earnestly
(One such did exist)

1600507150
pixelherodev
That's what I've been thinking of this whole time

1600507158
pixelherodev
Stop depending on ABIs.

1600507173
pixelherodev
The easiest (but bad) way is to add a non-native layer between libraries and executables

1600507194
pixelherodev
Maybe make dlsym itself versioned

1600507197
marler8997
that still doesn't solve the issues

1600507201
marler8997
compatibility isn't just to do with ABI

1600507204
pixelherodev
Have libraries contain every version of every symbol (within reason)

1600507215
pixelherodev
Have the linker, at startup, effectively hot-patch the executable

1600507218
marler8997
that's what Nix does

1600507225
pixelherodev
Except not quite.

1600507229
pixelherodev
I'm talking deduplication

1600507238
marler8997
even if you version every symbol

1600507239
pixelherodev
Heck, I'm bordering JITs more than packages

1600507240
marler8997
still not a solution

1600507244
pixelherodev
For sure

1600507253
marler8997
any solution you come up with...wills till break

1600507257
pixelherodev
But I don't have to have a solution to say that one is *possible*.

1600507260
pixelherodev
Like I said.

1600507264
marler8997
it's an unsolvable problem

1600507276
pixelherodev
The only unsolvable problem is that people think problems are unsolvable ;)

1600507281
pixelherodev
I said that already.

1600507289
marler8997
There are lots of problems that are solvable

1600507292
marler8997
this isn't one of them

1600507297
pixelherodev
Why not?

1600507300
marler8997
you can mitigate it to a high degree though

1600507305
pixelherodev
You want to claim it's unsolvable, prove it!

1600507311
marler8997
hardware

1600507312
marler8997
kernel

1600507321
pixelherodev
Or, just, static binaries.

1600507322
marler8997
atoms, time

1600507332
marler8997
any of these things can break your application

1600507342
pixelherodev
What advantage does a dynamic build supposedly provide?

1600507346
marler8997
even static binaries don't solve the problem

1600507356
marler8997
it allows you to share bits

1600507356
pixelherodev
(I say this as someone who hasn't actually bothered to switch my system to fully static just yet)

1600507366
marler8997
imagine you want to use firefox as a library or webkit

1600507370
pixelherodev
Then you're insane.

1600507371
marler8997
libraries that are gigabytes in size

1600507382
pixelherodev
Unless you use large portions, it won't matter.

1600507385
pixelherodev
The linker can remove dead code.

1600507397
marler8997
If you want to be able to use big dependencies, then it becomse unreasonable to compile statically

1600507400
marler8997
for small things, it's fine

1600507407
earnestly
This is like a discussion from the 70s lol

1600507409
pixelherodev
> On average, dynamically linked executables use only 4.6% of the symbols on offer from their dependencies. A good linker will remove unused symbols

1600507471
pixelherodev
earnestly: ha, true.

1600507474
tdeo
that seems like a pretty bad metric to measure how much those symbols actually pull in

1600507488
tdeo
you can have a huge implementation for a simple api

1600507489
earnestly
SynthesisOS was from the 80s even

1600507508
tdeo
well, a huge api for a simple implementation too

1600507517
pixelherodev
tdeo: sure, but on *average*.

1600507526
earnestly
tdeo: Someone will have to do another study as was done in the 90s, to prove once again (or not) that dynamic linking isn't worth the cost

1600507534
pixelherodev
If you want to talk about firefox, then definitionally, the average symbol is (1 / NSYMS) of the size

1600507542
earnestly
That last one was done on X11, which was large at the time

1600507543
marler8997
I'm not sure why you would want to store the same bits over and over again on your computer, when you can just store it once and share it

1600507548
nephele
what? who wants to talk about firefox? D:

1600507552
pixelherodev
marler8997: because they're not the same bits.

1600507559
earnestly
marler8997: Content Addressable Storage solves that issue

1600507579
marler8997
they're not the same bits?

1600507589
tdeo
what i'm trying to say is that how many symbols a binary links from a library doesn't necessarily correlate to how much code is pulled in from the library

1600507591
pixelherodev
Inlining, partial usage, etc

1600507594
pixelherodev
tdeo: I agree

1600507598
pixelherodev
I was saying that it goes both ways.

1600507607
pixelherodev
I can use 5% of the symbols and 1% of the binary, or vice versa.

1600507618
pixelherodev
But on average, if I use 5% of the symbols, it's

1600507629
pixelherodev
Practically speaking.

1600507640
pixelherodev
Sure, it

1600507643
marler8997
sure with those numbers it can makes sense to statically compile

1600507645
tdeo
i wouldn't say that without measuring, dunno

1600507650
marler8997
but you seem to be ignoring the other cases

1600507653
pixelherodev
tdeo: definitely true

1600507664
pixelherodev
marler8997: That's because those are, for all intents and purposes, *edge cases*.

1600507671
pixelherodev
Now, that doesn't mean they're not worth handling

1600507681
pixelherodev
But not at the expense of

1600507690
pixelherodev
earnestly:

1600507704
pixelherodev
Sources to run the same tests locally are included, too

1600507722
pixelherodev
> Over half of your libraries are used by fewer than 0.1% of your executables.

1600507740
pixelherodev
Most packages don't use most libraries.

1600507748
marler8997
what is the expense?

1600507749
earnestly
Yeah I'm aware, but see, people in software tend to cover the same points endlessly

1600507762
earnestly
Shiney new toys that do the same thing people did 40 years ago

1600507766
pixelherodev
marler8997: for using a fully static system?

1600507778
pixelherodev
Or for using a dynamic one?

1600507797
marler8997
why is it an expense to have both?

1600507809
pixelherodev
It's an expense to use

1600507822
marler8997
what's the expense?

1600507824
pixelherodev
And, taken to its logical conclusion, dynamic systems at all.

1600507834
pixelherodev
Well, for starters, it's impossible to inline. That's already a

1600507844
pixelherodev
Inlining opens up

1600507865
marler8997
why is it impossible to inline on a

1600507866
pixelherodev
I'm willing to bet that `gcc -O1 -march=native` with a fully static system would produce binaries faster than `gcc -O3 -march=native` on a fully dynamic one.

1600507877
pixelherodev
Because you can't cross the dynamic library boundary.

1600507885
pixelherodev


1600507887
marler8997
then compile statically

1600507888
pixelherodev
You can't inline the library itself.

1600507897
pixelherodev
This is an expense for *every application*.

1600507902
pixelherodev
And every library too, since libraries can depend on each other

1600507921
marler8997
I'm very confused by what you're saying

1600507921
earnestly
Bare in mind that almost all VM subsystems are CoW

1600507929
marler8997
I can't follow your logic at all

1600507934
earnestly
Bear*

1600507968
pixelherodev
marler8997: when building a Zig executable with, say, Hello World

1600507972
pixelherodev
it can inline *everything*.

1600507978
marler8997
yes I understand

1600507979
pixelherodev
(and fmt is comptime, so even better)

1600507985
marler8997
I don't know what that has to do with your original statement

1600507987
pixelherodev
With libc, it has to call out to an external function call

1600507995
pixelherodev
It can't inline for a dynamic build

1600508021
tdeo
would be neat to have cross-language lto working once we have llvm support in stage2

1600508037
marler8997
having a dynamic system...and compiling statically are not mutually exclusive

1600508048
pixelherodev
Yes, but I'm talking aboout why a primarily dynamic system is a cost

1600508058
pixelherodev
Given that

1600508078
marler8997
what does a systems' primary mechanism have to do with an application's mechanim?

1600508093
marler8997
an applciation can use any mechanism regardless of what the system is doing

1600508095
pixelherodev
... i haven't been talking about applications. I'm talking about the *system*.

1600508105
pixelherodev
e.g. if I install something with a package manager.

1600508112
pixelherodev
Say, Debian, or Alpine.

1600508124
pixelherodev
Nearly every single package in their repos would be better off statically linked.

1600508136
marler8997
Ok, so you're just talking about compiling dynamically vs statically in general, which to choose

1600508151
pixelherodev
That's the starting point of my argument, yes

1600508156
marler8997
ok gotcha

1600508182
pixelherodev
The fixed cost of building applications dynamically is relatively high

1600508188
marler8997
there was an article I saw recently about the importance of having a binary ABI/API, I didn't read it I"ll have to see if I can find it

1600508193
pixelherodev
So if most applications are better off static, there's no point in

1600508215
marler8997
how does that follow?

1600508222
pixelherodev
(you then need to have dynamic copies

1600508223
marler8997
if some are better off static, then they should be static

1600508229
marler8997
why does that mean everything should be static?

1600508230
pixelherodev
Nearly everything should be

1600508244
marler8997
how does that follow

1600508256
pixelherodev
Why have logic to handle dynamic binaries if almost no applications benefit?

1600508256
marler8997
You're saying that some should be static even if they are better off dynamic?

1600508271
pixelherodev
Most of the gains from being dynamic are gone if other applications are static.

1600508285
pixelherodev
Even an application which is normally better off dynamic loses its gains.

1600508295
marler8997
If an application is better off dynamic, why wouldn't you make it dynamic?

1600508303
pixelherodev
If only one application links against /lib/libgiganticfreakinglibrary.so then it doesn't benefit.

1600508309
pixelherodev
What would make it better off?

1600508317
pixelherodev
Generally, it's about sharing code, and reducing application size, no?

1600508322
marler8997
yes

1600508331
pixelherodev
Well, if nothing else is using it, the code isn't shared anyways.

1600508348
marler8997
Then it wouldnt' fall into the category of "better off dynamic"

1600508357
pixelherodev
and since only that application then depends on the library, it effectively makes the full size of the library included in the application size.

1600508372
pixelherodev
And between inlining and DCE, the application no longer benefits from dynamic linking.

1600508374
marler8997
Basica

1600508376
pixelherodev
marler8997: that's my point!

1600508386
pixelherodev
If a system is mostly static, then

1600508388
marler8997
If somthing is better off static, then make it static, if something is better of dynamic, make it dynamic

1600508399
pixelherodev
And if most things are better off static, then that means that

1600508411
marler8997
why?

1600508417
marler8997
that makes no sense :)

1600508422
pixelherodev
Even if only 90% of applications are better off, the fact that they are then statically linked means that the other 10% no longer benefit from being dynamic!

1600508438
earnestly
I swear, if dynamic linking was another idea from universities

1600508443
pixelherodev
The benefits of dynamic linking - code size and reuse -

1600508445
marler8997
that's like saying, if people are better off being in heterosexual relationships, then that means everyone should be

1600508449
marler8997
please don't start a new religion :)

1600508451
pixelherodev
Not at all!

1600508469
pixelherodev
Other people being in a hetero relationship doesn't affect whether being in one is good or bad for me.

1600508482
pixelherodev
Other applications being statically linked

1600508508
pixelherodev
If only two applications are linked against a single library, and one of them is static, the other has no gains from linking it dynamically.

1600508522
pixelherodev
Worse, it

1600508539
pixelherodev
Here's an idea

1600508550
pixelherodev
Instead of static vs dynamic linking per-*application*, we need it per-*library*.

1600508597
marler8997
This is not a valid inference:  If most thare are better of X, then that means everthing is better off X

1600508600
pixelherodev
marler8997: I think that actually creates a perfect hybrid. If

1600508606
pixelherodev
marler8997: but that was never the inference.

1600508616
pixelherodev
The inference wasn't "most are better off X so everything is"

1600508619
marler8997
You literally said this: And if most things are better off static, then that means that

1600508627
pixelherodev
That wasn't the logic at all.

1600508637
marler8997
that's a copy/paste of what you said

1600508649
pixelherodev
Assumption: Most things are better off static. Assumption: The benefits of dynamic linking only apply when most libraries are linked dynamically.

1600508650
pixelherodev
Conclusion:

1600508657
pixelherodev
s/Assumption/Precondition/s

1600508675
marler8997
damn how did you type that so fast?

1600508682
pixelherodev
Because I'm a fast typist? :P

1600508696
earnestly
They have a happy hackers keyboard

1600508698
pixelherodev
I've only been doing this since I was like five years old lol

1600508701
earnestly
Maximum torpe speed

1600508705
pixelherodev
Nope! Crappy laptop keyboard here ;)

1600508718
marler8997
ok so your statement was incomplete....I see

1600508727
pixelherodev
marler8997: or you missed some of my statements ;)

1600508732
marler8997
however, I'm not sure about your second assumption

1600508745
pixelherodev
Well, you said yourself that the benefits are code reuse and code size, right?

1600508759
marler8997
It only takes 3 libraries to break that assumption

1600508770
pixelherodev
Did you see my comment about a hybrid linking model?

1600508774
marler8997
Or I should say, 1 library and 2 users of it

1600508789
marler8997
about static linking with optimization?

1600508791
pixelherodev
No

1600508806
pixelherodev
"If

1600508831
pixelherodev
Honestly, I'm not convinced dynamic linking is an improvement in code size for all but the most common libraries.

1600508860
pixelherodev
libc is used by everything, so having a single 838K copy is probably less than statically llinking it in everything

1600508881
marler8997
I think you're making generalations and inferences here that just don't follow

1600508895
pixelherodev
Such as?

1600508904
marler8997
"If

1600508923
marler8997
So take the worse possible case against your statement

1600508934
marler8997
2 users of a single library, they use 100% of the library and the library is huge

1600508947
pixelherodev
That's not a possible case.

1600508954
pixelherodev
I don't think

1600508967
pixelherodev
But sure, let's take that hypothetical.

1600508969
marler8997
well percentage doesn't really matter

1600508974
marler8997
it's the amount of code used I supposed

1600508992
marler8997
so lets' say, each applicaiton uses 1GB of code from the library

1600508992
pixelherodev
Inlining also reduces total size, since a lot of it will be optimized out.

1600509005
pixelherodev
That's already talking about 0% of the libraries I have installed.

1600509008
marler8997
That measn that you save 1 GB every time you link to it dynamically vs statically

1600509014
pixelherodev
Not even LLVM is remotely that big.

1600509018
pixelherodev
And no, you don't save 1GiB.

1600509025
marler8997
well, so long as the applicaitons are using 1GB worth of the library

1600509037
marler8997
Maybe it's a 10 GB library, but most applications are using around 1GB of it

1600509045
pixelherodev
If it's 1GiB as a dynamic executable, chances are it's still less than 950MiB statically linked even if every line of code is used in it.

1600509055
marler8997
sure I'll give you that

1600509057
pixelherodev
Inlining is

1600509064
pixelherodev
So that's 900MiB saved, sure.

1600509068
marler8997
per use

1600509077
pixelherodev
I'd also point out that even in this case we're

1600509093
marler8997
not necessarily

1600509094
pixelherodev
Have you been more strapped for disk space than computing resources at any point in the last decade?

1600509098
pixelherodev
Sure we are.

1600509100
marler8997
processor caches

1600509105
pixelherodev
Statically linking improves caching.

1600509111
marler8997
for one program

1600509111
pixelherodev
Because of inlining ;)

1600509114
marler8997
not if you are running multiple

1600509124
pixelherodev
Except for one thing

1600509134
pixelherodev
That implies both binaries are using the same part of this enormous library at once.

1600509140
marler8997
yup

1600509149
pixelherodev
Otherwise, switching between them will actually be

1600509155
pixelherodev
Since with statically linked, it requires less cache space.

1600509173
marler8997
sure

1600509191
marler8997
but the statement "Statically linking improves caching" is not true in every case

1600509200
pixelherodev
True.

1600509230
marler8997
A very commonly used library with very commonly used functions might pratically have better performance as a dynamic library

1600509233
marler8997
like libc

1600509246
pixelherodev
Even in the absolute

1600509259
pixelherodev
and I explicitly said libc was an exception.

1600509263
marler8997
not necessarily though

1600509272
pixelherodev


1600509280
marler8997
oh?

1600509288
pixelherodev
Most libraries on my system are used by single-digit binaries, and are less than 10MiB tops.

1600509292
ikskuh
marler8997: i think most functions from a libc would eventually be inlined in static linked libs

1600509296
pixelherodev
If I reduced the percentage a bit, that number gets even better.

1600509302
pixelherodev
^that's a good point too

1600509318
ikskuh
drew devault did a measurement of how much of your shared libs are actually shared

1600509319
marler8997
so is this based on tests/data?

1600509320
pixelherodev
Statically linking libc would also probably improve performance, because inlining will most likely make up for loss of cache

1600509324
pixelherodev
marler8997: yes.

1600509328
ikskuh
and the percentage is … shockingly low

1600509328
marler8997
that 99% of libraries are better off static?

1600509340
marler8997
where can I find that data?

1600509347
pixelherodev
You can produce it yourself!

1600509351
ikskuh
marler8997:

1600509355
pixelherodev
There's some scripts at - imp'd lol

1600509372
pixelherodev
...

1600509377
pixelherodev
marler8997: s/libraries/*binaries*

1600509392
pixelherodev
99.9% of

1600509394
marler8997
I see one program

1600509398
marler8997
you said 99%

1600509403
pixelherodev
>

1600509405
pixelherodev
?

1600509422
marler8997
that link is showing one program that performs faster statically

1600509428
marler8997
you claimed that 99% run faster

1600509432
pixelherodev
That's... not the number I was talking about lol

1600509433
pixelherodev
That's startup time.

1600509443
marler8997
what?

1600509445
pixelherodev
That's a different metric entirely.

1600509450
pixelherodev
That's measuring how quickly binaries *start*.

1600509453
pixelherodev
Not how quickly they

1600509467
marler8997
wait

1600509473
pixelherodev
`Is loading dynamically linked programs faster? `

1600509478
pixelherodev
That's

1600509490
marler8997
so your initial claim that 99% of them are "better off static"...are you saying that mean they startup faster?

1600509507
pixelherodev
No!

1600509514
pixelherodev
I'm saying that's what

1600509520
marler8997
oh, you're talking about the linked page?

1600509527
pixelherodev
You were looking at startup time :P

1600509552
pixelherodev
I was talking about `On average, dynamically linked executables use only 4.6% of the symbols on offer from their dependencies` and `Over half of your libraries are used by fewer than 0.1% of your executables.`

1600509567
marler8997
On what system though?

1600509568
pixelherodev
Inlining + DCE of those libraries into those executables

1600509577
marler8997
And where is the data that 99% of programs are better static?

1600509578
pixelherodev
He lists that at the bottom, and you can run the scripts yourself

1600509580
marler8997
I don't see that on this page?

1600509585
pixelherodev
That specific claim isn't on the page, no

1600509598
pixelherodev
But the data to support it is.

1600509606
marler8997
What data?

1600509611
pixelherodev
The real kicker is `Over half of your libraries are used by fewer than 0.1% of your executables.`

1600509632
pixelherodev
That means that linking those libraries statically into those executables

1600509639
pixelherodev
That's just a basic assumption here.

1600509650
marler8997
The practial usage numbers of dyanmic libraries doesn't say anything about whether 99% of programs are better off static

1600509668
marler8997
but that doesn't follow

1600509671
pixelherodev
Second point is `On average, dynamically linked executables use only 4.6% of the symbols on offer from their dependencies.`

1600509691
pixelherodev
That first step might make this number higher or lower, but definitely still less than 10%.

1600509697
marler8997
It's an interesting data point

1600509706
pixelherodev
It means that, even with large libraries, the points about cache don't apply.

1600509711
marler8997
but you can't inferences like 99% of programs are better off static from them

1600509720
pixelherodev
Not *directly*, but combined with the earlier points.

1600509751
pixelherodev
If you can prove that the first 30% are better off static, then that directly causes more to be - since more and more libraries start having single-digit users.

1600509757
pixelherodev
That cascades easily.

1600509771
marler8997
I don't think anyone on the planet could make a claim like that, unless they actually tested it

1600509783
pixelherodev
You can test some generalizations.

1600509788
marler8997
Unless they actually took a large set of programs, compiled them statically/dynamically and tested it

1600509811
marler8997
Computers and processors an kernels and hardware and electronics are too complex to be able to make large inferences like that

1600509826
pixelherodev
If any program which uses, say, less than $(CACHE_SIZE_OF_MY_CPU) in dependencies is linked statically, it's almost certainly better off

1600509851
marler8997
what?

1600509865
marler8997
oh I see

1600509871
pixelherodev
Precondition: the advantage of dynamic linking is code size and reuse.

1600509877
marler8997
that still brings us back to that programs don't run in a vaccuum

1600509892
marler8997
not using dynamic libraries will have an affect on the system overall

1600509893
pixelherodev
Precondition: static linking of executables which use small fractions of their symbols results in faster code (due to various arguments already presented)

1600509901
pixelherodev
Yes. A positive one.

1600509903
pixelherodev
That's my point.

1600509911
marler8997
to say that a system as a whole will run faster if you compile everything statically is something you would have to test

1600509913
pixelherodev
If individual applications are better off like this, the system is too.

1600509915
pixelherodev
SUre.

1600509917
pixelherodev
Sure*

1600509922
marler8997
you can't look at one application and extrapolate that to the entire system

1600509929
pixelherodev
And since I plan on doing that to my PC within weeks, I can give you numbers then ;)

1600509936
marler8997
yes that will be good

1600509943
pixelherodev
Here's the thing

1600509963
pixelherodev
This doesn't really

1600509967
marler8997
But remember, that when you compile statically, running multiple programs together means less instruction memory can be shared

1600509969
pixelherodev
The claim that it results in lighter systems, yes.

1600509971
pixelherodev
That needs to be tested.

1600509976
marler8997
so there's reasons why running multiple programs statically could be slower

1600509985
ifreund
pixelherodev: have you seen oasis?

1600509987
pixelherodev
marler8997: but it

1600509993
marler8997
so you can't make the inference that if one program runs faster, then an entire system would

1600510006
pixelherodev
Like I said, inlining + DCE.

1600510026
marler8997
I understand

1600510030
marler8997
you still can't make that inference

1600510041
pixelherodev
The inference isn't "this program is faster so all are"

1600510064
marler8997
>  If individual applications are better off like this, the system is too.

1600510069
pixelherodev
The inference is "this program is faster *because of X*, and X applies to other programs, therefore other programs are faster"

1600510071
marler8997
you can't make that inference

1600510082
marler8997
I'll give you a counter example

1600510094
marler8997
If I give my application exclusive CPU access it will run faster

1600510119
pixelherodev
lol

1600510120
marler8997
but the system will stop

1600510133
marler8997
that's the same rule in your inference

1600510137
pixelherodev
the difference is, the factor here is the exact opposite.

1600510150
pixelherodev
Programs are faster because they don't need to do as much work, and they can make better utilization of caches.

1600510168
marler8997
still can't make the inference though, that's not the whole pictures...again, complexity

1600510196
marler8997
out of curiosity, how old are you and how long have you been programming seriously?

1600510202
marler8997
wait

1600510204
marler8997
let me guess

1600510210
pixelherodev
Sure, shoot :)

1600510215
marler8997
5 years programming seriously?

1600510215
pixelherodev
I'm curious what you'll think :P

1600510225
marler8997
and 24 yrs old?

1600510227
pixelherodev
Closer to seven or eight, I think

1600510234
pixelherodev
Years of programming seriously*

1600510237
pixelherodev
Not age xd

1600510253
pixelherodev
19, actually ;P

1600510257
marler8997
oh wow

1600510265
marler8997
you remind me of myself 4 years go :)

1600510277
pixelherodev
Constantly wasting time in debates on the internet that won't go anywher?

1600510279
pixelherodev
anywher*

1600510281
pixelherodev
anywhere*

1600510283
pixelherodev
:P

1600510288
marler8997
I'm enjoying it though

1600510293
pixelherodev
same :P

1600510299
pixelherodev
It's always good to hear other perspectives

1600510300
marler8997
and to be clear

1600510312
marler8997
I make no claims that dynamic or static is better

1600510317
marler8997
I hope to see more data on it

1600510341
pixelherodev
What I want to see is a serious, practical distro

1600510348
pixelherodev
ifreund: no, but I'll look soon

1600510349
marler8997
I just understand that there are alot of pieces to it, and one thing I've learned is that no matter how much you theorize, you'll never know until you actually test

1600510360
pixelherodev
Ugh. I think I'm too used to embedded systems lol

1600510408
pixelherodev
Much simpler systems == theoretical ideas actually work practically

1600510417
marler8997
its' kinda funny

1600510435
pixelherodev
Huh

1600510436
marler8997
as processors get better, the more predictable you make your code the faster it generally goes

1600510445
pixelherodev
I was about to bring that up

1600510446
marler8997
it's almost as if, as processors get smarter, programs should get dumber

1600510464
pixelherodev
I think static linking would improve branch prediction too, due to inlining

1600510471
pixelherodev
But that's also highly hypothetical

1600510490
ifreund
oasis is the only distro I know of that is serious about static linking

1600510492
marler8997
well sure, and each program will have it's own branch predictions

1600510511
pixelherodev
That's "idea I want to test", not "look at what I figured out!!!!"

1600510514
ifreund
it is a little different in other ways too of course

1600510542
pixelherodev
(Un)fortunately, my only web browser is ikskuh's Kristall :P

1600510550
pixelherodev
So it's a PITA to deal with GH

1600510559
pixelherodev
SourceHut is fine, in what really isn't a shock at all.

1600510602
ifreund
pixelherodev:

1600510621
ifreund
shoulda known he'd have it on sourcehut too

1600510630
pixelherodev
Holy crap oasis looks amazing!

1600510642
pixelherodev
Ahhhh it's mcf?

1600510658
pixelherodev
That explains it ;)

1600510680
pixelherodev
ikskuh: minor bug report for kristall: it doesn't seem to understand 404s from https :P

1600510695
ikskuh
whoopsies

1600510698
ikskuh
write me an issue :D

1600510748
pixelherodev
`/etc should be simple enough to be understood in its entirety.` It's... it's beautiful!

1600510757
pixelherodev
ikskuh: with what, kristall???

1600510759
pixelherodev
:P

1600510760
ikskuh
yeah

1600510771
ifreund
yeah mcf does some pretty cool stuff

1600510795
pixelherodev
ikskuh: ...

1600510808
pixelherodev
ikskuh: you realize that kristall doesn't support inputs, right?

1600510809
pixelherodev
;P

1600510816
ikskuh
... :D

1600510828
ikskuh
it does

1600510835
ikskuh
but nobody has written a gemini-github-bridge

1600510908
ifreund
pixelherodev: maybe you can try the github cli they keep putting banners up about

1600510966
pixelherodev
ifreund: ... uh... yeah, no.

1600510976
ifreund
lol

1600510981
pixelherodev
The only reason I still even

1600510987
pixelherodev
I can't get rid of it until a few other people leave it :P

1600510989
pixelherodev
e.g. Zig

1600510991
pixelherodev
lol

1600511048
ask6155
Hello!

1600511053
ifreund
I've decided that if/when wlroots moves to sr.ht I will follow

1600511073
ask6155
what is the equivalent of atoi in zig?

1600511085
ifreund
std.fmt.parseInt() ?

1600511102
ifreund
or wait, other way: std.fmt.bufPrint()

1600511110
ikskuh
atoi → array to integer

1600511114
ikskuh
parseInt is the right thing

1600511125
pixelherodev
ifreund: heh, that's probably a matter of time lol

1600511125
ifreund
lol, tripped myself up

1600511125
ask6155
thanks

1600511473
marler8997
I thought the "a" stood for "ascii"?

1600511510
marler8997
ah...I'm right :)

1600511517
ask6155
I thought it stood for alphabet?

1600511537
ask6155
wait that makes no sense

1600511545
ask6155
lol

1600511547
marler8997
lol

1600511553
pixelherodev
:P

1600511559
pixelherodev
marler8997: thanks for the brainfood :)

1600511578
marler8997
yeah you too

1600511588
marler8997
I think I gotta go to bed, 4:30 AM my time

1600511678
ifreund
night

1600511997
pixelherodev
heh

1600511999
pixelherodev
heh

1600512001
pixelherodev
4:30? Only?

1600512019
pixelherodev
(i'm two hours ahead :P)

1600512235
pixelherodev
You know, when I see code like this: `constructor(int a) { assert (a >= 0); }` it doesn't convince me C++ devs know what they're doing :P

1600512256
pixelherodev
Using a signed type for unsigned data? really?

1600512274
pixelherodev
There were numerous casts to "fix" that, too.

1600512307
pixelherodev
Gah, so many latent bugs in this codebase

1600512347
pixelherodev
The bugs-per-line in this library I'm using is ludicrous, but I don't want to rewrite it from scratch, so I'm just cleaning it up with `-pedantic -Wall -Wextra -Werror` for now and then redoing it later when I have time :P

1600512376
ask6155
If I remember correctly assert crashes the program on false right?

1600512409
pixelherodev
yes

1600512412
pixelherodev
Traps it, rather

1600512419
pixelherodev
So if you're in e.g. GDB you can backtrace

1600512421
pixelherodev
I think.

1600512552
ask6155
Does it make sense to just put asserts in your library?

1600512592
pixelherodev
Depends.

1600512606
pixelherodev
If the goal is to test that the library is behaving, yes.

1600512613
pixelherodev
e.g. preconditions, postconditions.

1600512623
pixelherodev
If the assert is testing input provided to the library, no.

1600512625
pixelherodev
Well

1600512627
pixelherodev
Hmm

1600512645
pixelherodev
I don't think "yes" or "no" really cuts it here. It's a bit contextual.

1600512656
pixelherodev
A better question is whether it is recoverable

1600512700
ask6155
I guess good software is somewhere between crashing all the time and java

1600512841
pixelherodev
lol

1600512867
pixelherodev
I'd say that if it's an *error*, it should be passed onwards, but if it's a *bug*, it should be an assertion

1600513029
pixelherodev
andrewrk: given that we're going to support parallel compilation, what are the odds we can extend that over networks?

1600513833
ask6155
I'm getting a invalid character error in parseint(u8, buffer, 10) even though I'm only giving it numbers

1600516221
kristoff_it
Zig SHOWTIME is live, we start in 20mins

1600516278
pixelherodev
kristoff_it: what's the topic this time?

1600516496
ifreund
pixelherodev: there's an rss feed you can find through

1600516518
ifreund
I think your browser can probably handle it, if not complain to kristoff_it :P

1600516566
kristoff_it
I jave no (mandatory) JS on the website, so all should work

1600516595
kristoff_it


1600516608
kristoff_it
not sure about how much JS is required to see this though

1600516690
pixelherodev
kristoff_it: my browser doens't support RSS lol

1600516697
pixelherodev
I curled it through a few sed-exprs

1600516704
pixelherodev
then tweaked it into semi-valid HTML

1600516706
pixelherodev
Now I can view it lol

1600517054
ifreund
nice :)

1600541870
adamkowalski
Can we use an ArrayList(str) as a key to a hash map?

1600541929
adamkowalski
And would you all recommend using a hash map if the number of entries is pretty small? I was considering using an ArrayList instead and just doing a linear scan

1600542061
Snektron
Thats probably faster yea

1600542084
Snektron
You could use an arraylist as hash map key but you'll need to make consistent hash/equality functions yourself

1600542210
adamkowalski
Yeah thats what I was thinking, hashing that would be quite tough

1600542257
adamkowalski
If the number of unique strings is fairly small (there will be lots of repeated strings)

1600542264
adamkowalski
would it make more sense to intern them first?

1600542288
Snektron
depends on what you want to do with them

1600542290
adamkowalski
have a mapping of strings to ints, then rather than storing an ArrayList(ArrayList(str))

1600542301
ifreund
this sounds like a rather unique use-case

1600542311
adamkowalski
well i'm working on a toy language and I am trying to implement overloading of functions

1600542314
Snektron
btw there is already a StringArrayList i believe, you could take a look at how hashing is implemented for those

1600542333
adamkowalski
so when you are doing name lookup, and you know something is a function, you don't know which one it refers to

1600542347
adamkowalski
you need to look at the types of the arguments and see which one you actually meant

1600542362
adamkowalski
so every function name actually resolves to an overload set

1600542384
adamkowalski
then inside the overload set, you have a "key" which is the argument types and the value is the index of the actual function you meant to call

1600542393
Snektron
right

1600542405
adamkowalski
now that i'm thinking about it, that actually doesn't work either

1600542421
adamkowalski
because when you have generics, you will have multiple matches

1600542436
adamkowalski
and if you have a generic function and a non generic function that both accept that type

1600542443
adamkowalski
you should prefer the specialized version

1600542457
Snektron
I would probably have a hash map that maps to a list of functions, which you manually search through for the given overload

1600542490
Snektron
You can't hash the parameters, considering you might need to have an implicit cast when calling a function

1600542501
adamkowalski
I won't have implicit casting

1600542520
adamkowalski
only caveat to that is integer literals to flaots

1600542526
Snektron
Even stuff like integer widening are implicit casts

1600542537
adamkowalski
and integer literals to i64, i32, u64, etc

1600542539
Snektron
or int literal -> signed/unsigned

1600542545
adamkowalski
but those are special cases

1600542556
adamkowalski
user defined implicit conversion will be disallowed

1600542595
adamkowalski
the trickiest part will be I want to implement something like concepts in c++ with subsumption

1600542616
adamkowalski
that means that you can have multiple generic functions, for example you can do a matrix multiply

1600542636
adamkowalski
if you get passed in a random access container you want to do one thing

1600542650
adamkowalski
but if you get passed in a random access SPARSE matrix you want to do another

1600542684
adamkowalski
so multiple generic functions can both match on the given argument type, then you need to figure out which one takes precedence

1600542712
adamkowalski
which pretty much means if function f takes any parameter x given that it satisfies contraints A

1600542725
adamkowalski
and you have a function g that takes x given that it satisfies A and B

1600542729
adamkowalski
then you prefer function g

1600542734
adamkowalski
since it's more specialized

1600542759
Snektron
If you want to do any kind of specialization hashing on anything but name seems infeasable to me

1600542772
adamkowalski
yeah exactly, talking it through with you helped me realize that

1600542785
adamkowalski
it seems like you have to do a linear scan over every function that matches the name

1600542789
Snektron
Praise rubber duck developing

1600542790
adamkowalski
then figure out the "best match"

1600542820
adamkowalski
but what do you actually store about the function? it's not really the type name that matters

1600542834
adamkowalski
it seems like it's more like a set of constraints that must be satisfied

1600542841
adamkowalski
the most primitive one being, the type is X

1600542869
adamkowalski
so maybe it's a list of list of constraints?

1600542885
adamkowalski
the outer list represents the number of parameters the function accepts

1600542893
adamkowalski
the inner list represents the constraints for that parameter

1600542925
adamkowalski
if the number of parameters match, and constraints all evaluate to true, then you are a candidate for overload resolution?

1600542962
adamkowalski
I think we are getting somewhere

1600543192
ifreund
ugh, stage1 is crashing on me :/

1600543240
adamkowalski
Snektron: do you see any glaring flaws with that plan?

1600543245
adamkowalski
It seems like it might be a bit slow

1600543257
adamkowalski
if every time you call a function you have to look through all functions with that name

1600543265
Snektron
let me see

1600543273
adamkowalski
but I guess it's pay for what you use. It's linear in the number of functions with that name

1600543283
adamkowalski
so if you do a lot of overloading, then you will pay more

1600543315
Snektron
The way i would implement an analyzer in general is that i would have a hashmap per scope with all variables, including functions

1600543329
adamkowalski
yeah that's roughly what I do

1600543333
adamkowalski
I scan the entire module

1600543335
adamkowalski
in parallel

1600543344
Snektron
The case of overloads is quite ugly though since you suddenly have to change that into a multimap

1600543355
adamkowalski
so I first start lexing, and figure out where each top level expression starts and ends

1600543358
adamkowalski
but I don't parse it yet

1600543364
adamkowalski
once I know where each segment is

1600543374
adamkowalski
I then start parsing each segment simultaniously

1600543384
Snektron
The easiest is probably to make the lookup function return an iterator or something over the possible overloads in the case of a function

1600543387
adamkowalski
then that AST is instantly transformed into SSA form

1600543389
adamkowalski
again in parallel

1600543405
adamkowalski
this means the functions do not know about each other

1600543413
adamkowalski
so each function maintains a list of scopes

1600543420
Snektron
Then you generate a list of candidates from that by filtering the ones that are applicable, and pick out the most specialized. You might need to look up the c++ rules for that to get inspiration on how that is handled

1600543439
Snektron
if there are ones that are equally specialized you generate a compile error

1600543451
adamkowalski
yeah that's roughly what I wanted to do

1600543463
adamkowalski
I'm gonna trhow one more wrench at you

1600543473
adamkowalski
I don't want classes

1600543491
adamkowalski
so if you define a struct called array in your module

1600543498
adamkowalski
and you have a free function named append in that same module

1600543505
adamkowalski
then I need to know about it.

1600543522
adamkowalski
why? because if you have a generic function, and you want to accept any data structure, given that you can append elements to the end

1600543526
adamkowalski
you can't say container.append

1600543533
adamkowalski
you say append(container, element)

1600543544
adamkowalski
at that point it will look at the current module for a function named append

1600543547
adamkowalski
if one is not found

1600543560
adamkowalski
if needs to look at the module where container is defined, and see if one is found there

1600543601
adamkowalski
BUT, suppose that you didn't define the contrainer struct, so you can't open up it's module and add an append method

1600543613
adamkowalski
yet you still want to use that container with that generic algorithm

1600543627
adamkowalski
so you need to create a new append free function in your module

1600543631
adamkowalski
then call the generic function

1600543647
adamkowalski
that means generic functions will also need to look into the callers module if the first two checks fail

1600543651
adamkowalski
does that all make sense?

1600543695
adamkowalski
but the one thing that makes it easier, is I don't want any virtual functions in my language

1600543717
adamkowalski
everything is resolved at compile time, I won't help people write object oriented code with runtime polymorphism since I disagree with it

1600543718
Snektron
> if needs to look at the module where container is defined, and see if one is found there

1600543722
Snektron
You want to implement ADL?

1600543731
adamkowalski
yeah essentially

1600543736
adamkowalski
structs are just data

1600543742
adamkowalski
they don't need methods

1600543753
adamkowalski
functions are just functions, they don't "belong" to anybody

1600543769
adamkowalski
so all "behavior" is defined in terms of free functions

1600543782
adamkowalski
so you're forced into adl if you want to support generic programming

1600543804
adamkowalski
Are you not a fan?

1600543835
Snektron
it seems unneccesarily complex to add adl. You could instead do like Zig and make the programmer require to explicitly import the freestanding function

1600543855
adamkowalski
Yeah I think zig is a step in the right direction

1600543862
adamkowalski
but I don't think that would work

1600543873
adamkowalski
how would you do the append example I discussed

1600543880
adamkowalski
In zig the method lives on the class

1600543909
adamkowalski
It's statically resolved, so that part is nice. But the only way to create a generic function which takes anything "appendable" is to make the function live on the struct

1600543927
adamkowalski
if it's a free function, how would your algorithm know how to call it?

1600543929
Snektron
It depends on some other ergonomics of the language, but you could for example have a programmer write `import my_container_module.append`

1600543951
Snektron
That would add the overload of `append` to the current scope

1600543953
adamkowalski
but then the algorithm needs to know about the container right

1600543966
adamkowalski
suppose you wrote algorithm A

1600543969
adamkowalski
I wrote struct S

1600543978
adamkowalski
and some user U wants to call A with S

1600543981
Snektron
not really. You look up the set of overloads of `append` and you find the one applicable for your container type

1600543983
adamkowalski
how does A know about S

1600544001
Snektron
The only issue is if you have `import my_other_module.append` which takes the same `container`

1600544013
adamkowalski
yeah exactly! The overload set is my solution right?

1600544027
adamkowalski
I'm saying in algorithm A you just call append

1600544027
Snektron
But you could simply store the origin module in some kind of "function alias" and select on that

1600544049
adamkowalski
and the overload resolution mechanism will know to check the module where S is defined

1600544063
adamkowalski
or check the callers module, because maybe whoever created S didn't define append for it

1600544072
adamkowalski
are we not saying the same thing?

1600544145
Snektron
My initial understanding was that you would have `import my_module.my_container` and then `append(my_container, item)` would be magically extracted from the module

1600544170
Snektron
Thats also possible, but requires a more sophisticated system to find that function

1600544172
adamkowalski
well it depends

1600544187
adamkowalski
it may be extracted from the module where my_container is defiend

1600544196
adamkowalski
but only if the usage site is a templated function

1600544233
adamkowalski
if I have a generic function which says I accept anything as long as there is an append function on it, matching a particular signature

1600544261
adamkowalski
that generic function can be defined in a module which does not know about an append function, nor does it know about your struct

1600544293
adamkowalski
append in that context is a placeholder for a function

1600544337
adamkowalski
so essentially ADL

1600544368
adamkowalski
but if you look at more modern languages like Julia they do something called multiple dispatch which is a similar concept and it led to some amazingly composable libraries

1600544396
adamkowalski
I want to do that, but just resolve everything at compile time, rather than runtime

1600544401
Snektron
Multiple dispatch is runtime right?

1600544443
adamkowalski
yeah it's at runtime, but they have a jit compiler, which if it can monomorphise as all the types are known statically, it will

1600544470
adamkowalski
but i'm getting off topic here

1600544479
adamkowalski
the main question I have for you is how to solve this problem

1600544506
adamkowalski
you defined some algorithm which wants to sum the elements of a container and return the total

1600544516
adamkowalski
you want to write two generic versions of it

1600544549
adamkowalski
one which says, hey if you are forward iterator (I can only iterate sequentially through the elements) then do that sum things and return the total

1600544579
adamkowalski
if you are a random access iterator then split the container into as many pieces as you have cores, sum each chunk, then sum the partial sums

1600544588
adamkowalski
random access iterators are by definition forward iterators

1600544595
adamkowalski
so both would be correct matches

1600544607
adamkowalski
clearly if I support random access I want to do the parallel version though right

1600544628
adamkowalski
now you found some vector library you want to use

1600544639
adamkowalski
but they only implemented the sequential iterator functions

1600544655
adamkowalski
I want to add new functions to suport random access (since it's a vector)

1600544664
adamkowalski
then call the algorithm

1600544680
adamkowalski
it should realize that even though the vector is defined in one place, the random access function is defined in another

1600544690
adamkowalski
I should combine the two, and still dispatch to the parallel implementation

1600544694
adamkowalski
does that make sense?

1600544958
Snektron
i see

1600545009
Snektron
Well its entirely possible using just the overload searching method i described, all you need to do is add some way to discover the list of possible overloads, and a way to select the most preferable one

1600545039
Snektron
The former you could take inspiration from Rust from, which allows you to implement a trait for any type, but you have to explicitly import it to enable it

1600545082
Snektron
That saves you from having to scan every file for functions, and also makes it possible for the programmer to select the overload they want

1600546727
adamkowalski
Snektron: yeah Rust is pretty nice in that regard

1600546743
adamkowalski
The main thing I love from there is the lifetime tracking / borrow checker

1600546754
adamkowalski
I think that combined with an allocator model like zigs would be killer

1600546767
adamkowalski
but I actually think that concepts from C++ are nicer to work with then rust traits

1600546787
adamkowalski
I say that because traits, like methods belong to a single type

1600546798
adamkowalski
free functions, like concepts, belong to nobody

1600546811
adamkowalski
concepts can be between a set of types

1600546878
adamkowalski
I also want to avoid the long compile times of c++/rust so I want to make sure whatever strategy I use needs to be fast

1600546893
adamkowalski
people tend to avoid templates/compile time meta programming because they know it's so slow

1600546917
adamkowalski
but in a language like D where the compiler is crazy fast, it enables a new style of programming, where you worry more about being expressive rather than the impact on compile time

1600549145
oats
I haven't checked in on zig stuffs in a while, is there a cohesive story for traits/interfaces yet?

1600549365
ikskuh
oats: same as before: embed struct + @fieldParentPtr or use

1600549373
ikskuh
which is pretty damn good already and convenient :)

1600549425
oats
quite cool that an interface system could be implemented with a library, tbh

1600549539
ikskuh
yeah

1600549547
ikskuh
it's also flexible and convenient to use

1600549566
ikskuh


