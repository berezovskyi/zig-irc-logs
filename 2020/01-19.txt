1579392007
daurnimator
andrewrk: ah okay; what so they are just considered equivalent? what does @intToEnum return? what does @tagName return?

1579392035
daurnimator
^ the answer to this should probably be in the docs

1579392068
andrewrk
agreed

1579392104
metaleap
daurnimator: guessing these @ built-ins iterate through the members in the order they're defined, but yeah just a guess and +1 for docs

1579392129
metaleap
aka first match

1579392202
daurnimator
I'm worried the answer might be "segfault" :P

1579393257
andrewrk
so this function works:

1579396696
mikdusan
andrewrk: yeah cmake was like 1 work around breaks windows, then fix windows, breaks posix but I think worth it

1579396731
andrewrk
seems to work for me

1579396816
mikdusan
hey at least I learned how to do a loop in cmake

1579396827
andrewrk
microsoft sent us a picture of the windows CI server:

1579396899
mikdusan
that's everything I imagined <grin>

1579396998
keegans
was reading:

1579397440
pixelherodev
keegans,  As of the end of that, I believe it's

1579397458
pixelherodev
You'd probably have to write the allocator yourself though at present

1579397536
pixelherodev
Actually, the one up top might work

1579397536
pixelherodev
Not sure

1579397636
keegans
well the ComptimeAllocator is referenced, but it doesn't exist, what do you mean but one up top?

1579397639
keegans
*by

1579397649
pixelherodev
It's shown in that issue

1579397655
pixelherodev
An example of one is, at least

1579397675
fengb
Assigning undefined at comptime is still a problem

1579397676
pixelherodev
Literally in the first post

1579397680
pixelherodev
Not saying it's not

1579397686
pixelherodev
Like I said,

1579397691
pixelherodev
Doesn't mean it's a good idea just yet

1579397719
pixelherodev
I will say, I far prefer the idea of finding workarounds to those problems that don't require adding in a builtin

1579397737
keegans
i will play around with it, thanks

1579397764
andrewrk
this use case one of the constraints of the possible "interface" feature to add to the language. it has to solve this problem

1579397764
pixelherodev
Minimizing builtin count where possible (within reason; no removing subtraction and replacing with inversion + addition for instance, that'd just be stupid) is probably a good idea

1579398288
keegans
error: cannot store runtime value in type '*ComptimeAllocator', in: const self = @fieldParentPtr(ComptimeAllocator, "allocator", allocator); -- I guess this worked previously, but not sure how I can solve this since I cannot really mark the `allocator` object as comptime, right?

1579398296
andrewrk
I need sys::getHostCPUName() and sys::getHostCPUFeatures() ported to zig

1579398634
pixelherodev
How complex are they?

1579398710
pixelherodev
Ah -

1579398737
pixelherodev
That one?

1579398759
pixelherodev
Ah, get

1579398775
pixelherodev


1579398789
pixelherodev
That looks awful

1579398825
pixelherodev
Alrighty, I was planning on redesigning my LLVM parser and then implementing to match the design, but that can wait; I'll port those shortly

1579398838
andrewrk
yeah that one

1579398865
andrewrk
unfortunately difficult to test, and catastrophic consequences for bugs in the implementation

1579398885
pixelherodev
Yeah, but there's a simple way to work around that

1579398894
pixelherodev
Just check the produced LLVM IR via `diff`

1579398902
pixelherodev
... oh wait

1579398907
andrewrk
...for every CPU

1579398907
pixelherodev
It uses the preprocessor :(

1579398927
pixelherodev
Okay, so is there a way to fake running Zig on a different host?

1579398934
pixelherodev
Could check the produced asm that way...

1579398943
andrewrk
to truly test this you would need to run it on N cpus * N operating systems

1579398947
mikdusan
you could plug in known values to unit test much like this project does:

1579398947
pixelherodev
Right...

1579398953
andrewrk
maybe qemu knows how to pretend to be certain CPUs

1579398959
pixelherodev
... ah right!

1579398965
pixelherodev
QEMU should work

1579398966
andrewrk
that's a good idea mikdusan

1579399065
andrewrk
I'm going to make this depend on LLVM's implementation of these functions for now, so that #3927 can get merged. but a zig implementation would be (1) cleaner (2) progress toward non-llvm backend (3) more complete! llvm's implementation only supports x86 and arm

1579399121
pixelherodev
... uh... I was

1579399125
pixelherodev
Like, line-for-line port

1579399127
pixelherodev
Then clean that up

1579399132
andrewrk
that would be fine

1579399137
pixelherodev
Lacks 3) for now

1579399156
pixelherodev
x86 is most definitely where I'm strongest, though I do plan on ordering a PineBook shortly

1579399168
andrewrk
yeah (3) is not a blocking problem

1579399173
pixelherodev
Got it

1579399182
pixelherodev
No promises, but I'll attempt to have it done tonight

1579399195
andrewrk
nice! if you get it done within a day or two I'll incorporate it into the merge

1579399207
andrewrk
I also have a pine book I can run it on

1579399229
pixelherodev
Also, holy craps - the PineBook Pro has 10k mAh battery?!

1579399236
pixelherodev
That's - that's still at 12V, right?

1579399241
andrewrk
is that a lot?

1579399254
pixelherodev
My Dell laptop's battery lasts ~7 hours, and it's 2700 mAh

1579399261
andrewrk
oh wow

1579399264
pixelherodev
With an

1579399268
andrewrk
and arm is-- yeah

1579399270
pixelherodev
So, yeah, I'd say so

1579399289
pixelherodev
Just how long does the battery typically last on there?

1579399300
andrewrk
hmmm, pixelherodev, you'll probably need the std.Target structs & definitions for this implementation, and I'm completely changing the structure and namespacing from the PR

1579399311
andrewrk
I've never had it die on me, but I haven't tested it either

1579399318
companion_cube
wait, it's a consumer laptop based on ARM?

1579399324
andrewrk
yeah, cheap too

1579399327
pixelherodev
$200

1579399338
companion_cube
wtf?! is this the notebook era again? :D

1579399350
andrewrk
the build is sturdy, I like it

1579399373
companion_cube
what OS do you use on it? debian?

1579399393
andrewrk
it comes with a fork of debian, and it's not clear to me that it is compatible with upstream debian

1579399400
andrewrk
for some confusing reason

1579399418
pixelherodev
Whoa, this is interesting

1579399419
pixelherodev
``The keyboard has a special firmware that lives on, and operates separately of, the operating system. In a nutshell, it detects if F1, F2 and F3 keys are pressed for 10s. Once one of the keys get pressed for the set duration, the keyboard firmware cuts power to the chosen aforementioned peripheral``

1579399454
pixelherodev
This has to be the

1579399509
pixelherodev
andrewrk, to my knowledge the Debian fork is to improve ARM support / performance

1579399515
andrewrk
ah

1579399518
pixelherodev
AFAIK it includes patched kernel / software

1579399531
andrewrk
pixelherodev, re: get native cpu - I'll push to a branch in ~30 minutes here so you can get a sense of the std.Target structs and stuff. It'll be an in-progress commit because I have to manually go through and refactor ~18,000 lines of things

1579399543
pixelherodev
So should I branch from that branch for this?

1579399545
andrewrk
it would be reeeeeally nice to have an IDE rename feature right about now

1579399549
pixelherodev
Hmm

1579399549
andrewrk
yeah

1579399557
karrick
I built my first non trivial and useful program with Zig 0.5 today, but using the debug allocator and need to use an arena. I tried to initialize the arena using `std.heap.page_allocator` but I get a compile error about `std.heap` having no `page_allocator` even though I see it right in the source code for std.

1579399561
pixelherodev
What's higher priority, a CLI Zig refactoring tool or this port?

1579399576
companion_cube
is the pine book entirely free? even for the bios (or whatever equivalent)?

1579399583
andrewrk
karrick, you can check out the 0.5.0 tag

1579399583
pixelherodev
companion_cube, AFAIK

1579399595
companion_cube
:o that's incredible

1579399604
andrewrk
if you're looking at a local git repo, `git checkout 0.5.0`. github.com has a way to browse tags as well with the UI

1579399617
andrewrk
pixelherodev, the port

1579399623
pixelherodev
Gotcha

1579399633
karrick
Even if `zig version` already shows 0.5.0? Sorry for the hassle.

1579399635
andrewrk
companion_cube, they have a phone too. I should be getting one within a week or two

1579399642
pixelherodev
karrick,

1579399648
pixelherodev
Whoops sorry, hit enter early

1579399649
companion_cube
yeah I knew that because of ddevrault's review

1579399659
karrick
Thanks for the help

1579399664
pixelherodev
karrick, yes

1579399665
companion_cube
I'm having a hard time imagining they can be profitable though

1579399686
pixelherodev
The version is usually shown as major.minor.patch + revision

1579399706
pixelherodev
The pre-0.6 revision changes renamed the alocator IIRC

1579399706
andrewrk
karrick, yeah, `zig version` shows what version of zig you are using, but if you're looking at the git repo, the main branch has changed since 0.5.0. so you want to look at the std lib version that matches the zig version  you have

1579399720
pixelherodev
companion_cube, AFAIK they don't try to be

1579399725
pixelherodev
They sell at literally zero profit

1579399739
companion_cube
nice

1579399764
pixelherodev
Yeah, found it

1579399765
pixelherodev
`When fulfilling the purchase, please bear in mind that we are offering the Pinebook Pro at this price as a community service to PINE64, Linux and BSD communities. We make no profit from selling these units. If you think that a minor dissatisfaction, such as a dead pixel, will prompt you to file a PayPal dispute then please do not purchase the Pinebook Pro. Thank you.`

1579399766
karrick
Okay thanks. So I’ll check out the 0.5.0 source and make sure I can find the proper allocator. Thanks

1579399793
andrewrk
karrick, it's std.heap.direct_allocator afaik

1579399807
pixelherodev
imp'd :P

1579399862
karrick
Thank you very much!

1579399876
andrewrk
karrick, just as a heads up, if you run into bugs in 0.5.0, the response is going to be "upgrade to master branch"

1579399938
karrick
Sounds fair.

1579400369
pixelherodev
Where should the port go in the stdlib?

1579400385
keegans
how do I tell compileLog to write out a []const u8 as a string?

1579400436
pixelherodev
andrewrk, ping me when the branch is available, I'm beginning work on a refactoring tool using the stdlib Zig parser until then :)

1579400443
andrewrk
ok :)

1579400447
pixelherodev
keegans, AFAIK it only accepts string literals

1579400475
keegans
ah, makes sense. thanks

1579400476
pixelherodev
Wait NVM I take that back

1579400488
keegans
ok then i am doing something wrong clearly

1579400498
pixelherodev
It only works on

1579400506
pixelherodev
If it's just one line, paste it here?

1579400565
andrewrk
@compileLog prints any value

1579400575
pixelherodev
Right

1579400582
pixelherodev
Wait, it takes varargs?

1579400583
pixelherodev
Hmm

1579400586
keegans
it is printing out like | []const u8{91,115,115,104,93}

1579400590
pixelherodev
Ohhh

1579400592
keegans
whereas I'd rather see it as a string

1579400596
pixelherodev
Try slicing it?

1579400598
pixelherodev
I mean

1579400606
pixelherodev
`s[0..]?` No wait, that makes no sense...

1579400613
andrewrk
hmm I think that maybe regressed recently

1579400658
keegans
yeah taking a slice doesn't seem to do the trick either

1579400670
pixelherodev
Like I said, that makes no sense

1579400678
pixelherodev
If you have a slice and it's doing that, slicing it is meaningless

1579400681
pixelherodev
It's already a slice

1579400702
keegans
i mean honestly i just spray and pray

1579400705
pixelherodev
On the other hand... okay, I doubt this will work, but you could try `.ptr`?

1579400706
keegans
eventually you'll get something working

1579400724
pixelherodev
Right, but going from Type A to Type A isn't going to help if the problem is the treatment of type A

1579400733
pixelherodev
`.ptr`

1579400744
keegans
yeah, .ptr is not `| *91`

1579400745
pixelherodev
It'll give you a `[*]const u8` instead of a `[]const u8`

1579400753
keegans
it just prints the first character as integer repr

1579400781
keegans
a []const u8 coming in through the function as a string literal has the same type as this []const u8, what would likely be the difference?

1579400788
pixelherodev
It doesn't.

1579400795
pixelherodev
String literals aren't `[]const u8`

1579400799
pixelherodev
They're

1579400801
pixelherodev
That's literally their type

1579400814
pixelherodev
They implicitly

1579400823
pixelherodev
So the compiler builtin sees a string literal, not a []const u8

1579400841
keegans
i think the string literal is null-terminated

1579400848
keegans
these are not

1579400856
pixelherodev
Nah, shouldn't matter

1579400856
keegans
oh

1579400870
keegans
yeah i read what you wrote after i wrote that

1579400884
keegans
strange, I'll just live with it for now

1579400914
pixelherodev
I think this gets back to the "if anything goes wrong" comment from earlier :P

1579400935
keegans
yeah I am on master

1579400962
pixelherodev
... maybe try `git bisect`ing between 0.5.0 and master? Should find

1579400984
pixelherodev
Might not be worth it if compilation of Zig takes too long though

1579401006
pixelherodev
Heck, might be simpler to e.g. write a shell script to parse the output and translate to a string :P

1579401021
keegans
yeah thats what i'm doing hehe

1579401031
pixelherodev
:D

1579401210
pixelherodev
What's the recommended allocator for now until the GP-allocator is finished? direct/page allocator?

1579401261
andrewrk


1579401275
pixelherodev
I somehow managed to forget that existed

1579401284
pixelherodev
Despite having read it at least half a dozen times previously

1579401288
pixelherodev
Sorry to waste your time, thanks for the link!

1579401358
andrewrk
no problem! I'm glad I invested in writing that short guide

1579401375
pixelherodev
Hmm... I should probably consider a refactoring tool a *library*, with the CLI as the default implementation

1579401390
pixelherodev
That would allow incorporating it more easily with future projects / IDEs / whateveer

1579401392
pixelherodev
s/eer/er

1579401451
pixelherodev
Oh hey wait, when you get a chance, is programming in Zig on the PineBook fast enough that it could be used as a daily driver if Zig is your primary concern?

1579401461
pixelherodev
Just realized I've been wondering that and you said you had one :)

1579401562
keegans
i keep running into this: error: expected type '[][]const u8', found '[4][]const u8', but in general how do I specify in types that there is no fixed slice size in a return value?

1579401581
keegans
because omitting it doesn't seem to cut it

1579401589
pixelherodev
[_]

1579401596
pixelherodev
That means

1579401604
keegans
error: inferred array size invalid here?

1579401607
pixelherodev
i.e. size is known at runtime but not comptime

1579401612
pixelherodev
But I don't think you can return that

1579401613
pixelherodev
Yeah

1579401621
pixelherodev
Size of a type has to be known at comptime

1579401644
keegans
this is a compile time function, but the size is calculated in the body of the function

1579401663
pixelherodev
Can you extract size calculation into its own function?

1579401672
keegans
yeah

1579401675
keegans
ah i see, will do

1579401689
pixelherodev
:)

1579401704
pixelherodev


1579401759
keegans
alright so i just ended up crashing the compiler

1579401762
keegans
not what i was going for

1579401777
pixelherodev
Heh yeah

1579401842
pixelherodev
The most important thing I've had to remember about compiler bugs is to mark them down as to-fix after the compiler bug is fixed

1579401860
pixelherodev
I don't doubt I have some workarounds in some projects for which I forgot to do so and the workarounds will just always be there

1579401873
keegans
ah, good point

1579401884
keegans
also it seems that i was causing out-of-bounds array access at compile time accidentally

1579401888
keegans
and that crashes the zig ir processor

1579401912
pixelherodev
Hmm, what's a good API sig for a library refactoring function? Currently, I'm thinking of taking in the source as a slice and returning a refactored slice

1579401931
pixelherodev
For some reason, I always have more trouble arguing with myself on function sigs than actually implementing them :P

1579401984
pixelherodev
It could modify-in-place the existing slice and use an adjusted offset, but if the caller wants to e.g. diff the refactor against the original and print that, it's better to not require duplicating the original

1579402031
pixelherodev
Or, it could take in two *streams*! I was thinking, "I don't think I've ever needed to stream... out... a string oh wait that was obvious" :)

1579402098
pixelherodev
That also allows for some nice performance increases in cases of slow I/O and for refactoring not-in-memory source

1579403559
karrick
For the record I did read that Choosing an Allocator doc before I asked the question. :)

1579403570
pixelherodev
:)

1579403636
pixelherodev
Anyone here who has used the std.zig API? The Doc comments are a bit... lacking, for some functions, and reading the entire source seems a bit excessive

1579403642
pixelherodev
Looking at the .render function RN

1579403789
andrewrk
pixelherodev, zig fmt is implemented using that

1579403798
andrewrk
it might clear things up a bit to look at std.zig.ast

1579403812
andrewrk
that has the AST node data structure that is central to std.zig.parse and std.zig.render

1579403867
pixelherodev
Yeah, I was mostly misreading how render worked - the comment said "checks for changes," I assumed by parsing the stream and comparing the trees, but a glance and thinking about the name indicates that it's by rendering the tree into a stream and comparing

1579404199
pixelherodev
Hmm, if I plan on providing this to Zig officially I probably shouldn't include some very annoyed anti-Windows comments in panic messages, even

1579404219
metaleap
pixelherodev: if your refactorings core logics go into a lib instead of a proggie, i could quite smoothly integrate them into my upcoming zig-lsp endeavour (with big fat credits of course=) --- otoh a separate prog has also benefits as people can update the external tool for future bug-fixes faster than I might react for a lib upgrade and republish..

1579404234
pixelherodev
I'm doing both

1579404254
pixelherodev
lib with a tiny arg processing + file reading main that passes the needed info to refactor.refactor

1579404263
metaleap
if lib, might be good if they take in already-parsed ASTs and dont do the same redundant parsing work that the "lib consumer" might also do on its own for other purposes

1579404277
pixelherodev
... ah right, that's a good point

1579404284
pixelherodev
Thanks!

1579404604
metaleap
symbol-renames can be a pervasive topic. for non-`pub`s aka file-only thats the easier case to attack initially. for `pub`s, cross-file renames involves figuring out importers, possibly in pre-scoped sets-of-proj-dirs potentially determined by the caller (or on your own), and then the cherry-on-top would be detecting nameclashes in both pub and local, with the transaction being rejected. but thats maybe going too wild. then one might actually kick off the

1579404604
metaleap
rename of a symbol not at the point of definition but any arbitrary point of reference .. have fun =)

1579404629
pixelherodev
Yeah, starting simple for now

1579404641
pixelherodev
But basically everything you said is in scope

1579404641
metaleap
way to go for sure

1579404652
pixelherodev
The last point is one of the simplest actually

1579404657
pixelherodev
At least, in terms of interface

1579404661
pixelherodev
`findPointOfDefinition`

1579404672
pixelherodev
I think the key is to require the root file

1579404687
metaleap
oooh if thats also exposed, thatd be neat too

1579404692
pixelherodev
From there, a full project tree can be built

1579404719
pixelherodev
Everything except refactor's going to start out private and then be exposed on demand, whether that demand is from me or someone else

1579404738
pixelherodev
And unless I have an overwhelming reason

1579404775
pixelherodev
(even if it ceases to be used internally, it can be deprecated and removed later on after the dependent project replaces it)

1579404913
pixelherodev
Out of curiosity, anyone have a use case for errdefer they can link? I don't think I've found a single use for it yet

1579405065
metaleap
i have 1, a sec

1579405078
metaleap
btw looking forward to your project. kicks me into high gear to get started on the LSP part at my end, too. aiming for everything from symbols listings, autocomplete, hover intel, list-references, jump-to-def, diagnostics-from-build-on-save, and so on

1579405102
pixelherodev
Hmm, well, I'd consider more than refactoring, but I'm not willing to go out of scope on this one

1579405117
pixelherodev
It's a simple enough project that I should be able to get done

1579405136
pixelherodev
Especially now that I thought of the root source file idea

1579405159
pixelherodev
A lot of work that's a pain for other languages is freaking

1579405166
pixelherodev
e.g. for stdlib, could use std.zig as the starting point

1579405206
metaleap
i will for sure

1579405213
metaleap
what would be EXTRA cool it just occurs to me: if the lib can gather all the "list of edits (file and position ranges and replacements)" as a return value , with another handler able to "interpret" (perform) such structure. because in LSP you can send "edits to do" to the editor back: this way, it can do them atomically (all or none) and the user has them in their undo

1579405255
pixelherodev
... that's within scope enough that I'm willing to accept it, though only because I've only done the basic AST testing so far and that doesn't require a massive rewrite or anything :)

1579405258
metaleap
so you compute a list-of-todos and separate the doing from the what-to-do

1579405280
pixelherodev
Can easily just make a plan_refactor function that returns a changelist

1579405298
pixelherodev
I think I'm going to end up having to build this from the top down and not the bottom up as I have been

1579405304
pixelherodev
e.g. need to

1579405315
keegans
toooooo powerful:

1579405358
pixelherodev
(thumbs up Unicode)

1579405378
keegans
of course this is really awful because you iterate each search but like,

1579405378
metaleap
pixelherodev: here's my errdefer since you asked for an example usecase

1579405398
pixelherodev
Ahh

1579405399
pixelherodev
Thanks!

1579405413
pixelherodev
The best worst part is now I just realized a lot of my code would be better if I'd used it :)

1579405428
pixelherodev
Zig is really nice, but it definitely requires a shift in thinking from other languages

1579405448
metaleap
whats happening is that usually the arraylist gets returned-and-freed via toOwnedSlice but in the error case it must still be cleaned

1579405455
pixelherodev
Right, I got that

1579405508
metaleap
hehe ok. people here seem to be real fast and scanning and grok'ing other folks' code. hope i can absorb this over time :P

1579405524
metaleap
s/and/at

1579405536
fengb
Only when it comes to identifying existing foot guns :P

1579405551
pixelherodev
Largely due to experience; I've spent a lot of time on OSS projects by now (even if it's split up among enough projects that it's very little per project, unfortunately)

1579405575
pixelherodev
I've been working on that last point; I've cut back on a lot of projects I've wanted to work on so I have more time-per-project

1579405589
pixelherodev
Hence me having time to work on Zig tonight instead of random idea #39120214

1579405627
pixelherodev
Also, while reading code is a very

1579405677
pixelherodev
s/reading/reading good && s/writing*/writing* good/

1579405714
fengb
Reading bad code is even more important 🙃

1579405742
metaleap
truth, nothing raised my standards for myself more than reading other peoples code

1579405757
metaleap
even tho i rarely

1579405787
metaleap
well except when idle and in "gardening and tending" mood..

1579405835
andrewrk
I'd like to think that zig is relatively easy to read compared to other languages :)

1579405919
fengb
We’re lucky to attract people who care about craft atm

1579405942
fengb
That might change once the language gets more popular >_>

1579405978
metaleap
like attracts like as long as unlike-repels-unlike and isnt bashful about it :D

1579405991
metaleap
or falsely ashamed

1579406117
fengb
It’s more that Zig is so niche and new that the only people that actually try it are people who care enough to try

1579406205
metaleap
andrewrk: no real complaints about readability overall from me. many idioms are exceptionally smooth indeed. such as capture vars, if/switch/block exprs and other such innovations. feels less noisy/verbose to me than c, c++, c#, java for sure. or the manner in which some JS codebases are concocted. some more sigils than go but to be expected as one can/must also express more details in zig (the whole ptr/slice/arr complex is more exposed in zig, as part of

1579406205
metaleap
its objectives naturally)

1579406319
pixelherodev
Anyways, metaleap, thanks for the help nailing down how this should work

1579406339
pixelherodev
(hopefully) final signature: `pub fn refactor(allocator: *std.mem.Allocator, root_path: []const u8)`

1579406352
fengb
I’m ratio happy at the keyword to symbol ratio

1579406364
fengb
That first ratio should be really lol

1579406375
metaleap
might there be a way to detect in your lib api that takes allocators whether its the allocator of an arena? other than a comptime bool. in order to `if` all the `free`s/`destroy`s/`deinit`s. or do they already turn into no-ops? but still call "overhead" is there

1579406378
pixelherodev
I considered having a separate function to parse a full project into trees, but then I figured that'd be better as an extension to std.zig

1579406394
pixelherodev
Probably going to build an arena internally

1579406412
pixelherodev
But yeah, I think it's detectable

1579406425
pixelherodev
Using @TypeOf comparison, no?

1579406433
andrewrk
pixelherodev, this branch push is delayed again because I decided to fundamentally change the data layout even more; so that cpu features are bit sets. this way std.Target can avoid having to own memory and manage resources

1579406443
pixelherodev
It's totally fine, just let me know when it's done

1579406454
pixelherodev
"Enjoying" working on this anyways :)

1579406491
pixelherodev
e.g. `if (@TypeOf(allocator) == *std.mem.ArenaAllocator)` should work, no?

1579406496
metaleap
pixelherodev: no @TypeOf wont help because a lib func takes any *Allocator but the caller might provide their &myarena.allocator --- now all the cleanups would be pointless extra work, hence the question

1579406498
andrewrk
here's hoping that no cpu has more than 64 features :)

1579406506
pixelherodev
metaleap, Ah right

1579406509
daurnimator
Ha

1579406512
daurnimator
ha

1579406518
andrewrk
(will find out at comptime if the assumption does not hold)

1579406523
metaleap
64 ought to be enough for everybody

1579406523
fengb
pixelherodev:

1579406571
andrewrk
I'm pleased with how namespacing and importing turned out in zig

1579406577
pixelherodev
Seconded

1579406581
pixelherodev
fengb, argh

1579406593
pixelherodev
Guess I'm adding another `TODO: see upstream #NNNN`

1579406620
pixelherodev
Actually

1579406622
andrewrk
pixelherodev, you don't need that to do what you said; it'll just lower waste once it's done

1579406630
pixelherodev
andrewrk, what's the status on that?

1579406638
pixelherodev
It says blocking on #2377

1579406640
pixelherodev
Which is solved

1579406650
andrewrk
yeah apparently it's done in a branch, just needs to be updated to latest zig and tested

1579406658
pixelherodev
Alrighty, I'll do that rn

1579406709
pixelherodev
Oh... oh wow, yeah it needs to be updated

1579406717
pixelherodev
I did a git checkout and my wd became invalid :P

1579406736
pixelherodev
panicked for a sec; last time that happened, it was because my HDD failed :(

1579406737
fengb
Was that before the lib directory move?

1579406742
pixelherodev
yeah

1579406807
pixelherodev
I should really see about hooking up the RAID controller in my not-quite-functional server (MB isn't properly connected to case stuff - e.g. power button - among other issues) into my PC so I don't have that panic again :P

1579406867
andrewrk
it wouldn't be too much work to start over probably

1579406871
pixelherodev
This seems to be just a single commit anyways

1579406871
pixelherodev
Yeah

1579406879
pixelherodev
~60 insertions / 80 deletions

1579406881
pixelherodev
So I'mma just do that

1579406889
fengb
Can it just be rebased / cherry picked?

1579406902
andrewrk
I think the way I did the std lib rename is friendly to rebasing

1579406910
fengb
I’ll stop butting in since I have no context

1579407013
pixelherodev
`warning: inexact rename detection was skipped due to too many files.`

1579407208
pixelherodev
Okay, worked for mem.zig, but not heap.zig - still an improvement

1579407439
pixelherodev
Alright, updated; just needs testing now

1579407696
pixelherodev
fengb, thanks for butting in, that helped

1579408018
pixelherodev
Gah, what's the term beginning with a p for when a variable has the full package name before it (e.g. a.b.c instead of c?)

1579408033
pixelherodev
Trying to use that as a function input name for a function to make it clearer what form it should be in

1579408058
pixelherodev
Qualified works I guess, but there was a clearer term I've seen and I'm blanking on it

1579408423
andrewrk
arm has a bunch of interesting cpu instructions that I've never seen used

1579408438
andrewrk
they have like crc and sha3 cpu instructions

1579408444
metaleap
pixelherodev: i only know "fully-qualified" and "package-qualified", which are both merely more qualified than "qualified" (5AM thoughts..)

1579408459
andrewrk
but I doubt if I code up a crc function on godbolt, that llvm will figure out to use the instruction

1579408469
pixelherodev
Which is probably why it's not used

1579408489
pixelherodev
Unlike a RNG, those are probably safe to use, too

1579408516
pixelherodev
I mean, from my admittedly limited understanding

1579408701
andrewrk
we're going to have to emit errors for some of these cpu features in the non-llvm backend, until they're supported

1579408723
andrewrk
for example "call-saved-x9" "Make X9 callee saved"

1579408894
andrewrk
ability to add comptime metadata tags to enum fields would come in really handy right now

1579408966
andrewrk
arm has a dot product instruction??

1579409034
pixelherodev
And, unlike RISC-V, this instruction is present in every single model?

1579409205
andrewrk
it's in: cortex-a55, cortex-a75, cortex-a76, cortex-a76ae, exynos-m4, exynos-m5, saphira, tsv110

1579409309
pixelherodev
Ah, so not

1579409329
pixelherodev
Thought you meant a basic instruction

1579409335
pixelherodev
That would be even odder

1579412045
rageoholic
Alright I keep coming in here for dumb questions but I was wondering

1579412061
rageoholic
Is it possible to have more than one output directory for executables per build?

1579412088
rageoholic
that way you can build a monorepo style thing

1579412174
rageoholic
But have dirs you zip up for distribution

1579412185
rageoholic
Or should I just use submodules

1579412199
andrewrk
are you aware of the "install" step of `zig build` ?

1579412224
andrewrk
this will create a distribution dir

1579412244
rageoholic
Yeah but I want more than one distribution in a project

1579412269
pixelherodev
That - can I ask *why*?

1579412333
rageoholic
I wanna build a raytracer and a game out of the same repository

1579412344
rageoholic
They share a bunch of math code and shit

1579412348
rageoholic
It's a monorepo

1579412351
rageoholic
They're pretty normal

1579412425
rageoholic
You know what, I'll just do a submodule thing

1579412445
rageoholic
It feels fragile but it'll work

1579412473
pixelherodev
... if they share a bunch of code, maybe make that a library linked into both?

1579412485
rageoholic
Essentially you are

1579412499
pixelherodev
Okay, but why do you need to install to multiple places?

1579412508
rageoholic
Never mind

1579412523
pixelherodev
Well okay then

1579412547
rageoholic
Basically for a game I want to have a resource compiler and a game executable

1579412564
rageoholic
i don't want to distribute the resource compiler with the game

1579412576
pixelherodev
So don't install the RC?

1579412589
pixelherodev
That is, don't add it to the `install` step?

1579412628
rageoholic
Oh you can do that?

1579412630
rageoholic
Huh

1579412635
rageoholic
OK

1579412654
rageoholic
So it stays in zig-cache then?

1579412693
rageoholic
And you can run it from build.zig?

1579412708
pixelherodev
I haven't actually used build.zig

1579412727
pixelherodev
I usually use Makefiles, because I'm honestly a bit lazy

1579412752
pixelherodev
And I already know anything I need to write basically any makefile, whereas switching to build.zig will require looking up some APIs here and there

1579412762
pixelherodev
Even if it admittedly will probably pay for itself pretty quickly

1579412764
rageoholic
A lot

1579412771
rageoholic
A lot of looking things up

1579412775
rageoholic
The docs are not there

1579412780
pixelherodev
You on Linux?

1579412785
rageoholic
Windows and Linux

1579412791
rageoholic
I dev on both platforms

1579412802
pixelherodev
Try `grep 'pub fn' std/build/ -r | less`

1579412805
andrewrk
rageoholic, it will make more sense how to do this the ziggy way once we have a package manager

1579412805
pixelherodev
Or something along those lines

1579412815
rageoholic
Fair enough

1579412826
rageoholic
Is there a timeline for package manager?

1579412837
andrewrk
it will look like having separate build.zig files for the sub-projects

1579412841
pixelherodev
andrewrk, to run tests for the null update, just open a PR and let CI run?

1579412855
andrewrk
pixelherodev, see CONTRIBUTING.md, it has some suggestions on testing

1579412884
rageoholic
I'll just copy paste math code between and factor out into a package for the package manager later

1579412898
rageoholic
I'm sure someone will want a dumbass's math lib

1579412944
andrewrk
rageoholic, like this? :D

1579412955
pixelherodev
Righty, was kinda hoping CI would handle e.g. QEMU, but for now I guess I'll just write a quick shell script to grep the package list, remove the version, and install all Alpine packages with qemu-system in the name

1579412971
andrewrk
pixelherodev, you are welcome to rely on the CI. it does do qemu

1579412978
rageoholic
Haha

1579412979
rageoholic
Nice

1579412989
pixelherodev
andrewrk, perfect, thanks! That definitely makes life easier!

1579413026
andrewrk
yeah it's just slower turnaround time

1579413045
pixelherodev
PR against master, not the upstream null-refactor?

1579413061
pixelherodev
Yeah that would be weird

1579413069
andrewrk
master plz

1579413112
pixelherodev
Alrighty, 4235 CI running

1579413137
andrewrk
nice!

1579413228
pixelherodev
Once 2727 is fixed, I'll improve the CLI for the refactoring tool (and LLVM parser now that I think about it), but for now it's just a stupid "check which needed strings are null, fill the first, if any are still null panic, if more than expected are received panic"

1579413267
andrewrk
I see you are a fellow yak shaver

1579413286
pixelherodev
Heh, yeah

1579413304
pixelherodev
Still, this at least proves the other solution wasn't too nested

1579413306
pixelherodev


1579413319
pixelherodev
It's just four nested if-unwrap-elses

1579413333
pixelherodev
Inside an iterator loop

1579413368
pixelherodev
And for the sake of not annoying anyone

1579413383
pixelherodev
I considered unreachable, but this seemed more satisfying

1579413385
pixelherodev
I mean, to

1579413393
pixelherodev
Not to Microsoft, and probably not to anyone who sees this

1579413486
andrewrk
should we allow null terminated strings to type coerce to slices?

1579413498
andrewrk
it's quite possible, and safe

1579413504
pixelherodev
From what type? `[*:0]u8`?

1579413526
andrewrk
[*:X]T to []T

1579413540
pixelherodev
Without explicit slicing?

1579413545
pixelherodev
Or with `[0..]`?

1579413549
andrewrk
without explicit mem.toSlice()

1579413574
andrewrk
it would basically amount to a hidden strlen

1579413588
pixelherodev
So just `const a: [*:X]T = ... ; const b: []T = a`?

1579413596
andrewrk
yes

1579413597
pixelherodev
I mean, that violates no hidden control flow, doesn't it?

1579413604
pixelherodev
If there's a behind-the-scenes strlen

1579413613
andrewrk
debatable. var a = b; where b is an array is a hidden memcpy

1579413624
andrewrk
both strlen and memcpy are O(N)

1579413646
pixelherodev
Well yeah, but I don't think performance factors into whether it's a problem that it's hidden

1579413663
pixelherodev
I don't think it's a problem personally, but others might disagree

1579413675
pixelherodev
Though I do prefer status quo

1579413694
andrewrk
also, `a / b` can possibly emit a libcall into compiler_rt depending on what instructions are available in the CPU, and the algorithm can be quite involved

1579413718
pixelherodev
True, but that qualifies as part of the language - it's not really hidden in the same way because ohhhh wait yeah that's fair

1579413726
pixelherodev
It's still inherently part of the language

1579413744
andrewrk
something to think about. it deserves a proposal at least, I think

1579413753
pixelherodev
I was going to say that `If you give a value of type `[*:X]T` to toSlice and it's not actually X-terminated it's on you but if the language strlens behind your back it's a problem`, but on further reflection I have to agree

1579413790
andrewrk
it would allow c libraries to work even more seamlessly with zig libraries

1579413794
pixelherodev
Right

1579413804
pixelherodev
Yeah, now that I'm thinking about it that'd be nice

1579413829
pixelherodev
Literally wrote a `cstr` method that just called std.mem.toSlice to clarify intent for one of my projects, so, yeah

1579413902
andrewrk
and then here's the weird part: we can even do out of bounds safety checking for null terminated strings

1579413945
pixelherodev
That reminds me, I still need to swap the strings in a C project from a home-grown string type to either `const char *` or rapidstring or something

1579413965
andrewrk
the safety would have some hard coded number it would give up after. like if the array index is less than 100 then make sure no null byte before that

1579414103
pixelherodev
There's something oddly satisfying about grabbing a piece of paper, a clipboard, and the nearest writing implement in order to design a library instead of just, well, writing the code and making it up as you go

1579414114
pixelherodev
The LLVM parser - well, I honestly didn't expect it to even

1579414117
pixelherodev
and then it

1579414122
pixelherodev
So the interface is utter garbage

1579414125
andrewrk
:)

1579414127
pixelherodev
I don't want that happening with the refactorer

1579414144
rageoholic
I dunno, my experience is that preplanning means everything will go to shit

1579414157
rageoholic
Wait, swearing, I should not do that here

1579414190
pixelherodev
Eh, I doubt anyone overly cares; we're *engineers*. If anyone has a reason to curse, it's *us*. :P

1579414220
rageoholic
hahaha fair enough. Also finally, people who admit software devs are engineers and not glorified mathematicians

1579414230
pixelherodev
Well,

1579414256
pixelherodev
But I've read code that - well, to say it was written by glorified mathematicians is an insult to the mathemeticians I know

1579414396
rageoholic
Anyways time to get started on that dependency free raytracer. No libc here! Just good ol (and by that I mean bad) bmp files

1579414404
pixelherodev
... bmps?

1579414415
pixelherodev
... why not, say, framebuffers?

1579414427
rageoholic
Cause then I'd need a way to display the framebuffer

1579414428
pixelherodev
Why does the file format matter?

1579414440
pixelherodev
If you work on the framebuffer internally, you can use any arbitrary library to do the actual work

1579414446
pixelherodev
of saving / loading!

1579414447
rageoholic
Yeah true

1579414449
pixelherodev
Not the raytracing :P

1579414452
pixelherodev
That came out wrong

1579414460
rageoholic
I mean the work is going to be on internal framebuffers

1579414479
rageoholic
It's just that eventually you wanna see it

1579414529
pixelherodev
hmm

1579414532
pixelherodev
Shameless plug here but

1579414544
pixelherodev
I have a simple (pun intended) library that allows for easily displaying framebuffers

1579414550
rageoholic
Oh neat

1579414562
pixelherodev
It's called SIMPLE (SIMPLE Idiot Manufactured Platform for ... I don't even remember what stupid acronym it is)

1579414563
rageoholic
Linksys plz. I am in the market

1579414638
pixelherodev
Well, I say library, but it's more accurate to say libgit + C-based ImGui library + simple windowing output + plugin loader, but I have some simple examples lying around still, and it works perfectly with @cImport

1579414647
pixelherodev
Give me ~two minutes to push an actually working version

1579414658
rageoholic
Oh I'm trying to avoid cImport

1579414662
rageoholic
I want it to be pure zig

1579414662
pixelherodev
It used to be a z80 emulator with distinct components because I kept rewriting pieces :P

1579414664
pixelherodev
Ah

1579414684
rageoholic
Actually maybe I can write my own dumb framebuffer library :p

1579414685
pixelherodev
Hmm, not sure there's any UIs in pure zig yet

1579414698
pixelherodev
Yeah, it shouldn't be too difficult if you just need to display one texture

1579414702
pixelherodev
Maybe just do raw OpenGL?

1579414710
pixelherodev
If it's something that simple, you probably don't need anything more?

1579414728
rageoholic
I was thinking win32 and X

1579414746
rageoholic
And again, factor into a lib and maybe someone decides to port to macOS

1579414751
pixelherodev
Whatever works for you

1579414760
pixelherodev
Hey, maybe you could just port sokol-app

1579414767
pixelherodev
s/app/gfx

1579414779
rageoholic
Someday. RN I'm just learning graphics stuff

1579414784
pixelherodev
It's a single header C library supporting Linux, macOS, and win32

1579414797
pixelherodev
So it should be relatively straightforward to port to Zig

1579414811
pixelherodev
Hence me suggesting it and not, say, SDL/SFML/GDX :P

1579414820
rageoholic
The problem is the obj-c bits. I'm pretty sure on mac y ou need to use obj-c to  output graphics

1579414843
rageoholic
Although maybe I'm wrong, I never used macOS before

1579414884
pixelherodev
Apparently not anymore

1579414894
pixelherodev
There's

1579414915
pixelherodev
Ah, the

1579414920
pixelherodev
Which

1579414936
rageoholic
That's right. Ugh. That is so annnnnooooooyyyyyiiiiinnnnggg

1579414979
rageoholic
She says as a giant nuisance to everyone who can't even come out as trans to a mom who she knows will be accepting

1579414998
pixelherodev
Can still probably port the Windows and Linux backends and give macOS the finger

1579415012
pixelherodev
If you don't need it, it's probably better not to port it yourself anyways

1579415044
pixelherodev
I find that people who create projects with the hope others will use them tend to a worse job than those doing it for themselves

1579415057
rageoholic
Giving MacOS the finger does sound fun. Someone else can figure out zig on MacOS and calling Cocoa APIs. I'm sure you can do some ASM nightmare

1579415077
rageoholic
However Rust does it. How does Rust do it?

1579415085
pixelherodev
I don't even think I want to know

1579415123
pixelherodev
Can I just say how happy I am Zig doesn't support shadowing?

1579415131
pixelherodev
This refactor design is going a lot smoother than I expected :)

1579415134
rageoholic
Oh they use obj-c

1579415137
rageoholic
OK

1579415157
rageoholic
I guess Zig will need an obj-c compiler *someday*. God knows I'll never use it

1579415183
pixelherodev
Eh, can just not bother supporting it

1579415192
pixelherodev
LLVM probably has a frontend anyways

1579415196
pixelherodev
Can just use that

1579415205
pixelherodev
Once it's turned into IR, langauge no longer matters anyways

1579415218
rageoholic
LLVM definitely has a front end, apple loves clang

1579415436
andrewrk
pixelherodev, the same reason you are happy there is no shadowing right now - because you're writing a tool that wants to make assumptions - is the same reason it is also beneficial for humans reading the code

1579415464
pixelherodev
I know, but that doesn't make it any less awesome

1579415478
pixelherodev
Coming up with a syntax for referencing variables is still mildly annoying though

1579415524
pixelherodev
Not nearly as bad though, only one shared syntax for function parameter and fn-local var

1579415568
pixelherodev
A couple tricky bits, but most can be resolved by rejection

1579415591
pixelherodev
e.g. if an attempt is made to refactor `std.ArrayList(u8).items` into something else, it can just be denied

1579415608
pixelherodev
At least until I figure out a better way to deal with it :P

1579415634
rageoholic
It's amazing how many problems can be solved by just throwing your hands up in the air and defining it out of the problem you're trying to actually solve

1579415635
pixelherodev
I mean, finding all calls to ArrayList() to build references might work...

1579415647
pixelherodev
rageoholic, true, but I try to avoid that

1579415657
pixelherodev
Better to be correct later than to be somewhat correct now

1579415727
pixelherodev
I think that requiring a specification of e.g `std.ArrayList:ret` might work

1579415735
pixelherodev
Explicitly modifying the source type

1579415747
rageoholic
I mean yes but knowing what's a constraint and what's extraneous to the actual problem is a really important skill to have as an engineer

1579415754
pixelherodev
Definitely

1579415769
pixelherodev
A good example of that here is that I'm explicitly rejecting attempts to refactor C

1579415815
pixelherodev
e.g. if `const a = @cImport`, and an attempt is made to modify `a.blob`, it's just a giant `@panic("Wow. Just, wow.");`

1579415835
pixelherodev
At least for now; might be worth implementing later

1579415864
pixelherodev
A better example of a rejected refactor would be an attempt to rename `std.ArrayList:ret.items` into `std.items`, since that's an attempt to move a field into a different structure

1579415911
pixelherodev
Whereas refactoring std.ArrayList:ret.init into `std.alinit` might be accepted if no usage of `init` as a member function is found, which makes it a tad trickier

1579415926
pixelherodev
Though, generally, the assumption is that the user knows what they're doing

1579415944
pixelherodev
So if no problem is *found*, it's assumed that if there is one we don't have to care :)

1579416187
pixelherodev


1579416188
pixelherodev
Such design, much wow

1579416236
pixelherodev
Have a good enough high-level overview to actually get to work now :)

1579416358
rageoholic
Alright now to fuck with win32

1579416364
rageoholic
The fun part of any project

1579416525
pixelherodev
Eh, I no longer, uh, "enjoy" that; I wiped the last bit of Windows infecting my computers a few months back

1579416537
rageoholic
That is fair

1579416546
rageoholic
I am actually back after a long time off of windows

1579416551
pixelherodev
Though, admittedly, I forgot to delete the

1579416565
pixelherodev
That's... that's probably the first time I've been annoyed enough to curse in this channel :P

1579416570
pixelherodev
And naturally, it's with myself

1579416734
pixelherodev
CI failed :(

1579416770
pixelherodev
failing_allocator and logging_allocator apparently call shrinkFn directly

1579416880
andrewrk
they should go through the std.mem.Allocator interface instead

1579416914
pixelherodev
Will submit regression fix after I finish typing up my initial step1 refactor design

1579417002
rageoholic
I just submitted a PR to put constants for kibibyte, mibibyte, and gibibyte into the stdlib

1579417013
rageoholic
Because 3 LINES

1579417066
pixelherodev
`KiB/MiB/GiB`?

1579417073
rageoholic
Yup

1579417088
pixelherodev
The problem with that is that e.g. `16 * std.KiB` is awkward

1579417100
pixelherodev
Worse than just `0x4000`

1579417104
rageoholic
Then import the symbols

1579417121
pixelherodev
Right, but that's a bit... overkill

1579417123
rageoholic
I prefer the former to the latter

1579417135
pixelherodev
I think that a namespace like `std.constants` would be useful

1579417144
rageoholic
Yeah that's true

1579417174
pixelherodev
'cause then you can do `usingnamespace std.constants` and get those and anything else useful without having to manually use them, and without them interfering if unwanted

1579417223
rageoholic
Fair but until we have that std.mem is the best place for them to live

1579417262
rageoholic
And I just realized I did it off master.... fuck me

1579417266
rageoholic
Should have forked

1579417314
pixelherodev
s/forked/branched/ ;)

1579417337
pixelherodev
Not that it matters, since it's in a soft fork anyways (a GitHub fork)

1579417345
rageoholic
branched yes. Oh well.

1579417365
rageoholic
Yeah but now I'll have to overwrite history and crap and I'll be annoyed

1579417403
pixelherodev
While I definitely think those constants help clarify intent, it's probably not that helpful unless the stdlib is also patched to use the constants, which should probably be a proposal before any work is done

1579417437
pixelherodev
(basically, just open an issue titled something along the lines of `Proposal: add std.constants and update stdlib to use them` and wait for approval before continuing)

1579417446
pixelherodev
No reason to go to that kind of effort if it won't be merged

1579417472
rageoholic
fair enough. How can I strip my last commit from github.

1579417481
rageoholic
I pushed too quick

1579417525
pixelherodev
Get the local history where you want it

1579417553
pixelherodev
then `git push -f` (-f == `--force`, which should only ever be used if a) the history is *wrong*, and b) nobody depends on the remote)

1579417782
pixelherodev


1579417870
pixelherodev
(design for step one of the refactor: building a complete project tree)

1579417946
pixelherodev
For clarification: refactoring imported packages is not actually supported, and importing packages at all is only done to validate that the import is valid

1579417962
pixelherodev
Which is really only needed to ensure that types used are valid

1579417995
rageoholic
I'll be honest my reading comp is starting to go

1579418002
rageoholic
I need tea to stay up

1579418006
pixelherodev
Same :P

1579418051
pixelherodev
Nice thing about tea is that it has other stimulants and chemicals which counteract the negative effects of caffeine while boosting the staying-alive aspects :)

1579419674
andrewrk
pixelherodev, I pushed the layneson-cpus_and_features branch. it doesn't build, due to needing to update all the rest of lib/std/target/* files to follow the pattern set by lib/std/target/aarch64.zig

1579419729
andrewrk
I plan to spend basically all of tomorrow doing vim macro hackery to update the rest of the 17,000 lines

1579420321
pixelherodev
All the more time to work on the refactorer :)

1579420432
pixelherodev
Also... I may have accidentally swapped the alignment and the size in that regression fix :(

1579420845
pixelherodev
Okay, and I wish I was joking, but I can't commit the fix because...

1579420848
pixelherodev
GPG: unknown system error

1579420850
pixelherodev
gah

1579420939
pixelherodev
...and now it spontaneously started working again... okay then...

1579421029
rageoholic
Welp, night

1579421069
pixelherodev
night

1579421979
pixelherodev
What's the idiomatic way to read a full file regardless of size? readAllAlloc with max_size of @max(u64)?

1579422067
andrewrk
the max_size parameter is there to remind you to set a limit, but yeah you can give std.math.maxInt(usize)

1579422086
pixelherodev
The idea is that if it should attempt to read it all regardless of size

1579422094
pixelherodev
If it can't - well, that's what the OOM killer is for

1579422107
pixelherodev
If the user wants to load in a giant file, that's on them

1579422123
pixelherodev
Might do e.g. check size and if above X ask for confirmation first

1579422259
pixelherodev
e.g. `if size > 50% of $[`grep MemAvailable /proc/meminfo | sed -e 's/MemAvailable:   //' -e 's/ kB//'`*1024]` then warn

1579422272
pixelherodev
And yes that's a combo of pseudocode and POSIX sh. That's not the point :P

1579422280
pixelherodev
and also Linux dependency

1579423199
pixelherodev
ohh

1579423211
pixelherodev
andrewrk, the reason they weren't using the interface is that new_align in shrinkFn isn't comptime

1579423219
pixelherodev
Whereas the interface requires it to be comptime for reflection

1579423227
pixelherodev


1579427575
metaleap
whats the algo for taking a "broken LLVM module found" error msg and deriving the offending .zig src file line / location. for example:

1579427594
metaleap
```

1579427595
metaleap
broken LLVM module found: Call parameter type does not match function signature!

1579427601
metaleap
%365 = getelementptr inbounds %.atem.eval.Frame, %.atem.eval.Frame* %19, i32 0, i32 0, !dbg !18690

1579427609
metaleap
%"[].atem.Expr"*  call fastcc void @"std.array_list.AlignedArrayList(.atem.Expr,null).toOwnedSlice"(%"std.array_list.AlignedArrayList(.atem.Expr,null)"* sret %365, %"std.array_list.AlignedArrayList(.atem.Expr,null)"* %callargs), !dbg !18691

1579427614
metaleap
```

1579427646
metaleap
ah found it :D

1579427676
metaleap
yeah the last line isnt hard to parse once its own of the tiny editor panel

1579431682
betawaffle
when i use addAssemblyFile in build.zig, what assembler is used? (i want to read the documentation)

1579431721
mq32
betawaffle: probably the clang/llvm assembler

1579432193
betawaffle
ok, next question... is it possible to build some zig code as 32-bit, and some as 64-bit and link them together into a single elf binary? (think a kernel that starts in 32-bit mode and switches to 64-bit)

1579432313
betawaffle
also... is it possible to compile and link llvm-ir assembly files into a zig program?

1579439371
mq32
betawaffle, sorry, i can't help you there

1579439573
metaleap
i grok divFloor and divTrunc easily but what what does divExact offer in contrast? langref.html says nothing, can i assume it's as described here?

1579439636
metaleap
in which case "correct" (actually divisible) nats produce correct results (10 / 2 = 5) but others "bogus" such as 10/3 = 2863311534 ?

1579439670
metaleap
or does zigs divExact have a different meaning

1579439725
mq32
metaleap, yeah, divExact only works when the divisor is a integer divisor

1579439743
mq32
it also asserts this in safe mode

1579439826
metaleap
but both args to @divExact are always ints i thought.

1579439870
mq32
yes

1579439886
mq32
but 5/2 is not a integer division but has a remainder

1579439981
metaleap
gotcha, "divisor" through me off because both operands need to be "ints" but yeah got it, thx

1579440004
metaleap
so basically like described in the gmp-divexact.php above

1579440077
mq32
yeah, seems so

1579441042
metaleap
funny find while searching for zig-related stuff: "zen-lang.org" with `comptime` syntax too

1579441096
metaleap
so i'd say.. another "achievement unlocked": the first eastasian clones appear

1579443447
Snektron
zen was a fork of Zig by a pretty active contributor

1579443503
metaleap
oh i see that explains it =)

1579443662
karrick
Wait why would someone fork it?

1579443715
GrooveStomp
What's the format string to print out a 4 character hexadecimal value?  I know {x} or {X} works for hex, but not satisfying the width constraint.

1579443810
mikdusan
{x:4}

1579443830
mq32
GrooveStomp: {X:0>4} will right-align a 4-digit-hex value and fill with 0

1579443853
GrooveStomp
Thank you mq32!

1579443898
karrick
Those are both good to know.

1579444514
GrooveStomp
If I want to assign the string "XX" to a variable, I can use the type '*const [2:0]u8', but what type would I use if the length of the string is not constant?

1579444541
GrooveStomp
ie., now I want to assign "XXX" to the same variable.

1579444618
mq32
var str : []const u8 = "hello";

1579444622
mq32
str = "world!";

1579444708
GrooveStomp
Oh geeze. Thanks again!  You can tell I was just fixing compiler error and naively fixed the exact error. :-)

1579444727
GrooveStomp
I've been padding the string with empty spaces until now...

1579444831
mq32
:D

1579444836
mq32
slices are quite handy :)

1579445101
GrooveStomp
I tried to do something with a slice... but it was an awkward contortion. I don't remember what it was, but it didn't work quite like your suggestion! :-)

1579445174
karrick
When learning Go for some reason slice syntax befuddled me quite a bit. Now I’m a fan, but still need to learn Zig syntax.

1579445202
mq32
GrooveStomp, i remember that you tried storing string literals in mutable slices (which doesn't work)

1579445227
GrooveStomp
Yup, definitely tried that.

1579445984
keegans
is it possible to use comptime as a block expression? so I can return a value from it? it doesn't seem like it

1579445993
keegans
i guess i can use a comptime var and set it from inside the comptime block

1579446016
mq32
keegans:

1579446043
mq32
const foo = comptime blk: { var x = 10; break :blk x; };

1579446044
mq32
should wrk

1579446056
keegans
oh i got the blk and comptime in the wrong order pfft

1579446057
keegans
thank you

1579446121
mq32


1579446182
keegans
somewhat unexpectedly the break :blk <val> needs to be a variable and not an expression

1579446199
keegans
otherwise I get a error: expected token ';', found ':'

1579446226
mikdusan
wut

1579446279
keegans
oh i just needed parenthesis

1579446283
keegans
oops

1579447202
treeshateorcs
hey guys, is there anything like rust's include_str!("file") in zig?

1579447214
keegans
@embedFile

1579447222
treeshateorcs
nice! thank you

1579447301
keegans
why is '\0' not a valid character? I want to (at compiletime) append a null terminator to a string so I may use it as a sentinel-terminated slice

1579447488
mq32
keegans: appending a 0-terminator is foo ++ "\n", not foo ++ '\n'

1579447512
mq32
oh, i see

1579447517
mq32
why not just append 0?

1579447553
keegans
i did: `break :b (date_format ++ [_]u8{0})[0..date_format.len:0];`

1579447579
keegans
it works but just doesn't seem like the nicest way

1579447588
fengb
All literals are null terminated

1579447604
keegans
it's not a literal

1579447819
mq32
keegans:

1579447889
keegans
yeah still doesn't feel great

1579447893
keegans
but thank you

1579447934
mq32
but note that the string literal is already zero-terminated

1579448024
keegans
yeah, unfortunately these are not string literals though

1579448033
keegans
I parse an ini configuration file at compile time to load the configuration

1579448044
keegans
but for certain usages they need to be terminated slices

1579448477
MaiDouH
Hi everyone. I just got saved from a big programmer mistake thank to `shr`enforcing the rhs to be comptime known Log2T. And I think that's beautiful

1579449101
keegans
stripping my zig executable causes it to SIGABRT ... ???

1579451489
sobeston
just a heads up:

1579452851
metaleap
sobeston: better comment right in there so folks get notified, this place here is eerily quiet on sundays it seems =)

1579453012
metaleap
question to zig compiler initiates / in(ti)mates: when `switch (true)` with the cases being rather involved runtime bool conditions, the compiler wouldn't ever re-order them right? (motivation? when multiple-`if-elseif` blocks chained together with fat logic inside them grow too large, going for `switch` with its `=>` markers clearly delineating the major cases is a real readability/scannability boon)

1579453278
fengb
Zig doesn’t but I’m not sure what LLVM does

1579453456
metaleap
fengb: so that kind of `switch(bool) { someIntricateRuntimeCond => ..., someOtherIntricateRuntimeCondOnlyCheckAfterwards => ... }` has a direct LLVM-IR equivalent? would have thought all that exists in there would be JMPs .. never studied their IR in as much detail as i've been meaning to

1579453480
metaleap
s/LLVM-IR/LLVM-IL

1579453695
fengb
Although... I’d expect switched to be pre evaluated because I’m not sure how else a jump table would work

1579453778
sobeston
thanks, have commented @metaleap

1579454032
fengb
I think I’m misunderstanding. I thought every switch branch must be comptime known

1579454096
metaleap
ooh could be, hope not but gonna find out in a sec :D (had sth else to fiddle while I asked away)

1579454171
metaleap
yeah, so it appears

1579454248
metaleap
too bad because support for this could be mere sugar to transform into `if`s. but switches with their => are nicer readable for big-blocks on any of a substantial (>=3) number of conditions

1579454312
metaleap
well not so critical either, tho :D fluff stuff

1579455223
rageoholic
Mooooorrrrrnnnnniiiiinnngg

1579455278
mikdusan
metaleap: if I grok zig IR for switch, first ranges are hoisted to if/branches. then regular items (non-ranges) make up the switch table which has a branch for each item. this is then codegen to LLVM-IR similar. range if/branches first. items inside a switch with branches for each. there is no re-ordering of items that I noticed.

1579455413
metaleap
mikdusan: what ya mean by "ranges" wrt `switch`?

1579455493
pixelherodev
I don't think using switch as if/else like that is a good idea...

1579455512
pixelherodev
Maybe set an enum based on a bool and switch on that?

1579455591
metaleap
pixelherodev: yeah i have just proposed what you suggest, for that to be ergonomic/productive/hi-leverage some of the existing inference powers should/could be marginally magnified I currently believe, as outlined here:

1579455752
pixelherodev
Eh, I'd honestly say if/else chains properly formatted seem easier to read

1579455791
fengb
Sounds like “cond” from Lisps

1579455836
metaleap
lisp conds, how so ?! i just want anonymous enums , like the anonymous structs we can pass to std.fmt / debug.warn :D

1579455856
mikdusan
metaleap: `5 => {}` is item. and `5,9,10 => {}` is sugar for 3 items, and here is a range `100...200 => {}` and some sugar is allowed to `100...200,95,90,500..900 => {}` so 2 ranges, 2 itmes

1579455905
metaleap
mikdusan: aaah thx i should have figured

1579455939
metaleap
the only lisp cond i know is what others call the ternary and zig has already as if-exprs

1579456080
metaleap
well if theres already selective-desugaring-of-*some*-switches-into-ifs .. there's no real "need" for comptime-known-cases or what am I missing =)

1579456152
fengb
Because Lisp cond is just a macro for nested if statements

1579456160
fengb
Or is it the other way around?

1579456397
metaleap
heh

1579457228
mikdusan
metaleap: here's an example showing switch src/ir/llvm-ir:

1579457330
metaleap
oh neat to see zig IR (or lets name it zigIL =)

1579457374
fengb
zIRg

1579457575
metaleap
the bunch of locals in bulk on top are wild... and indeed they all DO contribute to %12 in the end!

1579457603
metaleap
chic

1579457695
fengb
mikdusan: you know that Gists were created for sharing code like this 🙃

1579457733
adamkowalski
I'm running zig master branch and I'm getting an error when building

1579457734
adamkowalski
reference to unknown field is_exhaustive

1579457754
adamkowalski
even with a fresh project that only has a single line which just warns hello world

1579458012
traviss
anyone know approximately which recent commit broke inline while / for loops?

1579458273
metaleap
adamkowalski: if happens with any old minimal helloworld, sounds like a regression to report .. then revert to prior-day master ..

1579458558
Snetry
Whats the prefered way of gathering the source code for packaging? the git tags or tarball on the homepage

1579458680
cota
Is there a way to assign ~0 to a variable at compile time? i.e. 'const v = ~0;' -> Semantic Analysis [685/964] ./sim.zig:177:15: error: unable to perform binary not operation on type 'comptime_int'

1579458716
cota
(v = 1 + 2 works fine, BTW)

1579458761
keegans
there's maxInt

1579458765
keegans


1579458801
cota
keegans: that works, thx

1579460684
andrewrk
gonna do a coding stream here in 10 min

1579460707
keegans
perhaps someone will find this useful:

1579460711
betawaffle
woo!

1579460907
betawaffle
andrewrk: what's the subject going to be?

1579460909
andrewrk


1579460968
mq32
keegans, nice, i'd like to see that in zigstd

1579461002
treeshateorcs
how do i solve this error

1579461070
mq32
treeshateorcs, use aa slice instead of an array

1579461077
mq32
fn calculate_words(words: []u8)

1579461099
treeshateorcs
ah, right! thank you mq32

1579461148
treeshateorcs
hm, now this: error: expected type '[]u8', found '[796674]u8'

1579461160
mikdusan
fengb: yeah i keep forgetting if if i

1579462192
metaleap
treeshateorcs: if you change your arg from []u8 to []const u8 your string lit should coerce. you can also at the call site slice your known-length arr via: `arr[0..]`

1579462212
metaleap
as you pass it. might have to do both possibly

1579462315
treeshateorcs
thank you metaleap ! const did it

1579462337
treeshateorcs
but i dont understand why

1579462344
metaleap
what you passed is not mutable

1579462349
metaleap
but []u8 is mutable

1579462367
metaleap
whereas []const u8 is also not mutable (inside)

1579462389
mq32
keegans, btw, improvement for your printNamed: you can omit the type and use var instead, this will allow the use of anonymous struct literals as well

1579462411
treeshateorcs
so i need to declare everything that is not mutable const?

1579462427
treeshateorcs
i must*

1579462434
metaleap
it depends what the func needs to do and what you want to pass it.

1579462454
Snetry
Hey, I'm trying to package up Zig for Fedora but I'm having some troubles with an uninit error I can not track down

1579462456
Snetry


1579462471
metaleap
if the func strictly requires a mutable slice to write into it --- and you only have an immutable arg, then a copy must be made & passed

1579462478
mq32
treeshateorcs, that is a good pattern, ye

1579462479
mq32
*yes

1579462488
mq32
everything you don't want to change, make it const

1579462502
treeshateorcs
thanks

1579462534
fengb
The optimizer can do more stuff with const. In Zig it means we don’t have to store it on the stack

1579462569
metaleap
with the caveat that const only applies to ptr args (incl. slice types) and is invalid syntax on other types for args: the value being passed is "immutable anyway"

1579462617
metaleap
whereas for locals this whole thing is indicated by using `var` or `const`

1579462617
fengb
Oh you mean function args? Ignore what I just said :P

1579462631
fengb
I should stop responding without context

1579462659
metaleap
yeah its about the args type qualifier in treeshateorcs case

1579462707
fengb
For function args, const protects the caller from making bad assumptions, protects the function from accidentally mutating, and allows more general usages. So you should always do it if it’s possible

1579462775
fengb
Gets more apparent with strings since most of those are const and functions that only take `[]u8` are really hard to use

1579462914
metaleap
"so you should always do it" is generally true but it depends also on what you pass it to. to alloc you'll need a *Allocator so cannot take a *const Allocator etc. but its easy to get used to i found. depends where one is coming from, perhaps

1579462945
fengb
Hmm that’s a good point

1579462994
metaleap
compiler guides one nicely, mostly. i imagine in C it would just gobble up whatever and leave the headscratching for run time not comp-time

1579463020
metaleap
at least from my most recent impression of C, ca. late 90s :D

1579463036
treeshateorcs
>parameters are immutable

1579463041
metaleap
yes

1579463043
treeshateorcs
no way to change function arguments?

1579463062
metaleap
i'm not sure if you can change them as locals but wouldnt be visible to the caller

1579463086
metaleap
except for ptrs (incl slices) not declared const

1579463112
metaleap
these, you can write into (the members / elements) or call their mutating methods

1579463113
treeshateorcs
so if i want to change an array i need to declare it as a slice?

1579463157
metaleap
either pass a ptr to the arr or a slice of it (which is also a ptr to the arr with len info too)

1579463184
metaleap
hence your func can write inside it and the caller will get to keep the changes

1579463184
treeshateorcs
thanks

1579463326
mq32
<treeshateorcs> no way to change function arguments?

1579463344
mq32
nope, as zig allows to compiler to decide if an argument is passed by-value or by-reference

1579463355
mq32
which means, zig can decide that it's faster to pass a structure as a pointer

1579463361
mq32
which is really nice for performance

1579463410
treeshateorcs
according to my feeble-brained tests zig is at least 10 times faster than rust. i wonder why performance is not even a goal

1579463445
metaleap
compared dbg-vs-dbg builds and releasefast-vs-releasefast builds?

1579463475
karrick
I don’t think Rust ever wanted to solve performance related problems. They seem more interested in solving programming safety.

1579463476
treeshateorcs
release vs release

1579463499
treeshateorcs
releasefast vs release

1579463504
karrick
As in make the Rust language impossible to write memory unsafe programs with

1579463518
pixelherodev
Zig is also AFAIK the fastest non-asm language currently alive, language-wise at least

1579463553
pixelherodev
Idiomatic Zig outperforms idiomatic C and idiomatic C++ at runtime, with a metaprogramming interface vastly superior to C++'s

1579463590
treeshateorcs


1579463668
pixelherodev
treeshateorcs,

1579463680
treeshateorcs
i read that article

1579463689
pixelherodev
:)

1579463692
treeshateorcs
*have read

1579463705
pixelherodev
Curious how it's changed since 0.5

1579463750
torque
not sure it's reasonable to make such bold claims on the basis of such a trivial example

1579463764
pixelherodev
True

1579463774
pixelherodev
But in terms of the standard library / syscall count, I don't doubt it

1579463789
pixelherodev
In terms of actual language performance on large scale projects? We'll have to wait and see

1579463791
torque
but I think the coolest part of that blog post that I haven't seen anybody acknowledge is that zig is the only language there that has explicit error handling

1579463812
pixelherodev
For starters though, it's gotten easier to write the Zig example Drew used

1579463833
pixelherodev
Only one try is needed thanks to - IIRC Andrew's work - making it so that getting stdio couldn't fail on win

1579463864
pixelherodev
Size seems to have gone down

1579463908
metaleap
treeshateorcs: you on zig nightly or your distro's  0.5.0 pkg?

1579463921
treeshateorcs
i switched to zig nightly

1579463930
pixelherodev
I'm on git master branch

1579463932
treeshateorcs
before running this test

1579463933
pixelherodev
Updated yesterday

1579463935
pixelherodev
I think

1579463966
pixelherodev
yeah, definitely; it's up to date with the caveat that failingallocator and loggingallocator are broken because of unfinished changes

1579464061
pixelherodev
Huh - release-safe seems to have gotten a bit bigger actually

1579464082
pixelherodev
by 4KiB (from 11.3->15.3KiB)

1579464093
pixelherodev
And there's now a fourth syscall (though still three unique syscalls)

1579464105
pixelherodev
Though to be fair I shouldn't be trying to replicate Drew's results

1579464148
pixelherodev
Differing Linux distro / LLVM version / Zig version / kernel / etc, and he's explicitly said trying to replicate those would be a waste of time

1579464266
fengb
Back to function args, Zig can decide that a simple struct (8 bytes) should pass by register, slightly bigger ones can pass by multiple registers, and large ones by pointer. It’s a “free” optimization compared to C

1579464329
Snektron
Im pretty sure thats a perfectly valid thing to do for a C compiler

1579464361
Snektron
it requires a little more work to make that happen though due to ye olde headers

1579464366
fengb
C spec defines how args are passed. Zig intentionally marks it undefined

1579464366
Snektron
but LTO or inlines should do the trick

1579464402
Snektron
I doubt compilers have to adhere to c calling convention with non-exported funcitons

1579464777
metaleap
Snektron: but then such compilers should hopefully detect arg mutation inside a func where it decides to use a pointer for a syntactically "value-copy pls" signature

1579464864
metaleap
and that would go for propagating to subsequent calls etc. because in my limited understanding in C you write what you want and get it. but might be missing something , my only hands on ptr exposure outside of zig was go

1579465984
pixelherodev
Third try on regression fixing the failingallocator and loggingallocator pushed

1579466007
pixelherodev
This attempt requires that the alignment passed to FailingAllocator.shrink and LoggingAllocator.shrink be comptime known, which IIUC is basically true anyways

1579466104
treeshateorcs
so does zig automatically inline functions when possible?

1579466110
pixelherodev
99% sure

1579466116
treeshateorcs
nice

1579466119
pixelherodev
Because it uses the same backend Clang does

1579466136
pixelherodev
And most optimizations for LLVM-based languages are done at the IR level IIUC

1579466171
treeshateorcs
IR?

1579466205
pixelherodev
Intermediate Representation

1579466210
pixelherodev
Basically, meta-assembly language

1579466217
treeshateorcs
ah

1579466224
treeshateorcs
i need to read up on that

1579466235
pixelherodev
Only if you plan on doing toolchain work

1579466344
epmills
want to target wasm and return struct from zig back to js.  anyone have luck with 'complex types'?  i understand passing/returning ints.

1579466380
pixelherodev
Not a clue sorry

1579466382
pixelherodev
Haven't used WASM

1579466403
epmills
pixelherodev: thx

1579466404
metaleap
treeshateorcs: prepend `inline` to `fn` if for some cases you wanna be sure / enforce it

1579466426
pixelherodev
Yeah, unlike in C, a function marked `inline` in Zig will always be inlined.

1579466439
metaleap
or else compile-time fail, so you know whats up

1579466457
treeshateorcs
yeah, i read in the docs that if it can't be inlined it will be a compile time error

1579466475
treeshateorcs
right

1579466671
pixelherodev
How do you open a directory?

1579466678
pixelherodev
Not a subdir, just a directory from an absolute path

1579466713
pixelherodev
A lot of the functions have been deprecated, and when they reference a function to use instead, it refers to a relative path

1579466732
mq32
cwd().openDirList("/")

1579466758
pixelherodev
... huh. That's... odd.

1579466761
mq32
yep

1579466772
pixelherodev
Either way, found std.fs.openFileAbsolute, which is sufficient

1579466781
pixelherodev
Only the null-terminated version shows up under std.fs listings

1579467339
MaiDouH
Small question to you all! Is it possible to initialize a `struct` field with the result of a `comptime`block?

1579467450
pixelherodev
I think so?

1579467517
treeshateorcs
>fn intRangeAtMost(r: *Random, comptime T: type, at_least: var, at_most: var) var

1579467523
treeshateorcs
this is from std.rand.Random

1579467530
treeshateorcs
what should be the first argument?

1579467555
MaiDouH
I have an array that i use to represent memory for small emulator, i would like to initialize the reserved area with whatever static values have to go in there. Seems like `comptime`is the perfect candidate

1579467593
pixelherodev
treeshateorcs, that's a self argument, isn't it?

1579467623
pixelherodev
That is, it's used as `random.intRangeAtMost(T, at_least, at_most)`?

1579467631
livcd
is there any real world zig cli tool  ?

1579467638
treeshateorcs
doesn't seem like it, pixelherodev because the compiler gives me an error, when i give it only 3 args

1579467652
pixelherodev
livcd, such as?

1579467671
livcd
anything ?

1579467682
pixelherodev
treeshateorcs, not std.rand.Random.intRangeAtMost()

1579467701
pixelherodev
I meant, you have some `r` (maybe std.rand.Random.init()?) and you call `r.intRangeAtMost`

1579467720
treeshateorcs
how do i init this r?

1579467758
pixelherodev
Ah, you need to use a specific type

1579467762
pixelherodev
e.g. SequentialPrng

1579467819
pixelherodev
treeshateorcs, DefaultPrng or DefaultCprng

1579467819
livcd
is there a production ready app in zig that people use?

1579467825
pixelherodev
s/Cp/Csp

1579467852
pixelherodev
Part of the compiler is written in Zig

1579467858
pixelherodev
A C -> Zig translator used for @cImport

1579467900
metaleap
livcd: "production ready" isnt clearly defined, but for most interpretations of that phrase, zig is still experimental fast-evolving early days

1579468030
metaleap
so there's no k8s/docker/redis/rabbitmq/etc equivalent project done in zig and deployed in the wild, yet, AFAIK  =)  to compare, go appeared 2009 and zig iirc ~2016

1579468046
metaleap
if thats what you consider "real world"

1579468135
livcd
ah i get i was just curious

1579468150
livcd
did not think of docker or similar

1579468161
livcd
coule be a conky plugin for what do i care

1579468232
metaleap
well you can certainly stdin/stdout with ease by now so if stuff like this exists here or there i wouldnt be surprised

1579468261
metaleap
just not sure about the state of networking in stdlib at present

1579468367
metaleap
livcd: here's some "real looking" stuff listed:

1579468373
livcd
ahh that

1579468376
livcd
early

1579468508
Snektron
Is this valid?

1579468530
Snektron
`var a: []u8 = undefined; {a = [0]u8;}`

1579468551
metaleap
livcd: this looks pretty realworldish, uses gtk too

1579468599
metaleap
[0]u8 is a type not a value, right?

1579468610
Snektron
yeah, i meant to write [0]u8{}

1579468629
metaleap
then you attempt to give the slice-typed a an array. not on

1579468642
metaleap
& in front, or slice [0..] at the back

1579468670
Snektron
The point is, what lifetime does a zero-sized array literal have if you cast it to a slice

1579468730
metaleap
"cast to a slice" means taking the address. means here the same address that any zero-size value has

1579468954
metaleap
do a `std.debug.warn("{*}", .{ &[0]u8{} });` and compiler errors with "pointer to size 0 type has no address"

1579468979
Snektron
Suppose that means i can pass a stack-address

1579468991
Snektron
or well, what would be a stack address for a nonzero sized array

1579468996
metaleap
=)

1579469047
metaleap
in the above, if you used {s} instead of {*} it would be "conveniently" coerced into the empty string, easily seeable with eg. a ">{s}<" fmt-str

1579469109
metaleap
same i guess if assigned to a []const u8 var. since the len must be 0 the address never really "matters" so maybe you dont get mauled by the compiler but try doing anything useful with it :D

1579469195
treeshateorcs
i can't seem to find anything on the new rules of interpolation in the docs. (this thing - .{}) it was different in 0.5.0

1579469227
Snektron
you might need to look at the source code

1579469234
treeshateorcs
it's called interpolation right?

1579469254
Snektron
I think you might have more hits with "format"

1579469257
SyrupThinker


1579469260
SyrupThinker
Maybe?

1579469262
metaleap
treeshateorcs: for now your autoritive source of intel is lib/zig/std/fmt.zig from line ~47 :D

1579469272
SyrupThinker
Not usre whether I undestand the question correctly

1579469276
metaleap
if you wanna see the placeholders supported i mean

1579469337
metaleap
the .{} is usually filled with values to be placed into the string, its as simple as std.debug.warn("Name: {s}, Age: {d}", .{ name, age })

1579469361
treeshateorcs
that's what i wanted to hear. thanks

1579469496
metaleap
using this fmt stuff outside of std.debug.warn is a bit hairy .. when constructing a longer string into a buffer, I made me a shorthand helper thusly:

1579469575
metaleap
on the plus side its a thoroughly "as much comptime as possible" api as possible which i'm digging when it comes to compiletime sanity-checks on my string-formattings

1579470716
pmwhite
I'm on my Pinebook Pro, and I'm hitting an error that says `reached unreachable code` while switching on an enum. The code works fine on my x86 laptop, so something must be on ARM.

1579471019
fengb
metaleap: format() will be changing “soon”. The current signature has been a blocker for async OutStream

1579471020
pmwhite
Note that I'm not hitting an `unreachable` part of my own code, so I'm wondering if this is a bug in the Zig compiler.

1579471074
fengb
We have std.fmt.bufPrint and std.fmt.allocPrint as simple helpers for what you want to accomplish

1579471445
treeshateorcs
what is the equivalent of argc, and argv in zig?

1579471467
treeshateorcs
command line arguments in other words

1579471775
treeshateorcs
found it. std.process.args()

1579471924
betawaffle
darn, just hit this:

1579471924
betawaffle
what's the workaround?

1579472431
pixelherodev
pmwhite, probably a compiler bug yeah - I'd definitely open an issue; worse case, it's not, and the issue gets closed

1579472950
shakesoda
pmwhite: how's the pinebook pro been treating you? i'm intending to pick one up on next batch

1579473322
mq32
treeshateorcs: .{} is an anonymous struct literal (so a struct value with an implicitly created type). if you write .{ a, b, c }, you will get a struct with with field names @"0", @"1", @"2" which you can asses like any other field

1579473340
mq32
this is conveniently used for foratting, as it removes the need for varargs in Zig

1579473380
treeshateorcs
ah

1579473396
mq32
so you can use this to store some random stuff as well:

1579473400
mq32
var foo = .{ a, b };

1579473405
mq32
foo.@"0" = 10;

1579473524
treeshateorcs
what type are a and b?

1579473550
mq32
they are just placeholders for anything

1579473556
treeshateorcs
ah, okay

1579473659
treeshateorcs
i have a kinda feature request but i don't know what it is called. would be nice if when you would run `zig build run -- arg ` it treated arg as an argument to the executable

1579473693
treeshateorcs
to the executable that was built by that command

1579473737
Snektron
I think that was already added

1579473771
mq32
yeah afaik that is possible

1579473817
treeshateorcs
Snektron: it wasn't. at least it's not working right now on master

1579473844
mq32
you probably have to add some stuff in your build.zig, it won't work out-of-the-box

1579473869
mq32
but afaik you can just parse arguments to "zig build run" and pass them to the executable started

1579474656
svmhdvn
Hi, does anyone know where I can find some documentation on how exactly "dot syntax" works when calling methods on struct instances? Specifically, I'm reading the `lib/std/array_list.zig` source file and I noticed that methods that have a pointer type as the first argument can be called normally on a instance value using dot syntax.

1579474783
svmhdvn
For example, `array_list_val.deinit()` and `array_list_val.append(item)` are both valid. In the former, array_list_val is passed as a Self and in the latter, array_list_val is passed as a *Self. I would like to learn more about these method calling semantics.

1579475212
fengb
Method calls are sugar for passing the first argument in. Similar to Python or Go

1579475232
svmhdvn
Yes I understand that much from the documentation page

1579475297
svmhdvn
but as far as I can see, that makes sense in the first example I gave, but in the second one, the method is expecting a *Self parameter, but the type of the `array_list_val` expression is a Self (i.e. an ArrayList(...)) right?

1579475401
fengb
Ah that’s Zig comptime. ArrayList(...) returns a type so it’s a generic

1579475480
svmhdvn
Yes, but when does it get implicitly cast to a pointer before getting passed to the function as its first argument?

1579475558
pfg_
if the first argument is a pointer

1579475569
svmhdvn
the function signature for deinit is `fn deinit(self: Self)` and the function signature for append is `fn append(self:

1579475607
treeshateorcs


1579475678
metaleap
treeshateorcs: you can out of box do `zig run foo.zig -- arg1 arg2` but the same isnt supported by `zig build`, why is that? `zig build` gets its subcommands such as `run` from your project's build.zig

1579475706
treeshateorcs
ah, okay, understood

1579475709
metaleap
here's how i added what you wanted to my proj the other day: passes in all args after ` -- `

1579475710
metaleap


1579475782
treeshateorcs
i think it would make sense if that was added in the standard build

1579475823
metaleap
yeah. the build.zig is usually coming from some template that `zig init-exe` or `zig init-lib` creates --- so I could do a PR

1579475831
metaleap
or you if you prefer, i dont care

1579475880
metaleap
probably as an option for `.run()` or a helper method for `std.build.RunStep`

1579475958
metaleap
so doesnt even need to touch the default build.zig template being created by zig init-exe/init-lib

1579476002
treeshateorcs
anything to say on the video i posted above?

1579476060
metaleap
a screenshot will get more views i think

1579476070
mq32
treeshateorcs: yeah, it is completly correct what the compiler does

1579476108
mq32
std.process.args() returns an ArgIterator

1579476117
metaleap
your local args is clearly different from the std.args namespace

1579476126
mq32
std.process.args is a function

1579476129
mq32
not a namespace

1579476137
metaleap
i mean std.process.args is different than std.process.args()

1579476137
mq32
see here:

1579476139
mq32


1579476146
metaleap
yeah i looked again, see above

1579476150
mq32


1579476163
treeshateorcs
ah, silly me

1579476183
mq32
std.process.ArgIterator.next is a function that takes an ArgIterator and returns either the next arg or null or an error

1579476260
mq32
need to get some sleep, happy coding, treeshateorcs!

1579476270
treeshateorcs
thank you mq32 !

1579476273
treeshateorcs
good night

1579476428
svmhdvn
pfg_: is there any special treatment of calling semantics when the first argument is a pointer?

1579476464
pfg_
I'm not sure

1579476970
svmhdvn
No problem, thanks anyway! I'm wondering if anyone else would know about this

1579477028
mikdusan
svmhdvn:

1579477080
mikdusan
and then you make it a pointer if self modifyig

1579477181
hryx
mikdusan: hey, sorry for the silence lately, crazy week. I just got home and tried your patch! Looks great although some tests result in a null deref -- I will investigate after I get some food

1579477428
mikdusan
hryx: I mostly did that patch to verify some assumptions. speculating on the real solve, probably going to involve moving CheckSwitchProngs out of the branch and make it unconditional. and the "right way" to make analysis run on ranges/items instructions

1579477445
svmhdvn
mikdusan: I don't think that section of the documentation answers my question. I see that I should write a function with a pointer first argument if I

1579477507
mikdusan
svmhdvn: if it's `self: Foo` the compiler will choose for you. and you won't know. if you want to know, make it either `self: *Foo` or `self: *const Foo`

1579477622
svmhdvn
ah okay that makes sense, thanks!

1579478129
hryx
mikdusan: ah, gotcha

1579478214
daurnimator
andrewrk: Re: cpu features, were you serious about 64 of them? note that x86-64 already has more than that.

