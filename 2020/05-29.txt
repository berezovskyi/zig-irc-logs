1590713338
andrewrk
fraktor, std.meta.trait should be renamed to std.meta.concepts

1590713352
andrewrk
to match the corresponding C++ terminology

1590715273
shakesoda
is there a particular reason to match c++ terminology instead of rust's for it

1590715576
tdeo
well the concept (ha) is much closer to the c++ one

1590715597
tdeo
in that it just checks if a type fulfills some description you give

1590717422
torque
std.meta.ducktype

1590717481
shakesoda
i would be all for std.meta.duck

1590717485
pixelherodev
Agreed

1590717795
tdeo
yeah

1590718503
andrewrk
haha

1590720389
andrewrk
pixelherodev, I just merged some big stage2 improvements

1590720413
andrewrk
* virtual address allocation scheme * dependency tracking / handling deletions and no longer referenced decls

1590720448
andrewrk
pixelherodev, my question to you: what is it in stage2 that interests you, that you would like to work on, so that I can work towards unblocking you?

1590720458
pixelherodev
Well, first I want to finish the current PRs

1590720470
pixelherodev
get error_tests (#5422 IIRC) merged, and then finish implementing function calsl

1590720472
andrewrk
right of course

1590720476
pixelherodev
After that... hmm

1590720487
pixelherodev
I think the most pressing concern to me is esoteric platform support

1590720493
pixelherodev
Like, genuinely

1590720502
pixelherodev
Because if we don't support them *now*, it'll be hell to do later

1590720508
pixelherodev
Since it'd require reworking existing backends

1590720522
pixelherodev
Better to get the infrastructure in place now

1590720531
andrewrk
for the error tests one, I'm actually going to update that to be merged with non-error tests. so for example, you could have some source that succeeds with some output. then you modify the source, and it has such and such error on a specific decl, then you modify the source again and now it has different output. that's an example test case for stage2

1590720552
pixelherodev
Gotcha

1590720557
pixelherodev
Want me to do that, since I was just working on it?

1590720559
andrewrk
stage2 tests are really involved because they test not only one input->output but input,output,modification,output,modification,output, etc

1590720565
andrewrk
sure!

1590720582
pixelherodev
Then I want to work on actual codegen for something more unusual, though I'm not sure what

1590720592
pixelherodev
What's a nice, unusual architecture?

1590720615
pixelherodev
Z80 is one I'm familiar with, but it doesn't

1590720627
pixelherodev
I want to make sure there doesn't have to be something like SDCC for Zig

1590720654
andrewrk
ikskuh tends to know about esoteric architectures

1590720655
pixelherodev
Ooh, maybe something like a SUBLEQ?

1590720674
andrewrk
how about 6502

1590720689
andrewrk
the cpu of the NES

1590720717
pixelherodev
That's definitely a good *target8

1590720719
pixelherodev
*

1590720723
pixelherodev
but it doesn't meet my standards for this, I don't think

1590720737
pixelherodev
I'm looking for something unusual enough that it'll break our normal assumptions

1590720747
andrewrk
hmm I think your goals aren't matching up with my short term goals

1590720759
pixelherodev
That's because this isn't really a short term goal for me

1590720761
andrewrk
I want to focus on common architectures right now, getting self-hosted to a working state

1590720767
pixelherodev
It's a short term goal to ensure long term goals are achievable later on

1590720785
pixelherodev
The thought to me is that it's relatively straightforward to do this

1590720790
pixelherodev
but it won't even be possible later

1590720798
pixelherodev
I don't want to spend

1590720809
pixelherodev
Eh, it's probably not that big of a deal

1590720825
pixelherodev
Maybe I'll focus on x86?

1590720834
pixelherodev
Just to make sure we didn't accidentally introduce any dependencies on 64-bit

1590720850
pixelherodev
Plus, most of the backend is the same

1590720855
pixelherodev
So it'll be useful for amd64 too

1590720859
andrewrk
that's a good idea

1590720921
pixelherodev
I think my short term goal is to refactor it a bit

1590720938
pixelherodev
Anything AMD64-specific should be in backend/x86_64/something.zig and not in codegen.zig

1590720962
pixelherodev
A way to map architectures to backend structs when the arch is only runtime known helps, but that's probably what an inline for is for

1590720994
pixelherodev
One other idea that's been percolating for a bit is to make it easy to connect out-of-tree backends

1590721036
andrewrk
I'm not sure I agree with that refactoring idea

1590721038
pixelherodev
Whether that means exposing parts of stage2 in std.zir, an alternate library (`@import("zig")`, or explicitly defining a backend interface

1590721056
pixelherodev
the thought to me is basically this

1590721066
pixelherodev
Most of the time, if you're working on codegen, it's for a specific architecture

1590721081
pixelherodev
You don't care how x86 implements calls if you're working on it for ARM

1590721108
andrewrk
counterpoint: codegen.cpp is architecture-agnostic and it is 11,198 lines

1590721117
pixelherodev
Yes, but it's also limited to LLVM architectures

1590721124
pixelherodev
One goal of stage2 is to extend beyond that

1590721166
pixelherodev
and, more importantly

1590721170
pixelherodev
We can't rely on LLVM

1590721184
pixelherodev
codegen.cpp is ~11K lines, and it can rely on an external library to do the heavy lifting

1590721205
pixelherodev
We're effectively incorporating both the parts that LLVM does, and the LLVM implementation

1590721314
pixelherodev
So we have more architectures, a lot of implementation, and the biggest part to me is what I was mentioning about unofficial backends

1590721326
pixelherodev
We should make it easy to work on unofficial backends, so that it's easy to get them merged upstream later on

1590721400
pixelherodev
If I'm working on an external backend, I don't want upstream patches to force me to rebase everything

1590721677
andrewrk
I definitely agree with organizing the codebase to optimize for contributions to unofficial backends

1590721705
pixelherodev
I'm not certain what the best way to do it is, I just want to make sure that it's done

1590721710
andrewrk
humor me a little bit though, let's figure out the best way to organize the code after codegen.zig is more than just a proof of concept

1590721729
andrewrk
once it starts to get unruly, it should be a lot clearer how to better refactor it

1590721730
pixelherodev
Agreed

1590721742
andrewrk
the patterns will be more clear

1590721742
pixelherodev
It definitely doesn't matter just yet

1590721858
andrewrk
all aboard the merge train! choo choo!

1590721920
pixelherodev
Nice :)

1590721934
pixelherodev
andrewrk: you asked what

1590721955
andrewrk
that was a helpful response btw! and I agree with your goals

1590721999
pixelherodev
Good to know :)

1590722001
pixelherodev
Oh, relatedly then

1590722007
pixelherodev
Should I move codegen/*.zig into codegen.zig?

1590722009
andrewrk
anything that gets us closer to self-hosted compiler completion would be most helpful. I can try to break that down into smaller steps

1590722013
pixelherodev
(The register definitions)

1590722016
pixelherodev
Nah, that's good enough

1590722022
andrewrk
nah it's fine

1590722037
pixelherodev
Should

1590722057
pixelherodev
Or is it more "no need to change it" than "let's make this our organization!!!"

1590722065
andrewrk
I'm really not too concerned with which bits go in which files at this point

1590722070
pixelherodev
Gotcha

1590722078
pixelherodev
Oh, a thought occurred

1590722082
pixelherodev
Should e.g. FLAGS be defined in Register?

1590722091
andrewrk
I just think that moving things around is pretty easy, so might as well wait until it's obvious how they should be moved around

1590722095
pixelherodev
flags/eflags/rflags?

1590722108
pixelherodev
I can see how they

1590722141
pixelherodev
(for e.g. `(a & b) != 0`)

1590722143
andrewrk
that's another thing that I think will become obvious when we get further along towards self-hosted completion

1590722150
pixelherodev
in other words:

1590722162
pixelherodev
Stop obsessing over design and focus on actually being productive?

1590722164
pixelherodev
Drats

1590722167
pixelherodev
:)

1590722196
pixelherodev
PR incoming shortly; extracting the REXes into a function

1590722211
pixelherodev
So that instead of reproducing the same logic at every point, it's just `self.REX(.{ .b = true});`

1590722215
pixelherodev
(as an example)

1590722216
andrewrk
:)

1590722234
andrewrk
I think obsessing over the design is useful, but we just don't have enough information yet on those particular areas of code

1590722277
andrewrk
btw what do you think about the virtual address allocation scheme?

1590722301
andrewrk
c7ca1fe6f7b8796a42de908faeaa6ec24e8eb118

1590722326
pixelherodev
Going to finish up and then take a look

1590722395
andrewrk
it's ironic that to implement zig, a language with manual memory management, the compiler has several different ad-hoc garbage collector implementations

1590722442
andrewrk
* ELF sections * .text blocks * top-level declarations * symbol table entries / offset table entries

1590722448
pixelherodev
self.REX(.{ .B = true }) uses `if (@hasField(arg, "B") and arg.B)`

1590722467
pixelherodev
Returns a u8, so it can be used in-place in a write operation and doesn't require a separate one

1590722501
andrewrk
huh why do we need reflection?

1590722517
andrewrk
`options: struct { B: bool }`

1590722530
pixelherodev
Because there's four options, and in 99% of cases only one matters

1590722540
pixelherodev
... wait

1590722544
pixelherodev
Struct default values exist

1590722547
pixelherodev
I keep forgetting that

1590722600
andrewrk
you can also make REX and REX_fancy with one of them calling the other, and the other taking parameters

1590722727
pixelherodev
?

1590722748
pixelherodev
You mean with reflection -> parameters?

1590722756
pixelherodev
That seems unnecessarily elaborate

1590722767
pixelherodev
anonymous structure with default arguments seems perfectly fine to me

1590722843
pixelherodev
The only reason to even use a tuple as the argument is to avoid having to say "No, we

1590722874
pixelherodev
This lets us say, "here's what we want," and not, "here's what we want, here's the other things we don't"

1590722884
pixelherodev
(Well, that and it lets us name them)

1590723006
pixelherodev
hmm, another option is to make REX `write` the value directly

1590723013
pixelherodev
That has the advantage of simplifying codegen logic

1590723045
pixelherodev
Instead of `if we need REX, generate it too`, it becomes `generate a REX if we need one`, which is a simple `self.REX(.{.B = reg.isExtended()});` for instance

1590723219
pixelherodev
I wonder how much my comments in codegen will increase the line count :P

1590723845
pixelherodev
andrewrk: thought; should e.g. XOR encoding also be moved into a function?

1590723864
pixelherodev
That way, any usage of it (e.g. an actual XOR implementation) can just be `self.XOR()`

1590723897
pixelherodev
The idea is to basically separate the low-level encoding (raw bytes) from the high-level meaning ("zero this register")

1590724250
andrewrk
I don't really see any reason to move any codegen.zig stuff around at this point, until it's more fleshed out

1590724289
andrewrk
remember: solve the problems that you have now. solve the problems that you will have in the future, in the future

1590724291
andrewrk
YAGNI

1590724325
andrewrk
we have plenty of tasks to do on self hosted

1590724335
andrewrk


1590724346
andrewrk
some of this stuff is really difficult

1590724375
andrewrk
but some would be I think really helpful and would get things closer to the state where you are anticipating

1590724397
andrewrk
for example, implementing math and other binary operations would be really helpful

1590724437
andrewrk
function arguments and conditional branching at runtime are also good candidates

1590724438
pixelherodev
I'll do that after function calls

1590724445
pixelherodev
Function args is something I'm mostly done with

1590724574
andrewrk
exciting

1590724890
pixelherodev
How much special-casing should there be?

1590724895
pixelherodev
I mean

1590724909
pixelherodev
We have e.g. u8_function_no_args and such

1590724916
pixelherodev
Should we have that for all common function types?

1590725164
andrewrk
it's a balance between maintenance cost, code bloat, and perf improvements / memory usage reduction

1590725185
andrewrk
probably some of those really special case ones will go away eventually. they were handy for when the type handling code was less sophisticated

1590725261
andrewrk
generally: add additional representations when it makes some code easier to implement, or if you have a benchmark demonstrating that it saves memory or improves perf

1590725451
pixelherodev
Gotcha

1590725704
andrewrk
note that if you are trying to access information about a Type or Value you should be using the accessor methods, not looking at the individual tags

1590725743
andrewrk
e.g. use ty.zigTagType() == .Array and ty.arrayLen() and ty.elemType() rather than peeking into the guts of how the type is represented

1590725759
andrewrk
although, obviously, exceptions can be made if it makes sense to do so

1590725774
pixelherodev
I figured that out :)

1590725791
pixelherodev
Mostly because I tried using the tag first and realized how annoying it was

1590725801
pixelherodev
So I looked at other code and saw how it was done elsewhere

1590725814
andrewrk
nice

1590725916
pixelherodev
I'm just going to finish up the REX thing and go to sleep

1590725923
pixelherodev
I'm mostly doing it because it's already mostly done

1590725933
pixelherodev
I'm not going to do anything more like it until stage2's a lot further along

1590725974
andrewrk
oh I think I see what you were hitting with the type coercion tihng

1590725984
andrewrk
I think this is the ZIR parser emitting the wrong code

1590726088
pixelherodev
What i saw from tracing it in gdb was that the ZIR Inst representing the function's

1590726096
pixelherodev
within resolveConstString

1590726132
andrewrk
check out zir.zig parseParameterInst, the part where it doesn't find it in the map

1590726147
andrewrk
it tries to emit it as a declref but it's missing a ref there. adding it now

1590726157
pixelherodev
That's not it

1590726161
pixelherodev
At least

1590726163
pixelherodev
that's not what I hit

1590726170
pixelherodev
Because this was

1590726172
pixelherodev
wait

1590726175
pixelherodev
...

1590726177
pixelherodev
no yeah

1590726179
pixelherodev
that's probably it

1590726193
pixelherodev
been a few days and Ive already largely forgot it :P

1590726311
pixelherodev
andrewrk: let me know when that lands

1590726343
pixelherodev
Actually, I should finish error_tests first

1590726351
pixelherodev
Then enable the tests using the updated harness instead

1590726412
pixelherodev
alrighty, PRed

1590726647
andrewrk
thanks!

1590726709
pixelherodev
:)

1590727982
pixelherodev
#5457 is good to go now

1590727996
pixelherodev
(or at least be closed if you'd rather not merge it)

1590728028
pixelherodev
Would be neat if we could tweak CI so that it only runs relevant tests

1590728043
pixelherodev
e.g. if nothing in src/ changes, skip the stage1 tests

1590728051
pixelherodev
If nothing in src-self-hosted/ changes, skip the stage2 tests

1590728328
pixelherodev
!!!

1590728339
pixelherodev
There's an Intel manual on machine code optimization!

1590732162
pixelherodev
Holy freaking... `push`, `pop`, `return`, etc have effectively no cost on modern CPUs (both from Intel

1590732184
pixelherodev
The CPU just renames the stack pointer to a different internal register and keeps going

1590732194
pixelherodev
Sorta like running the actual memory access in the background

1590732229
pixelherodev
Faster in Ryzen than in Intel microarchs, apparently

1590732461
pixelherodev
... probably not the right place for this :P

1590742865
shakesoda
pixelherodev: i'm curious about the performance properties of the arm equivalents

1590742874
pixelherodev
?

1590742876
pixelherodev
Ahh

1590742878
pixelherodev
I wouldn't know

1590742893
pixelherodev
I only know this from a microarchitectural optimization guide

1590742899
pixelherodev
Well

1590742916
pixelherodev
A microarchitecture analysis study that's used to provide info in a optimization guide :P

1590742941
shakesoda
somewhat directly related: just bought myself a raspberry pi 4 (8gb model exists now!)

1590742960
shakesoda
my arm knowledge could stand to gain a fair bit and it's a lot beefier than my other pis here

1590743172
pixelherodev
Ooh nice

1590757451
data-man
Maybe you're interested

1590757600
data-man
> std.meta.trait should be renamed to std.meta.concepts

1590757617
data-man
andrewrk: I take it if you wish :)

1590757776
ikskuh
nycex: and here! 👋

1590758711
data-man
Possible backend for Zig:

1590759827
fengb
Is it not allowed to put extern in struct declarations?

1590760044
data-man
I don't know :) For example

1590761268
antaoiseach
Hello ... I am trying to print an "expression" recursively ... is this sort of thing not possible?

1590761294
antaoiseach
I get the following error - "Semantic Analysis [555/831] ./eval.zig:21:13: error: cannot resolve inferred error set '@TypeOf(show).ReturnType.ErrorSet': function 'show' not fully analyzed yet try show(d.left, stdout);

1590761298
antaoiseach
"

1590761376
ifreund
antaoiseach: you can't use inferred error sets with recursion

1590761427
ifreund
if you explicitly specify the return type as `MyErrorSet!void` it should work

1590761460
ifreund
as noted in the docs, this limitation might be overcome in the future

1590761507
antaoiseach
ifreund: Oh... okay

1590761524
antaoiseach
The debug.warn examples works fine ... just confirmed

1590761535
antaoiseach
ifreund: Aha .. lemme try that and get back

1590761661
antaoiseach
ifreund: confirmed .. it works with anyerror as well!

1590761664
antaoiseach
Thanks!

1590761682
ifreund
oh that's interesting

1590761686
ifreund
no problem!

1590761692
antaoiseach
ifreund: Another question if you don't mind

1590761699
ifreund
fire awawy

1590761702
antaoiseach
in the type signature for stdout that I pass into my show function

1590761719
antaoiseach
I printed out the type of stdout explicitly and then used that as the signature

1590761734
ifreund
i would do @TypeOf(stdout)

1590761750
antaoiseach
What I am not clear on is this - why does std.io.OutStream not work by itself? The signature std.io.StdIn works for stdin?

1590761784
antaoiseach
Also, I figured that std.io.OutStream itself is a function of sorts which needs those three types to become a type itself ... is this correct? Is this some sort of trait-like feature?

1590761807
ifreund
yeah it's a comptime function returnin a type

1590761814
ifreund
*returning

1590761821
antaoiseach
Hmmm ... interesting!

1590761847
ifreund
this is how generics work in zig, there's no special language feature, just the ability to use types as first class values at comptime

1590761853
antaoiseach
I'm sorry .. how would you use that snippet - @TypeOf(stdout) ... I mean where exactly?

1590761884
antaoiseach
ifreund: Ah, right ... I'd forgotten about that part entirely (the generics bit)

1590761884
ifreund
@TypeOf() returns the type of a given variable at comptime

1590761905
ifreund
i assume you're using getStdOut() or something?

1590761906
antaoiseach
ifreund: right ... but how would I be able to simplify the function signature using that?

1590761917
antaoiseach
yes, in the calling function..

1590761923
ifreund
then you could do @TypeOf(getStdOut)

1590761936
ifreund
err with the right parentheses

1590762034
antaoiseach
ifreund: trying that like to show(stdout: @TypeOf(std.io.getStdout())) anyerror!i32 ... is that right?

1590762041
antaoiseach
This gives me an error about constness

1590762107
ifreund
hmm, maybe `stdout: *const @TypeOf(...` would work

1590762112
antaoiseach
Ah never mind... got it working

1590762118
ifreund
i have never actually tried this tbh

1590762120
ifreund
nice

1590762125
antaoiseach
`stdout: *const @TypeOf(std.io.getStdOut().outStream())`

1590762129
antaoiseach
that works very nicely indeed!

1590762137
antaoiseach
Thank you so much for the help, ifreund! :-)

1590762150
ifreund
no problem!

1590762155
antaoiseach
Cheers!

1590764756
gonz_
Has anyone successfully included sqlite3 statically  in zig?

1590764770
gonz_
statically from source, that is

1590765351
gonz_
Oh, hang on, it seems I just did. I just had to change one of the types in the zig windows intrinsic includes.

1590765427
data-man
gonz_:

1590765477
gonz_
Hadn't seen that, but it's also linking shared libs.

1590765555
data-man
Including c source isn't hard, IMHO. :)

1590765588
gonz_
my point exactly

1590765624
gonz_
And it was hard now (apparently) only because there is a type error in one of the Windows intrinsics that Zig ships.

1590765657
gonz_
A mismatch with real windows headers, that is.

1590766698
gonz_
sqlite3 didn't use to build from source correctly, though, AFAIR.

1590766710
gonz_
I tried maybe 6 or so months ago and had to resort to shared libs back then.

1590766736
gonz_
Or I just didn't have the presence of mind to diagnose this error I was getting now back then, I don't know.

1590767268
gonz_
Including C source in Zig is neither hard nor easy in any meaningful general sense of the word, IMO.

1590767296
gonz_
It pretty much always just depends on whether or not someone has stepped on and found a landmine before you.

1590767343
ifreund
hah, that's some good imagery

1590773626
andrewrk
wtf, the ninja package on alpine is called samurai?

1590773696
FireFox317
haha lol, thats weird indeed

1590773986
wilsonk
nice

1590774077
data-man
no, samurai is pure-c reimplementation

1590774123
fengb
We should reimplement it in Zig

1590774163
pixelherodev
No yeah, samurai is a reimplementation :P

1590774186
pixelherodev
Alpine prefers samurai over ninja because samurai has historically been more willing to work with distros to meet their needs

1590774459
pixelherodev
On a different note, nooooooooooo

1590774464
pixelherodev
All my PRs being merged!!!

1590774480
pixelherodev
Going to need to open new ones!

1590775418
dimenus
is anyone currently using the tcpConnect* functions in std.net?

1590775437
dimenus
Seems like I can keep reading from the socket forever even if the underlying other end is closed

1590775452
dimenus
i'm a bit of a linux noob still, is that expected?

1590775507
pixelherodev
I don't think so, but I'm not certain

1590775514
pixelherodev
The network functions are... not stable yet.

1590775516
pixelherodev
at all

1590775631
edr
How many bytes do you get from the read? If 0 that means the connection was closed

1590775656
dimenus
ah good call

1590775704
pixelherodev
not necessarily

1590775714
pixelherodev
The other end can just not write to it for a while

1590775720
pixelherodev
Or the internet connection can drop for a second

1590775722
pixelherodev
or...

1590775725
pixelherodev
you get the point

1590775945
edr
I am not sure exactly how the zig code implements it, but getting 0 from recv() means the other side has "gracefully disconnected"

1590776141
dimenus
currently it calls read not recv

1590776893
dimenus
edr & pixelherodev: looks like recv returns 0 if the other end flushed 0 bytes ooooooooor it terminated

1590777300
dimenus
i take that back, the write syscall will catch the 0 byte write when SOCK_STREAM is specified and basically do nothing or return errors

1590777311
dimenus
so checking if read() returned 0 is a valid case

1590779637
leeward
What am I missing in fs.Dir? openFile wants an instance, but I don't see a Dir.init.

1590780146
FireFox317
leeward, cwd()

1590780166
leeward
FireFox317: Of course, now I remember. Thanks.

1590781175
satchmo
would anybody be interested in a Zig version of rust-vmm (a collection of common components for building VMMs/hypervisors)?

1590781358
satchmo
been trying to find a project to do and I quite like this one

1590781654
leeward
If it's a thing you want to do, go for it. I wouldn't use it, but that's not a reason not to build it.

1590781683
leeward
Particularly since there exist users of other languages who would.

1590781685
gonz_
Yeah, I think most libraries stand the highest chance of being good when someone just wants to make and use them, regardless of the outside world.

1590782108
satchmo
trueeeeee

1590782361
leeward
I mean, I can't use Zig at work anyway until at least 1.0. Not a reason to refrain from building libraries for it.

1590782456
gonz_
IMO the best thing people can do for Zig before 1.0 is to write tons of code in it

1590782472
gonz_
There's been enough armchair language designers drive-bying the repo, to be honest.

1590782485
satchmo
^

1590782586
leeward
Batteries included did a lot for Python. Probably not as much as not being Perl, but it's debatable.

1590782608
leeward
Plus, the best way to find problems with a language is to use it.

1590782620
gonz_
Indeed

1590783632
fraktor
I'd also say that being batteries-included helped Java, although that's a very different kind of philosophy

1590783720
satchmo
what do you mean by different kind of philosophy?

1590783728
pixelherodev
"Worse"

1590783730
pixelherodev
Probably

1590783739
pixelherodev
That's the general view of Java I've heard

1590783845
leeward
Do you not have an opinion of Java, pixelherodev?

1590783900
pixelherodev
I have a more positive opinion of it than most

1590783924
pixelherodev
I like the JVM, and I mostly like the language, though i think the standard library is... well... "not nice" is the nicest way I can put it

1590783953
pixelherodev
I still use it occasionally for some tasks

1590783958
fengb
I'm always impressed that Java collections exists alongside Java dates

1590783980
fengb
The best and worst OO patterns right here!

1590783983
pixelherodev
I have a small Java "script" that converts a ... hold on I don't even remember how it works

1590784015
pixelherodev
Read in a CSV and generates a C file :P

1590784041
companion_cube
oh boy

1590784052
gonz_
How fast is the generation? I feel like you probably spend most of your time starting the JVM(?)

1590784053
pixelherodev
That C file was linked against by my OS game entry for the terminal game jam IIRC, which used it as a renderer demo

1590784057
pixelherodev
No

1590784062
pixelherodev
It ran nearly instantly

1590784083
leeward
It's not like the JVM takes several seconds to start up on a modern computer.

1590784084
gonz_
How short is the JVM startup nowadays? It used to be massive.

1590784107
pixelherodev
Nearly instant

1590784113
pixelherodev
For something this small? Milliseconds I think

1590784114
fengb
It's a lot better. Usually sub second for Java proper

1590784125
fengb
Um... it's still around 200 ms

1590784134
fengb
Unless it's been warmed up

1590784146
gonz_
It definitely used to be ridiculously high, and not because of computers being slow.

1590784149
fengb
$ time java -- 0m0.423s

1590784158
pixelherodev
`time java` -> 0.097 seconds

1590784163
fengb
There's some design flaws, like needing to load all the classpaths

1590784171
companion_cube
have you ever tried julia? that makes the jvm soooo much faster in comparison

1590784172
fengb
You primed it by running it before

1590784178
pixelherodev
@fengb no I didn't

1590784181
pixelherodev
THis was a first run

1590784182
pixelherodev
But

1590784186
pixelherodev
It's compiled with -march=native ;)

1590784187
leeward
It just ran a hello world in 0.338s on my system.

1590784193
pixelherodev
I don't use a binary VM

1590784207
pixelherodev
I have a compiled from-source OpenJDK optimized with `-O2 -march=native`

1590784213
companion_cube
oh nice.

1590784216
companion_cube
gentoo?

1590784217
pixelherodev
Gentoo ;)

1590784219
fengb
A lot of Java languages are still balls slow to start, like Groovy and Clojure :(

1590784228
fengb
OpenJDK isn't what most people consider Java though >_>

1590784243
pixelherodev
But I'm curious now how much faster the VM startup time is with an optimized build vs a binary

1590784249
pixelherodev


1590784259
fengb
Hotspot is what most people refer to when talking about the VM

1590784274
leeward
OpenJDK is what runs when I type java. I call it fair.

1590784290
fengb
Fine!

1590784318
fengb
"fn getA() uint8_t" I've forgotten how to write C -_-

1590784323
pixelherodev
lol

1590784328
pixelherodev
Just use translate-zig ;)

1590784334
pixelherodev
... ohhhhhh

1590784339
pixelherodev
I should totally make a C backend to stag2

1590784343
pixelherodev
s/stag/stage

1590784346
leeward
I mean, if you're running a stupid script that's going to take a few seconds at most, it doesn't make sense to run a fancy VM.

1590784358
pixelherodev
It doesn't even take a full second IIRC

1590784361
pixelherodev
It's subsecond

1590784368
pixelherodev
and it's not about the VM

1590784370
pixelherodev
It's about the language

1590784381
satchmo
it's about sending a message

1590784382
pixelherodev
Do you know how much easier string manipulation is in Java vs C?

1590784384
leeward
Is hotspot a different language? I don't java.

1590784393
pixelherodev
It took, like, 50 lines of Java

1590784399
leeward
Oh, that. Yeah, I would have written that in Python for the same reason.

1590784401
pixelherodev
and no mental effort

1590784409
pixelherodev
This was before I knew python well enough to use it

1590784409
fengb
Hotspot is the "official" VM published by Oracle

1590784411
satchmo
how much of that was boilerplate though

1590784418
pixelherodev
Maybe six lines?

1590784422
pixelherodev
It's like, a single function

1590784430
pixelherodev
Just repeated I/O

1590784435
pixelherodev
It's actually kinda sad, honestly

1590784439
pixelherodev
Java was the first real language I knew

1590784453
fengb
Java has a lot of baggage :(

1590784460
pixelherodev
Between Go, Python, C, and Zig, basically every use case I had for it is gone

1590784486
leeward
Depending on how you define real, I think VB3 was my first real language.

1590784487
pixelherodev
Web stuff -> Go, Low-effor one-shot string handling -> Python, literally everything else -> C and Zig

1590784502
fengb
And its design has been behind for ~15 years. Almost no real reason to use it now that Kotlin is a thing

1590784517
pixelherodev
Heard good things about Groovy, too

1590784519
fengb
Although admittedly Kotlin is becoming more C++ like

1590784525
pixelherodev
I also don't really like the OOP patterns

1590784528
pixelherodev
It's one reason I ditched C++

1590784535
fengb
Kotlin is more functional than Java

1590784552
fengb
And offers less OO style defaults, like dataclasses

1590784555
pixelherodev
I'm guessing you don't mean "It has more functionality" :P

1590784556
leeward
There are so many reasons to ditch C++. If only more employers could see them.

1590784572
fengb
I mean it's a lot more natural to do FP in Kotlin

1590784572
pixelherodev
I'll take C99 over C++ anyday

1590784578
leeward
seconded

1590784586
pixelherodev
C99 lets you take the address of a temporary

1590784587
fengb
Pattern matching, dataclasses, lambdas

1590784603
gonz_
I think C++ is less of a blight on the world than people make it out to be. But perhaps you're saying you'd like your employer specifically to see the light, leeward?

1590784612
fengb
I can't grok C++. My only knowledge was C++98, and that was already very bad

1590784634
satchmo
it's just hard to look at imo

1590784646
leeward
gonz_: I disagree. I've never met a significant C++ project that didn't make me feel a little squicky to look at.

1590784664
BaroqueLarouche
Wish I was working in and on Zig

1590784671
gonz_
I don't personally like it, but I feel like a lot of people make it out to be that the world would somehow be better if everyone switched from C++.

1590784686
pixelherodev
Ehh nah I disagree with that idea too

1590784689
satchmo
s/C++/Rust/

1590784696
leeward
But in general, yes, I would like more employers that I consider to share my view on C++. It doesn't hurt me if other people write C++ code and it works.

1590784698
pixelherodev
In the same way that I think JS is less of a problem than people think

1590784712
fengb
orly

1590784721
pixelherodev
The problem isn't the language

1590784723
pixelherodev
It's the people using it

1590784725
pixelherodev
If they switched to Zig, we'd have to deal with people trying to change the language for the worse constantly as well

1590784726
fengb
Like me

1590784740
pixelherodev
Nah, you're good

1590784748
fengb
Um... JS didn't really get worse over its history

1590784774
fengb
Honestly, the hard parts of web has very little to do with the language and more to do with the APIs

1590784781
gonz_
I think it's fine to use a piece of software and say "This would've been of higher quality if they used X, probably", but people silently working on their own stuff elsewhere isn't a bother to me.

1590784784
fengb
They're all terrible and we keep applying more bandaids

1590784796
leeward
I really wish JS would embrace its role as webassembly, and fork into another language that compiles down to actual browser-code.

1590784810
fengb
You mean wasm? It already exists :P

1590784823
leeward
For certain values of exists.

1590784836
pixelherodev
The web itself is the problem, not the language

1590784844
pixelherodev
I wasn't talking about the web though

1590784857
pixelherodev
Node.JS for instance

1590784866
pixelherodev
Just like Rust, the problem is the community

1590784874
companion_cube
satchmo: switch from rust to… what? :p

1590784881
gonz_
Shots fired :D

1590784899
fengb
Nodejs offered a niche that didn't exist at the time. Non-blocking IO wasn't really on app dev's radar

1590784903
leeward
Wasm became a standard last year. Javascript's been around for decades, and people have been using it as wasm for at least 15 years.

1590784938
fengb
When Java was struggling with 10k connections, and nodejs handled it out of the box

1590784949
leeward
Erlang?

1590784951
leeward
Erlang.

1590784966
andrewrk
there is no "the community"

1590784968
fengb
Hmm, why didn't Erlang get more popular?

1590784977
satchmo
companion_cube: i was joking about gonz's statement about everyone wanting to switch to c++, it feels like everyone wants rust to me

1590784978
leeward
fengb: I don't know, and it makes me sad.

1590784980
companion_cube
cause it's weeeeird, fengb

1590784980
andrewrk
that's an oversimplification

1590784991
satchmo
if the s/c++/rust was what you're talking about that is

1590784998
companion_cube
andrewrk: yesss, thank you

1590785000
fengb
Fair, I didn't really look at it until Elixir

1590785021
gonz_
fengb: Erlang was internal for a long time, then got open source when they got "banned" internally at Ericsson.

1590785037
fengb
wat really

1590785062
leeward
It's not that weird, it's just functional. Erlang's a tiny language with amazing library support.

1590785063
fengb
I knew about it in 2007, but it was somewhat of a joke: "Hey here's a language more esoteric than Haskell!"

1590785081
marler8997
hey, working on getting DNS to work on windows

1590785094
marler8997
there's an error code ADDRFAMILY that is supported on non-windows platforms, but not on windows

1590785110
marler8997
and dns is switching on that value....is there a way to make switch cases platform specific?

1590785114
marler8997
not sure what the clean/right solution is here

1590785189
gonz_
In 98 they open sourced it after being shut down inside of Ericsson. It was also very, very buggy for a long time and contrary to what you might believe didn't actually have SMP support for some time.

1590785190
andrewrk
marler8997, the pattern we have for this in std is: functions that abstract across platforms have a union of error sets

1590785201
leeward
fengb: Really? I don't think Haskell was in any real applications in 2007, whereas Erlang was in real switches with real uptime.

1590785205
andrewrk
marler8997, and then if you know you are in a code path where some error codes do not apply,  => unreachable

1590785239
gonz_
Erlang hasn't always been rock solid and to some extent still has weird bugs and issues (specifically SSL stuff is very clowny even in recent OTPs).

1590785239
marler8997
I'm working on getaddrinfo

1590785240
andrewrk
in this case it will be useful to have an explicit error set, not inferred

1590785250
marler8997
it's not abstracted

1590785254
leeward
gonz_: Yeah, I don't think it got SMP support in beam for a while, but it did let you talk to other instances of beam running on a different processor just fine, even if the other processor was across a tcp link.

1590785294
andrewrk
marler8997, hmm I don't think I understand your question

1590785309
marler8997
net.zig is calling os.system.getaddrinfo...is that supposed to be an abstracted wrapper around the platform specific getaddrinfo?

1590785325
fengb
Haskell was always semi-popular in academia. Erlang just sorta existed

1590785338
companion_cube
well, erlang also has a super weird syntax

1590785343
companion_cube
which is why elixir is eating its cake

1590785348
fengb
That was my view of it at least. I graduated college 2007 so it's not like I knew anything

1590785349
andrewrk
marler8997, it's planned to rename std.os to std.posix

1590785357
andrewrk
std.net is cross platform

1590785359
gonz_
Erlang is more popular than Elixir and Haskell in turn is more popular than Erlang.

1590785372
andrewrk
so if std.net is unconditionally calling into the posix apis, it means that it is missing a windows implementation

1590785394
marler8997
right, but the windows implementation doesn't return one of the error codes

1590785404
marler8997
so I should just add it to the enum anyway, even if windows will never return it

1590785406
leeward
Erlang's syntax is basically prolog. I guess if prolog is weird, you're right.

1590785421
companion_cube
prolog is definitely weird :D

1590785426
andrewrk
marler8997, the enum of the cross platform abstraction? yes the cross platform abstraction error set is a union of all possible errors on all platforms

1590785443
marler8997
what value do I set it to?

1590785449
marler8997
the enum that will never be returned?

1590785452
marler8997
some random value?

1590785456
andrewrk
are you talking about error sets?

1590785458
marler8997
I'm talking about EAI

1590785512
andrewrk
your goal is to get std.net.getAddressList working on windows right?

1590785536
marler8997
with libc, yes

1590785538
marler8997
then without libc

1590785620
andrewrk
I see, you are trying to unify the code paths for if libc is linked and with or without windows

1590785621
marler8997
here's what I got so far, if it helps to have a look:

1590785628
marler8997
yes

1590785639
marler8997
getting libc to work first

1590785660
andrewrk
so the windows libc has getaddrinfo but the error codes are different

1590785671
marler8997
it's missing the ADDRFAMILY error code

1590785678
marler8997


1590785712
marler8997
actually, I think windows FAMILY might be ADDRFAMILY, so it maybe it's actually missing FAMILY? not sure

1590785745
andrewrk
if the error codes are not compatible then I suggest splitting the code path into two switches

1590785747
marler8997
actually it looks like it's missing quite a few

1590785752
marler8997
ok

1590785767
andrewrk
the direct answer to your question is no, there's no language feature like this

1590785782
marler8997
yeah I didn't think there was, your other answer is what I was looking for

1590785783
alexnask
marler8997, You should check out

1590785795
alexnask
Its almost exactly like std.net

1590785804
pixelherodev
andrewrk: true enough

1590785816
pixelherodev
"A vocal minority

1590785832
alexnask
It has blocking socket support for windows rn, I will be working on async sockets this w/e

1590785841
companion_cube
there already are several vocal subcommunities in rust, pixelherodev, I think

1590785857
pixelherodev
That's what I was saying, yeah

1590785870
companion_cube
there's a minimalist fringe, with low dependencies, there's the RiiR team, and the silent majority that just writes code

1590785922
pixelherodev
I, unfortunately, have mostly seen the RiiR folks

1590785948
companion_cube
it's like the crazy haskell people and their towers of abstraction

1590785952
companion_cube
you hear more about them

1590785974
fengb
There are others? 🙃

1590785986
companion_cube
yes, there are people who want to get shit done

1590786018
companion_cube


1590786050
companion_cube
or rather:

1590786232
pixelherodev
heh

1590786234
pixelherodev
Oh, unrelated

1590786242
pixelherodev
I plan on implementing a Forth in Zig soon :)

1590786267
leeward
That sounds like a fun short project.

1590786354
gonz_
RiiR = Rewrite it in Rust?

1590786363
companion_cube
yes

1590786385
companion_cube
it's cliché because a lot of rust users, even the more well known ones, aren't like that

1590786443
pixelherodev
But the ones that are never shut up

1590786835
marler8997
what a minute what am I doing...windows doesn't even have libc

1590786855
pixelherodev
lol, yes it does.

1590786857
pixelherodev
Not a good one

1590786858
marler8997
what happens differently on windows when libc is enabled?

1590786859
pixelherodev
but it does

1590786865
pixelherodev
I mean, you can use glibc on windows

1590786871
pixelherodev
and I think msvc has a crappy one too

1590786960
marler8997
I suppose it has to have a libc doesn' it

1590786985
marler8997
is it those msvc...dll s?

1590787025
marler8997
those really bad ones that you need to install separately, the versioned runtime packages, and then there's that unversioned one that can change!

1590787037
marler8997
goodness what a mess

1590787106
gonz_
And yet some people choose to use this method of library consumption voluntarily with system-wide shared libs.

1590787113
gonz_
It's indeed completely braindead.

1590787120
marler8997
I think I might abandon the windows libc support, go straight to the ws2_32 direct support

1590787330
pixelherodev
You can support e.g. mingw's glibc

1590787336
andrewrk
I think that's probably a good idea

1590787341
andrewrk
going straight to ws2_32

1590787352
marler8997
yeah, I'm switching to that

1590787364
marler8997
I don't use mingw so I don't care about it's support

1590787375
andrewrk
in my experience, windows libcs are more compatibility layers than anything useful. when implementing something from scratch like you are, better to target the actual interface rather than the compatibility layer

1590787397
pixelherodev
ws2_32?

1590787410
andrewrk
ws2_32.dll is how you do networking in windows afaik

1590787420
pixelherodev
ahh, gotcha

1590787429
pixelherodev
Yeah, that makes sense

1590787437
marler8997
yeah I've found the same,  I thought it was going to be some quick easy changes to get the libc route working but didn't turn out that way

1590787446
pixelherodev
Only support the compatibility layer if you don't have time to target the direct API IMO

1590787464
andrewrk
not relying on libc for windows builds is a pretty nice feature of zig imo

1590787466
pixelherodev
e.g. I have a header that does some #defines to improve POSIX support with MSVC's libc

1590787483
pixelherodev
but it's only useful because it means I don't have to bother with a second set of APIs

1590787490
andrewrk
I wonder what rust does

1590787492
pixelherodev
Zig is definitely nice in that I don't need either of those

1590787494
pixelherodev
Rust links libc IIRC

1590787502
andrewrk
on windows though, have you checked?

1590787503
pixelherodev
By default

1590787507
pixelherodev
Nah

1590787511
companion_cube
unless you use no_std, I think?

1590787513
pixelherodev
I have more productive things to be doing

1590787516
pixelherodev
Yeah, that sounds right

1590787524
pixelherodev
I think Rust has libc as opt-*out* whereas we have it opt-*in*

1590787550
companion_cube
but there are platforms where even Go gave up and linked libc for syscalls

1590787550
marler8997
I think I recall seeing a thread on rust complaining about the msvcrt dlls

1590787551
companion_cube
right?

1590787557
andrewrk
man, waiting for 1 thread to do 600 compile error tests is a huge bummer

1590787608
andrewrk
linux and windows are the only OS's I'm aware of that have a stable syscall ABI that is not libc

1590787628
marler8997
osx system.dll though?

1590787633
marler8997
or libsystem.so

1590787636
andrewrk
libSystem is libc

1590787649
marler8997
ah

1590788679
metaterically
I'm trying to build andrewrk/zig-vulkan-triangle

1590788692
metaterically
and currently I'm stuck on readFileAllocAligned...

1590788714
metaterically
It was:     const vertShaderCode = try std.io.readFileAllocAligned(allocator, "shaders/vert.spv", @alignOf(u32));

1590788726
metaterically
but that gave:    error: container 'std.io' has no member called 'readFileAllocAligned'

1590788757
metaterically
had a look in the stdlib docs, found it's moved to std.fs.Dir

1590788788
metaterically
tried this:     const vertShaderCode = try std.fs.cwd().readFileAllocAligned(allocator, "shaders/vert.spv", maxShaderSize, @alignOf(u32));

1590788808
metaterically
but that gives:   error: no member named 'readFileAllocAligned' in struct 'std.fs.Dir'

1590788811
metaterically
???

1590788830
metaterically
What am I missing?

1590788842
metaterically
Is it neither here nor there?

1590789085
gonz_
Use `readFileAlloc` from `Dir`:

1590789118
gonz_
`readFileAllocOptions` is also available, but you shouldn't really need it...?

1590789263
gonz_
In any case that version also takes alignment.

1590789996
metaterically
Thanks, didn't realise it was renamed and extended

1590790071
metaterically
Might not need it but my knowledge here is lacking, so I'm gonna go with the Options variant for now to play it safe

1590790089
metaterically
At the moment I'm just trying to update the code to current Zig, rather than making any changes

1590790119
gonz_
Yeah, stuff is moving fast in the standard library and friends, it's worth it to just have a tab open to it and navigate in the addressbar to the file you're interested in.

1590790148
gonz_
there's also the interactive stdlib search but I found that less complete and possibly out of date(?)

1590790195
metaterically
Yeah I was using the search, which shows readFileAllocAligned instead of readFileAllocOptions

1590790206
gonz_
Right

1590790213
metaterically
Though I notice now in the sidebar it says Zig v0.5

1590790249
metaterically
Which is weird given that it says master in the addressbar

1590790794
fengb
Yeah those docs are manually generated

1590790983
leeward
Yeah, replace master in the address bar with 0.6.0

1590790997
leeward
Not the best, but at least it's usable.

1590792870
leeward
Is there a way to check if an error is a member of a particular errorset? I want to handle File.OpenErrors up at a high level where other kinds of errors could also have happened.

1590793080
ifreund
just switch on the error set? I'm probably misunderstanding

1590793256
leeward
else |err| switch (err) { ErrorSet => blah }

1590793272
leeward
^ That's what I tried at first, but no

1590793285
leeward
It was expecting an error, not an error set.

1590793343
ifreund
oh, yeah I misread what you wrote

1590793391
leeward
I probably should handle the error further down the stack, but...this whole program is a crappy hack anyway.

1590793396
ifreund
does @TypeInfo give you what you want?

1590793420
leeward
hmm, maybe

1590793421
leeward
will check

1590793458
ifreund
it will give you a slice of errors that are members of the queried set

1590793469
ifreund
then you can loop over those and compare

1590793478
ifreund
this seems like a pretty weird thing to do though tbh

1590793577
leeward
Yeah, it does.

1590793592
leeward
Reading builtin.zig makes me want to fix the docstrings though.

1590793602
leeward
Maybe tonight.

