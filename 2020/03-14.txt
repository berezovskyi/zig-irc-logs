1584147529
jjido
mikdusan I don't like IEC/IEEE decimal numbers anyway. Why allow denormalised representations?

1584147745
jjido
"representations that have the same numerical value but different quantum exponents, e.g., (1, 10, −1) representing 1.0 and (1, 100, −2) representing 1.00, are distinguishable."

1584147789
jjido
crazy

1584160970
daurnimator
fengb: heh. I just andrewrk's fixup commit.... I was going to make some of those same changes

1584161290
fengb
Great minds think alike :)

1584162914
diginet
jjido: the alternative to not allowing them is far worse and more complicated

1584174148
Kingsquee
so I'm looking over the zig documentation, and it says that casting a signed number to unsigned int is UB

1584174173
daurnimator
Kingsquee: where?

1584174180
Kingsquee


1584174204
daurnimator
Kingsquee: with @intCast: yes: you're promising that the number fits in the destination

1584174226
Kingsquee
oh, can I @yoloCast or something?

1584174244
daurnimator
Kingsquee: e.g. you might have a i64, but you

1584174281
daurnimator
Kingsquee: you might be looking for @bitCast for going between unsigned and signed?

1584174290
daurnimator
that lets you e.g. go between a isize and a usize

1584174292
Kingsquee
I see there's also @as

1584174325
daurnimator
Kingsquee: @as only lets you go... "bigger" e.g. `@as(u64, my_u32)` works, `@as(u32, my_u64)` is a compile error

1584174372
Kingsquee
so many casts

1584174390
Kingsquee
a cast-astropy

1584174416
daurnimator
Kingsquee: @intCast is a pinky-promise that you can fit into the destination

1584174424
daurnimator
Kingsquee: if you're not sure if you can fit into the destination, see @truncate

1584174442
daurnimator
Kingsquee: explicit over implicit

1584174459
Kingsquee
this is interesting since I never thought about this stuff being implicit

1584174465
Kingsquee
and yet it be

1584174486
Kingsquee
@daurnimator @bitCast looks like what I was expecting, yep

1584174515
Kingsquee
thanks

1584174524
daurnimator
Kingsquee: and FYI, @bitCast will compile error if the types are not exactly the same size.

1584174532
Kingsquee
yeah, I saw

1584174561
Kingsquee
same dealio as rust's mem::transmute<T>(x)

1584174671
Kingsquee
this language looks pretty nice

1584174699
Kingsquee
the smooth jazz that is anyerror feels almost sinful after coming from rust

1584174781
daurnimator
Kingsquee: welcome :) what sort of things do you work on?

1584175519
Kingsquee
i make bideo game

1584175760
Kingsquee
I've been trying to do a thing with fixedpoint numbers in rust but the language's lack of compiletime numbers in generics has limited my shenanigans

1584175791
daurnimator
What's on the menu Kingsquee?

1584175795
Kingsquee
so productivity hasn't been all that great but I really didn't want to go back to C++

1584175820
Kingsquee
and then Zig ((holylight))

1584175840
Kingsquee
so I'm playing around with it despite its apparent infancy

1584175856
daurnimator
you didn't follow the script! :(

1584175899
Kingsquee
these memes cannot contain a force as strong as I

1584176170
jjido_
diginet: as far as I can tell all that denormalised do is defer the normalisation until the time you need to compare two numbers.

1584176335
Kingsquee
man...this looks so much more comfy to use

1584176359
Kingsquee
the fact I could just write normal code for generics is beautiful

1584176449
Kingsquee
this is the kind of crap I'm dealing with atm

1584176460
Kingsquee
basically type-level register finagling

1584176500
Kingsquee
is zig actually practically usable in its current state?

1584176525
Kingsquee
or are we regularly playing compiler bug whack-a-mole

1584176616
daurnimator
Kingsquee: you will hit compiler bugs.... but its usually when you have buggy code

1584176634
Kingsquee
fair

1584176656
daurnimator
Kingsquee: which is to say:

1584176667
Kingsquee
hmmm

1584176689
daurnimator
they're getting less and less frequent though :)

1584176699
Kingsquee
that kind of assumption feels iffy though

1584176721
daurnimator
Kingsquee: essentially missing validation in various stages of the compiler that later stages assume to have occured

1584176762
Kingsquee
whats the turnaround time on fixes like?

1584176771
Kingsquee
and/or how hard is it to fix things

1584176775
daurnimator
anywhere from 10 minutes to 6 months? ;)

1584176794
Kingsquee
. _.

1584176797
daurnimator
(depends on how hard it is to fix it; and who is around with the relevant skills+interests)

1584176826
Kingsquee
what kind of stuff are you working on with zig?

1584176924
daurnimator
good question. I think I've managed to get too absorbed into zig itself and have barely worked on anything

1584177000
Kingsquee
the hero we need, not the one we deserve

1584177128
daurnimator
I should actually go back and finish some projects

1584177173
Kingsquee
what were you working on?

1584177182
Kingsquee
also I should ask, how's jai's compile time doing

1584177186
Kingsquee
er, zig

1584177191
daurnimator
one project was a decentralised messaging protocol

1584177201
Kingsquee
(they're kinda occupying the same region in my brain)

1584177232
daurnimator
compile time is mostly waiting for LLVM itself: we have plans to one day write our own assembler so we don't have to wait on LLVM; but that's pretty far off

1584177330
Kingsquee
not hitting any massive slowdowns with evaluation of comptime stuff?

1584177353
daurnimator
comptime is not fast.... but I think only a couple of people have actually hit real slow paths

1584177395
daurnimator
we have plans to optimise it in future: in theory it shouldn't be any slower than, say, cpython; but bug fixing and language changes take priority

1584177635
Kingsquee
yeah, the issue I see hit in rust occasionally is type recursion and non-obvious compiletime increases from certain comptime programming patterns

1584177694
Kingsquee
have to do weird workarounds like "don't assign to (the rust equivalent of) a comptime variable before returning it, just return the expression immediately"

1584177723
Snektron
<Kingsquee "I've been trying to do a thing w"> Arent there const generics by now?

1584177734
Kingsquee
no, we have typenum

1584177750
Kingsquee
monstrous beauty that it is

1584177815
Snektron
Huh

1584177832
Snektron
Weird, i thought they hit stable already

1584177848
Kingsquee


1584177900
Snektron
I see

1584177913
Snektron
Rust development is so slow

1584177934
Kingsquee
that's becoming my main beef with it yes

1584177950
Kingsquee
I've been patient but it's getting insane

1584177960
TheLemonMan
it takes time to get things right

1584177974
daurnimator
rust and I had irreconcilable differences around that fact that memory is not infinite

1584177990
TheLemonMan
when you are past the 1.0 you cannot throw shit to the wall and see what sticks

1584178014
Snektron
Thats true

1584178162
Kingsquee
daurnimator: explain

1584178225
TheLemonMan
rust panics on OOM

1584178299
Kingsquee
hot take: in any situation you'd possibly panic on OOM, you should be preallocating your own heap and writing your own allocators

1584178300
daurnimator
Kingsquee:

1584178323
Kingsquee
*possibly not panic

1584178326
daurnimator
Kingsquee: correct answer: panic is unrecoverable. never panic on OOM.

1584178343
Kingsquee
catch_unwind?

1584178369
Kingsquee
like, what are you going to do if you have no more memory, call an x86 intrinsic to pray to the gods

1584178376
daurnimator
i.e. "unable to allocator memory" must be an error returned/thrown by functions. i.e. functions that allocate need to have a way to signal errors

1584178397
daurnimator
Kingsquee:

1584178424
Snektron
<Kingsquee "hot take: in any situation you'd"> I think using your own allocator is not very useful in rust, since you can only have one allocator really

1584178446
Kingsquee
daurnimator: fair enough

1584178470
Kingsquee
I actually tried this with writing my own containers, but didn't find it very useful

1584178485
daurnimator
Kingsquee: try using zig ones, we do it right :)

1584178489
Kingsquee
and the OOM error handling everywhere was pretty fugly

1584178519
TheLemonMan
stackable allocators are quite nice

1584178551
Kingsquee
Snektron: custom global allocator allocating custom allocators allocating custom containers allocating PODs

1584178557
Kingsquee
it's the only way to be sure

1584178589
Snektron
Aaaa

1584178605
Kingsquee
^ -^

1584178806
Kingsquee
reading about zig's allocators now

1584178816
Kingsquee
this is...actually quite thoughtful

1584178841
daurnimator
Kingsquee: its more that anything that needs an allocator

1584178863
Kingsquee
yeah, rust's hidden allocation always bugged me

1584179079
Kingsquee


1584179173
TheLemonMan
arena is an allocator as it implements the Allocator trait

1584179191
TheLemonMan
`allocator` is the interface implementation

1584179310
Kingsquee
that seems unusual

1584179337
daurnimator
?

1584179340
Kingsquee
I'd expect arena to be the allocator with the interface implementation

1584179368
Kingsquee
arena.create(i32)

1584179383
TheLemonMan
the whole interface story is not completely fleshed out yet, check out #130 for more details

1584179580
Kingsquee
hmmmm

1584179908
Kingsquee
wait, I thought zig was self hosted

1584179917
Kingsquee
/src is full of .cpps 8V

1584179948
Kingsquee
RUSED 8V

1584180136
Kingsquee


1584180141
Kingsquee
gotcha

1584180144
daurnimator
Kingsquee: not yet. and /src-self-hosted is where the self-hosted implementation is

1584180208
daurnimator
Kingsquee: see also

1584180218
TheLemonMan
that comment is slightly stale, bytesToSlice was removed last week

1584180546
frett27_
seems the std.io.getStdout().outstream().print function is broken on the head ?

1584180555
frett27_
is it linked to buffer introduction ?

1584180566
daurnimator
frett27_: hmm? got an example?

1584180589
daurnimator
frett27_: .outStream() was only really introduced last night...

1584180616
frett27_
here : Semantic Analysis [803/1039] /home/use/zig/lib/std/fmt.zig:329:32: error: expected 6 arguments, found 4

1584180617
frett27_
return try value.format(fmt, options, out_stream);

1584180617
frett27_
^

1584180617
frett27_
try formatType(

1584180617
frett27_
^

1584180638
frett27_
in just a line : (using)

1584180660
frett27_
try std.io.getStdOut().outStream().print("{}\n", .{dev});

1584180681
daurnimator
frett27_: did you implement your own .format() method? the trait signature changed.

1584180704
frett27_
no, i tried to compile the svd2zig project

1584180714
frett27_
for embedded

1584180745
daurnimator
frett27_: that's a "yes" :)

1584180765
daurnimator
frett27_: please file a bug with svd2zig to use the new .format() interface

1584180814
frett27_
thnx so much, i'll adjust the code and make a pull request

1584181179
daurnimator
Kingsquee: as you may notice: things can move pretty quickly round here :)

1584181303
Kingsquee
daurnimator: as long as I can move pretty quickly as well, that might be amenable

1584181363
daurnimator
Kingsquee: if not, you can always still to the releases. Though you're likely to hit a bug that we only fix in master.

1584181369
daurnimator
s/still/stick/

1584181707
Kingsquee
eeh I tried that back when rust was beta

1584181741
Kingsquee
there's a balance to it

1584184179
frett27_
daurminator: thnx, made the pull request, it works fine :

1584187767
Kingsquee
so I see that there's arbitrary i#/u# integer bit width syntax, that's hella cool

1584187777
Kingsquee
but...can

1584187793
Kingsquee
or is that builtin

1584187948
Kingsquee
it'd be nice to have that same general syntax for fixedpoint

1584188020
Kingsquee
...wait a minute, the language could have fixedpoint built in

1584188022
Kingsquee
8V

1584188049
mq32
Kingsquee: the language does not have fixed-point types builtin yet

1584188053
Kingsquee
oh no now i will mak compiler and will never mak game

1584188055
mq32
but there are proposals for that

1584188062
Kingsquee
I would be interested in working on this

1584188146
mq32
if you want, you can do that

1584188163
mq32
mikdusan wrote a writeup about the compiler, you can find it on his github

1584188170
mq32
there is also some other compiler internals docs

1584188188
mq32
but i recommend working with the lang first :)

1584188258
Kingsquee
ofc

1584188268
Kingsquee
I'm just getting excited )))

1584188381
Kingsquee
is there an rfc process?

1584188426
mq32


1584188434
mq32
we use github issues for tracking proposals

1584200966
pixelherodev
... huh. I just realized why I stopped using email to track Zig issues: I filtered Zig emails into a different folder and then forget about it :(

1584201813
TheLemonMan
andrewrk, ping

1584203516
pixelherodev
Anyone have Zig syntax highlighting for kak?

1584203556
pixelherodev
Ah, found one

1584203556
pixelherodev


1584203614
jessermeyer
kakoune?

1584203716
jessermeyer
lmao the readme

1584204346
pixelherodev
Yeah I know

1584204362
pixelherodev
But the highlighter I linked is broken so I need to fix it anyways

1584205226
shakesoda
frustrating, keep running into c abi problems trying to build this program on linux

1584205230
shakesoda
guess i'm windows only for now

1584205505
pixelherodev
What sorta problems?

1584205511
shakesoda
#1481

1584205561
shakesoda
compiler outright errors when trying to use cimgui functions that take (certain?) struct parameters on x86_64 linux

1584205636
shakesoda


1584205866
shakesoda
not quite a showstopper, but frustrating, I have to modify a bunch of functions to take pointer args instead to workaround whenever I'm up for fixing that build

1584206534
jessermeyer
Huh, That reminds me that I had some issues with DX12 COM that I never got to the bottom of.  Possibly related.

1584206603
jessermeyer
I recall passing a struct with an int offset for a heap descriptor and it would always fail.  Worked fine compiling in straight C.

1584206683
jessermeyer
Now I'm in Vulkan land, and thankfully the API takes pointers universally from what I can tell.

1584207510
TheLemonMan
eh fuck this shit, I keep stumbing into LLVM bugs

1584208138
pixelherodev
I configured kak to auto-zig fmt on idle, not realizing how often that was. I hit enter, it hits backspace :P

1584208295
TheLemonMan
zig fmt is a drug

1584208573
pixelherodev
Yeah

1584208579
pixelherodev
I upped the idle timeout a bit and now it's perfect

1584208592
pixelherodev
Auto-formats nearly the instant I stop typing :)

1584211574
jaredmm
I'm going through and fixing some translate-c issues and I've started to see a lot of redefinition errors. (pub const __ = @compilerError) that are all identical. One instance of a const and pub const definition with the same @compileError body.

1584211726
jaredmm
I'm checking without my patch to confirm it didn't create the scenario rather than just being hidden because of all the other errors.

1584211916
jaredmm
I'm attempting to bisect with my patch to be sure, but I think I'm doing it wrong. I'm following the hot-fix example on

1584211931
jaredmm
Is that the best way to deal with this scenario or is there a more efficient route?

1584211963
frett27
i'm having a redefinition issue for pointer on struct, is that's legal ?

1584211985
jaredmm
(Although looking at an old master I see the issue there, just not reported as an error because of an earlier error, so it doesn't seem to matter for this case)

1584212054
frett27
because of the same name for parameter and global variable

1584212827
pixelherodev
Variables can never shadow other variables

1584212840
pixelherodev
You'll have to rename one

1584213581
adamkowalski
What is the rule with anonymous struct literals? Sometimes when I call a function it works fine, other times I get `error: TODO: type coercion of anon struct literal to struct`

1584216139
fengb
andrewrk: I'm looking at implementing optional shrinkFn. Your old branch hijacks realloc if shrinkFn is null:

1584216173
fengb
But FBA has an explicit test to do an in-place expand if it's the last element

1584216305
adamkowalski
fengb: do you happen to know why the anonymous struct error above happens?

1584216336
fengb
Nope... but I've seen it semi often

1584216406
fengb
One major problem I had (that might be fixed) is that anon literals can't be coerced into anon structs e.g. fn blah(args: struct {})

1584216461
adamkowalski
it worked when I defined the struct in the file where the function was being called though

1584216492
adamkowalski
I had a common struct I wanted to refactor into one file, and then all those other files could no longer use it anonymously

1584216705
adamkowalski
nevermind even when I declare it in the same file it seems to not work

1584216859
fengb


1584216947
adamkowalski
okay awesome, I'm glad it's a known issue. Sounds like 0.6 has some cool things planned

1584217000
fengb
Well... it's only about a month away so don't hold your breath on a fix :P

1584217105
adamkowalski
okay well I don't mind getting involved, it sounded like Andrew thought it was a relatively simple issue

1584217150
adamkowalski
Are there any design docs or something which describe the overall structure of the compiler?

1584217197
adamkowalski
I guess I can start by looking at the unit tests?

1584217401
fengb


1584217418
fengb
I don't really know much about the compiler either :P

1584217702
adamkowalski
awesome thanks, I'll get to reading

1584217922
andrewrk
TheLemonMan, yo

1584218443
TheLemonMan
I forgot what the question was heh

1584218922
TheLemonMan
gah I love some more crazy SIMD-related test failures

1584219057
andrewrk
TheLemonMan, I wonder how the llvm10 branch fares

1584219119
TheLemonMan
much better I guess

1584219156
TheLemonMan
the 10 series already fixes a few crazy codegen problems

1584219380
pixelherodev
Just for the record: github.com/pixelherodev/kak-zig

1584219391
pixelherodev
Found a better version, then integrated zig-fmt

1584219728
Kingsquee
considering arbitrary sized numbers, is there any support / libraries for dynamic bitwidth integers that don't overflow? (except when hitting max integer bitwidth)

1584219755
TheLemonMan
the stdlib has "classical" bigints

1584219800
Kingsquee
hmm

1584219951
pixelherodev
Only thing I need to fix for kak-zig is `zig build` integration (which works with my setup, but the commands to go the errors are confused by the zig command line showing up in the output due to verbose mode)

1584219990
Kingsquee
is there a way to disable the implicit conversion from machine sizes to bigints for integers?

1584220014
Kingsquee
i.e. getting a compiler error if I use a u129

1584220110
andrewrk
llvm10 branch passed the full test suite with llvm assertions enabled

1584220115
andrewrk
llvm10 rc4

1584220125
Kingsquee
I imagine if someone starts doing high perf code with type generation one could accidentally tank their perf as complexity increases

1584220166
andrewrk
Kingsquee, there's no implicit conversion from primitive int types to std.math.big.Int

1584220184
Kingsquee
andrewrk: I mean the support for arbitrary i#/u#'s

1584220195
Kingsquee
i512 etc

1584220206
Kingsquee
i7

1584220215
Kingsquee
u9

1584220217
andrewrk
using large fixed width int sizes doesn't necessarily mean tanking perf. it could actually be quite well performing

1584220260
andrewrk
the "maximum machine int size" is different for different targets

1584220272
andrewrk
applications should pick reasonable upper bound limits for integers and then use the appropriate types

1584220294
pixelherodev
Is there an equivalent to

1584220422
Kingsquee
andrewrk: I'm just exploring zig now, so sorry for the unfamiliarity, but can the width of a returned integer type be defined using comptime calculations?

1584220455
andrewrk
Kingsquee, yes

1584220460
Kingsquee
conceptually equivalent to concat(u, n+m) -> u#

1584220473
Kingsquee
where # is the sum of n+m

1584220495
andrewrk
pixelherodev,

1584220541
Kingsquee
because in that case, the 'reasonable upper bound' for integers may quickly become obfuscated behind a bunch of typegen

1584220575
Kingsquee
so it'd be nice to have some kind of `-set-max-integer-width #` to help with linting intent

1584220807
andrewrk
nah you don't need that. try it out a bit and see

1584220827
andrewrk
just put a type on something if you want to limit its size

1584220899
Kingsquee
hmm, true

1584220931
Kingsquee
I have to remember to do that though!

1584220949
Kingsquee
EVERYWHERE

1584221006
Kingsquee
that said I could just add that check to said typegen macros :I

1584221035
Kingsquee
hmmmmmmmmmmmmmm :I

1584221048
jaredmm
How would a compiler intrinsic from a C header get translate-c'd? Are there any existing examples?

1584221712
pixelherodev
Poorly, from what I remember :(

1584221890
fengb
andrewrk: I'm looking at implementing optional shrinkFn. Your old branch hijacks realloc if shrinkFn is null:

1584221921
fengb
But FBA has a implementation / test to do an in-place expand if it's the last element

1584221927
pixelherodev
Integrated `zig build` into kakoune :)

1584221947
pixelherodev
It's actually

1584221953
jaredmm
More "how is it expected to be done" rather than how well does it work. I know clang has definitions for the MSVC intrinsics. Is the expectation that each intrinsic is re-implemented in Zig?

1584221998
Kingsquee
is there a way to define a test should fail?

1584222012
Kingsquee
better yet, fail to compile?

1584222095
TheLemonMan
no

1584222144
TheLemonMan
you can add a @compileError that's only triggered if the code compiles

1584222464
andrewrk
fengb, sounds like FBA would not be elligible for null shrinkfn

1584222507
andrewrk
I don't understand your concern- realloc is non-optional so it's always available

1584222540
Kingsquee
hmm

1584222547
Kingsquee
variables in tests don't seem to be scoped to the test?

1584222582
Kingsquee
test "fooy" { var foo: i32 = 4; } const foo: i32 = 10;

1584222589
Kingsquee
"error: redefinition of foo"

1584222626
TheLemonMan
the local variable is shadowing the global one

1584222653
fengb
I don't think null shrinkfn should dictate how an expand should work

1584222680
Kingsquee
TheLemonMan: fn fooy() void { var foo: i32 = 4; } const foo: i32 = 10;

1584222682
Kingsquee
no error

1584222738
andrewrk
fengb, in what way does null shrinkfn dictate how an expand should work?

1584222759
Kingsquee
oh interesting, it doesn't display the error unless fooy() is used

1584222763
andrewrk
pretend that I have no idea what you are talking about because I wrote that code years ago and don't remember

1584222780
TheLemonMan
everything that's not referenced won't be compiled/analyzed at all

1584222786
Kingsquee
I'm not sure if this is a feature or not

1584222800
andrewrk
it has benefits and problems

1584222804
Kingsquee
yeah

1584222825
andrewrk
this is the same problem as conditional compilation that all languages have, but zig has it for every function

1584222825
fengb
Your old implementation checks if there's a null shrinkfn, it'll automatically do a copy expand for realloc

1584222837
TheLemonMan
it's great when you're refactoring a lot of code

1584222855
fengb
I don't think that should be there, only a special case for a shrink realloc

1584222859
TheLemonMan
it's not great when you discover some code path has bit-rotted

1584222879
andrewrk
yeah. it's not considered to be a "closed" part of the language design

1584222896
andrewrk
still an unsolved problem

1584222902
Kingsquee
noted

1584222977
fengb
I'll make my change and have you review it :P

1584222995
andrewrk
fengb, I think I agree with you that it should call realloc on the underlying implementation

1584223046
Kingsquee
oh jeez, namespaced_global.zig

1584223057
Kingsquee
mind = blown

1584223098
TheLemonMan
that's a good title for a talk, "Zig blows (your mind)"

1584223118
Kingsquee
this is going to take some getting used to

1584223141
andrewrk
Kingsquee, zig is a Domain Specific Language for generating machine code. if you think of it this way, it may help

1584223173
adamkowalski
andrewrk: is there some guideline on when anonymous struct literals work and don't work? I've had some issues with them today

1584223201
Kingsquee
andrewrk: what else could one want

1584223202
adamkowalski
I'm getting error: TODO: type coercion of anon struct literal to struct

1584223246
andrewrk
adamkowalski, you can avoid this problem by time traveling until the TODO is implemented, or by using @as

1584223288
adamkowalski
Kingsquee: everything is lazy evaluated, which is great, it speeds up compile times. However, something thats a gotcha is tests wont run if they aren't referenced. So if you look at the standard libraries main file is has to "reference all decls" and then it will force evaluation and run your whole test suite

1584223321
adamkowalski
andrewrk: But is there a guideline on when it will work? In other parts of my codebase I am able to use them

1584223331
Kingsquee
interesting

1584223360
andrewrk
adamkowalski, yes, when the result location has a type

1584223379
adamkowalski
So here is the call site:     const actual = try minimum(f64, &arena.allocator, x, .{});

1584223390
adamkowalski
and the function prototype: pub fn minimum(comptime T: type, allocator: *Allocator, tensor: CpuTensor(T), parameters: ReduceParameters) !CpuTensor(T) {

1584223407
adamkowalski
shouldn't type inference pick up that parameters is of type ReduceParameters

1584223424
adamkowalski
and then the .{} will be implicitly of type ReduceParameters?

1584223427
andrewrk
yes

1584223458
adamkowalski
so does the result location not have a type in this case? I guess I don't understand what that means

1584223485
andrewrk
TheLemonMan, it's pretty neat how the Target feature set can use SIMD as an actually more convenient way to add/remove items from the set righ? :D

1584223511
andrewrk
idk if the codegen is better or worse, but in theory it should pretty much be the same

1584223536
TheLemonMan
hah yeah, that's what pushed me to implement some other missing ops

1584223591
andrewrk
I need to get the skeleton of stage2 figured out, with async I/O and all that good stuff, so that contributors can have something exciting to work on

1584223619
andrewrk
a big milestone recently is that now the std lib tests build with --test-evented-io

1584223624
TheLemonMan
great! the CI fails because of a QEMU bug :(

1584223643
andrewrk
(but they fail at runtime due to an event loop bug - which is good because that's what I want to be working on now)

1584223909
TheLemonMan
andrewrk, do you think it's possible to upgrade qemu in the azure img?

1584223945
adamkowalski
andrewrk: I think there was a break on master last night or today btw./Users/adamkowalski/zig/lib/std/fmt.zig:329:32: error: expected 6 arguments, found 4

1584223962
adamkowalski
return try value.format(fmt, options, out_stream);

1584224012
adamkowalski
but allocPrint still uses the old arguments so it breaks when called

1584224023
frett27
adamkowakski: got the same, if you define a specific format trait

1584224035
frett27
you have to change the signature

1584224038
frett27
of format

1584224045
adamkowalski
of allocPrint?

1584224052
adamkowalski
I guess I can submit a PR

1584224081
frett27
ha, not the same issue

1584224099
fengb
Are you using a custom formatter?

1584224121
frett27


1584224151
frett27
i change a bit some code linked to custom "format" trait changes yesterday

1584224158
Kingsquee
hm, so I tried removing 'threadlocal' from the thread local storage example in the documentation, and I get a "panicked during a panic"

1584224181
fengb
I probably should have worked on a better compiler error :/

1584224201
adamkowalski
fengb: yeah I am

1584224214
adamkowalski
ah it seems like now we just need to pass fmt, options and out_stream

1584224217
frett27
adamlowalski:

1584224227
frett27
yep

1584224228
Kingsquee
I expected random order :I

1584224235
TheLemonMan
Kingsquee, the assertion failed

1584224254
TheLemonMan
when #4731 is merged you'll get a proper error message

1584224270
fengb
Yeah it’s just the compiler could have helped with better detection / messaging. I’ll actually go and add it real quick

1584224291
Kingsquee
TheLemonMan: cool, thanks

1584224315
Kingsquee
we don't have expected value printing for asserts yet either hey

1584224329
Kingsquee
"assertion failed, expected X, got Y"

1584224342
TheLemonMan
assertions expect a boolean expression

1584224352
TheLemonMan
you may want std.testing.expectEqual

1584224445
Kingsquee
"std.debug.panic("expected {}, found {}", .{ expected, actual });"

1584224459
Kingsquee
I guess this is why they call it testing :D

1584224460
adamkowalski
std.testing.expectEqual(expected, actual)

1584224483
Kingsquee
adamkowalski: no, that's the error message using expectEqual gives me

1584224491
adamkowalski
ah

1584224513
adamkowalski
yeah for more complex types I sometimes write my owh expectEqual

1584224515
TheLemonMan
what else should it do? fix the error for you?

1584224533
Kingsquee
TheLemonMan: print what the values of expected and actual are

1584224535
adamkowalski
and if you define formatted printing for your type that can help a lot

1584224545
Kingsquee
it's just an i32 mang

1584224554
Kingsquee
ain't nothin fancy here

1584224556
adamkowalski
it works for most things, unless you are dealing with nested arrays

1584224564
TheLemonMan
... it does ?

1584224578
Kingsquee
TheLemonMan: where

1584224588
TheLemonMan
"std.debug.panic("expected {}, found {}", .{ expected, actual });"

1584224601
Kingsquee
except it actually printed that

1584224603
Kingsquee
not the values

1584224610
adamkowalski
are you sure you're using a real terminal emulator? is the standard out being manipulated at all

1584224617
adamkowalski
in emacs things are a bit fishy

1584224631
Kingsquee
lets see

1584224682
Kingsquee
nope, same thing

1584224696
Kingsquee
lemme paste

1584224708
adamkowalski
use a pastebin, showcase your test case and your output please

1584224788
Kingsquee


1584224803
andrewrk
TheLemonMan, I can look into it. I briefly looked into it before and it seemed difficult

1584224818
andrewrk
it would be nice if more projects just gave you a tarball you could unpack...

1584224872
adamkowalski
Kingsquee: line 15 Test [2/2] test "thread local storage"...expected 1237, found 1235

1584224873
Kingsquee
sorry, forgot to paste testTls, but it just executes `tl_x += 1` like in the example, but without the asserts

1584224892
Kingsquee
adamkowalski: oh man that's hidden in the melange

1584224896
TheLemonMan
Kingsquee, "expected 1237, found 1235"

1584224946
TheLemonMan
what you were pointing to is the stack trace...

1584224996
Kingsquee
in my defense, it's far more visible :v

1584225035
Kingsquee
so expectEqual is actually saying it backwards, based on the params, which is kinda whatever, I'll just reverse them

1584225054
Kingsquee
but when I reverse them I get "error: expected type 'comptime_int', found 'i32'"

1584225077
TheLemonMan
the prototype is expectEqual(<expected>, <actual>)

1584225097
Kingsquee
right, so when I put a literal into expected and variable into actual, it gives that error

1584225110
adamkowalski
if you have a comptime_int use @as(i64, 5)

1584225114
fengb
Yeah the inference is wonky. See also

1584225178
TheLemonMan
eh, it's not much a matter of type inference being wonky, it's because how expectEqual is defined

1584225181
TheLemonMan
`fn expectEqual(expected: var, actual: @TypeOf(expected))`

1584225201
TheLemonMan
so if `expected => comptime_int` actual has to be comptime_int too...

1584225244
TheLemonMan
andrewrk, yeah it seems the only way to do so is to built it by hand

1584225286
Kingsquee
but we can do 'var a: i64 = 5"

1584225300
TheLemonMan
and?

1584225338
Kingsquee
it just seems like by the expectEqual logic we should have to do `var a: i64 = @as(i64, 5)`

1584225342
fengb
Kingsquee: it's because the args match JUnit, but our type inference needs to be the other way around

1584225364
fengb
So we can only do left to right inferencing, and it doesn't work when comptime literals are on the left side

1584225373
TheLemonMan
that's an implicit cast

1584225381
adamkowalski
I think it's fine as is. you want to make sure expectEqual does not implicitly change types

1584225398
adamkowalski
if it's a literal it will be a compile_int/compile_float unless explictily casted otherwise

1584225401
TheLemonMan
5 is comptime_int, the compiler is smart enough to know it fits into a i64 and so inserts the cast for you

1584225408
fengb
I'd prefer if expected is on the right, and a lot of people on that issue agree :P

1584225410
adamkowalski
having to type a tiny bit more is worth having the power of compile time numbers

1584225448
Kingsquee
TheLemonMan: I'd expect typing a literal into something that has an integer type will be the integer type, no exceptions :V

1584225456
adamkowalski
and if you really care, you can easily write an expect equal which accepts two vars and then does the coercion yoruself

1584225467
adamkowalski
it already does that

1584225481
adamkowalski
if you have a function expected an i32 and you pass a comptime_int it will conver it

1584225505
adamkowalski
but in this case the leftmost argument is a comptime int, and so the right argument (which must match the left most argument) will not be known at comptime

1584225519
Kingsquee
ah, I see

1584225542
fengb
It's really just this one function

1584225550
Kingsquee
yeah lets swap dat order

1584225561
fengb
Most of the other times, it resolves as you expect or it's actually ambiguous

1584225671
fengb
I do kinda like Rust's 1u32 syntax though

1584225696
Kingsquee
I prefer its 'as' syntax, frankly

1584225707
Kingsquee
just wish it doesn't some special snowflake for basetypes

1584225750
Kingsquee
in practice I just write my own `.cast<T>()`'s

1584225834
Kingsquee
so when somethings been added to Milestone 0.7.0 or whatever, does that imply it's accepting PR's?

1584225860
fengb
No, it just means it's planning to be worked on for 0.7 release. You can make PRs for anything at any time

1584225894
Kingsquee
ah, so if someone does it before 0.7, we're not in conflict

1584225936
Kingsquee
just means it's graced awrk's bucket list

1584225941
fengb
Right

1584225948
Kingsquee
nice

1584225960
fengb
Or more likely... he'll look at it 2 months before end of release and push it out again >_>

1584225986
fengb
Release features are rather lax heh

1584226014
Kingsquee
HRMMvibratingface.mov

1584226037
adamkowalski
this is a fun error

1584226037
adamkowalski
./src/eager/cpu_tensor.zig:28:9: note: 'error.NoSpaceLeft' not a member of destination error set

1584226040
adamkowalski
) error{NoSpaceLeft}!void {

1584226069
adamkowalski
am I crazy?

1584226100
Kingsquee
there is no space left in the destination error set, ergo you have caused all possible errors across all time and space axis

1584226237
adamkowalski
I think it's because I'm using recursion and the error set is not properly being inferred. I'll keep digging

1584226243
Kingsquee
huh, this is interesting

1584226347
Kingsquee
so without threadlocal storage on the global variable storing 1234, I ran two threads, each incrementing tl_x by 1, and after wait()ing for each thread to finish, I expectEqual'd tl_x to be 1236

1584226359
Kingsquee
in practice I get either 1236 or 1237

1584226408
Kingsquee
I'd expect the thread execution order to be nondeterministic, but the value should be deterministic after the wait()s, no?

1584226438
fengb
I wouldn't expect 1237... but 1235 wouldn't surprise me

1584226452
adamkowalski
andrewrk: In the past you mentioned I could use error{}!ReturnType and the compiler will tell me what to put in. It seems like that is no longer the case? Any Ideas

1584226461
Kingsquee
but it's wait'd!

1584226521
fengb
Oh waiting between each thread?

1584226529
fengb
Anyway... not sure how 1237 came out

1584226543
Kingsquee
oh wait, yeah I messed up

1584226547
Kingsquee
it's 1235 or 1236

1584226553
Kingsquee
hol' up

1584226585
adamkowalski
fengb: do you happen to know any code examples with formatting + recursion after the api change?

1584226603
fengb
(tl_x += 1) => (tl_x = tl_x + 1). No guarantees the assignment will happen directly after the add so it's possible both threads picks up 1234 and adds by 1

1584226613
fengb
And one of the assignments is just clobbered

1584226691
fengb
You should be able to just delete the leading Error and inference would just work

1584226700
adamkowalski
not with recursion

1584226714
adamkowalski
./src/eager/cpu_tensor.zig:53:13: error: cannot resolve inferred error set '@TypeOf(src.eager.cpu_tensor.printTensor).ReturnType.ErrorSet': function 'src

1584226738
fengb
Hmm

1584226747
fengb
@TypeOf(out_stream).Error!void

1584226749
adamkowalski
it's trying to infer the error set, which I'm assuming means following each function call to find the error set and then do the union

1584226767
adamkowalski
and when it follows the recursive call it's realizing it's going into an infinite loop?

1584226789
adamkowalski
Hell yeah!!! that worked, thanks

1584226801
fengb
np

1584226808
fengb
I'll add that to the compile error :)

1584226828
fengb
Maybe I should just add that everywhere in the code. It doesn't need it... but it'll be more obvious looking at the examples

1584226849
adamkowalski
I mean overall it's a much slimmer/cleaner API so I like it

1584226862
adamkowalski
it just took me a second to update to it, so I haven't gotten anything done today haha

1584226880
adamkowalski
I've been adding in all the type names to fix the anonymous struct issue, and then updating the formatted printing

1584226910
fengb
Sure, there's no reason we can't be more helpful (other than I forgot)

1584226959
Kingsquee
fengb:

1584226987
fengb
It runs both in parallel and waits on execution

1584226989
fengb
That's a race condition

1584227004
fengb
Spawn starts the execution. Wait only waits for completion

1584227019
adamkowalski
Kingsquee: Are you sure you don't want to use an atomic

1584227022
adamkowalski
the issue is not the wait

1584227026
adamkowalski
it happens well before then

1584227034
adamkowalski
try to describe what you think is happening

1584227046
Kingsquee
adamkowalski: I'm not very familiar with threading so I very well might

1584227054
adamkowalski
you either need a mutex, or a atomic operation

1584227077
Kingsquee
oh, I guess it makes sense

1584227080
adamkowalski
but yeah I'm curious what you think is happening (at a high level)

1584227088
adamkowalski
then we can figure out how to change the intuition

1584227130
Kingsquee
I'd expect each thread to load the value into a local register, modify it, and then write back to main memory/cache/wherever it is

1584227147
Kingsquee
if they both load at the same time then both values written would be 1235

1584227162
Kingsquee
if they do slightly before/after we'd get 1236

1584227216
adamkowalski
and in your example are you using a thread local variable?

1584227218
fengb


1584227224
fengb
This error message looks pretty verbose :(

1584227224
adamkowalski
just because you call it tl_x doens't make it so

1584227232
adamkowalski


1584227234
Kingsquee
I was half-thinking originally they'd both be working on the same memory location, which obviously isn't so

1584227251
Kingsquee
adamkowalski: I was originally, but then removed the threadlocal keyword

1584227262
Kingsquee
just didn't bother to modify the variable name

1584227278
Kingsquee
wanted to see what would happen

1584227355
adamkowalski
right, so it will "very rarely" be 1236

1584227362
adamkowalski
it has to read the variable in both threads

1584227369
adamkowalski
there is some likelihood it will be 1234 in both

1584227383
adamkowalski
because it tries to read from l1 cache, which will miss

1584227390
adamkowalski
then go to l2, l3 and then main memory

1584227398
adamkowalski
l1 and l2 are not shared per core

1584227408
adamkowalski
it depends on your architecture*

1584227417
adamkowalski
then when you write it writes to cache

1584227428
adamkowalski
it doesn't write just that variable either, but a whole cache line

1584227453
adamkowalski
so what you really want to do is have some sort of syncronization

1584227466
adamkowalski
either use an atomic operation, such as compare and exchange

1584227478
adamkowalski
which will look at the current value, if it matches what you expect then it will do the swap

1584227504
adamkowalski
or you can use a lock, and wait until you acquire it, then do the mutation, release the lock

1584227521
Kingsquee
is there some reading on how atomics actually work?

1584227522
adamkowalski
but the best thing to do is not share memory between threads at all (at least mutibly)

1584227536
Kingsquee
I've looked a little before but it felt very handwavey

1584227547
adamkowalski


1584227551
adamkowalski


1584227564
adamkowalski


1584227576
Kingsquee
yessssss

1584227586
adamkowalski
overall atomics are fairly straightforward in concept

1584227590
adamkowalski
just like in a database

1584227601
adamkowalski
either the whole transaction succeeds or fails in an atomic unit

1584227648
adamkowalski
keep in mind if your goal is increased performance and so you are trying to move to a multi threaded envirnonment, but your solution is to share mutable state between threads, you may very well be slower then a single threaded solution

1584227685
Kingsquee
yeah, that's intuitive

1584227739
adamkowalski
I recommend only sharing immutable data between threads. Or partition the work so that each thread works on a different section of an array and coordination is not required.

1584227758
adamkowalski
Or use a queue and send messages back and forth between threads. but each thread does not share any data between themselves

1584227780
adamkowalski
mutable data + locks and threads is like a stop light at an intersection. Only one direction can move freely at once

1584227806
adamkowalski
prefer on ramps and off ramps of highways which route traffic to different part of the system uninteruprted

1584227921
Kingsquee
wouldn't you need some sort of lock to stop queues from having race conditions?

1584227946
Kingsquee
eg thread1 writes to queue1, thread2 writes to queue1

1584227957
Kingsquee
then again could just have unidirectional queues

1584228000
Kingsquee
only lock then would technically be a 'being written to' flag

1584228068
Kingsquee
perhaps a 'being read' flag

1584228461
adamkowalski
yes the queue would have to be written in terms of locks and or atomics, but it's much easier to get one part of the system correct and tested and then everybody else just benefits

1584228513
adamkowalski
aditionally you could have three queues one for the writer, which is not locked, and is where you can place things when the middle queue is currently locked

1584228537
adamkowalski
one at the reader which the middle queue can write to when the reader is unaviable, as to not lock the main queue

1584228563
adamkowalski
then the middle queue would require a lock, then read from the write queue, and then put onto the read queue

1584228590
adamkowalski
the point is the complexity is managed once rather then dealing with threading everywhere which becomes really complex really fast

1584228857
adamkowalski
Kingsquee: this is a great talk about that

1584230153
Kingsquee
neat, thanks!

