1590193445
leeward
fraktor: read the readme

1590193486
leeward
It's in README.md, under macos

1590193487
leeward
same bug

1590193558
leeward
or, the easy version

1590193563
leeward
fraktor:

1590193756
alexnask
Right this is the fix they were talking about, if you check the option they copy pasted they used W1 instead of Wl (one instead of l) :P

1590199162
hspak
nvim-lsp and zls with more ðŸ’©

1590201208
Kingsquee
I like the poop emoji on the current line

1590207068
pixelherodev
ikskuh: does zpm build or just clone?

1590207245
pixelherodev
"FileNotFound" ugh

1590207289
pixelherodev
Ah

1590207293
pixelherodev
I don't have a /etc/ssl/cert.pem

1590207725
hspak
It seems "openDirList" disappeared in a past few months, is there a replacement?

1590208575
hspak
okay, I see that openDir has changed quite a bit

1590211116
pixelherodev
andrewrk: the args naming of inst.* is kinda confusing when it comes to functions

1590211144
pixelherodev
Because there's inst.args, which is just

1590211540
pixelherodev
Gah, remote zigging the self-hosted work is more annoying

1590211555
pixelherodev
Requires a constantly open terminal and custom commands, since the standard script doesn't work with the in-tree compiler

1590211565
pixelherodev
And while static zig works locally, the self-hosted src rejects it

1590211571
pixelherodev
I guess I'll just keep making do

1590211580
pixelherodev
Still easier than fixing Clang

1590211641
pixelherodev
At least multiplexing makes it easy to manage

1590212087
pixelherodev
Current time to build stage1 for me: 34 seconds

1590212092
pixelherodev
Time to build stage2: 21

1590212103
pixelherodev
Stage1 build is using four cores, stage2 build is using one

1590212113
pixelherodev
Hopefully we can get compile times for stage2 using stage2 to be even lower :D

1590212291
fengb
o_O

1590212541
pixelherodev
Arguably, the stage2 compile is still intolerably slow

1590212556
pixelherodev
It's ~23342 lines plus stdlib, which means just over 1KLoC/s

1590212615
pixelherodev
I've had Rust programs compile at ~50lines per second though, so this is still much better lol

1590212630
pixelherodev
Though, I've had C compiles reach nearly 5KLoC/s

1590212641
pixelherodev
and Zig is supposed to be simpler, so we should be able to exceed that :)

1590212673
pixelherodev
Hmm, should probably reject Windows for now too

1590212679
pixelherodev
It uses a different ABI

1590212685
pixelherodev
(to go back to a different topic :P)

1590212692
fengb
But V can do 1 million lines in <1s

1590212694
pixelherodev
So I'll implement POSIX first, then maybe Windows later

1590212702
pixelherodev
fengb: seriously, please stop :(

1590212711
pixelherodev
trolling is more annoying than anything else

1590212744
pixelherodev
also, LoC/s is more a rough approximation than a useful benchmark

1590212782
pixelherodev
It's not consistent (different programs use different line densities, and some nodes take more time process than others), and it's really easy to cheat on

1590212811
pixelherodev
We could, for instance, write a program using the self-hosted parser (the way ZLS uses it) that extends a program to as many lines as possible :P

1590212816
pixelherodev
s/that/to

1590212822
pixelherodev
s/extends/extend

1590214491
pixelherodev
Okay, wrote a simple test, ZIR parses correctly

1590214501
pixelherodev
Need to function analysis working, then codegen

1590214586
pixelherodev
Ohhh neat

1590214604
pixelherodev
Extra data is stuffed into the Type tag, allowing lower memory to be used for payloads

1590214607
pixelherodev
Clever

1590214766
pixelherodev
andrewrk: currently, machine code is defined internally as align(1)

1590214775
pixelherodev
I think this is an example of something that should be backend-specific

1590214790
pixelherodev
e.g. instead of returning 1, it should return `backend.functionAlignment()`

1590214798
pixelherodev
That allows the backend to expose overrides, too

1590214825
pixelherodev
e.g. GCC has `-ffunction-alignment=32`, which Clear Linux uses on Intel hardware for a performance boost, since Intel CPUs prefer machine code to be 32-bit aligned (even though it doesn't require it)

1590214844
pixelherodev
s/function-alignment/align-functions

1590214860
pixelherodev
Not going to touch that for now though, since my goal here is just to get parameters working

1590215759
pixelherodev
Oh neat, was able to hook up building to a separate script :)

1590221187
pixelherodev
andrewrk: I might end up documenting some internal functions further before finishing implementing function call parameters

1590222184
pixelherodev
andrewrk: given the presence of fnIsVarArgs, I take it ZIR has a low level varargs feature?

1590222203
pixelherodev
What is it used to implement?

1590223259
pixelherodev
For the record, I'm explicitly

1590223263
pixelherodev
That can be added later though

1590224118
pixelherodev
Also assuming only primitives are valid function params in ZIR for now, because I can't find documentation indicating either way

1590224190
pixelherodev
I don't see e.g. a struct type, so I'm assuming they're broken down within ZIR into primitives

1590224210
pixelherodev
andrewrk: Mostly documenting assumptions here so we can go over them later and when you're online you can correct me :)

1590225628
pixelherodev
andrewrk: review of #5411 would be appreciated :)

1590227701
pixelherodev
Half hearted proposal before I go to sleep: there should be a way to make it easier to manage massive structures without exposing everything as public

1590227750
pixelherodev
Maybe something like `@exposeInternals(src, other)` which allows all methods in `other` to access `src`'s private fields

1590227761
pixelherodev
Use case: stage 2 backends

1590227770
pixelherodev
As is, they're all in a single file, codegen.zig

1590227775
alexnask
Lets call it friend :D

1590227796
pixelherodev
(with the exceptions of the Registers, which I added to codegen/ previously, and have refactored into backend/ in my local branch)

1590227805
pixelherodev
alexnask: I don't care what we call it, honestly

1590227813
pixelherodev
The problem is, this isn't scalable

1590227860
pixelherodev
If we add even just one line for each arch per function, that's still hundreds of lines easily

1590227867
pixelherodev
And it's not going to be one line per arch, not by any means

1590227880
pixelherodev
Which means that codegen would grow to be simply massive

1590227890
pixelherodev
Obviously, that's not a practical option, so some form of refactoring is needed

1590227913
pixelherodev
My current idea is to move everything into backend/$ARCH, with a backend/$ARCH.zig file providing common access to the internals

1590227935
pixelherodev
e.g. @import("backend/$ARCH.zig").Register will give the register enum for any given $ARCH

1590227937
gonz_
Private fields? When did this get added?

1590227947
pixelherodev
This is pretty easy to scale, and future devs can more easily add in new targets

1590227950
pixelherodev
gonz_: since 0.6 IIRC

1590227955
pixelherodev
Not fields

1590227956
pixelherodev
functions

1590227967
pixelherodev
Sorry, took me a sec to process that

1590227972
pixelherodev
There are no private fields

1590227988
pixelherodev
... heck, why

1590228003
gonz_
Aha, I figured you either misspoke or this was some crazy thing someone flash-added.

1590228102
pixelherodev
Did I say fields?

1590228106
pixelherodev
ugh I did

1590228107
pixelherodev
Good catch

1590228141
ifreund
private fields make initialization weird

1590228151
alexnask
pixelherodev, I dont really see the issue with the above, just expose what needs to be exposed with 'pub', am I missing something?

1590228204
pixelherodev
No, actually

1590228219
alexnask
Or is the point that just a specific file should be able to access them? ðŸ¤”

1590228222
pixelherodev
alexnask: I'm looking for the proposal that addded private methods

1590228237
pixelherodev
Because now that I think about it, i don't see why all methods aren't automatically pub

1590228257
alexnask
pub -> priv?

1590228269
ifreund
pixelherodev:

1590228283
alexnask
I could live with that personally :D

1590228284
ifreund
but that's just enforcing what the parsing allowed you to do

1590228290
pixelherodev
alexnask: No, I mean there shouldn't

1590228297
pixelherodev
For the same reason there are no private fields

1590228303
pixelherodev
Those were proposed and explicitly rejected

1590228306
pixelherodev
Why should methods be any different?

1590228338
ifreund
pixelherodev: I disagree, fields have the issue of screwing up initialization if there is a non-defaulted private field

1590228346
ifreund
methods don't have that problem

1590228351
pixelherodev
That's not why they were rejected though

1590228355
ifreund
link?

1590228358
pixelherodev
Yeah one sec

1590228370
pixelherodev


1590228406
alexnask
Its useful to use functions and other variable declarations knowing only the implementation can access them

1590228422
pixelherodev
Yes, except that by that logic we should have private fields too

1590228432
pixelherodev
It's useful to the implementer, but I think this is sorta related to the zen of zig

1590228468
pixelherodev
When you're writing a library, it makes life easier

1590228473
pixelherodev
private fields, methods, etc

1590228481
pixelherodev
But, when you're

1590228506
pixelherodev
At the very least, I think we need to be consistent

1590228519
pixelherodev
Either we should get rid of private functions and vars, or we should allow private fields

1590228549
pixelherodev
If we keep private functions, then we get back to what I was mentioning about stage2

1590228564
pixelherodev
While I very much don't think "friend" is a good name, I do think the underlying idea makes sense then

1590228586
pixelherodev
There should be a way of specifying that another module is also part of the implementation

1590228657
WilhelmVonWeiner
yeah private fields really make using libraries annoying when you have to do a minor change in functionality

1590228666
pixelherodev
Right, which is why Zig doesn't allow them

1590228669
alexnask
pixelherodev, THat I can agree withalthough I dont mind the inconsistency between fields and decls wrt pub

1590228691
WilhelmVonWeiner
I hope it doesn't ever allow them

1590228698
pixelherodev
It probably won't

1590228717
pixelherodev
I really think we need something friendly though

1590228721
WilhelmVonWeiner
at work we have a lot of internal builds of typescript libraries because of private crap

1590228763
pixelherodev
Because if a) you should only make functions public if they're to be used outside of the implementation and b) the implementation is massive enough that it's sprawled actoss many files...

1590228769
pixelherodev
s/actoss/across

1590228773
alehander92
overally

1590228785
alehander92
how important is type safety for zig

1590228787
pixelherodev
Sure, you could make every function public

1590228797
pixelherodev
But that defeats the point of private functions entirely

1590228810
pixelherodev
alehander92: I'd say it's extremely important, why?

1590228814
alehander92
i mean it seems to me its more important thatn C

1590228822
alehander92
but e.g. less than rust / haskell

1590228836
alehander92
pixel, just trying to get a feeling

1590228859
alehander92
e.g. the encapsulation and "a motivated programmer can always access etc" from the issue

1590228872
pixelherodev
AFAIK that's true in Rust too

1590228873
pixelherodev
Via unsage

1590228877
pixelherodev
s/unsage/unsafe

1590228897
pixelherodev
I don't know of a single language in which tha's not true

1590228899
alehander92
well .. obviously, but the point is that it's possible to scan for unsafe/completely limit it to 1-2 places in a project

1590228912
alehander92
not really a good comparison imo

1590228927
pixelherodev
Sure, except you can limit it to one place and then call that place everywhere

1590228932
gonz_
alehander92: I don't know that type safety has anything to do with encapsulation, but Zig in general tries to err on the side of compile-time-error vs. run-time-error.

1590228954
pixelherodev
That's true of e.g. java too; you can write a single JNI function that "casts" a value to a different type and then use it everywhere

1590228964
alehander92
well, it doesnt, but the idea of making it impossible for the programmers to do certain things

1590228969
pixelherodev
MyThingy.TerribleIdea(String, int)

1590228973
alehander92
is basically "type safety"

1590228980
pixelherodev
It's not possible to make it impossible

1590228990
pixelherodev
Again, a "motivated programmer" can find a way

1590228997
gonz_
It's no more or less type safe on a base level than f.e. Haskell and in certain contexts more so. You have more static type info in `[5]u8` than you have in `String`, and talking about array lengths in Haskell would be a much more complicated enterprise.

1590229024
alehander92
sorry i didnt want to attack or anything, just trying to compare it

1590229040
alehander92
pixel, good point, but i'd say unsafe functions can be still limited to what they do

1590229040
gonz_
No, I'm just trying to tease out what we actually mean by type safety here.

1590229054
alehander92
e.g. i can have just 2-3 of them which i know that cant change my e.g. fields

1590229055
pixelherodev
^ definitions are really important

1590229075
alehander92
so even if i use them i still know that a certain field is changeable only from e.g. 2-3 places

1590229094
pixelherodev
If it's changeable in any function it's changeable in all of them

1590229102
gonz_
I work with Haskell and I would say the main difference for me when it comes to the base type system is

1590229118
alehander92
pixel but here it goes the private functions thing

1590229144
pixelherodev
Quick question: can you JIT code from Rust?

1590229146
pixelherodev
I assume the answer is yes

1590229158
ikskuh
probably

1590229159
alehander92
gonz_ cool

1590229160
pixelherodev
since it's just mmap()ing + writing to a buffer + calling

1590229175
alehander92
really i am wondering about another thing sorry guys

1590229176
pixelherodev
Then I guarantee you I can break every single one of Rust's guarantees without the compiler being able to detect it

1590229185
alehander92
its : what is the priority for a feature

1590229187
pixelherodev
Which gets back to, again, motivation

1590229200
alehander92
e.g. first safety 2) speed 3) simplicity or 1) speed 2) safety etc

1590229205
pixelherodev
I can write a module that uses a JIT to violate Rust's safety mechanisms

1590229205
alehander92
purely stuff like this

1590229227
pixelherodev
alehander92: I don't think there's any clear-cut guidelines like that

1590229240
alehander92
because after all you dont have dependent types and z3 model checking builtin etc or even borrow checking: some things are less lax

1590229240
pixelherodev
There's more nuance

1590229245
pixelherodev
`zig zen` might be more useful

1590229247
alehander92
which is perfectly fine

1590229263
alehander92
e.g.

1590229270
pixelherodev
Right, but again: if you can dynamically generate code, the compiler can't utilize its model checking or type safety

1590229275
alehander92
if i write a sqlite model or postgresql module

1590229284
pixelherodev
No language that can run a JIT can be 100% type safe

1590229291
alehander92
would it be idiomatic to somehow typecheck the schema/queries on compile time and stuff like this

1590229299
alehander92
or would it be "this it too much we dont do it"

1590229305
pixelherodev
If the schema is known at comptime, then yeah sure

1590229327
gonz_
alehander92: I think that'd be something people liked a lot. I know I would.

1590229355
pixelherodev
The one question is whether Rust allows calling an arbitrary address

1590229360
alehander92
ok, awesome

1590229367
pixelherodev
At least, within "safe" code

1590229377
alehander92
pixelherodev well it seems to me

1590229385
pixelherodev
I'm just thinking to myself actually

1590229385
gonz_
In general putting things at compile-time is generally not really frowned upon, especially since there are obvious limitations on what can be done currently, like allocation, etc.

1590229388
alehander92
it would be obvious for me if i use the JIT in my own rust code

1590229398
alexnask
I dont think it would, this would require a cast from a void or u8 ptr to a fn pointer I would assume

1590229407
pixelherodev
Right, but can you do that in safe code?

1590229409
alexnask
But Im not a rustacean or w/e they call themselves

1590229410
pixelherodev
I don't know Rust all that well

1590229424
alehander92
gonz_ i see

1590229432
alehander92
so can one open files / etc?

1590229441
pixelherodev
No

1590229445
pixelherodev
You can

1590229448
gonz_
You can get file content with `@embedFile`, but not that.

1590229449
pixelherodev
But you can't use I/O at comptime

1590229450
alehander92
ok this makes this idea harder

1590229464
alehander92
ah embedFile sounds almost good

1590229468
pixelherodev
You're not allowed to make syscalls

1590229476
alexnask
Inline assembly is not allowed at comptime as wsell as some pointer aithmetic stuff

1590229479
alehander92
except embedFile ?

1590229488
alexnask
Those are pretty much the two restrictions

1590229510
alexnask
alehander92, Well we provide this specifically as a builtin

1590229519
alexnask
For exactly this reason

1590229592
pixelherodev
alexnask: embedFile doesn't make a syscall

1590229595
pixelherodev
It's a builtin

1590229601
alexnask
(calling non async, non 'unspecidied' calling conventions is probably disallowed too, I should compile some definitive list)

1590229652
alexnask
pixelherodev, Well the compiler does :P

1590229725
alexnask
Syscalls are not allowed by virtue of using inline assembly

1590229734
pixelherodev
Yes, but that's not your code

1590229738
pixelherodev
The compiler can do whatever

1590229746
pixelherodev
Your code cannot make any

1590229750
ikskuh
therer are no syscalls in-language :D

1590229756
ikskuh
syscalls are a user space concept

1590230392
pixelherodev
Unsurprisingly, intToPtr in Rust requires unsafe, which means I don't have to waste time trying to break it :P

1590230439
ifreund
as I understand it, dereferencing raw pointers is the only feature unsafe rust "adds" to normal rust

1590230458
ifreund
and with that one feature you can break everything :D

1590230488
pixelherodev
Pretty sure there's more to it...

1590230500
pixelherodev
Not going to waste time thinking about it though

1590230502
ifreund
as in, all the saftey gaurentees fall apart

1590230670
gonz_
`unsafe` is nice, IMO, and I think it's a neat way to say "Here be dragons" and to silo off stuff that is nastier.

1590230690
gonz_
That doesn't mean Rust is for me, though, but I get what it's trying to do.

1590231020
pixelherodev
I mostly like stage2's code base, but then I have to do something like this

1590231022
pixelherodev
`inst.args.func.cat(ir.Inst.Constant).?.val.cast(Value.Payload.Function).?;`

1590231025
pixelherodev
s/cat/cast

1590231067
pixelherodev
Oh, and add a `.func` after the second unwrap :P

1590231208
pixelherodev
and since the only part I even need is the type, add a `.fn_type` after that :P

1590231225
pixelherodev
inst.args.func.cast(ir.Inst.Constant).?.val.vast(Value.Payload.Function).?.func.fn_type

1590231227
pixelherodev
So readable

1590231229
pixelherodev
:)

1590231231
pixelherodev
/s

1590231235
gonz_
Mmmm

1590231240
ifreund
sounds like this is your chance to make things prettier

1590231241
pixelherodev
s/vast/cast

1590231245
pixelherodev
ifreund: not really

1590231247
pixelherodev
I mean sure

1590231253
pixelherodev
but that would require tremendous reworks

1590231258
pixelherodev
I'm making things prettier in other ways

1590231260
pixelherodev
Simpler ones

1590231261
ifreund
easy for me to say, i know

1590231267
gonz_
Proposal: Change `cast` to `vast` everywhere.

1590231278
pixelherodev
Plus, this actually makes sense as is

1590231288
pixelherodev
It's only that long because I'm accessing specific fields

1590231290
ifreund
it's verbose, but readable imo

1590231298
pixelherodev
It

1590231306
pixelherodev
But i sure as hell won't be the one doing that design work

1590231319
pixelherodev
I do think args needs to be renamed there

1590231337
pixelherodev
I'd say payload, but we're using that already too lol

1590231512
pixelherodev
andrewrk: should I assume (and assert) that ZIR will be well-formed?

1590231518
pixelherodev
e.g. calls have the right number of args?

1590231533
pixelherodev
Or does the analyzer not necessarily check that before the call is reached?

1590231541
pixelherodev
SOrry to add to the backlog of questions I've asked :P

1590231740
pixelherodev
Yay for EEE

1590231838
gonz_
alehander92: If you're feeling unsure of whether or not you should invest time in Zig, I can tell you that the time investment needed for Zig is comparatively very low.

1590231895
gonz_
alehander92: It's a language with a fairly small feature footprint and most of what you'd be learning would likely be useful elsewhere (depending on your existing familiarity with lower-level programming).

1590231996
gonz_
I think one of the biggest blockers for a lot of people is actually that Zig very likely won't have that one C++ feature that someone likes so much. It's just not possible to have a language be small and still add everyones' pet features.

1590232020
ifreund
yeah i definitely agree with that. If you've spend any time at all writing C, learning Zig should be a breeze

1590232055
pixelherodev
whelp, I'm actually heading to sleep now

1590232070
ifreund
pixelherodev: nice, it's afternoon here :P

1590232072
pixelherodev
Should be able to get callconv(.C) calls working tonight though, I have it mostly odne locally

1590232078
pixelherodev
ifreund: it's seven here

1590232080
pixelherodev
AM

1590232082
pixelherodev
s/odne/done

1590232085
alexnask
Gnight :-)

1590232093
ifreund
yeah that's about what I was guessing for the US

1590232123
pixelherodev
Just need to go over the x64 ABI once again, implement arg clas processing (INTEGER,MEMORY,SSE,etc), load to appropriate place, and actual call

1590232132
pixelherodev
But the analysis and such is all in place

1590232144
pixelherodev
Then I need to add more tests

1590232157
pixelherodev
Make sure it fails when given nonsense (e.g. calling with wrong types, incorrect number of args, etc)

1590233474
alehander92
gonz_ hey i am mostly interested as lang design enthusiast: i want to learn more about some languages/concepts and apply that eventually

1590233521
gonz_
alehander92: All right. From that perspective I think the choice to use `comptime` for a lot of usually disparate features is probably the most interesting aspect of Zig.

1590233531
gonz_
It unifies a lot of concepts under one umbrella.

1590233540
alehander92
i am mostly in the nim community currently, so i have to add the disclaimer that i might try to apply some lessons there but i just like some of zig's ideas and enthusiasm and tooling

1590234143
alehander92
yeah i am mostly interested in generics using it, also in error checking and also in the IC/parallel compiler tooling: as i am trying to do something similar(ic/parallel tooling, using error-type-like libs for some things and a lot of macro stuff), so i want to be honest about my motivations :D

1590234194
alehander92
but i just enjoy bikeshedding/random discussions mostly :D ( i'd love to write a lib/or help with stuff i become a bit more familiar though)

1590234212
alehander92
anyway, time to do some other stuff, see ya these days, thanks for the tips

1590234226
gonz_
You're welcome, have a good one :)

1590234485
cren
Why does std.fs.Dir have a close method?

1590234526
cren
Do I need to close any instances I instantiate?

1590234530
ikskuh
yes

1590234537
ikskuh
you keep an handle to that dir

1590234554
ikskuh
this also means that you have the guarantee that this directory will exist as long as you have the handle

1590234647
cren
Ok, thanks. Also, I'm sure that this must be documented somewhere, but I can't find it: how do I raise an error?

1590235241
ikskuh
you don't

1590235249
ikskuh
return ErrorUnion.ErrorName;

1590235255
ikskuh
or for implicit errors:

1590235259
ikskuh
return error.ErrorName;

1590235287
ikskuh
your function has to return ErrorSet!ReturnType or just !ReturnType for implicit error set

1590235397
cren
Is there documentation of all the available errors and error unions?

1590235496
alexnask
You can return arbitrary errors. Most std stuff defines explicit error unions that you can look up in the std docs or in the source code

1590235523
alexnask
For example

1590235524
alexnask


1590235545
alexnask
You can see a list of the possible errors returned

1590235725
cren
When you say I can return arbitrary errors, do you mean I could just make up some new errors for my program that never existed before?

1590235747
gonz_
Yes.

1590235762
cren
Then how does the compiler know that that's a valid name for an error?

1590235774
gonz_
`return error.ErrorSpecificToThingThatIAmMaking;`

1590235787
cren
What's `error` in that context?

1590235831
ikskuh
error is a keyword you can use for two things:

1590235834
gonz_
To my mind just a way to say that this is an error.

1590235845
ikskuh
const ErrorSet = error{NotAFile,InvaldFormat};

1590235853
ikskuh
this specifies a new error set

1590235857
ikskuh
you can also use

1590235859
ikskuh
error.Foo

1590235864
ikskuh
which is equivalent to error{Foo}.Foo

1590235872
ikskuh
which is an error set with a single value

1590236395
cren
That makes sense now, it was the existence of error as a keyword that I was missing

1590236424
cren
I am still struggling to understand

1590236449
ikskuh
they are a better version of error enums

1590236457
ikskuh
you can merge error sets

1590236462
ikskuh
or split them with a switch

1590236466
cren
But why would I need to have a set of errors? Why not just one?

1590236489
ikskuh
"just one error" means you can only return "an error happened" or "no error happend"

1590236504
ikskuh
error sets are "these errors may happen in this function"

1590236526
ikskuh
do you know checked exceptions from java?

1590236532
cren
No

1590236539
ikskuh
okay

1590236543
ikskuh
what error handling techniques do you know?

1590236545
cren
My only experience with exception handling is Python

1590236547
alexnask
FileNotFound is not the same failure as AccessDenied

1590236570
alexnask
You will want to handle different failure conditions differently

1590236576
cren
alexnask: I get that. Is the idea then to return

1590236588
ikskuh
that cannot happen

1590236600
cren
That's what I was feeling, which is why I am confused

1590236603
ikskuh
Either the file does not exist

1590236603
alexnask
^ "error set" means a collection of possible error conditions in this context

1590236610
alexnask
Not a set of errors returned

1590236616
ikskuh
you always return one error FROM an error set

1590236625
ikskuh
you don't return a set of errors

1590236628
alexnask
As in multiple errors (if that makes sense)

1590236638
cren
Ah I get that now

1590236645
ikskuh
an error set just states:

1590236655
ikskuh
"one of these errors may happen when invoking the function"

1590236721
cren
Okay. So what is going on with the definitions at the top of the first example here:

1590236792
alexnask
These define error set types, you can then use them in error unions, eg. `fn open(path: []const u8) FileOpenError!fd_t { ... }`

1590236866
alexnask
They are not collection of values, you can think of them pretty much like enums

1590236887
alexnask
collections*

1590236916
cren
So, by declaring that `open` will return either fd_t or one error from `FileOpenError`, you're telling the compiler that if an error is returned, it will be one of the three from FileOpenError

1590236938
ikskuh
yes

1590236951
ikskuh
but even more: you're telling it the user

1590236959
ikskuh
wonderful example:

1590236969
ikskuh
open("foo") catch |err| switch(err) { }

1590236979
ikskuh
will give you compile errr of which switch entries are missing

1590236979
alexnask
This allows the user to catch the error, switch on it and get a printout of all possible errors from the compiler :D

1590237112
cren
Surely you would know that already from the docs

1590237165
gonz_
And when someone forgets to change the docs after they add an error?

1590237172
alexnask
Compiler enforced > docs. Also if e.g. an error is added or removed

1590237220
cren
That's interesting. I've always treated the docs as a reliable source of  truth.

1590237227
gonz_
To: everyone@coolco.com\nSubject: I added an error, please check your code to see you're handling it.\n\n

1590237263
alexnask
Sure high quality docs are good, the compiler systematically checking for you is the strongest guarantee though

1590237301
cren
I totally get that. It's probably related to the differences in guarantees of behaviour that you need between a systems language like Zig and a dynamic language like Python

1590237359
gonz_
C doesn't guarantee exhaustiveness checks (though I guess some compilers do it nowadays?). It's more an issue of modern expectations, I think. Exhaustiveness checks for enums, tagged unions and error sets are invaluable to me.

1590237364
gonz_
I can't imagine designing without them.

1590237391
cren
gonz_: what sorts of programs do you design?

1590237519
gonz_
To be clear, I'm talking about modelling domains, etc., not physical/artistic design.

1590237624
gonz_
As for which programs I'm making with Zig, it's currently a game engine + UI stuff, some interpreters, etc.

1590237663
afontain_
gcc can do it, -Wswitch plus -Wswitch-enum if you want a warning even if you did put a default case

1590237672
gonz_
Mhm

1590237692
afontain_
clang has similar options, maybe the same do work too

1590237696
gonz_
What I'm getting at is that it's not so much a "we need this for systems programming" thing but rather a modern toolset kind of thing.

1590237714
gonz_
If anything, this kind of guarantee is more popular in ML derivatives

1590237734
alexnask
Btw, if anyone is writing libraries and putting them on github, you should use the zig-package tag

1590237777
ikskuh
+1

1590237779
alexnask
That way ikskuh's tool zpm can detect them :) Just a PSA

1590237824
gonz_
Thanks for the heads-up.

1590237852
gonz_
Added it to `zig-win32` now

1590237872
alexnask
zig-win32 appeared :D

1590237909
gonz_
I might make my sqlite lib public soonish as well, I guess.

1590238024
gonz_
Ah, `zig-humantime` still compiles with newer versions as well, may as well have that out there.

1590238036
gonz_
Though it's bordering on `npm`-level package.

1590238075
cren
What do you mean by `npm`-level? Too simple, like `left-pad`?

1590238108
afontain_
zig-humantime is one way only, right?

1590238169
gonz_
Yeah. It has two functions, "seconds" & "milliseconds", which take human readable time strings ("1h3m6s", etc.) and return the corresponding second/millisecond value.

1590238194
gonz_
And it indeed goes only one way, so you can't go from seconds/milliseconds to human readable

1590238215
alexnask
lepto.zig (which will prob become chrono.zig when it has some more features) will provide formatting and parsing as well (and timezones, calendars etc) but it only has timepoitns and durations for now

1590238223
gonz_
Obviously you could, but I've only ever needed this way

1590238281
alexnask
(strftime-style)

1590239559
afontain_
gozn_, thanks for confirming. It's probably simpler the other way around anyway

1590239602
gonz_
Just to be clear, I wasn't disparaging someone else when I said it was `npm`-level.

1590239611
fengb
Best packages are one liners ðŸ™ƒ

1590239621
gonz_
It's my package, so I'm just calling it like it is.

1590239825
fengb


1590239834
fengb
Hereâ€™s the king of npm stupidness

1590240196
greenfork
fengb, what does this script do?

1590240211
fengb
Downloads 10 other packages

1590240251
fengb
Also nominally does 1 thing but this is the perversion of the npm ecosystem

1590244063
gonz_
fengb: :D

1590244455
greenfork
is it expected behavior that program hangs when using evented io_mode with multiple threads? any specific reason why it doesn't hang while in --single-threaded?

1590244722
alexnask
greenfork, no it should work in multithreaded mode, what os/arch are you running?

1590244802
greenfork
alexnask, I might have said it wrong, it works. But I don't understand why with empty `main()` it doesn't quit when using multiple threads

1590244838
greenfork
I'm on x86_64 linux, everything should be alright

1590244872
alexnask
Hmm I remember this was a bug at some point but I thought it was fixed

1590244909
alexnask
(the loop wasnt doing finishOneEvent in the start code or something like that)

1590244950
greenfork
okay, thanks

1590246294
fraktor
So when main returns, it doesn't stop the other threads?

1590246318
fraktor
Most of the coroutine stuff I've done is in Go, which does stop the other coroutines.

1590246449
greenfork
seems so, I found this issue, probably related

1590247120
oats
does valgrind only work on zig programs if you use the C allocator?

1590247244
ikskuh
yes

1590247263
oats
aww

1590247339
ikskuh
but you can do something like that yourself :)

1590247349
ikskuh
theres a LeakCountAllocator

1590247406
oats
it's in testing, huh

1590247421
oats
ok to use as the main allocator? or should it be reserved for testing

1590247537
ikskuh
it's just a wrapper allocator

1590247542
ikskuh
it passes through data

1590247551
ikskuh
but will count allocation/free count

1590247571
oats
oh!

1590247573
oats
neat

1590247934
alexnask
You can use this if you are interested in some more info:

1590247958
oats
I love this idea of allocator wrappers, such a neat thing

1590247986
alexnask
You should check out #5151 PR then :D (generic composable allocators)

1590247992
oats
though I wonder if there's a way to get valgrind to understand other allocators

1590248637
fraktor
oats: If you wrap the C allocator in another allocator valgrind correctly recognizes it

1590249168
fraktor
There's also some valgrind stuff in the standard library, but it might need some more documentation first.

1590251567
andrewrk
it drives me nuts when people talk about RAII without explaining exactly what they mean

1590251591
andrewrk
are they talking about c++? c++ resource management is completely broken, constructors are not even allowed to fail

1590251602
andrewrk
so then what? where is this magical RAII paradigm

1590251637
companion_cube
so don't use constructors, use a function

1590251645
companion_cube
Drop in rust works pretty well

1590251666
andrewrk
yeah rust's Drop works well. but I don't hear Rust people saying "RAII". they just say Drop

1590251681
andrewrk
if you use a function in c++ then you're not doing RAII

1590251706
companion_cube
they definitely say it's RAII when talking to C++ people :)

1590251713
companion_cube
a function that does the checks and calls a constructor

1590251749
companion_cube
(like in rust, since after all rust doesn't have constructors at all; RAII is purely about destructors)

1590251868
andrewrk
so you have a c++ function which gets the resource, calls the constructor, and then what, returns it? invoking the copy constructor?

1590251885
andrewrk
this is so clunky

1590251920
andrewrk
why would you copy something just to initialize it

1590251934
companion_cube
ah, well, that's the lack of move semantics by default

1590251945
companion_cube
(I won't argue that C++ doesn't suck! :D)

1590252210
gonz_
andrewrk: Ah, you found the zig "Why Zig..." thread on proggit, I see. :D

1590252221
andrewrk
:)

1590252223
gonz_
"Does it have RAII? No? I'm not interested"

1590252238
gonz_
Oh, well :D

1590252242
andrewrk
"Is it C++? No? I'm not interested."

1590252413
nephele
Only a C++ compiler :)

1590252418
companion_cube
it's more like "does it make doable to use refcounting?" :)

1590252480
alexnask
Dont you know the exact subset of C++ I use is the best language?

1590252483
gonz_
SFINAE, RAII, what other ridiculous acronyms have been invented by <only language to come up with these>?

1590252491
alexnask
Nvm any library I call into may do whatever it wants

1590252614
ikskuh
andrewrk: [c++] constructors are not even allowed to fail

1590252622
ikskuh
they are

1590252653
ikskuh
it's not adviced by the core guidelines to make constructors that leave half-valid objects

1590252661
andrewrk
but in C++, constructors throwing exceptions is considered to be bad practice, and many people use -fno-exceptions

1590252688
ikskuh
yeah, there's several fractions on that

1590252695
andrewrk
if you make a library, using exceptions disqualifies the library from being used in any application that uses -fno-exceptions

1590252698
companion_cube
factions* ? :)

1590252704
ikskuh
yeah :D

1590252711
ikskuh
also: community fractions! :D

1590252751
ikskuh
well-made C++ raii with exceptions works

1590252772
ikskuh
but unchecked exceptions are hell

1590252773
companion_cube
same in rust, I should say

1590252791
companion_cube
Drop works well with generics, imho it's why it's so useful

1590252796
companion_cube
(it composes)

1590252802
ikskuh
imho rusts pattern is RAII as well

1590252822
ikskuh
don't know how well-made it is in practise, though

1590252864
companion_cube
yeah, it is RAII, and seems to work pretty well (it does for me)

1590252874
companion_cube
also makes Arc/Rc a breeze

1590252919
ikskuh
zigs memory management is often also pretty RAIIesque

1590252940
ikskuh
where you have constructors that may fail (Foo.init()) and destructors Foo.deinit()

1590252949
ikskuh
but you can reuse the resources after that

1590252953
companion_cube
but it doesn't compose well in generics (unless you always call `x.deinit()` or something?)

1590252960
ikskuh
so it has storage separated from lifetimes

1590253006
companion_cube
yeah, I guess you can do it in rust with std::mem::swap but it's a bit hackish

1590253062
gonz_
companion_cube: Part of this rests on the idea that allocation can never fail, though.

1590253082
companion_cube
part of what?

1590253092
gonz_
Or at the very least the C++ version of it does

1590253095
companion_cube
(RAII is more assuming that deallocation can never fail)

1590253118
ikskuh
gonz_: c++ does not assume that allocation may never fail

1590253121
ikskuh
people do, though :D

1590253134
ikskuh
new throws a std::bad_alloc when it fails

1590253146
ikskuh
if you use no exceptions, it returns nullptr

1590253641
leeward
Doesn't the new keyword in C++ throw an exception?

1590253646
leeward
I can read.

1590255370
gpanders
Hi all, from the Zig docs referring to using an arena allocator for a command line application (item 4 under Choosing an Allocator) it says "When using this kind of allocator, there is no need to free anything manually. Everything gets freed at once with the call to arena.deinit()". Does that mean that when using this allocator I should not include "defer allocator.free()"s or "defer

1590255372
gpanders
array_list.deinit()"s, etc. in my code? Or should I still include those things to keep my code idiomatic? This is more of a "best practices" question than anything really

1590255413
ikskuh
arena allocators are pretty simple:

1590255423
ikskuh
you create a new arena allocator and allocate memory with that

1590255436
ikskuh
if you don't need that memory anymore, you deinit() that arena

1590255441
ikskuh
and all of its memory is released

1590255460
ikskuh
this is pretty nice for temporary data

1590255518
ikskuh
but you should deinit() your arena

1590255577
karchnu
ikskuh: so its a way to deinit all unnecessary memory in a single function call? Yep, sounds kinda nice.

1590255592
ikskuh
yeah

1590255614
gpanders
I'm more curious about what it means to write good Zig code when using an arena allocator. I am writing a command line tool that instantiates an arena allocator in main() and then passes it around to the rest of the application. Throughout the rest of the code I allocate other memory, e.g. in array lists or dynamically allocated strings. My understanding is that it is best practice to always match an

1590255616
gpanders
allocate with a deferred free -- but since that is not necessary with an arena allocator, should I still include those defers, or simply omit them? The arena allocator is always deinit()'d at the end of main()

1590255643
ifreund
i'd omit them

1590255645
ikskuh
example usage (which i consider good):

1590255658
ikskuh
i require some temporary strings there to assemble a path

1590255664
ifreund
freeing memory is important for long-running processes

1590255667
ikskuh
and using the arena makes that code less cluttered

1590255697
ikskuh
but if you get passend an allocation into a function, never assume something about that allocator

1590255703
alexnask
Its also a pretty common pattern for std to return data structures that use an arena to allocate all their memory and call its deinit when deinited

1590255736
alexnask
E.g. the json ValueTree

1590255842
alexnask
(or the zig ast tree)

1590255860
gpanders
thanks for the example ikskuh, it's useful to see real Zig code "in the wild"

1590255911
ikskuh
you're welcome

1590256394
andrewrk
yeah json ValueTree is a great use case

1590256414
andrewrk
parsing a json payload requires many small allocations that all have the same lifetime

1590256461
andrewrk
it makes it a lot easier to write code that behaves correctly under error conditions

1590256491
andrewrk
the self hosted parser test harness actually tests every possible memory allocation failure case and makes sure no leaks happened ever

1590256507
ikskuh
andrewrk: wow, nice!

1590256522
fraktor
Honestly custom allocators and `defer` are one of the core things I like about Zig. It makes manual memory management actually feasible.

1590256536
andrewrk
it's not even that hard to set up:

1590256555
ikskuh
i noticed that std.json.Parser.parse actually leaks a single allocation somewhere

1590256752
andrewrk
might be nice to set up a similar test harness

1590257022
fraktor
So this might be a stupid question, but I notice that a lot of issues focus on optimization of the stage1 compiler.  I understand fixing bugs in it, but why add new features or improve already-adequate code generation in stage1 when stage2 is being worked on?

1590257060
r4pr0n
well stage1 should always be able to compile stage2

1590257076
r4pr0n
and if you don't add new features you can't use them for the stage2 source code

1590257124
fraktor
Yes, that's true.  I should clarify that I'm mostly talking about optimizations (one that I saw is that defer is generating a lot of code in some cases).

1590257321
ikskuh
fraktor: Even if stage1 isn't meant to be good, it's still a really good thing to know (and document) all the problems with the current code generator approach

1590257443
fraktor
Okay. That makes sense. thanks

1590258260
andrewrk
fraktor, many of those issues will never become a problem with self-hosted because they were discovered in stage1, and therefore will be deprioritized or possibly even closed

1590258287
andrewrk
but until we have something shipping that has the problem solved, it's important for it to be an open issue

1590258290
fraktor
Okay. So they're more for documentation purposes than for determining what will be developed in stage1.

1590259666
dongcarl
Hi all, any documentation on the zig build system yet? I see it's TODO on the latest docs

1590260591
ifreund
dongcarl: not really, but I'm sure folks here would be happy to help out

1590260614
ifreund
if you don't know already, zig init-exe or zig init-lib will get you started

1590260810
andrewrk
stabilization of the build system will probably be one of the last things to stabilize

1590261583
pixelherodev
Did I get pinged at any point recently? Because the buffer is highlighted with the "you were pinged!!!" color but I'm looking through the buffer and I don't see one...

1590261607
pixelherodev
meh

1590261696
pixelherodev
andrewrk: did you see my notes in this channel?

1590261935
pixelherodev
andrewrk: let me know when you're available to discuss stage2 some more :)

1590261945
pixelherodev
I'm going to add more to the draft PR

1590262004
andrewrk
I'm trying to finish up this branch, and then I have some chores to attend to, then I'd be happy to discuss

1590262029
andrewrk
I underestimated how much effort it would take to update translate-c with the new AST API

1590262044
pixelherodev
Sounds good :)

1590262049
pixelherodev
Ah, yeah, I get that

1590262085
pixelherodev
I had a similar but smaller-scale annoyance backporting my stage2 codegen Register stuff over to Lightzing

1590262095
alexnask
I should get around to start porting zls on the new ast branch too

1590262158
andrewrk
alexnask, I think the API changes are done in the branch, and they should be simple enough to update to for ZLS. everything is still arrays with slightly different ways to access them

1590262169
andrewrk
the good news is that parsing speed is doubled

1590262174
alexnask
Nice!

1590262186
andrewrk
and memory usage is cut down quite a bit too

1590262187
alexnask
Cool I will finish fixing a couple of bugs then start adapting :)

1590262195
alexnask
We do tell ppl to use zig master after all

1590262219
alexnask
Wouldnt want to tell ppl to use some commit between 0.6.0 release and master :P

1590262225
andrewrk
ha yeah

1590262297
mq32
'*const [10:0]u8', found '[]const u8' shouldn't that coerce?

1590262364
andrewrk
the type system cannot be sure that the runtime-known length will be 10

1590262379
andrewrk
also the sentinel does not match

1590262395
andrewrk
the other way coerces

1590262406
mq32
andrewrk: but this was a

1590262412
mq32
foo.bar orelse "text"

1590262431
mq32
shouldn't that coerce to @TypeOf(foo.bar) ?

1590262442
andrewrk
yes probably. hard to say without more context

1590262474
mq32
okay, i worked around it

1590262489
mq32
const lic = pkg.licence orelse "no licence";

1590262489
mq32
works

1590262497
mq32
.{  pkg.licence orelse "no licence" } does not

1590262532
mq32
seems like the peer type analysis in anonymous structs is different?

1590262535
andrewrk
ahh the good ol' assign-the-thing-to-a-const workaround

1590262541
mq32
:D

1590262544
mq32
also

1590262580
mq32
.{  pkg.licence orelse @as([]const u8, "no licence") } will yield error: cannot store runtime value in compile time variable

1590262653
andrewrk
I'm going to be sure to solve all these edge cases up front in self hosted

1590262791
mq32
yah

1590262801
mq32
focus on stage2 as muc as possible :)

1590262928
pixelherodev
stage2 = <3

1590262935
pixelherodev
I'm so glad I can finally contribute to the compiler :)

1590262951
pixelherodev
I was... not all that willing to touch C++ even for this

1590262952
pixelherodev
:P

1590263441
gonz_
This seems like mission accomplished for stage 2, then

1590264029
andrewrk
the one last thing that is tripping me up in translate-c, is that some functions append their ast nodes to the containing block node and then return the containing block node (??) instead of the new AST node

1590264041
andrewrk
I wonder if anyone around here knows why that is the case

1590264114
andrewrk
hmm you know what I can do, is just comment out the code and put @panic in there and see what test cases fail

1590264142
andrewrk
then I'll have some context to understand why

1590265874
andrewrk
it's such a weird feeling when the friggin thing compiles after days of errors

1590265888
andrewrk
there's no light at the end of the tunnel, it's just darkness for days and then all the sudden everything works

1590266003
ifreund
it always takes me a minute to actually believe that it worked too

1590266015
mq32
andrewrk: yeah, unreal feeling

1590266023
mq32
but also a great feeling when the code doesn't crash

1590266029
ifreund
i assume that somethings still broken and i haven't found it yet

1590266032
alexnask
Then comes all the fun of debugging

1590266067
andrewrk
yes I'm about to find out how much havoc I have wreaked on translate-c

1590266091
andrewrk
I do expect it to be faster, however. I'll add a benchmark for it to gotta-go-fast before merging

1590266096
andrewrk
oh. I already did

1590266111
andrewrk
I meant I will add a benchmark for zig fmt before merging

1590266207
ifreund
I kinda want to try my hand at #1499 once stage2 is a little farther along. I'd have to learn a ton to implement that, but it'd be worth doing

1590266236
ifreund
it's because of this issue that i'm still using a glibc based system

1590266352
karchnu
andrewrk: I saw on youtube that you expect to drop C support in v2, do you really think you will get to the point you won't let an optional dependency to LLVM for mixed C-Zig code? I surely don't expect the end of C anytime soon (not even in 20 years).

1590266434
andrewrk
karchnu, I'm not sure what you're referring to, can you be more specific about "drop C support"?

1590266507
ifreund
pretty sure translate C is still going to be part of stage2

1590266562
karchnu
andrewrk: drop the LLVM support. It may only be related to the `zig cc` functionality, but I guess it is also used for being able to import C code.

1590266594
andrewrk
karchnu, the plan is for LLVM/Clang/LLD to be optional dependencies, which enable more features

1590266720
karchnu
ack

1590266808
mq32
btw i really love that plan :)

1590266924
gonz_
Heh, drop C support. That'd be something, given the stated goals of the language.

1590266990
andrewrk
one day, the new generation of students will wonder why the zig language specification has this weird optional extension regarding this "C" thing

1590267018
karchnu
Nice, I'm not the only one with this feeling.

1590267086
gonz_
To clarify, I was being a bit sarcastic. I don't know exactly what gave the impression that C was going anywhere, but I'm fairly confident this is just a misunderstanding.

1590267242
alehander92
haha

1590267277
alehander92
bam 2070 happens and people code in 3d visual programming dialect of python

1590267286
pixelherodev
If that happens I will literally start a revolution

1590267306
pixelherodev
"You will have my Haxe!"

1590267311
pixelherodev
(sorry)

1590267327
mq32
I cannot take Haxe as a name serious

1590267331
pixelherodev
oh wait dammit it's the other way around, "And my axe!"

1590267336
pixelherodev
mq32: neither can I

1590267338
pixelherodev
but

1590267344
pixelherodev
name one other lang that fits in that joke

1590267344
alehander92
no idea what it means

1590267353
mq32
pixelherodev: Schweins-Haxe is [knuckle of ham]

1590267364
pixelherodev
I was making a reference to LotR :P

1590267418
pixelherodev
"You will have my Go!"

1590267422
pixelherodev
There, that's better

1590267423
mq32
^^

1590267433
gonz_
And my VAX

1590267438
gonz_
:|

1590267455
mq32
I'm anti-VAX, no DEC for me!

1590267473
pixelherodev
Ahh, that's a good one gonz_ :D

1590267537
gonz_
I guess most of us are too young for VAXs. I feel old but not that old :D

1590267611
pixelherodev
andrewrk: does ZIR not support iN/uN?

1590267633
pixelherodev
I only see u8 and usize...

1590267721
pixelherodev
Ahh, never mind

1590267725
pixelherodev
int_signed / int_unsigned

1590267741
pixelherodev
{u,i}{8,size} are for reducing memory usage of common types?

1590267938
pixelherodev
No c_char type? I'm guessing we just use u8 for that always?

1590268012
pixelherodev
Hmm, slices need to be split into two parameters, ptr + len, which are both INTEGER class

1590268018
pixelherodev
Should be pretty straightforward though, I hope

1590268035
andrewrk
pixelherodev, not all the type/value representations are added yet

1590268053
andrewrk
it's worth it to take some time to understand how those 2 files work, type.zig and value.zig

1590268063
andrewrk
I think it will make sense once you take a look

1590268086
andrewrk
the idea here is twofold: (1) reduce memory usage (2) avoid the requirement of shared state, to facilitate multi threading

1590268126
pixelherodev
andrewrk: I've been doing that :)

1590268144
pixelherodev
Had to go over them to implement analysis of function argument types, for instance

1590268151
pixelherodev
Took more of a look while I was there

1590268161
pixelherodev
Oh, and I

1590268163
pixelherodev
I forgot about that :)

1590269559
pixelherodev
andrewrk: is there any quick "get target pointer size" utility?

1590269655
andrewrk
`@divExact(target.cpu.arch.ptrBitWidth(), 8)`

1590269671
andrewrk
feel free to make a local helper function for it where necessary

1590269683
andrewrk
e.g. on Function in codegen.zig

1590269703
andrewrk
whatever makes sense to you

1590269926
pixelherodev
Ahh, didn't know arch had that

1590269927
pixelherodev
Thanks :)

1590269945
pixelherodev
Trying to figure out the best way to get an arbitrarily sized integer Value as a u64 for codegen

1590270007
andrewrk
toUnsignedInt()

1590270014
andrewrk
however it asserts that the value fits in u64

1590270038
andrewrk
so you have to have emitted a compile error or otherwise not be in this control flow if that is not the case

1590270062
pixelherodev
That doesn't seem to support usize though

1590270064
andrewrk
if the type is unsigned and 64 bits or smaller, then you can be sure that check has already happened

1590270067
pixelherodev
Which is why I was looking for pointer size

1590270080
pixelherodev
Thinking of adding .usize => if (fits_in_u64) as_u64 else unreachable

1590270084
andrewrk
I see. Currently it is assumed that u64 is >= pointer size

1590270104
pixelherodev
Okay, I'll just keep with that assumption then

1590270112
andrewrk
I'm ok with reworking some of the logic if that ends up not being true in the future

1590270165
andrewrk
also remember not to get usize in the compiler code mixed up with usize of the target!

1590270180
andrewrk
a 32 bit compiler should be able to produce 64 bit binaries

1590270184
andrewrk
and vice versa

1590270216
pixelherodev
Right, I know :)

1590270470
kushalp
I am trying to write a basic NTP client in Zig. I know how to do this in ~100 lines in C but trying to things as Zig intended. I'm struggling at my first hurdle: using "try". I'm seeing the following error: expected type 'void', found '@TypeOf(std.net.getAddressList).ReturnType.ErrorSet'. Any ideas what I'm doing wrong? The line in question is this: const address_list = try std.net.getAddressList(&arena.allocator, hostname,

1590270470
kushalp
port);

1590270500
pixelherodev
ZLS still eats CPU sometimes :(

1590270518
andrewrk
kushalp, looks like you are perhaps using `try` in a function with a `void` return type

1590270548
andrewrk
`try` means "return the error if any" so the return type has to take that into account

1590270613
ifreund
tldr: make it return `!void`

1590270772
fengb
I still read that as not void

1590270832
ifreund
|void would make more logical sense but | is already quite overloaded

1590270897
fengb
Hmm why is exclamation == not?

1590270949
ifreund
no idea, why is ^ xor? why is | or?

1590270980
ifreund
i guess our forefathers just chose whatever symbols they weren't already using for something

1590271019
kushalp
Oh, interesting. I think that's because of how I'm using main: pub fn main() void {

1590271053
ifreund
yeah, my main usually returns !void

1590271066
fengb
Conjunction: the symbol âˆ§ appeared in Heyting in 1929[2] (compare to Peano's use of the set-theoretic notation of intersection âˆ©[5]); & appeared at least in SchÃ¶nfinkel in 1924;

1590271095
gonz_
Algol60 had proper notation for these things AFAIK

1590271099
fengb
I think we inherited a lot of those operators. Except I canâ€™t find the history for !

1590271102
gonz_
Not the ASCII "We have symbols at home" kind

1590271145
fengb
Mostly annoyed because ! is universal (American?) symbol of error and itâ€™s more natural to be an error

1590271166
gonz_
There's a surprising amount of "right" in ALGOL, actually. You'd be surprised how many things they made worse *after*.

1590271219
companion_cube
/\ and \/ wooo

1590271219
gonz_
Or maybe you wouldn't be surprised, I don't know. :D

1590271220
fengb
We shoulda kept the EE gates as symbols :P

1590271264
andrewrk
wow, I'm down to 1 remaining translate-c test case failing. so far the debugging has been very straightforward

1590271277
pixelherodev
Nice :_

1590271278
pixelherodev
:)*

1590271282
pixelherodev
I just got the test passing!

1590271290
ifreund
woot!

1590271293
andrewrk
this is incredible. I completely changed the API that a complex, 6,000 line file was using all throughout. it took 3 days just to work through compile errors

1590271296
pixelherodev
Calling a `fn void(usize) callconv(.C)`

1590271297
pixelherodev
:)

1590271305
andrewrk
but I've spent all of 1 hour doing easy debugging and nearly all tests passing

1590271310
pixelherodev
Nicely done :)

1590271315
ifreund
good api i guess :D

1590271333
ifreund
now watch this last test take another hour :P

1590271336
pixelherodev
Gahhh halp

1590271344
pixelherodev
How do I get Git to stop seeing deps/ as changed?!

1590271351
pixelherodev
On a fresh clone even :(

1590271362
pixelherodev
... or... not?

1590271364
andrewrk
idk I think it has something to do with .gitattributes

1590271365
pixelherodev
what the hell?

1590271373
pixelherodev
I use `git stash`, it claims to work but is still there

1590271377
andrewrk
and txt files with weird newlines. I have no idea what's goign on

1590271420
pixelherodev
`gco deps` -> "updated 2 paths"

1590271422
hermier
git diff seems not follow the new lines from .gitattributes

1590271440
pixelherodev
yeah...

1590271444
pixelherodev
it still thinks they're changed

1590271447
pixelherodev
and git rebase refuses to do any work

1590271464
hermier
as soon as the file date don't correspond, the diff enter in action and you are fscked

1590271464
pixelherodev
going to do a fresh local clone, rebase, push back to original fork, push from there to GH :(

1590271495
kushalp
Should I use the standard C library for creating a socket or is there a preferred way to do this in zig? socket(AF_INET, SOCK_DGRAM, IPPROTO_UDP)

1590271499
fengb
Can you delete the files and check them back out?

1590271557
pixelherodev
Ugh, there we go

1590271559
andrewrk
kushalp, check out std.net. it's in the early days, it's missing a lot of API. you could consider contributing or you could just put the code you need in your own project, using the lower level std.os (posix) API

1590271561
pixelherodev
fengb: I've done that before, yes

1590271562
hermier
no, checkout, follow .gitignore, and is instantly different from archive

1590271565
pixelherodev
Still a pain

1590271584
andrewrk
what I want from git is very simple:

1590271585
pixelherodev
Given that it's only the READMEs, can we just wipe those? :P

1590271588
andrewrk
DONT MANGLE THE FILES

1590271597
pixelherodev
Ah wait it's the license too

1590271601
pixelherodev
dammit

1590271607
pixelherodev
do we need to maintain line endings of the license though?

1590271611
andrewrk
no we dont

1590271618
pixelherodev
Can we override that and the README so they don't constantly do this?

1590271621
andrewrk
yes

1590271662
fengb
It kinda sucks that git mangles line endings :/

1590271704
pixelherodev
Sure, but

1590271711
pixelherodev
I literally can't think of a single other issue with it :)

1590271720
pixelherodev
So as much as this bothers me, I still am totally willing to accept it

1590271736
pixelherodev
it's

1590271770
hermier
git does a pretty good job on different host, I don't know why it bombs here, maybe the line encoding don't correspond to what .gitignore says

1590271780
kushalp
andrewrk: Thanks! I'll try to check out more of the repo and docs before asking away in here! :)

1590271784
gonz_
I have a suspicion that Fossil is much better but I've zero reason to try to convert people around me to use it anyway.

1590271843
fengb
Because zig turns off line ending mangling and thatâ€™s apparently not well tested

1590271843
waleee-cl
some nix/nixos-folks is a bit hyped about pijul 1.0 approaching

1590271926
gonz_
On a surface level Fossil offers a much more human interface as well as more features you pretty much always want anyway, and uses SQLite for history management which all in all is a much better idea than plain files, IMO. The idea of back references also makes it possible to walk history front and back in a different way.

1590271947
pixelherodev
gonz_: Fossil certainly thinks so lol

1590271968
fengb
I learned DVCS with Mercurial and I still wish that won

1590271973
fraktor
I'm working on PR #5412 and someone brought up the point that we might want to change the recursion depth that the `fmt` module uses when displaying self-referential structs at runtime instead of just at comptime.  How necessary is that, and would it introduce any footguns?

1590271997
pixelherodev
I think it's useful, yes, and I think that whether it introduces footguns depends on the implementation

1590271999
pixelherodev
fraktor: ^

1590272039
fraktor
It would just be a `pub var` instead of `pub const`.

1590272079
fraktor
I copied the pattern that io uses, where it looks for "fmt_max_depth" declared in the root module and then uses that, or else a default.

1590272205
fraktor
But making it a pub var would make it possible to just do `fmt.default_max_depth = 16` or whatever.

1590272238
alexnask
Nice, switching to the parser branch was easier than expected

1590272260
alexnask
The only change that affects it a bit is the fact that ParamDecl is no longer a Node but I will work around this

1590272295
alexnask
s/it/zls

1590272488
pixelherodev
andrewrk: is there no facility in ZIR testing for "expect an error" yet?

1590272533
andrewrk
pixelherodev, correct. however that is obviously an important kind of test that we need to add

1590272544
pixelherodev
I'll take care of that

1590272549
pixelherodev
I need it for this PR anyways

1590272564
pixelherodev
Might do some more refactoring first though

1590272582
andrewrk
alexnask, the (new) criteria for something to be a Node is whether there is ever a time when a *Node could be more than 1 different thing

1590272608
alexnask
Yes I get it and I agree with the design, it was inconsistent in a couple of places before

1590272660
andrewrk
I'm hoping to get this branch mergable by this evening

1590272771
pixelherodev
alexnask: ... what's your zig-serial ???

1590272781
alexnask
lol

1590272808
alexnask
I will delete it, xq asked me to make it to test zpm support for multiple packages with the same name

1590272825
pixelherodev
Ahhhhh

1590272827
pixelherodev
phew

1590272830
pixelherodev
was worried for a second

1590272853
pixelherodev
mq32: ... firstly, do you change your name on here constantly just to confuse the rest of us?

1590272862
pixelherodev
Secondly, mind adding a build option to embed the trust CA on Linux too?

1590272868
pixelherodev
Actually, you know what, ignore that

1590272879
pixelherodev
It's fine

1590273202
alexnask
I think the plan is to embed it (or at least the key relevant to github) for every os instead of trying to support all possible distros and/or OSes

1590273974
pixelherodev
Tackling #1364 before continuing...

1590275096
pixelherodev
Ugh

1590275100
pixelherodev
Zig is marked as failing CI

1590275110
pixelherodev
because GitHub was down and CI failed to retrieve wasmtime and such

1590275392
andrewrk
I love that you can use git blame to find the commit that added a test case, and therefore find the relevant code that was changed to make that test case work

1590275584
andrewrk
alexnask, sorry, I forgot to mention, I was planning on reverting ast node children iteration to how it works in master

1590275676
alexnask
Meh this is a small change :P

1590276208
mq32
pixelherodev, nah my server is just rebooting too often

1590276445
ikskuh
<pixelherodev> mq32: ... firstly, do you change your name on here constantly just to confuse the rest of us?

1590276447
ikskuh
did that already

1590276613
pixelherodev
Anywho, I'm just finishing up more backporting (going to be releasing an unofficial 0.6.3 soon) and then getting back to stage2

1590277238
ikskuh
pixelherodev, could you try to use zpm again? i have now included only the DigiCert certificate

1590277246
ikskuh
that should be sufficient for communicating with github

1590277490
pixelherodev
ikskuh: it'll have to wait

1590277510
ikskuh
okay :D

1590277588
pixelherodev
Network is a bit clcogged right now :P

1590277734
pixelherodev
Pushing the full Zig repo over SSH lol

1590277737
pixelherodev
Not just changes to compile, the way I normally do; the full repo

1590277739
pixelherodev
y

1590277792
pixelherodev
whoops

1590277810
ikskuh
why?

1590277835
afontain_
I just saw zpm and thought it looked nice from the readme. It seems atrociously tied to github though :-(

1590277946
afontain_
If I'm not mistaken, packages are indexed if published on github and the package manager uses github's api to index and retrieve the packages?

1590278019
ikskuh
yeah

1590278025
ikskuh
it's a glorified github search actually

1590278027
afontain_
It seems it depends on this specific centralised service

1590278034
ikskuh
correct

1590278047
andrewrk
afontain_, it's not official

1590278061
afontain_
I saw

1590278069
ikskuh
first thing in the readme :D

1590278086
fengb
Since itâ€™s based on GitHub, shouldnâ€™t we name it... zithub?

1590278097
afontain_
:D

1590278108
ikskuh
afontain_: i don't know about other hosting services

1590278113
ikskuh
that provide that kind of API

1590278118
afontain_
githuz

1590278124
ikskuh
github provides even finer grained searches like

1590278132
ikskuh
"give me all repos that have a package.zig included"

1590278134
ikskuh
(afaik)

1590278366
afontain_
Well, python, rust, haskell, do have a similar service, but they built it themselves I think

1590278394
afontain_
they are probably at a later stage of development and targeting stable releases,too

