1600214796
ccube
waleee-cl: Thanks, I think that's where I picked up an the anonymous tuple syntax and figured the [...] syntax was no longer used.

1600215175
andrewrk
companion_cube, meet ccube

1600215186
andrewrk
I got confused for a sec

1600215276
fengb
Theyâ€™re multiplying

1600215309
ccube
My initials are ccc

1600215347
ccube
some places I go by ccubed, but ccube is also my GitHub id

1600215389
waleee-cl
I can imagine that ccc is fairly hard to register

1600215409
ccube
I was surprised I got something as short as ccube

1600215453
waleee-cl
I was thinking more about the chaos computer club

1600215547
ccube
No, I was a unix guy since 1983 and never cared much for DOS or windows

1600215628
waleee-cl
I'm pretty sure these guys

1600215664
ccube
Okay

1600215703
ccube
But I never got into that culture,

1600215775
ccube
What's the roadmap to getting to 1.0?

1600216190
ifreund
well, the big thing right now is making the switch to the self hosted compiler

1600216241
ifreund
you can filter the github issues using the "proposal" and "accepted" tags to see what language changes are still planned

1600216246
ifreund
big one is #1717

1600216261
ccube
Thanks

1600216351
waleee-cl
this got a bit weird with your username

1600216423
ccube
Not me - I'm ccube not c-cube

1600216435
andrewrk
ok std.fmt fill character definitely regressed

1600216447
waleee-cl
yeah I know it's companion_cube (sorry for the ping)

1600216451
andrewrk
var char: u8 = 9; std.debug.print("\n\\x{X:02}\n", .{char})

1600216705
andrewrk
ok {X:0>2} works

1600216732
andrewrk
I think {X:02} should be a compile error telling you how to use the API

1600217459
fengb
Sounds like you need a refresher course at ziglearn.org ðŸ™ƒ

1600217937
andrewrk
omg is that there?

1600217982
andrewrk
amazing. I should have checked here

1600220064
companion_cube
ah, an impostor!!

1600220079
companion_cube
oh they left :(

1600220088
fengb
Iâ€™ve never seen the both of you in the same room ðŸ¤”

1600220513
andrewrk
I could tell it wasn't you companion_cube, they were slightly more edgy

1600220538
andrewrk
also more interested in zig :P

1600221376
leeward
To be fair, it's hard to be edgy with hearts on your faces.

1600222419
mkchan
isn't the while (i < size) : (i += 1) {} syntax equivalent to while (i < size) {defer i += 1;} ? Why should there be 2 ways of doing it?

1600222582
leeward
mkchan: It's subtly different. The defer happens if there's an error.

1600222591
mkchan
that's errdefer

1600222601
leeward
Yes, errdefer also happens if there's an error.

1600222661
leeward
I'm not saying it's an important or useful difference, just that they're not equal.

1600222724
mkchan
so if an error occurs there's 2 things that could happen: 1. you handle it within the scope => it won't actually do the defer statement because scope is still on. 2. it exits the scope and in this case, does the : (i += 1) execute? Because the defer variant will execute

1600222778
leeward
I don't believe the : (i += 1) will execute, which isn't super important for counters scoped to the function, but can matter for more broadly scoped state.

1600222803
leeward
Worth double checking...

1600222835
mkchan
it feels like a footgun because the scope of the counter var is not the scope of the loop usually because zig doesn't have the for (init;condition;update) kind of formulation

1600222870
leeward
It is true that the counter variable is not scoped to the loop. I don't think I would want it incremented in the event that the loop exits with an error.

1600222905
mkchan
so then the defer i += 1 could lead to unexpected behavior

1600222913
mkchan
ok thanks, i'll use the other syntax

1600222997
companion_cube
andrewrk: I am interested in zig :p

1600223002
leeward
Just confirmed it, i does not get incremented.

1600223030
mkchan
though the lack of loop-scoped variables and the inclusion of loop-scoped updates seems kind of... half-baked

1600223064
leeward
I'm not gonna argue there, mkchan.

1600223164
leeward


1600223218
mkchan
nice, thanks for the example code

1600223249
mkchan
maybe there should be a noerrdefer :))

1600223259
leeward
That has been discussed.

1600223267
leeward
I think nobody's come up with a good use case yet.

1600223270
leeward
D has it.

1600223437
mkchan
seems perfect for a executing post-function hooks

1600223499
mkchan
for example you could noerrdefer something and errdefer something else

1600223745
leeward
Hmm, I seem to remember something about a way to get the error from inside a defer, but can't find the ticket.

1600224073
mkchan
i vote for `while (init) : (cond) : (update) {}` syntax

1600224085
mkchan
or just the usual c++ style

1600224131
leeward
ah,

1600224342
mkchan
i was thinking along the lines of: say you have a tcp session object and its lifetime is controlled by its scope, if you need to shut it (for example you need to allocate a new connection at the expense of a less valuable one), you would noerrdefer a close on it. because if you just normal defer it, and an error occurred, you trying to close the connection would presumably also give an error because

1600224343
mkchan
it's already closed

1600224362
mkchan
unless i'm wrong and zig says closing is a no-op if already closed

1600224415
leeward
Why is it already closed in the normal case?

1600224428
torque
you would set up the defer to close it after it had successfully opened, typically

1600224467
mkchan
yes, but my point is if it fails because of a network issue, the connection would be implicitly closed right? then the deferred handler runs and tries to close it again

1600224507
torque
that sounds more like imaginary bad api design than a practical problem

1600224528
mkchan
boost asio works kind of like that

1600224538
leeward
real world bad api design?

1600224600
leeward
It does sound like a bad API though. You don't have to close the socket if the other side already closed it, and it's bad if you do?

1600224618
justin_smith
a real problem with the same shape: double free

1600224643
torque
yeah, if you give ownership of the socket to someone else, you shouldn't be doing things like implicitly closing it

1600224647
leeward
Double free has a different shape, because remote code over which you have no control won't sometimes free your memory for you.

1600224675
leeward
And if it does, then it's that code's fault if you have a memory leak and you shouldn't be freeing it ever.

1600224709
leeward
andrewrk: I do what I can to push your time-in-merge-queue averages down.

1600224720
andrewrk
:)

1600224762
mkchan
if the other side closed the socket, your object would still go out of scope and the defer would run. now you could obviously wrap a call to close with isClosed() but that's a style choice whether you want noerrdefer or whether you want defer to be errdefer+noerrdefer

1600224773
andrewrk
that might be the first CI commit that makes it all the way to the download page with Ave/Luna's newly provided freebsd CI testing service

1600224781
leeward
Wooo

1600224799
leeward
mkchan: I think you're making some OOP assumptions that look like RAII.

1600224803
andrewrk
they are graciously giving us more RAM on freebsd builds so we can enable std lib testing. it already caught a regression (which is not yet fixed in master branch)

1600224841
mkchan
i'm assuming the session manages its own lifetime based on scope and has a way of some other service telling it to shutdown. this is how boost-asio works

1600224880
mkchan
but yeah it could very well not be the best way to do it in zig

1600224888
mkchan
like you said it assumes RAII

1600224946
leeward
Yeah, defer is how Zig does RAII, and they're not particularly compatible. Destructors are very implicit function calls, which is a no no in Zig.

1600225009
mkchan
while zig is still young lets try to call it scope-based-lifetime-management SBLM or SLM instead of a crappy name like RAII :)

1600225043
leeward
RAII is really one of the worst names ever.

1600225057
justin_smith
right, we aren't talking about I at all here

1600225073
mkchan
that's the argument bjarne uses for not changing the name RAII to something else: "you should have been there 20 years ago"

1600225125
justin_smith
on the posix level, double closing an fd is an error (hopefully) or closes someone else's socket that used the same numeric fd (oops)

1600225165
mkchan
yes, which is why if you use defer to handle an error related to it you must check isClosed() before you close it

1600225187
justin_smith
that can close someone else's file

1600225191
justin_smith
it's just a number

1600225312
justin_smith
I could be confused because you all are talking about an abstraction above sockets that manages the identity and state of objects holding sockets

1600225329
mkchan
that was an example use case i borrowed from my experience with c++

1600225342
mkchan
the core issue was the double close pretty much

1600225417
justin_smith
sure, and given the implementation of files (numeric fd passed to syscall), checking if it's open isn't a fix, because it can be reallocated after closing

1600225431
justin_smith
you need something dumber, or something smarter

1600225470
mkchan
the open close stuff is per-process i think

1600225481
mkchan
at least in c

1600225500
mkchan
presumably if you wrote syscalls you

1600225511
justin_smith
so only one thread is allowed to open/close files, that helps

1600225530
justin_smith
(maybe that's not a valid leap...)

1600225548
justin_smith
sorry I'm used to programming at a much higher level abstraction so this stuff still confuses me sometimes

1600225607
mkchan
i'm not sure if it's per process or per thread. i think per-process

1600225620
andrewrk
any windows users want to help out a small task with self-hosted? see if you can figure out why the Cache.zig unit tests are failing on windows in the stage2-zig-cc branch:

1600225678
justin_smith
mkchan: right, my steps were: if it's per process that it's managed, two threads can potentially get into a funky state, if the closes and opens happen in different threads, maybe that's not a realistic concern

1600225739
mkchan
i mean it's realistic in the sense multiple threads could be reading the same file but if someone actually writes multithreaded writing code oof

1600225769
mkchan
i haven't tried it so i really have no idea. it seems like an inane thing to do

1600225817
justin_smith
mkchan: but the root thing that made me anxious was the idea of some state that can be flipped by my code, or a connection between my machine and another, or the other machine, and needing to gracefully handle things using only a yes/no of open or closed, plus the fact the kernel is allowed to give you the same numeric fd between a close and another open. maybe that's not a real problem though

1600225855
justin_smith
even if each fd was opened/closed by one thread, one thread could still close another's fd due to reuse of the descriptor which is just a number

1600225859
mkchan
i don't really know all the specifics, sorry i can't help much

1600225898
mkchan
my knowledge mostly ends at the memory/cache level. i'm a noob at storage

1600225943
andrewrk
oh sorry never mind I think I figured it out already

1600226506
justin_smith
mkchan: upon refreshing my memory, network related errors don't close the fd, but they do raise a signal that an application can set a handler for to fix / cleanup. not setting a handler means your process is simply shut down.

1600226621
justin_smith
so I think a socket does fit the defer pattern

1600226685
mkchan
the problem is the OS can close a socket for you and then your read() function fails and you try to close it again

1600226706
justin_smith
oh, I must be misreading the docs

1600226712
mkchan
it is not analogous to double free because afaik OS won't partially free memory for you, they'll just completely shut you down

1600226775
justin_smith
there's no mention of close happening from the outside

1600226795
justin_smith
there's mention of a signal raised for broken sockets, that's not the same

1600226962
justin_smith
the kernel promises to reuse the lowest available fd number, so clashes where a "double close" closes a resource being used are quite likely

1600227030
justin_smith
combining that with silently / implicitly closing your fd from outside your process seems pathological, but I could be missing something important here

1600227035
mkchan


1600227057
mkchan
it's the exact same example

1600227118
mkchan
though i suppose if close() can fail for whatever reason anyway (regardless of previously closed) and you have to check the close() return value in any case, it makes the entire point moot

1600227275
justin_smith
I'm afraid I'm getting too hung up on this detail, I just don't see how the API for file descriptor allocation and closing could be sanely used if a something outside your control can close the fd, since fds are guaranteed to be reused after closing. but I don't think that detail was even the material point you were making

1600227342
mkchan
i was assuming that if you're guaranteed that you're the one closing the fd that you own (which you don't. the OS owns the fd) then you don't need to check if its already closed

1600227354
mkchan
the OS just does whatever it wants

1600227363
justin_smith
the fd is a number unique to your process

1600227366
mkchan
praise OSjesus

1600227369
justin_smith
there's no other data process side

1600227390
justin_smith
your process

1600227410
mkchan
imagine you're writing to a file x.txt on desktop, and while you're writing someone `sudo rm`s the file

1600227415
justin_smith
your fd 1 is your fd 1, if you close it and open another file, that's your new fd 1

1600227436
justin_smith
the OS doesn't care what your file name was etc. when you write, it just wants the fd, which  is a number

1600227452
justin_smith
mkchan: that rm doesn't close the file

1600227456
mkchan
the OS cares exactly what inode that fd points to

1600227463
justin_smith
it's easy to test, you still have an open fd for that file after rm

1600227465
mkchan
if that inode disappears, the os closes your file

1600227489
justin_smith
no, it does not, this is a trick that is deliberately exploited (in posix applications)

1600227499
mkchan
wut!?

1600227500
justin_smith
well - OK, the inode

1600227504
justin_smith
the rm doesn't delete the inode

1600227510
justin_smith
it just reduces the usage count

1600227519
justin_smith
your fd being open is another usage

1600227528
justin_smith
the inode isn't free until you close

1600227564
justin_smith
many apps create a temp file, open it, then delete the file, and continue to use the inode via the fd

1600227599
mkchan
that's so hacky and shared-ptr-esque

1600227613
justin_smith
it's quite common, and a guranteed behavior

1600227626
justin_smith
it's not a shared pointer, because the kernel doesn't close the fd on you

1600227716
justin_smith
anyway, I think I've lost the topic of this irc channel here, and I need to retire for the night, apologies for the noise

1600227718
mkchan
that's why it is a shared ptr to the inode isn't it. the process using it would be another reference

1600227737
mkchan
oh yeah massively off topic, sorry

1600227748
justin_smith
the process only has a number, starting from 0 and counting up, the kernel maps that to a resource

1600227751
justin_smith
np, cheers

1600227778
andrewrk
OS stuff is on topic here :)

1600227784
andrewrk
we like to think about how computers work

1600228203
andrewrk
here's an idea I didn't consider before:   `block` keyword which makes `break` apply to it (no label)

1600228220
andrewrk
const x = block { ...; break y; };

1600228252
mkchan
seems like a lambda?

1600228259
companion_cube
without arguments

1600228264
mkchan
yes

1600228266
companion_cube
that's an interesting compromise andrewrk

1600228275
companion_cube
removes the need for inventing a name

1600228277
andrewrk
nah it's syntax sugar for label: {...; break :label y;}

1600228316
fengb
Once we have anon functions, we can switch to IIFE instead of named blocks ðŸ™ƒ

1600228357
andrewrk
joke's on you I don't even know what IIFE is

1600228361
mkchan
x = [capture](param){code + return}(args);

1600228368
companion_cube
my guess is is `(() -> â€¦) ()`

1600228380
companion_cube
the kind of stuff you see in JS and Go

1600228384
andrewrk
is IIFE like UUPDG?

1600228387
mkchan
and c++

1600228393
companion_cube
ðŸ˜‚

1600228401
companion_cube
statement based languagesâ€¦

1600228511
mkchan
btw, can someone point me to an example where you sort of stack generic types. I have this:

1600228752
mkchan
the c++ equivalent would be a variadic template

1600229207
mkchan
i can think of a not-so-nice way of implementing it => taking all the layer parameters N times followed by the respective N layers which works i guess. You would do the same in c++ i believe but you don't have to because it deduces a lot implicitly hmm...

1600229708
andrewrk
mkchan, are you trying to dispatch control flow at runtime?

1600229726
mkchan
i'm not sure what you mean

1600229742
andrewrk
oh I think I see your question. you'd use duck typing for this in zig

1600229748
mkchan
but basically i know the exact structure of the network at compile time

1600229760
andrewrk
pub fn Network(layers: anytype) type { ... }

1600229787
andrewrk
if you want some safety rails you can add `comptime assert(..);` to give yourself compile errors

1600229892
mkchan
so i can assert that layers is a list and once i pick out one with layers[0] i will still be able to call the self-method on it?

1600229922
mkchan
so basically it's modeled correctly at compiletime but i just can't express it nicely in source code right?

1600229984
andrewrk
right

1600230005
andrewrk
rust is pretty good at that sort of thing, but zig is too simple so you have to use duck typing

1600230068
mkchan
that's alright, i find rust syntax very... different and i actually did try doing this in rust and i'm not a fan of the style it boxes you into

1600230093
mkchan
zig feels more like the kind of thing c++ should've been but c++ is more like c+++++++++++++++++++++ now

1600230128
mkchan
so i'm leaning towards zig quite a bit for hobby projects

1600232241
nikki93
hey there :)

1600232276
nikki93
looked at zig on and off but really trying it out now. it's nice!

1600237799
andrewrk
<3

1600242182
jjsullivan
does the build API have helpers for compiling/linking static C libraries?

1600242225
jjsullivan
even just something to get `zig cc` for the current target would probably be enough

1600242401
traviss__
are you looking for exe.addCSourceFile(file: []const u8, args: []const []const u8)?

1600242572
jjsullivan
traviss__, I was trying to compile something that already has a makefile, but I don't think there's really anything stopping me from doing that

1600242583
jjsullivan
I'll give it a try

1600242856
traviss__
if the makefile is simple enough, this may work. another idea, maybe run the make command from build.zig with b.addSystemCommand(argv: []const []const u8)

1600243021
jjsullivan
yeah, the makefile isn't too complicated. There's a few options but I'm ignoring most of them anyway. If I have a `build.zig` next to it, it can probably compile without much effort.

1600243030
jjsullivan
plus I get cross-compiling for free

1600243043
andrewrk
jjsullivan, it's even better than that, it will build C and C++ libraries from source with zig instead of relying on external tools

1600243080
andrewrk
your_exe.addCSourceFile("foo.c", extra_c_flags);

1600243148
jjsullivan
yeah, I think this library is mostly turning source files 'on/off' in the makefile. Probably wouldn't be too difficult to do everything in the main `build.zig`

1600243258
jjsullivan
thanks traviss__ andrewrk :^)

1600243277
andrewrk
and now you probably made your project buildable by windows users

1600243289
jjsullivan
ehh, wayland client actually

1600243294
andrewrk
ahh fair enough :)

1600243301
jjsullivan
although wsl could probably do it?

1600243315
jjsullivan
I know they got xforwarding anyway

1600243325
andrewrk
ðŸ¤”

1600243358
andrewrk
ooh do they? that's super interesting

1600243366
andrewrk
I did not know you could do graphical stuff with WSL

1600243389
jjsullivan
it's kind of a hack, but yeah you can peek into a running xserver from the 'outside'

1600243405
jjsullivan
I forget if there's some special client or if the client is built-in now

1600243628
jjsullivan
andrewrk, I got it backwards, xserver runs on windows and linux clients connect

1600244176
rain1
sorry to hear this shit is happening, you're making a good language don't let annoying people take the fun out of it!

1600244357
jjsullivan
think I'm late to the party, something bad happenening rain1 ?

1600244532
andrewrk
jjsullivan, I believe rain1 is referrring to this announcement that went out today:

1600244543
andrewrk
it was on hacker news for a good part of the day

1600244602
andrewrk
don't worry rain1 we're still going full steam ahead. I'm proud of our MIT license and not asking contributors to sign CLAs and it's going to stay that way ðŸ’ª

1600244616
rain1
:)

1600244922
jjsullivan
wow, hard to believe people will try to grift like this. Hope any well-meaning people can benefit from the outreach

1600245997
jjsullivan
idk if this is helpful at all, but for the contributor in a non-compete, maybe the SFLC would have something to say?

1600252216
ifreund
this is pretty neat:

1600252684
ifreund
everything on their site is pretty neat in fact :)

1600254166
Cadey
ifreund: 100 rabbits is great

1600260185
cren
would be fun to see if you could write a program that was also a meaningful passage in some natural language like English

1600260364
cren
(in orca, not zig! you could try with zig but it would be quite difficult...)

1600267299
pixelherodev
andrewrk: I'm starting to think it might be worth integrating CBE with the normal backends a bit more thoroughly...;

1600267314
pixelherodev
Instead of duplicating all of the core logic in a separate file (e.g. branches)

1600267348
pixelherodev
Maybe instead of using cpu.Arch, we could switch on a Backend struct which is defined as, effectively, `Arch || enum { C }`?

1600268917
marler8997
Found around 10 instances of undefined behavior in the Dune source code by compiling it with Zig instead of GCC

1600268930
marler8997
Sorry, "DOOM" source code (not Dune)

1600268959
fengb
Is this one of the cleaned up repos?

1600268959
leeward
That is not super shocking.

1600268960
marler8997
not sure what LLVM options Zig is using to detect these instances of UB

1600268965
marler8997
original repo

1600268972
marler8997
from id-software

1600268983
leeward
It's just using ubsan, right?

1600268983
marler8997
I'm sure the cleaned up repos will have fixed these issues :)

1600269003
fengb
I'm impressed with only 10 UB

1600269008
marler8997
10 UB so far :)

1600269020
marler8997
I can now go through menus and start the game...still hunting down more

1600269025
fengb
lol

1600269030
marler8997
ubsan though..thanks for the tip

1600269046
marler8997
is there a way to disable ubsan? to check if that' it?

1600269060
fengb
Hmm, do you think the ports were cross compiled? I'd expect SNES and before to be rewrites

1600269084
marler8997
SNES was a rewrite in assembly as I understand (code was release recently actually)

1600269104
marler8997
but the C code is pretty portable, I expect most would be modified and cross-compiled

1600269127
marler8997
but my plan is to port to Zig...which will be super fun :)

1600269143
fengb
Sure, I'm mostly curious if they had to cleanup UB :P

1600269166
ifreund
you can disable with -fno-sanitize=undefined iirc

1600269198
marler8997
I'll try that, off the top of your head do you know how to add LLVM options in build.zig?  If not Ill figure it out

1600269400
ifreund
marler8997: you pass them to addCSource() iirc

1600269402
fengb
I think Rust has a translate-c library that worked on DOOM. They're ahead of us :(

1600269479
marler8997
fengb: thanks that worked!  I can now play the game :)

1600269518
marler8997
I mean, thanks ifruend :)

1600269531
fengb
I'll take some credit too

1600269571
marler8997
lol

1600269719
ifreund
:D

1600270125
justin_smith
regarding IIFE mentioned above, I learned what they were while writing a lisp transpiled to a source language with "statements", in lisp everything is an expression (has a return value to use), to use expressions and also have a return value, you turn every expression usage into an Immediately Invoked Function Expression

1600270152
justin_smith
a function of no args (thunk, as scheme calls it), that exists so that your block of code will have a return value, and no other reason

1600270212
justin_smith
err, I switched statement/expression a few times above - to be clear, statement=noreturn expression=return

1600270463
justin_smith
surely the more civilized adult approach is forth, where each word results in a variable reduction or increase of the depth of the stack

1600270780
blinghound
is there an approach I can use to implement an event system - basically an array of bound fns I can call? Functions bound to a particular instance of a struct can't be used as a Fn pointer

1600270841
justin_smith
blinghound: you can capture and bind the "frame" - the initialized stack data of a function, and revive it

1600270889
blinghound
oh sweet! Are there any docs or pointers you can provide?

1600270912
justin_smith
the async examples all revolve around this technique

1600270978
justin_smith
look at the stuff around binding @frame() / and resume - I think this fits your use case very nicely

1600270992
justin_smith
eg. "Resuming from Suspend Blocks"

1600271067
blinghound
That looks like exactly what I'm after, thanks. I assume I can store an array of frame pointers?

1600271090
justin_smith
blinghound: it's data, I wouldn't save it to a file and read it back, but otherwise it's data :D

1600271112
justin_smith
(because maybe you read it back from a version of the executable where the type no longer makes sense...)

1600271155
justin_smith
blinghound: sounds like a nice way to make an event queue processing loop - keep a queue of stuff that's not done processing, hand it off to threads...

1600271389
blinghound
I'm in the process of translating a cross-platform GUI toolkit I wrote in C++, and my initial approach in Zig was to write a huge switch statement with the corresponding function for every widget type

1600271409
blinghound
which worked well with a small number of widget types, but ultimately doesn't scale

1600271455
blinghound
with an event queue, it's also easier to implement a new widget type without having to modify the huge switches

1600271735
justin_smith
blinghound: I think I understand, in a lisp I'd use functions closing over state, the @frame() technique lets you allocate that closure explicitly

1600271918
cren
are zig strings utf-8?

1600271939
fengb
Sorta. stdlib mostly expects UTF8 but they're just bytes at the language level

1600271943
cren
this question may make no sense. My understanding of how programming languages handle strings is bad lol

1600271965
cren
oh yeah uh

1600271967
cren
course they are

1600271977
cren
I had my python head on

1600271977
fengb
If you ingest data that's known to be UTF8 and you do UTF8 logic, then it'll work

1600271984
fengb
But there's mostly no validations atm

1600271996
justin_smith
I have yet to see zig code that handles encoding

1600272017
cren
so if I were to try to get the stdlib to process some utf-16 or cp1252 strings, it would probably break?

1600272019
justin_smith
it's all u8 everywhere, so sufficiently naiive code handles all encodings equally well (badly)

1600272022
fengb
There's a lot of encoding work for Windows interop

1600272054
justin_smith
fengb: it's just bytes at the zig stdlib level, you need functions that care about characters to run into problems, do we even have any of that?

1600272083
justin_smith
of course you could break things by splitting a codepoint across buffers

1600272097
justin_smith
and not recombining before real string/character code sees the data

1600272138
fengb
I'm not sure. But I do know this problem needs to be addressed for proper HTTP support >_>

1600272151
justin_smith
right, your HTTP layer needs to know about encodings

1600272180
justin_smith
fengb: quoting the comment under "using slices for strings" test in the master docs "Zig has no concept of Strings"

1600272218
companion_cube
http doesn't know about encodings, does it?

1600272225
companion_cube
only the content aware layout, like the browser, needs to

1600272303
justin_smith
companion_cube: I hope that's true, because then zig would be at the same layer of abstraction as the HTTP layer (don't worry about the bytes, just convey them and don't scramble them, let the presentation layer worry about the nonsense)

1600272360
companion_cube
if I remember correctly, it is: headers are ascii

1600272365
justin_smith
even if a multi-byte codepoint is split across data frames, you don't need to care as long as said frames are not mangled

1600272367
companion_cube
bodies are binary (length is given in header)

1600272382
justin_smith
right, images would be such a waste of bandwidth otherwise

1600272394
companion_cube
but yes

1600272400
companion_cube
for large content you also have chunked encodings :)

1600272404
companion_cube
so you stream the data

1600272464
justin_smith
right, and the chunking shouldn't care about object boundaries, whether it's codepoints or video frames or zip file entries

1600272616
companion_cube
indeed not.

1600272645
companion_cube
http 1.1 is a pretty neat protocol, in the end

1600272681
justin_smith
almost worthy of the variety of insane use-cases it's been shoehorned into

1600272716
justin_smith
nowadays the concept of "internet but not http" blows minds, or makes people think you're an evil hacker

1600272720
justin_smith
or so it seems

1600272742
fengb
HTTP is the new TCP

1600272790
justin_smith
fengb: and block-chain is the new HTTP

1600272795
justin_smith
the layers will never stop...

1600272848
companion_cube
nah, blockchain is a fad

1600273166
pixelherodev
^

1600273347
justin_smith
companion_cube: math flavored beany babies, yeah, but I still see people trying to mis-apply it in so many places

1600273348
leeward
blockchain has yet to provide a good solution to a problem. I'm not convinced it never will, but it's hard to convince me of a never.

1600273395
justin_smith
leeward: there's that one "programming language in block chain" project, which turned the ability to learn a programming language quicker than others, or find and exploit bugs, into short term cash rewards

1600273467
leeward
justin_smith: Did it need to be a block chain, or would a database have sufficed?

1600273477
justin_smith
I don't think that's what they wanted to make, but they made it

1600273500
justin_smith
leeward: with a database, an admin could have fixed an obvious error without forking the whole reality of the project

1600273510
justin_smith
oh, etherium, that's the name I was thinking of

1600273541
justin_smith
leeward: in other words, a database would be less exploitable by fast language learners / fast exploit finders

1600273632
leeward
Not ethereum?

1600273724
justin_smith
leeward: no yeah, I was thinking of etherium, they forked their chain due to stupid bugs in apps that were effectively chain letters / pyramid schemes

1600273758
justin_smith
"oh wait my code accidentally gives me all your cash on this corner case, easy mistake I guess"

1600273791
leeward
Yeah, that's one of the problems with transactions that are not reversible. Easy to defraud.

1600273806
justin_smith
I am being sardonic of course, cynically exploiting rubes is a use case, but not one that makes block chain look appealing to me

1600273837
leeward
Oh, I get it.

1600273854
justin_smith
leeward: the great thing is it didn't even look like fraud, it looked like an easy programming mistake that

1600273855
leeward
I thought you were talking about an actual project.

1600273915
leeward
Yeah, block chain has been found to be of great use to many kinds of criminals. The kind of useful I'm thinking of is for people whose business model is not primarily fraud.

1600273916
justin_smith
similar things with bitcoin wallets that just happen to accidentally put a fraction of btc in a wallet whose id is determined by a weird but predictable side effect of the hashing

1600273938
justin_smith
easy bug, just happens to benefit the people who figure out how to find and access the result sooner

1600273978
justin_smith
leeward: right, the systems we have now have a lot of allowance for combatting fraud, which block chain impedes by design

1600274010
leeward
Oh, someone stole your credit card? No problem. Someone stole your bitcoin wallet? You're SOL.

1600274020
justin_smith
luckily block chain also impedes true obfuscation of said fraud, so there's one more monster at the bottom of pandora's box

1600274054
leeward
Yeah, I love how so many people think transactions are anonymous.

1600274095
justin_smith
leeward: on the internet, the many meanings of "anonymous" approach absolute meaninglessness

1600274138
justin_smith
I'm anonymous right now, "oh no that's his real name you've narrowed him down to one of hundreds of thousands of people with thatlegal name"

1600274179
leeward
Even in the BTC dystopia where you never have to convert out to a real currency, it's basically impossible to hide your identity when every transaction you make is necessarily public.

1600274181
justin_smith
brb swapping out my nick for a UUID

1600274247
leeward
Narrowed down to hundreds of thousands of people who connect to IRC through the netherlands with that name.

1600274326
leeward
with IP addresses from Santa Clara (Hey, my mom used to live there)

1600274444
leeward
Lunch time. I wonder if I should bounce my IRC sessions through digitalocean. Oh well.

1600277538
pixelherodev
leeward: I'm in copmplete agreement with you

1600277551
pixelherodev
I think blockchains are a fascination solution... to absolutely no problems.

1600277555
pixelherodev
They're a solution looking for problems.

1600277594
pixelherodev
ifreund: you're good with wayland, right?

1600277598
pixelherodev
I had a small question :P

1600277628
ifreund
you could say that

1600277667
pixelherodev
How hard do you think it'd be to port a small application, which currently uses X11 + GLX, to Wayland?

1600277681
pixelherodev
libwayland + EGL, rather

1600277685
pixelherodev
(as the target)

1600277739
ifreund
I know comparatively little about GLX and EGL, which is what that questions really about :P

1600277753
pixelherodev
That's true, yeah

1600278380
leeward
pixelherodev: that's because you like being correct, and my position on blockchain is correct ;P

1600278470
pixelherodev
lol

1600278709
nephele
I'd think beeing completely anonymous would imply that your interactions have no chronological cohesion, so nobody remembers you

1600278737
nephele
wouldn't be easy to acomplish, if you are that one guy that joins as a different UUID every day people quickly recognize you as the UUID guy :)

1600278757
leeward
That sounds true, nephele. Also, you can't be a member of any communities.

1600280030
justin_smith
nephele: but anybody could easily spoof you by picking their own UUID

1600280141
justin_smith
I watched the async chat server video demo this morning, and follow up with a few thoughts that I tagged onto an existing "issue" on gh

1600280179
justin_smith
I should check if concurrent queue / concurrent hash with lock-free reads are on the road map already

1600281574
leeward


1600281743
justin_smith
leeward: oh cool, maybe various data structure questions are consolidated somewhere (eg. arguments about which data structures are good enough / light weight enough / general enough to come with zig?) good data structures being available can make a big difference in language lib quality / usability

1600281780
justin_smith
eg. if we all start using a data structure that doesn't fly on embedded, that doesn't seem like what zig was designed for

1600281807
justin_smith
OTOH if there's a light and powerful data structure that avoids re-implementing trees / lists everywhere, that's a bonus

1600281818
leeward
I haven't seen that discussion, but it's probably happened. If you know of a data structure that's not supported in the standard library, it's pretty easy to get an implementation in.

1600281825
justin_smith
TBH I should look at what data structures are already provided before speculating

1600281853
justin_smith
leeward: yeah, sounds like a plan, and a way I could likely contribute something I'd be proud of :D

1600281879
leeward
sweet

1600281907
leeward
It's all under lib/std in the source. That's (unfortunately) the best place to look these days.

1600281971
leeward
The standard library docs at ziglang.org/documentation/master/std are not up to date.

1600282004
leeward
Or maybe I'm wrong? It looks like they have been updated since I last looked.

1600282011
justin_smith
leeward: thanks for the tip, yeah I don't find much about data structures in documentation/master and that's been my primary learning resource so far

1600282032
leeward
The source is still a better place to go for now.

1600282058
justin_smith
eg. I spent way too long trying to translate a library example from c, because translate-c isn't mentioned in documentation/master, I only noticed it because someone mentioned it here

1600282062
justin_smith
great

1600282113
leeward
Huh, that seems like an oversight.

1600282141
leeward
documentation/master is also in the source, under doc/langref.html.in

1600282890
justin_smith
oh, so it's like std/hash-map std/atomic/queue

1600282923
justin_smith
it would be nice if they were at least aliased to std/data-structures/...

1600283631
leeward
agreed

1600283658
leeward
maybe std/data-structures/threadsafe/

1600283678
leeward
or std/data-structures/threadunsafe/, if there's anything that belongs in there.

1600283770
leeward
I'm not sure there should be. Since you can tell it to build single-threaded, it makes sense to have the implementations chosen at build time.

1600284115
andrewrk
pixelherodev, that's something worth considering, certainly. are you running into situations where you have to copy+paste logic?

1600284244
pixelherodev
andrewrk: not direct copy paste, but close enough

1600284251
pixelherodev
The next big change on my radar is condbr

1600284278
andrewrk
I'd like to see a couple instances of the logic being duplicated and then we'll have something to look at when figuring out how to re organize

1600284292
andrewrk
let's let it get a little bit bad at first

1600284355
pixelherodev
Heh, sure

1600287154
nikki93
i've been working no an ecs-based game engine in c++ that runs natively but also in wasm and uses the dom for an editor ui in the web -- quick video here:

1600287191
nikki93
anyways i've been interested in how zig could be cool for such a thing bc. you can reflect on the structs and do a bunch of comptime stuff for editor ui / serialization / scripting bindings etc.

1600287352
nikki93
there's also this dom dsl (you can see in `Sprite_uiInspect` or `Feet_uiInspect` below for example, where i define custom inspection ui for the sprite and feet stuff you see in the vid) -- would be cool to try something like that in wasm zig (tho the c++ version relies on emscripten for js bindings and isn't much freestanding wasm)

1600289652
nikki93
playing around w/ reflection in zig rn and it's nice :o a main thing that caught my eye is also a quick recursive fibonacci benchmark that i tend to do in any new language i'm trying out and it's faster in zig than see / neck n' neck lol

1600289735
pixelherodev
I accidentally made an infinite loop in freaking color extraction code

1600289738
pixelherodev
Haven't felt this dumb in a while

1600289786
fengb
Thatâ€™s a type of error I make every week >_>

1600289863
nikki93
@pixelherodev: maybe the zig compiler could detect if one's code is going to infinite loop ;o lolz

1600289933
leeward
That sounds like a nice easy problem that could be solved in an afternoon.

1600289950
leeward
Just write a little program that tells you if a loop is infinite.

1600289963
pixelherodev
Hahaha

1600289991
pixelherodev
There's a few types that could be caught

1600289993
pixelherodev
This isn't one of them

1600290067
leeward
We actually discussed having an SDL I worked on detect certain types of infinite loops. It's not hard in some cases, and can be very handy.

1600290091
pixelherodev
s/SDL/DSL ?

1600290094
nikki93
but what if ur program does an infinite loop if zig says the program doesn't

1600290112
pixelherodev
Some loops are definitely infinite, some are definitely finite

1600290126
pixelherodev
Most, the compiler can't reasonably know

1600290153
nikki93
fn f() { if (doesntInfiniteLoop(f) { while (true) {} }

1600290283
leeward
heh, yes, a DSL

1600292766
jjsullivan1
`@doesHalt()`

1600292767
jjsullivan1
lol

1600292789
andrewrk
welcome nikki93 - I'm looking forward to seeing how it works out for you

1600292815
fengb
Until andrew takes away recursion ;)

1600292953
mkchan
alright, i've been banging my head against this since yesterday:

1600293003
mkchan
there's also other errors i suppose because i seem to be doing some really questionable stuff

1600293321
mkchan
nvm, i'm dumb. i returned the struct into network but never initialized it

1600293330
mkchan
this channel is a good rubber duck it seems

1600293337
ifreund
quack!

1600293349
mkchan
rubber ducky debugging! :)

1600294220
mkchan
also the other error was i hadn't marked my loop variable as comptime so the array access complained. the code works now

1600296612
nikki93
andrewrk:  thanks! i'm gonna keep doing this existing game project in c++ but gonna keep keeping an eye on zig and trying lil projects in it ^_^

1600296660
andrewrk
oh nice all checks passing for #6250

1600296677
andrewrk
let's see how the CI server likes it when I delete 5,000 lines of C++ code

1600296690
fengb
:o

1600296787
nikki93
:O is self-hosting done? lol

1600296819
andrewrk
a large chunk of it happening in a giant branch

1600297138
daurnimator
was there an issue around to fix the problems that come up with new glibc releases?

1600297155
daurnimator
(i.e. that the native target should fall back to the newest known glibc version)

1600297251
andrewrk
daurnimator, solved in this branch:

1600297670
daurnimator
is that the 6250 branch?

1600297713
andrewrk
yes

1600297722
daurnimator
cool :)

1600297765
andrewrk
nice, just got `zig cc -o hello hello.c` working entirely self-hosted (depends on clang of course)

1600297796
mkchan
wait then what's the self hosted part?

1600297828
daurnimator
mkchan: "what is `zig cc` written in"

1600297832
andrewrk
providing all the objects needed to link and doing the linker driver

1600297846
andrewrk
zig is doing quite a lot of handy work for you when you use zig cc

1600297882
mkchan
yeah i remember that from your talk. so you mean zig is bootstrapped now?

1600297945
mkchan
like initially you would compile zig with c++ but now you used that c++-compiled zig compiler itself to compile zig

1600297953
mkchan
if i understand correctly

1600298034
andrewrk
well there is

1600298057
andrewrk
it will be a milestone when self-hosted (without llvm) can build itself

1600298061
mkchan
alright nvm me then, i need to google some stuff

1600298067
andrewrk
I think we're about 6 months away from that ;)

1600298160
andrewrk
building hello.c into an executable: stage1 took 2.4s with cold cache, stage2 took 1.0s with cold cache

1600298181
fengb
o_O

1600298189
andrewrk
with a warm cache, stage1 took 0.04s, stage2 took 0.02s

1600298265
andrewrk
I'll get some tracy screenshots going :D

1600298276
andrewrk
oh those were debug builds of stage1/2 btw

1600298815
pixelherodev
Warm cache is cheating...

1600298820
pixelherodev
Ah wait, zig cache?

1600298825
pixelherodev
Thought you meant cpu cache for a minute :P

1600298902
andrewrk
ya zig cache

1600298924
andrewrk
all this shit

1600298976
pixelherodev
why is stage2 so much faster?

1600298976
fengb
So itâ€™s always 100+% faster

1600299025
andrewrk
b/c c++ sux

1600299034
mkchan
:O

1600299043
fengb
Youâ€™re just using it wrong ðŸ™ƒ

1600299055
andrewrk
yeah, that's the whole problem lol it's impossible to use it correctly

1600299069
pixelherodev
i mean, I agree, but...

1600299071
mkchan
use less templates

1600299087
mkchan
and by that i mean the entire stdlib

1600299172
pixelherodev
I thought C++ had runtime perf on par with C?

1600299183
pixelherodev
(and atrocious comptime perf, and also just sucky as a lang :P)

1600299264
mkchan
mostly does, but depends on the optimizations it can make if you use exotic features

1600299622
mkchan
if i use --release-fast on godbolt, it no longer shows corresponding source and asm colors is that normal?

1600299789
mkchan


