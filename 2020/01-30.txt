1580343534
fengb
Yeah that’s a good point

1580344471
dimenus
wow, i cannot believe how much sampling from an MSAA buffer costs in performance

1580344493
dimenus
(this is in Vulkan)

1580344573
dimenus
MSAA vs non-MSAA halves my framerate (but has barely any effect if I don't do any post processing)

1580344880
shakesoda
dimenus: even worse, the performance is vastly different between vendors

1580344913
dimenus
i think i'm overcreating buffers though, shouldn't need an MSAA buffer / render target per swapchain

1580344948
shakesoda
on some mobile hardware the msaa is full rate and you mostly have to worry about the resolve cost

1580345010
fengb
I’m actually happy that nobody is complaining about my leak detector. Literally slapped together without any forethought

1580345072
shakesoda
there's also all kinds of gotchas, like if you actually use the sample id in your shader then you get more pixel shader invocations (iirc you can avoid this, but i don't remember the details)

1580345268
dimenus
5500 fps to 2700 fps from using MSAA

1580345302
dimenus
it's still faster than the GL clone, but nowhere near the 4x I originally had

1580345315
dimenus
in short, MSAA on a shader attachment is super expensive

1580345366
shakesoda
eh, the fps makes it sound a lot worse

1580345396
dimenus
yeah, my frame time is still ~0.5ms :P

1580345397
shakesoda
it's a bad relative difference, but that's still pretty dang fast :)

1580345411
dimenus
but the numbers!

1580345452
dimenus
this is obviously a simple game, but I love how Vulkan forces you out of the OO style

1580345481
shakesoda
good, oo style is an insanely bad habit for doing renderers

1580345498
shakesoda
i have to get on people's cases a lot for shooting themselves in the foot trying to abstract GL that way

1580345501
dimenus
i have barely any uniforms in this program, just a textures essentially

1580345517
dimenus
*just for textures

1580345576
shakesoda
i haven't got too many uniforms in general anymore, most stuff ends up in ubo/ssbos unless it truly needs to change per draw

1580345580
dimenus
this is on a RX550 btw

1580345598
dimenus
eer isn't a uniform a ubo?

1580345600
dimenus
or am i confused

1580345607
dimenus
Vulkan only has blocks, no standalone uniforms

1580345628
shakesoda
aye, i'm on GL

1580345654
shakesoda
vulkan renderer is a bit stillborn, haven't had the need to complete that project

1580345722
dimenus
this project is about 5k lines so far

1580345770
shakesoda
when i think 5k lines and vulkan i think "ah, a triangle"

1580345774
shakesoda
:P

1580345794
dimenus
hah! it's not that bad. I'm not including the zig generated vulkan headers

1580345803
dimenus
if i do that it's 30k

1580345826
dimenus
that's including the cimports for a couple libraries though, not just vulkan

1580345891
shakesoda
30k D:

1580345924
shakesoda
at least it's just generated code, i guess

1580345956
shakesoda
i think my entire engine currently amounts to something like 50k

1580346125
dimenus
how do you handle a uniform of arrays in gl, does it make a copy in the background and align them to 16 bytes?

1580346145
Snektron
Dimenus, its logical that fps is slower with MSAA of course

1580346163
Snektron
Especially considering 5500 fps on a 550 means youre not doing a lot

1580346166
dimenus
Snektron: agreed, but didn't think it would be 50%

1580346187
dimenus
without rendering to a shader attachment, it barely even hicked up when adding MSAA

1580346196
dimenus
*hiccuped

1580346200
Snektron
4x msaa is rendering at 4 times higher resolution, so 50% is alright

1580346269
Snektron
This one time i changed one variable in my compute shader and doubled performance

1580346331
Snektron
Anyway, if youre not doing a lot of rendering, anything can have a large impact

1580346364
Snektron
Because the whole shader switching thing has a lot of overhead

1580346389
Snektron
Its probably more fair to test the difference when you render a lot of things

1580346423
shakesoda
dimenus: i have everything packed into vec4's to maintain 16 byte alignment without really doing anything special

1580346425
shakesoda
no magic

1580346548
Snektron
In vulkan theres this nice feature called push constants

1580346563
Snektron
You can embed a shader variable directly in a command stream

1580346587
Snektron
Its really efficient for things that update every frame

1580346588
shakesoda
sounds like a regular uniform in gl?

1580346635
Snektron
Hm i dont know, depends on implementation

1580346651
Snektron
I expect opengl to do a staging buffer kind of thing in the background

1580346663
dimenus
Snektron: not sure if you missed some of the convo earlier, but the only uniform blocks i'm using are for textures / combined samplers

1580346671
dimenus
indices and small values all come of push constants

1580346677
dimenus
the other nice thing is that push constants are align(4)

1580346707
Snektron
Instead of align(16) you mean?

1580346737
dimenus
yep, I just wrapped uniform types in a struct and that solved the issue

1580346743
Snektron
Isnt any glsl value aligned by its size, up to 16 bytes

1580346756
dimenus
no, arrays are 16 regardless of size

1580346763
Snektron
I see

1580346769
dimenus
eg vec2 would be align(8) but vec2 foo[3] would be align(16)

1580346799
Snektron
Hm, i thought it rounded up

1580346801
dimenus
And MSAA is just overkill for a breakout clone, it's only rendering at 800x600 :D

1580346840
Snektron
dimenus, i assume you saw that im working on a zig generator from vk.xml

1580346850
dimenus
nice

1580346854
Snektron
Do you happen to have any feature requests?

1580346874
shakesoda
dimenus: think of the smooth edges you could have on the backgrounds!

1580346882
shakesoda
of course it's not overkill! ;)

1580346891
dimenus
no, i'm not an idea man and i don't work for a game dev company - so I don't really have a business case for Vulkan. I just wanted to try building the learnopengl.com breakout clone in zig/vulkan

1580346899
dimenus
and see how fast I could makme it

1580346927
dimenus
but i apprecate the thought, I'll let you know if I need something :)

1580346937
Snektron
Currently i mostly have default values for some struct fields (like sType), error sets instead if VkResult, more accurate pointer types, and stuff like that

1580346978
dimenus
those are all nice to haves, i went through the generated code and set a good chunk of defaults, but i haven't touched any code I don't need yet

1580347016
dimenus
default struct init is a really nice feature to have in a language with Vulkan's API

1580347023
Snektron
Doesn't matter if youre a professional game dev or not (im certainly not), just if you maybe thought "this would be useful"

1580347042
Snektron
Yeah, its mostly just about nice-to-haves

1580347106
Snektron
Stuff that cant be expressed in C but can in zig, and happens to be defined in vk.xml

1580347136
Snektron
Theres also information about optional types but i was told that its incorrect

1580347142
Snektron
Too bad

1580347168
dimenus
50% performance was at 8x btw, definitely overkill for 800x600 :P

1580347526
shakesoda
8x is always overkill :P

1580347543
fengb
I have an important question

1580347573
shakesoda
unless you've got some special needs, at least (i.e. msaa trick + additional msaa... but i haven't seen anyone do that in a while)

1580347578
fengb
How should the community name projects? Java likes to append 4j, Python prepends Py, etc

1580347604
fengb
We need a dumb standard

1580347631
shakesoda
i'm fine with zig-whatever or just nothing

1580347645
companion_cube
suffix with -zag

1580347660
shakesoda
zig-thing-zag

1580347664
companion_cube
(which means zig becomes zig-zag, badum-tss)

1580347666
companion_cube
yep

1580347751
shakesoda
i like the (old and now somewhat discouraged) love2d library naming scheme of "plausibly deniable sexual innuendo"

1580347756
shakesoda
alas, it has fallen out of favor

1580347864
companion_cube
like, weboob?

1580348261
shakesoda
usually a bit more subtle than that, although not always

1580348384
Snektron
Java also prepends j

1580348635
companion_cube
just suffix your project name with `.comptime`

1580348646
companion_cube
(or prefix?)

1580348705
pmwhite
comptime-websockets

1580348725
companion_cube
there's a ring to it, right?

1580349584
pmwhite
I'm not sure what I would think when I see that title. I don't want my program to require an internet connection while it compiles.

1580349595
pmwhite
It has google-ability going for it though.

1580349614
companion_cube
it'd be a private joke in the community, is all :p

1580354801
seoushi
so I made a basic zig uild file based off the tetris project. It references the root source file main.zig. I want to start writing a lot of code but not nessiarly put anything in main.zig yet. If I import the file it seems like ti doesn't compile it till I reference the struct in the file. Is there a better way to just add files to the build script or something to force compilation? I can't seem to find any documentation on

1580354801
seoushi
build scripts.

1580355008
andrewrk
here's the issue for docs for the build system:

1580355048
andrewrk
zig has lazy analysis, so you will have to reference things before they are checked by the compiler

1580355063
andrewrk
one thing you can do is to add unit tests

1580355078
seoushi
ok

1580355081
seoushi
thanks

1580355091
andrewrk
even something as simple as `test "stuff" { _ = foo; }` will now semantically analyze `foo` when you run `zig test file.zig`

1580355158
seoushi
is this true for libraries as well? or just executables? I would figure that libraries would evaulate everything marked with pub?

1580355323
andrewrk
exported symbols are entry points

1580355440
andrewrk
but a zig package to be used by other zig code is subject to the same lazy analysis rules

1580355475
andrewrk
this is an acknowledged issue, with open github issues related to it

1580355518
seoushi
ok

1580355590
andrewrk
note that any programming language that has generic functions suffers from this same problem. it's just that in zig, generic functions and regular functions are treated less differently

1580355896
fengb


1580356287
andrewrk
fengb, yes, should be using the allocator parameter

1580356562
salotz
zig is an acronym for "zig is good" right?

1580356688
fengb
I think I found an actual leak

1580356702
andrewrk
nice

1580356906
andrewrk
salotz, actually it stands for Zag Isn't Good

1580356951
salotz
zig's evil twin

1580357016
andrewrk
creator of zag:

1580357035
nofmal
hello, i just made a basic implementation of termios:

1580357044
nofmal
any feedback is appreciated

1580357068
andrewrk
nice work nofmal

1580357113
salotz
zag arches zig

1580357138
andrewrk
nofmal, it looks like termios is a POSIX standard, which means that it's a good candidate to go into lib/std/os.zig, following the pattern of the other functions there

1580357255
nofmal
yes. i've only tested it in my machine (linux x86_64)

1580357262
nofmal
is it available in *bsd too?

1580357305
fengb
`TERMIOS(4)               BSD Kernel Interfaces Manual               TERMIOS(4)`

1580357319
fengb
Seems like it

1580357377
nofmal
well either way i cannot be sure if it works perfectly in bsd

1580357454
nofmal
the only differences from what i've looked is that, in powerpc, the `NCCS` constant is 19 instead of 32

1580357482
nofmal
anything else is the same

1580357724
andrewrk
still, if you are considering submitting it as a pull request to zig, it should be structured in a way so that bsd programmers will be able to contribute to

1580357740
andrewrk
(the structure of the existing things in std.os)

1580359090
ajl
A function in a C library is returning a value of type [*c]const u8. I believe that means a c style pointer to a const u8, and I think its actually a null terminated array of const u8. Is there any way to cast that array into a zig style []const u8 string?

1580359174
andrewrk
ajl, `[]const u8` needs to know the length. you can convert with std.mem.toSliceConst(u8, your_c_ptr)

1580359458
ajl
That was exactly what I was looking for. Thank you.

1580362749
adamkowalski
How do I include a file that is in the parent directory? when I did @import("../foo.zig"); I get an error 19: error: import of file outside package path: '../util/array_info.zig'

1580362782
adamkowalski
When I test by doing zig test src/main.zig everything passes however, it's only when trying to test files within the nested folder

1580362866
gruebite
heyo, i'm getting this when compiling master: zig_clang_cc1as_main.cpp:511:23: error: ‘Value’ may be used uninitialized in this function

1580362907
gruebite
clang version 9.0.1

1580362985
adamkowalski
whats your os?

1580363062
gruebite
linux

1580363069
gruebite
Linux zork 5.4.13-arch1-1 #1 SMP PREEMPT Fri, 17 Jan 2020 23:09:54 +0000 x86_64 GNU/Linux

1580363265
adamkowalski
hmm, i'm on arch and I'm running master build just fine. Did you run `pacman -Sy clang cmake gcc llvm lld`

1580363369
gruebite
yeah, good there. weird

1580363421
adamkowalski
how are you compiling? mkdir build; cd build; cmake -G Ninja ..; cmake --build .;

1580363441
adamkowalski
I also usually throw on a release flag

1580364376
gruebite
got it working, thanks

1580364886
gruebite
is c"foo" still a thing? i'm getting an error and can't find any documentation

1580365271
shakesoda
gruebite: i think that was removed

1580365295
mikdusan
gruebite:

1580365319
gruebite
thanks, yep

1580366242
gruebite
foo_struct.@"bar" is interesting. i do not anything for accessing it at runtime? for anonymous lists it would be useful for callee's to iterate over the struct members at compile time

1580366269
gruebite
runtime/compiletime

1580367230
gruebite
can i purposefully disqualify const qualify if say... c code doesn't have a const function pointer?

1580367449
fengb
The nuclear option: @intToPtr(*T, @ptrToInt(ptr_const))

1580367504
gruebite
heh

1580367571
gruebite
for every function pointer D:

1580367649
gruebite
i'm dealing with an api that heavily uses function pointers (dynamic plugins, register callbacks all the time)

1580367677
gruebite
i had a patch file that just added consts everywhere but i don't like that solution

1580368168
gruebite
.create_func = @intToPtr([*c]fn(?*c_void, ?*c_void) callconv(.C) ?*c_void, @ptrToInt(test_constructor)),

1580368190
gruebite
beautiful

1580368248
gruebite
not 100% sure if that should be &test_constructor

1580368620
fengb
Oof

1580368658
fengb
I've never interfaced with C function pointers with Zig :/

1580371351
shakesoda
i had some mild trouble with it too, day 1 of trying zig

1580374118
traviss
does anyone know if there is already an issue for this?

1580374130
traviss
it looks like the lhs of == between @Vector(4, usize) usize is being turned into @Vector(4, u64) inside a function but not outside of it

1580384155
betawaffle
how does one define a function with is_var_args == true?

1580384614
betawaffle
does that just mean "has at least one argument with type `var`", or is it related to variable-length argument lists?

1580386884
Snektron
traviss, i think boolean operators aren't implemented yet for vectors

1580386960
Snektron
or at least not properly

1580392937
traviss
Snektron, == does work for other vector types. in the example i linked, i can do `const v = v1 == v2` where v1 and v2 are @Vector(4, usize). the issue is when i try that inside a function.  i think v1 gets interpreted as @Vector(4, u64) and there is a compiler error.

1580392976
traviss
also errors for isize.  the error goes away if the vectors are declared as u64.

1580393030
Snektron
i see, i actually ran into that issue before too

1580393097
traviss
i couldn't find a github issue so i wanted to see there's already one created

1580393289
Snektron
i don't think so, but its related to

1580393502
traviss
ok thanks. i'll create one then.

1580393583
traviss
actually maybe i'll wait a bit to see if there's any other input on this

1580395384
andrewrk
gruebite, that file comes from upstream clang. it may need to be updated for 9.0.1

1580395451
andrewrk
as for function pointers what happens if you just try to corece the type rather than using inttoptr/ptrtoint?

1580395496
fengb
He mentioned needing to ditch the constness

1580395562
andrewrk
ah

1580395583
andrewrk
ditching constness looks ugly in zig ¯\_(ツ)_/¯

1580396066
fengb


1580396300
andrewrk
nice work on finding and fixing BufMap value leak

1580396351
fengb
👍 I hope this ref counting is good enough™ for now. I had to fix a few errors so my biggest fear is false negatives

1580396444
fengb
For the builder, I think it'd be even better if it auto creates an arena so it always does the correct thing. But until we get the optional shrink, chaining arenas seems to degenerate a bit

1580396462
andrewrk
that makes sense

1580396474
andrewrk
ugh annoying time for sourcehut to shit the bed

1580396482
andrewrk
I'm pretty sure the only admin is on a plane to FOSDEM

1580396649
fengb


1580396681
fengb
Or does the source image depend on the package and we need an admin

1580397354
andrewrk
let me try

1580397723
andrewrk
it works but that means I have to do this:

1580397732
andrewrk
(which I'm going to do because it Just Works)

1580397756
andrewrk
imo the sr.ht script itself should do that

1580397912
andrewrk
thanks fengb

1580398379
fengb
np

1580398771
fengb
Oof, I just noticed that this is an antipattern:

1580398800
fengb
The parseList needs to happen before assigning the arena

1580398954
Snektron
yeah, i've noticed a few cases in the std where theres a workaround for that

1580399119
fengb
I'm glad the leak detection is working :D

1580400157
betawaffle
is it always safe to assume *c_void and usize are the same size? can i use either one for a field in an `extern struct`?

1580400176
andrewrk
zig target cpu/features already having a wider ecosystem impact:

1580400218
andrewrk
betawaffle, yes, usize is defined to be the size of pointers

1580400292
betawaffle
when the package manager is a thing, is the std library going to be... uhh... pluggable?

1580400364
Snektron
I never understood why there are different types for size_t and intptr_t

1580400390
betawaffle
size_t is unsigned and intptr_t is signed, right?

1580400410
Snektron
you're thinking of ptrdiff_t

1580400442
Snektron
oh nevermind

1580400447
Snektron
theres also an uintptr_t

1580400453
andrewrk
I think there were once upon a time, systems that had pointers of different sizes than registers

1580400454
Snektron
because why not

1580400502
andrewrk
betawaffle, what use case specifically are you thinking of?

1580400525
betawaffle
andrewrk: this very moment, byo event loop?

1580400680
andrewrk
event loop is already pluggable

1580400690
betawaffle
oh?

1580400713
betawaffle
i suppose there are probably a lot of things like that, but there's no documentation yet

1580400738
andrewrk
yeah

1580400782
andrewrk
I was also considering whether making an event loop an interface would make sense. kinda like Allocator

1580400800
betawaffle
i think that could be good, yeah

1580400826
companion_cube
(are event loops going to be composable as well? :p)

1580400827
betawaffle
speaking of interfaces... the documentation really needs to discuss them, at least a little

1580400847
phillyiscool
Something I'm curious about, if you want to libraries that are consumable from C using Zig, does this mean you can't use comptime (and possibly other Zig features)?

1580400850
betawaffle
because afaict, there are already a number of them in std, and i don't know what they are or how to use them

1580400862
companion_cube
amen to this betawaffle

1580400918
andrewrk
phillyiscool, only types that are compatible with the C ABI are available when exporting symbols

1580400933
betawaffle
what i want is to be able to have per-thread event loops

1580400942
andrewrk
betawaffle, that's already a thing too

1580400956
companion_cube
if you use zig with libuv and jemalloc… are you cheating? :D

1580401016
andrewrk
betawaffle, oops, spoke too soon. I think there are a couple problems to solve to make that work. but that's planned too

1580401037
andrewrk
the way zig does async functions makes this possible:

1580401043
andrewrk
switchToGuiThread();

1580401044
betawaffle
i want resume/suspend to have atomics be optional

1580401068
fengb
Ah so do generators :P

1580401092
andrewrk
betawaffle, yes I've been thinking about that too

1580401105
andrewrk
you can use --single-threaded to avoid that, but it's a global setting

1580401107
phillyiscool
andrewrk Thanks. What do you recommend when you want to have both a C ABI and a "nicer" Zig API?  Write a low-level C compatible layer and "wrap" that with Zig niceness?

1580401125
betawaffle
because sometimes you have your own locking wrapping the resume/suspend stuff

1580401125
andrewrk
phillyiscool, other way around. have a nice zig package api, and wrap it with a C compatible layer

1580401158
phillyiscool
How is that possible if the nice zig package depends on comptime? The C layer can't use that, right?

1580401183
andrewrk
the parameters of the exported function cannot. but the function implementation can call zig functions

1580401235
phillyiscool
Hm, ok thank you very much. I'm currently working on something where I do this. I haven't gotten to the point yet where I can have more feedback but hopefully I can share something soon.

1580401254
phillyiscool
Would love to write an article or something on this to share with the community once I've figured out how to do it.

1580401337
andrewrk
you can have pointers to zig types in exported functions

1580401966
companion_cube
why hello this is a void*

1580402135
andrewrk
better yet it can be a fwd struct decl

1580403118
betawaffle
hmm... what's the "right" way to read errno in zig?

1580403164
andrewrk
you can see a lot of examples of this in std/os.zig

1580403187
andrewrk
without knowing any more about what you're doing, the right way might be contributing another function to os.zig

1580403317
betawaffle
it's a function that returns a file descriptor, or -1 + sets errno

1580403356
betawaffle
which is such a stupid interface, why do people suck

1580403767
andrewrk
ok so you're interfacing with a third party c library that messes with errno

1580403785
betawaffle
a system c library, but yes

1580403806
andrewrk
std.c.getErrno()

1580403818
andrewrk
oops

1580403825
andrewrk
std.c._errno()

1580403866
andrewrk
what is the function called?

1580403884
betawaffle
kqueue, don't judge me

1580404002
andrewrk
why not use std.os.kqueue?

1580404021
betawaffle
eh, ok will do

1580404769
metaleap
ouf.. one day I'll have to bite the bullet and devise a "comptime-reflection querylang-eDSL-ish" to not hardcode traversing-whoppers like this one:

1580404797
betawaffle
lolwat

1580404809
Snektron
what the fuck

1580404810
companion_cube
is this a predicate? :D

1580404815
metaleap
or am i missing some techniques

1580404826
metaleap
other than "no duck interfaces (yet)"?

1580404835
metaleap
(unless someone took a stab at that somewhere? havent searched tbh. std.meta is helpful but here wouldnt save all that much)

1580404836
betawaffle
you could definitely break that into functions

1580404903
metaleap
yeah there's even some structurual repetition of similar test-and-traverse paths 3x in there so, sure. thats the first step towards a comptime-reflection-queryer-lib/api/lang

1580404912
mq32
metaleap, that can be written much easier

1580404922
betawaffle
what you need is the equivilent of rust's `if let Variant(...) = ...` stuff

1580404937
metaleap
mq32: thats what i hoped! :P

1580404941
companion_cube
and use `return false;` early

1580404952
companion_cube
betawaffle: but you can do that here

1580404953
mq32
you are NOT required to switch on tagged unions

1580404953
mq32
var typeInfo = @typeInfo(T);i

1580404957
mq32
if(typeInfo != .Struct) return falsE;

1580404964
betawaffle
companion_cube: sure, i know

1580404976
mq32
typeInfo.Struct.…

1580404976
companion_cube
`const x = switch(…) x: { else => return false; .Struct => break 'x whatev}`?

1580404978
metaleap
companion_cube: if you look careful, i technically

1580405007
companion_cube
ah but you have some inline for… yeah

1580405032
mq32
metaleap, invert all conditions and fast-skip loops with continue

1580405039
gruebite
fengb: i like that function. mind if i use it?

1580405050
metaleap
mq32: great pointer with the union-switch-not-necessary, brain still shaped from go's type-switches

1580405082
metaleap
thatll make stuff more readable (continue instead of return of course)

1580405083
mq32
=> your code will have probably a max indendt depth of 1

1580405083
mq32
*3

1580405107
Snektron
What do you even need this for

1580405126
companion_cube
that's what you'll have to expect if/when Zig gets contracts on generics :p

1580405135
companion_cube
`if isHashMap(T)

1580405137
companion_cube
`

1580405156
metaleap
Snektron: some json-ery (treat other-structs and hashmaps un-alike in un/marshaling)

1580405181
metaleap
daurnimator will probably be able to relate :D

1580405487
fengb
gruebite: sure, but I’m not sure which function you’re taking about

1580405797
adamkowalski
how are you supposed to import zig files in a directory above you?

1580405852
adamkowalski


1580405852
adamkowalski
./src/lazy/graph.zig:3:24: error: import of file outside package path: '../eager.zig'

1580405852
adamkowalski
const CpuTensorUnion = @import("../eager.zig").CpuTensorUnion;

1580405899
adamkowalski
If I run zig test src/lazy/add.zig then I get this error. However, I run zig test src/main.zig which itself references lazy/add.zig then everything works fine

1580405924
andrewrk
adamkowalski,  --main-pkg-path ..

1580405980
andrewrk
we're in a bit of a transition to packages, bear with me

1580405984
adamkowalski
thanks that works!

1580406016
adamkowalski
well it's not a big issue, my entire test suite runs in 0.08 seconds since zig is awesome

1580406073
metaleap
i think i'll write a general `fn doesTypeMatch(comptime T: type, comptime Spec: builtin.TypeInfo) bool` to ditch my above ad-hoc whopper.. let's see how that goes

1580407310
gruebite
fengb: removeConst

1580407393
fengb
Oh I added that as a small joke because it’s not as gross looking as it should be :P

1580407425
gruebite
yeah, it's better than what I was doing, more type safe

1580407522
andrewrk
better yet, fix the .h file upstream

1580411514
gruebite
andrewrk: true. one is slower than the other, but they can certainly be done in parallel

1580413072
seoushi
andrewrk: created my first working zig code last night. It's a pool data structure which might be useful in std.

1580413306
gruebite
with @import must i include `.zig`?

1580413324
gruebite
docs say no, but compiling says yes

1580413505
SyrupThinker
There are these special imports for std and builtin but all others need the .zig extension the way I see it (because they are paths)

1580413610
andrewrk
wow, llvm 10 release candidate 1 already

1580413614
andrewrk
I better get this llvm10 branch passing tests

1580413616
SyrupThinker


1580413695
BaroqueLarouche
std and builtin are special, but you can set your own package path

1580413730
BaroqueLarouche
with zig build:

1580413744
BaroqueLarouche
then you don't have to specify the file extension

1580413762
gruebite
cool

1580413905
SyrupThinker
Good to know, time to clean some stuff up

1580414436
gruebite
i feel like my conversion is wrong

1580414447
gruebite
in zig a function pointer does not need a "&" preceding the alias?

1580414481
gruebite
fn foo() {}; const bar = foo; // bar is a function pointer

1580414490
gruebite
am i correct?

1580414609
andrewrk
correct

1580414703
gruebite
is there some magic when passing it to C then? i've been doing `removeConst(&func_ptr)` but that's wrong, it should be `removeConst(func_ptr)` but it isn't treated as a pointer type

1580414717
gruebite
it's like a const reference that coerces to a const pointer?

1580414840
gruebite
basically: `@TypeInfo(func_ptr)` is not `.Pointer`

1580414896
andrewrk
gruebite, try this: std.debug.warn("{}\n", .{@typeInfo(@TypeOf(main))})

1580414990
gruebite
it's .Fn, so i cannot remove const easily when passing to C

1580415001
metaleap
i'm still bit new to mem-mgmt.. how does anyAllocator.shrink of some previously alloc'd bytes "return to the caller the just freed bytes"? i mean ..

1580415009
gruebite
fixing upstream seems like the

1580415049
metaleap
take Buffer.toOwnedSlice: "The caller owns the returned memory." and inside it calls allocator.shrink(). which becomes the result of toOwnedSlice..

1580415099
metaleap
so i call that and now "own" the memory but it was just freed so does that mean i need to put it somewhere STAT before it gets overwritten... it cant be on stack AFAIK

1580415107
gruebite
also, side note, what's the significance of capitalization convention regarding: @typeInfo and @TypeOf?

1580415136
metaleap
gruebite: convention is, `type`-typed expressions are uppercase

1580415169
metaleap
also goes for funcs that return `type`s (because thats how the generics work, eg. `std.ArrayList(T)`)

1580415176
andrewrk
gruebite, the pointer casting builtins work for functions as well as pointers

1580415362
gruebite
how do i get around "cast discards const qualifier"

1580415370
gruebite
using standard casts

1580415396
gruebite
doing this: `@ptrCast([*c]fn(?*c_void, ?*c_void) callconv(.C) ?*c_void, test_constructor)`

1580415417
andrewrk
you never need to type [*c] into your keyboard

1580415470
andrewrk
@ptrCast does not have the ability to strip `const`

1580415502
andrewrk
the nuclear option is @ptrToInt/@intToPtr

1580415526
gruebite
is that the nuclear or only option?

1580415529
gruebite
or both :D

1580415596
metaleap
so real-world example on my above mem-mgmt-newb question.. lets say a user-defined func, passed to some zig lib ("use this func to get say some id") to return a string. might be tempting for the implementer to use its own favorite allocator and a std.Buffer, then return `buf.toOwnedSlice()` which cleans up the buffer kinda. now the "caller owns" the returned string but also needs to free it (at some point) "from somewhere". so the caller needs to know the

1580415597
metaleap
user-code's allocator used, i guess?

1580415701
pmwhite
that would be a leaky abstraction, no?

1580415738
metaleap
how so

1580415783
metaleap
libs allowing "user-specified fn impls of certain signatures" isnt all that uncommon pattern in interface-less langs I'd have to presume?

1580415876
metaleap
guess i have to give an alloc (for the implementer to alloc his ret-value from but not free from.. hum) to such a sig, to keep things predictable

1580415892
pmwhite
Oh, I misunderstood your explanation I think.

1580415997
pmwhite
Perhaps you don't actually want to return the owned version of the slice to the caller?

1580416005
metaleap
np.. somehow i tend to run into issues that defy clear problem description. might be a sign of garbled synapses :D

1580416065
pmwhite
I think I get your conundrum now, but of course I don't have the whole picture.

1580416202
gruebite
checking my sanity: `.create_func = @intToPtr(*fn(?*c_void, ?*c_void) callconv(.C) ?*c_void, @ptrToInt(test_constructor))` should work if `create_func` is defined by: GDCALLINGCONV void *(*create_func)(godot_object *, void *), where godot_object is void, and GDCALLINGCONV is __attribute__((sysv_abi))

1580416246
gruebite
test_constructor is `export fn test_constructor(obj: ?*c.godot_object, method_data: ?*c_void) callconv(.C) ?*c_void`

1580416289
gruebite
it's crashing godot, so something is off

1580416303
andrewrk
gruebite, `fn()void` is already a pointer. `*fn()void` is a double pointer

1580416321
Snektron
function point syntax is honestly kind of confusing

1580416328
Snektron
because its a pointer yet there is no star

1580416329
gruebite
removing it i get: error: expected type '[*c]fn(?*c_void, ?*c_void) callconv(.C) ?*c_void', found 'fn(?*c_void, ?*c_void) callconv(.C) ?*c_void'

1580416364
gruebite
yeah, so used to C and having to provide an asterisk

1580416365
gruebite
heh

1580416403
Snektron
ah, at least its nothing compared to c++ member function pointers

1580416408
gruebite
oof

1580416410
gruebite
yeah

1580416812
andrewrk
gruebite, it's expecting a double pointer then, so you do need the *

1580416845
gruebite
this is in cimport.zig: create_func: [*c]fn (?*godot_object, ?*c_void) callconv(.C) ?*const c_void,

1580416875
andrewrk
let me just take a look at godot and see

1580416878
gruebite
from: GDCALLINGCONV void *(*create_func)(godot_object *, void *);

1580416887
andrewrk
that does look like a double pointer to me

1580416902
andrewrk
which is weird

1580416914
gruebite
void *(*create_func)(void); would be a single pointer i thought?

1580416926
andrewrk
void (*create_func)(void); is a single pointer

1580416934
gruebite
void * is the return type

1580416939
andrewrk
oh right

1580416953
gruebite
C function pointers :D

1580416975
andrewrk
hmm that C translation needs to be audited

1580416996
gruebite
is this a bug? :D

1580417002
andrewrk
unclear

1580417011
Snektron
it might be in the same ballpack as the issue daurnimator ran into a few days ago

1580417060
Snektron
i can't find the issue but it was about `void (func)();`

1580417077
gruebite
i don't know where to look to change this translation, but i can make a change and test it

1580417105
Snektron
ah, #4289, which is already fixed

1580417266
gruebite
if [*c]fn is a double pointer in zig

1580417273
gruebite
then that translation is incorrect

1580417508
gruebite
also, c doesn't have a concept of const pointers to functions?

1580417513
andrewrk
I think there is a design flaw here

1580417548
gruebite
void (const *func)(void); would be it but i don't think that's allowed

1580417581
gruebite
void (*const func)(void); is just a constant pointer

1580417616
Snektron
const functions should be possible

1580417623
Snektron
const function pointers, that is

1580417676
andrewrk
I don't know how to solve this

1580417692
Snektron
isnt `void (*const func)(void);` what you want?

1580417708
gruebite
that's a pointer that must be initialized

1580417716
gruebite
or can't change what it's pointing to

1580417718
andrewrk
all function pointers can be considered const. that's an easy improvement to make in translate-c

1580417730
gruebite
what's the design flaw?

1580417742
Snektron
anyway gruebite, if you're writing C, i recommend using `typedef void (func)(void);` so you can use `const func*` and `func*`

1580417755
gruebite
ahh, yeah i do that when writing C

1580417757
andrewrk
gruebite, how to translate a C function pointer to zig

1580417759
gruebite
i'm just using existing C

1580417767
andrewrk
in C function pointers can be null

1580417781
gruebite
why not ?fn?

1580417799
andrewrk
maybe that's the solution. but it means function calls look like foo.?()

1580417804
Snektron
you could have `?extern fn` have a guaranteed abi layout

1580417806
gruebite
for C function

1580417827
gruebite
how does zig handle null function pointers?

1580417838
gruebite
if `fn` cannot be null without `?`

1580417849
Snektron
well, not

1580417859
andrewrk
in zig a null function pointer will have type `?fn()void`

1580417870
andrewrk
and it will require unwrapping before calling

1580417880
Snektron
which is to be expected

1580417886
gruebite
yeah

1580417910
andrewrk
I think that's right. function pointers should translate as ?fn rather than [*c]fn

1580417930
gruebite
i can make that change and test if i'm pointed in the right direction

1580417939
andrewrk


1580417964
andrewrk
the const thing is also solved with this approach

1580417980
andrewrk
ok, this is not so bad. no design flaw after all

1580418019
Snektron
crisis averted

1580418091
Snektron
andrewrk, is `?fn() callconv(.C) void` already guaranteed to be the same as `void (*func)()`?

1580418106
andrewrk
yes

1580418254
gruebite
fork or pr?

1580418287
andrewrk
a pull request makes it easiest to merge, since there is integrated CI testing

1580418293
gruebite
i prefer pr

1580418322
Snektron
hold up

1580418352
gruebite
hol' up

1580418368
Snektron
I have the translate-c'd Vulkan headers here to compare against, and here function pointers are translated including optional

1580418373
Snektron
`pub const PFN_vkFreeFunction = ?fn (?*c_void, ?*c_void) callconv(.C) void;`

1580418415
gruebite
have any structs with function pointer definitions?

1580418433
Snektron
not directly, they're al typedeffed

1580418456
gruebite
the c code I have has no typedef function pointers

1580418459
gruebite
edge case?

1580418471
Snektron
seems like it

1580418479
andrewrk
next step is minimal repro

1580419279
gruebite
okay, so like test/translate_c.zig:455 looks like what it should do

1580419392
gruebite
added 16Dec2019

1580419695
gruebite
stumped now

1580419877
andrewrk
look at this pattern that LemonBoy discovered:

1580419957
gruebite
the `= .{}` part?

1580419990
andrewrk
anonymous struct with methods

1580420030
andrewrk
maybe it helps to see the diff:

1580420038
gruebite
basically closure

1580420078
gruebite
niiice

1580420123
gruebite
so i see a test case that matches the correct ?fn translation

1580420189
andrewrk
start with your C code that generates [*c]fn and try to reduce it until it is as small as possible

1580420591
metaleap
comptime-reflecting a func with one `var` arg and one fully-typed arg. BOTH result in `.Fn.args[i].arg_type` of `null`. by design?

1580420648
metaleap
ie. if both args are not `var`, both `...arg_type`s are not `null`. but just one `var`, all 2 `null`

1580420683
andrewrk
metaleap, see

1580420696
gruebite
got it

1580420715
gruebite
struct foo { __attribute__((sysv_abi)) void (*bar)(void); }; doesn't work

1580420723
gruebite
struct foo { void (*bar)(void); }; works

1580420738
metaleap
thx andrewrk will follow the issue

1580420754
andrewrk
gruebite, nice find. would you mind filing an issue?

1580420762
gruebite
yeah

1580420780
gruebite
if this is an easy fix, it'd be fun for me to do

1580420826
betawaffle
has anyone already suggested the ability to embed the fields from one type into another? something like usingnamespace, but for fields, rather than declarations

1580420828
andrewrk
it might involve adding a new calling convention to zig. the first step is understanding what does that attribute mean

1580420846
andrewrk
that would be easier than it sounds, however, it's likely just an enum value to llvm

1580420858
andrewrk
betawaffle,

1580421404
TheLemonMan
gruebite, do you mind if I submit a PR to fix the translate-c problem?

1580421411
gruebite
go ahead :D

1580421430
gruebite
#4332 is the issue I just created

1580422440
andrewrk
hmm, I'm unable to get the behavior test that is failing in the llvm10 branch, to fail independent from the other tests

1580422478
gruebite
for passing C strings to C do I just do `"foo"` no special syntax?

1580422484
gruebite
used to be c"foo"

1580422511
andrewrk
gruebite, that's correct. string literals now are null terminated

1580422529
andrewrk
the coerce both into slices and null terminated pointers

1580422597
gruebite
nice

1580422662
gruebite
when the pointer is a [*c] pointer it will add the null?

1580422670
TheLemonMan
done! Hopefully it passes the CI checks

1580422674
gruebite
woo!

1580422698
andrewrk
oh, that's interesting. if I comment out the new_stack_call test then a seemingly unrelated test passes

1580422709
andrewrk
we might have to drop @newStackCall in 0.6.0

1580422746
Snektron
isn't it part of @call now anyway?

1580422754
TheLemonMan
yeah, it's quite unsafe as it's implemented right now

1580422757
andrewrk
it's flawed anyway:

1580422808
Snektron
hm, this whole Vulkan thing turned out to be quite complicated

1580422866
Snektron
one thing i wanted to do was add a way to make using the function pointers a little less of a nuisance to set up

1580422880
Snektron
since you can either dispatch statically or dynamically

1580423245
TheLemonMan
andrewrk, what would be a nice API for a binary-search-in-slice function? I wanted to add one to the stdlib but I'm not sure about the API

1580423360
andrewrk
TheLemonMan, how about: fn binarySearch(comptime Elem: type, list: []const Elem, comptime lessThan: fn (lhs: T, rhs: T) bool) void

1580423371
andrewrk
s/T/Elem/

1580423397
Snektron
Why lessThan comptime here but not in sort.zig?

1580423404
andrewrk
it should be in sort too

1580423539
TheLemonMan
the predicate should take a single parameter as the element you're looking for is fixed

1580423620
andrewrk
ah right

1580423706
andrewrk
libc bsearch takes a predicate with 2 args

1580423722
andrewrk
how about: pub fn binarySearch(comptime Elem: type, list: []const Elem, item: Elem, comptime lessThan: fn (lhs: Elem, rhs: Elem) bool) void

1580423726
gruebite
yeah, how does the predicate know the fixed value?

1580423732
TheLemonMan
and the predicate should be able to return more than a bool, it's a full-fledged comparison operator with the usual {.gt,.eq,.lt}

1580423747
andrewrk
does it need that though? sorting doesn't need that

1580423747
gruebite
need a compare enum :P

1580423756
gruebite
Lt, Eq, Gt

1580423767
TheLemonMan
two args means you're passing the value to be searched

1580423770
andrewrk
if it needs it, that's std.math.Order

1580423794
Snektron
Until theres some kind of closure i think its better to pass in both arguments

1580423802
Snektron
makes it compatible with asc and desc too

1580423806
TheLemonMan
if you want to return a ?usize you need that, it's needed to handle the failure case

1580423806
andrewrk
with two args, it can be lessThan, because the code can swap the args order to find greater than

1580423822
andrewrk
oh yeah return vaule should be ?usize

1580423861
gruebite
what would be a failure case of a sort?

1580423862
andrewrk
I think it should be lessThan, and then the impl swaps lhs, rhs, to find greater than, and therefore also equal

1580423897
TheLemonMan
yeah, if we go for the two-args route then we can avoid the predicate

1580423928
TheLemonMan
gruebite, it's a binary search, the element you're searching for may not be there

1580423941
gruebite
ohhhh bsearch, not sort

1580423946
gruebite
do'h

1580423948
traviss
anyone have a build.zig i can look which installs a test artifact?  i want a fixed path to my test exe which i can use to launch a debugger. something like zig-cache/bin/my_tests.

1580423952
TheLemonMan
the only downside is that you need one more call to the comparison function

1580423973
andrewrk
traviss, the default `zig init-exe` does that I believe (do that in an empty dir)

1580424003
andrewrk
oh that's a good point

1580424059
andrewrk
I'd be ok with either

1580424071
andrewrk
but the enum you're looking for is std.math.Order

1580424104
traviss
oh nice. i'm working from an 'init-lib'.  i'll have a look.

1580424119
andrewrk
traviss, it's just exe.install();

1580424163
andrewrk
and the fn should be comptime, because zig is getting pretty hostile to runtime-known function pointers

1580424247
fengb
That function pointer fix is to delete a bunch of edge cases? lol

1580424313
pixelherodev
`might have to drop @newStackCall in 0.6.0` will there be a replacement?

1580424377
Snektron
@call

1580424410
traviss
this doesn't seem to work for a test created using `var main_tests = b.addTest("tests.zig");`  i moved my main test into my root package directory. the only test binary i'm seeing is buried within zig-cache/o, not in zig-cache/bin or zig-cache/lib where i hoped.

1580424419
andrewrk
pixelherodev, inline assembly

1580424457
andrewrk
traviss, you want your test binary to get installed?

1580424480
pixelherodev
If it can be done with manual assembly, the compiler should be able to do it, no? Couldn't the implementation just be inline asm for the specific target?

1580424480
andrewrk
if you're trying to run it in a debugger, you have a few options:

1580424482
traviss
yes i want a fixed location for a debugging script

1580424486
TheLemonMan
you have to be extra careful even with inline asm, gcc and llvm don't like their sp being clobbered

1580424506
pixelherodev
Yes, but it's doable, and in some cases necessary

1580424522
pixelherodev
I don't think I've seen a single freestanding application that doesn't need it, for instance

1580424527
traviss
or if i can just get the path to the artifact, i can manually move it in build.zig

1580424530
TheLemonMan
of course it is, nobody stated otherwise

1580424537
andrewrk
pixelherodev, yes zig should be able to do it

1580424581
TheLemonMan
use a naked function to act as a trampoline and you should sidestep any trouble

1580424611
andrewrk
the problem is that it is getting dropped now, in the llvm10 branch, because the current implementation is no good. so if a more robust implementation can be completed by the master branch merge, then it will be available

1580424774
andrewrk
I'll try the naked function strategy before merging llvm10

1580424910
jessermeyer
Are the semantics different between these two statements?

1580424917
jessermeyer
var d12_device: *ID3D12Device = undefined;    var result = D3D12CreateDevice(null, D3D_FEATURE_LEVEL_12_1, &IID_ID3D12Device, @ptrCast(**c_void, &d12_device));

1580424927
jessermeyer
var d12_device: *ID3D12Device = undefined;    var result = D3D12CreateDevice(null, D3D_FEATURE_LEVEL_12_1, &IID_ID3D12Device, &@ptrCast(*c_void, d12_device));

1580424935
jessermeyer
Both compile, but the first one is what works.

1580424950
andrewrk
yes

1580424951
jessermeyer
And by works, I mean the com init succeeds.

1580424964
Snektron
youre taking an address of a stack variable in the second case

1580424965
andrewrk
one of them is taking a pointer to a temporary; the other is taking a pointer to the variable

1580425042
jessermeyer
Huh, I have to think about that.

1580425271
jessermeyer
I'm amazed you both could parse that so quickly.

1580425365
andrewrk
I copy pasted it into vim and maximized the window

1580425390
fengb
I'm a little surprised a @ptrCast introduces a new variable. Does it also in C?

1580425403
jessermeyer
I think that's what's throwing me.

1580425416
Snektron
it would be weirder if it didn't

1580425446
jessermeyer
So it's causing a copy, or a move instruction?

1580425470
Snektron
the generated assembly is probably the same

1580425485
Snektron
semantically its causing a copy

1580425507
Snektron
or rather, a copy at a different point

1580425517
jessermeyer
So why does is it more natural to cause a copy to perform an interpretation?

1580425552
andrewrk
fengb, you can put & in front of any expression in zig

1580425590
jessermeyer
@ptrCast(comptime DestType: type, value: var) DestType

1580425598
jessermeyer
So, yeah, it has a return type (sort of obviously)

1580425605
jessermeyer
Which I guess is what Snek is referring to?

1580425651
jessermeyer
It's quite a mental task to go from Zig code to C code, back to back.

1580425663
Snektron
What i mean is, the result of @ptrCast is a temporary value, even though in code-terms its a no-op]

1580425705
jessermeyer
Right. It's an actual function.

1580425721
Snektron
You can view it as such, yes

1580425731
jessermeyer
I mean, it's defined that way.

1580425757
jessermeyer
It may be useful to add a comment to this effect for its documentation, to ease the psyche from those coming from a C background.

1580425761
andrewrk
it's not an actual function

1580425774
andrewrk
builtin functions in zig are syntax

1580425788
Snektron
but it acts as an actual function

1580425798
andrewrk
in some ways

1580425801
Snektron
I understand why you think that way, even without a C background

1580425817
andrewrk
it can't be passed as a pointer

1580425822
andrewrk
it has to be called directly

1580425827
andrewrk
var x = @ptrCast; // error

1580425847
jessermeyer
Good distinction.

1580425859
jessermeyer
If not already, might be a good documentation addition =)

1580425881
Snektron
I think the important thing here is that functions in zig are call-by-value

1580425891
fengb
andrewrk: ah but not any expression... because double address && is parsing incorrectly 🙃

1580425915
Snektron
if @ptrCast would be call-by-reference, those cases would be equal

1580425933
jessermeyer
Right.

1580425939
jessermeyer
That was my null-hypothesis.

1580425952
andrewrk
feng, always keeping me honest

1580425963
fengb
I'm technically correct, the best kind of asshole

1580425967
jessermeyer
lol

1580425972
Snektron
by the way, are `(void**) a` and `&(void*) a` the same in c?

1580426153
jessermeyer
Maybe I'm not testing it correctly but

1580426153
jessermeyer
test_translate.c(31,19): error: cannot take the address of an rvalue of type 'void *'

1580426155
Snektron
ah, no

1580426163
jessermeyer
void** test = &(void*)device;

1580426170
Snektron
latter is not allowed since its not an lvalue

1580426722
traviss
anyone know how to get the path to a test artifact in build.zig created by `b.addTest("tests.zig")`. i'm looking for something like zig-cache/o/iAwVl8Fjwhfh.../test

1580426777
andrewrk
traviss, pass --verbose to `zig build`

1580426861
andrewrk
you can also use setExecCmd to make it run in a debugger

1580426873
andrewrk
which you could integrate with b.option

1580426922
andrewrk
finally you can use setOutputDir, which is a bit unstable API and disables caching

1580426973
traviss
i was hoping to do this within build.zig, not externally. ok thanks i'll have a look at setOutputDir

1580426987
andrewrk
this is within build.zig

1580427002
andrewrk
it also looks like tests support being installed

