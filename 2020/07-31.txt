1596161321
pixelherodev
Kristall is my new favorite web browser

1596161327
pixelherodev
ikskuh really outdid himself with this one

1596161343
pixelherodev
It's a gemini browser, but it supports basic HTML (HTTP/HTTPS) too :)

1596161419
ifreund
kristall is quite nice indeed, my package for void finally got merged a few days ago too

1596161448
pixelherodev
Nice!

1596161552
pixelherodev
Almost done with the article

1596161580
pixelherodev


1596161583
pixelherodev
Have another preview :)

1596161988
gruebite
searching "kristall" yields interesting results

1596162062
ifreund
gruebite: If you didn't find it:

1596162104
gruebite
yep! i did end up finding it haha

1596162136
pixelherodev
gruebite: I don't want to know.

1596162175
ifreund
neat:

1596162210
ronsor
what is kristall?

1596162250
ronsor
hmmm interesting

1596162352
ronsor
I should port it to my OS

1596162677
pixelherodev
ronsor: you're an OSDev?

1596162681
pixelherodev
Link? :)

1596162806
ronsor
pixelherodev: my current project in zig isn't ready for showing yet (or even online)

1596162836
ronsor
it will exclusively run webassembly code (that part works)

1596162880
pixelherodev
Gotcha

1596162884
pixelherodev
andrewrk: are you online?

1596162894
andrewrk
yo

1596162910
pixelherodev
I want to quickly extract some of the refactors from the SPU II PR into a separate PR for review, is that okay?

1596162924
pixelherodev
I want to get them merged before I release the article :P

1596162948
andrewrk
sounds good

1596162950
pixelherodev
(e.g. the testing harness refactor for non-native code execution)

1596162956
pixelherodev
Will submit within five minutes probably

1596163217
pixelherodev
Slightly longer, need to rebase :)

1596163222
pixelherodev
I love the rate of progress here

1596163272
pixelherodev
Dealing with it, a bit less so lol

1596163504
pixelherodev
andrewrk: lol, we had the same idea

1596163510
pixelherodev
You moved options into File, right?

1596163515
pixelherodev
I moved the ?fs.File into there too :P

1596163566
andrewrk
nice

1596163588
pixelherodev
Almost done...

1596163651
pixelherodev
Just need to make sure I didn't break anything lol

1596163870
pixelherodev
I broke a few things, you broke one, I win!

1596163871
pixelherodev
:P

1596164203
pixelherodev
Okay, just deciding what to cherry-pick...

1596165105
pixelherodev
almost done, ugh

1596165109
pixelherodev
That was more annoying than expected

1596165407
pixelherodev
Just removing bits that accidentally got in (I really need to commit things more cleanly)

1596165541
pixelherodev
okay! done!

1596165625
pixelherodev
andrewrk: #5957

1596165627
pixelherodev
:)

1596165682
andrewrk
got it

1596165690
pixelherodev
Ah wait

1596165695
pixelherodev
Need one second

1596165700
pixelherodev
Forgot to remove a dumb lol

1596165786
pixelherodev
There

1596165859
pixelherodev
The biggest things are ELF16 support, address_space in std.Target, and std.ihex (ikskuh's zig-ihex merged in with permission :)

1596166012
pixelherodev
The `TODO wtf` can be removed; 32-bit pointers are required for internal ELF structures since it's still technically ELF32

1596166792
pixelherodev
var -> anytype :P

1596166907
pixelherodev
First draft done! Just working on revising / fixing up formatting...

1596168360
pixelherodev
Running the test suite locally at this point :P

1596171355
pixelherodev
andrewrk: if there's any issues with that PR, mind pinging me here instead of GH? :P

1596174629
ronsor
what is ELF16? 16-bit ELF? If so,

1596175869
alexnask
ronsor, phd is writing a backend for the SPU Mark II (

1596178278
pixelherodev
andrewrk: nice! Debug info!

1596178282
pixelherodev
and I need to rebase again :(

1596178287
pixelherodev
But debug infoo!!!

1596180026
pixelherodev
The `TODO wtf` comment was me misunderstanding my own code, I'll remove that

1596180037
pixelherodev
The ELF16 support basically amounts to using 16-bit pointers within an ELF32 file

1596180065
pixelherodev
I'm doing this because it's what is officially used by actual architectures

1596180074
pixelherodev
m6800 does it IIRC

1596180079
pixelherodev
That's where I got the idea

1596180125
DarkUranium
pixelherodev,

1596180155
pixelherodev
The address_space holds a list of memory ranges and tracks whether they are readable, writable, executable

1596180169
pixelherodev
I'm not certain std.Target is the best place for it either, maybe it should go in the linker Options instead

1596180175
pixelherodev
Yeah that makes a lot more sense now that I think about it

1596180180
pixelherodev
Commented code will be fixed too

1596180203
pixelherodev
andrewrk: ^

1596180213
andrewrk
ack

1596180244
pixelherodev
The TODO wtf was because I'd forgot that the code was ELF headers :P

1596180364
Snektron
Hadn't shared this yet here: a first preview of rendering. Thats a quarter sphere made up of 256Â³ voxels

1596180404
DarkUranium
pixelherodev, ^ one idea ... raytracer.

1596180415
DarkUranium
(you know what for)

1596180422
Snektron
It's extremely slow (about 1 fps or so on my laptop) as i'm not taking advantage of the acceleration structure yet, but i have thought of a plan:

1596180423
pixelherodev
Hmm... not a bad idea, but it's outside my field of expertise, sorry

1596180447
Snektron
Currently the voxels are stored in a generic type of octree, where each node has NÂ³ children with a pointer and a color

1596180462
Snektron
Stored in a single shader storage buffer

1596180536
Snektron
Instead, i'll use a series of 3D textures: One type for internal nodes, which consist of just an offset into the next level, and another type for leaf nodes, which just contain colors

1596180621
Snektron
I'll make every level individually configurable for size, as well as make the height configurable. Hopefully that structure works better. Also 3D textures for 3D cache

1596180697
Snektron
<DarkUranium "(you know what for)"> I don't, what about it?

1596180713
DarkUranium
Snektron, pixelherodev does :P

1596180723
DarkUranium
(it's for that repl.it language jam, we're deciding on a "sample project")

1596180758
Snektron
oh

1596180759
pixelherodev
I have a bunch more free time now, and it looked interesting, so I figured I'd help out on a second compiler :P

1596180786
alexnask
Ah cool

1596180808
pixelherodev
And KnightOS again. And Zany80 again (a project I started four years ago and mostly abandoned half a year ago)

1596180821
pixelherodev
One or two other things too :P

1596180827
pixelherodev
Plus I'm ramping up time spent on Zig :D

1596180833
Snektron
Trying to make some money i see?

1596180842
pixelherodev
I wish :(

1596180844
Snektron
with a $10K prize

1596180849
pixelherodev
Ah, you mean repl.it

1596180852
pixelherodev
That would honestly be awesome

1596180871
pixelherodev
But I consider that a bonus

1596180878
DarkUranium
I don't have high hopes for that reward, the project's too conservative, I think. But hey, it's an excuse to do this :D

1596180883
pixelherodev
^

1596180917
Snektron
>During the jam, we ask all participants to code and submit their projects on Repl.it

1596180922
Snektron
ouch

1596180924
pixelherodev
Yeah that's the one downside

1596180943
DarkUranium
I suspect it's fine if we code offline and just do daily uploads, though.

1596180970
pixelherodev
...

1596180999
DarkUranium
Someone should make an "open collaboration protocol".

1596181024
alexnask
DarkUranium, Are you guys building the embedded language you were talking about or is that another project?

1596181033
DarkUranium
alexnask, we are :)

1596181059
Snektron
<DarkUranium "Someone should make an "open col"> Thats called git

1596181163
DarkUranium
Snektron, I mean live collab (which is sort of repl.it's shtick)

1596181169
DarkUranium
I.e. operational transformation or such.

1596181182
Snektron
oh, right

1596181221
DarkUranium
Of course, the problem is that you have 5 million flavours there. Of OT, of CRDTs, of DS ...

1596183477
Snektron
So whoever else uses matrix and is in here, theres a Zig matrix room now. I made a group to group the irc and matrix rooms together:

1596185296
pixelherodev
Anyone want to proofread the "How to backend" post?

1596185390
DarkUranium
pixelherodev, go to sleep! :P

1596185394
pixelherodev
I will!

1596185395
pixelherodev
:P

1596185401
pixelherodev
I just finished the second draft

1596185404
pixelherodev
Now I'm sleep

1596185453
pixelherodev
If anyone does want to, ping me for link

1596185524
DarkUranium
Maybe later (but you'll be awake by then anyways, so :P)

1596186996
alexnask[m]
ðŸ‘‹ eleanor-nb

1596187005
eleanor-nb
Heyo

1596187061
eleanor-nb
pixelherodev I will proofread

1596187087
ikskuh
alexnask[m]: here via matrix? :O

1596187094
ikskuh
and hey eleanor-nb!

1596187203
Snektron
Matrix is the lazy solution to irc

1596187243
ikskuh
i won't use matrix until they make a push-based backend

1596187492
Nypsie[m]
Works surprisingly well, the Matrix bridge that is

1596187532
ikskuh
still, matrix is based on HTTPS polling

1596187534
ikskuh
which is horrible

1596187627
Nypsie[m]
Interesting approach, considering the (better) alternatives we have.

1596187635
ikskuh
yep

1596189837
gruebite
hmm, can i cast a known length (at runtime) C pointer to a slice? basically [*c][*c]const u8 -> [n][]const u8?

1596190273
ikskuh
yeah, slice it

1596190287
ikskuh
var ptr: [*c][*c]const u8 = â€¦;

1596190301
ask6155
hello!

1596190301
ikskuh
var slice : [][*]const u8 = ptr[0..len];

1596190306
ikskuh
hey ask6155

1596190312
ask6155
hello

1596190365
Nypsie[m]
Hello

1596190365
ask6155
It is better to use bindings of others or make your own considering the language is so new

1596190465
ifreund
ask6155: well, it depends. I just use @cImport() directly cause I haven't invested the time to write good bindings yet

1596190539
ask6155
I thought you can cImport and then write your 'glue' code on top of that

1596190703
alexnask[m]
Yeah usually to pass slices instead of ptr lengths and use error handling I guess

1596190717
gruebite
yeah

1596190787
gruebite
ptr[0..len] would be [][*c]const u8

1596190860
ifreund
ask6155: yes you totally can, I just have put in the time to do so as it hasn't seemed like it would be "worth it" yet

1596190923
gruebite
i'm currently writing a tile engine on top of glfw/libepoxy

1596190944
ifreund
gruebite: you can also create slices by manually setting the .ptr and .len fields, they're just like special structs

1596190974
ifreund
var s: []u8 = undefined; s.ptr = blah; s.len = 42;

1596190976
alexnask[m]
Does .{ .len = ..., .ptr = ...} coerce?

1596190983
gruebite
yeah, just trying to remove *c with a level of indirection: [*c][*c] -> [][]

1596190988
alexnask[m]
Prob not right

1596190991
ifreund
alexnask[m]: not currently no

1596191011
ikskuh
gruebite: that won't work with casting, as @sizeOf([]u8) != @sizeOf([*]u8)

1596191054
ask6155
ifreund: okay, thanks for letting me know

1596191068
gruebite
[][*] then, haha

1596191248
ifreund
classifying the [*c] pointers into the granular zig pointer types is very satisfying

1596191283
gruebite
yeah, the granularity is great

1596191523
gruebite
just double checking, this works: @ptrCast(*[][*:0]const u8, &paths[0..@intCast(usize, count)]).*

1596191595
gruebite
perhaps it's possible to manually set the slice len for each C pointer? if i didn't want to use sentinels

1596191781
ifreund
so you've got a c pointer to many null terminated pointers and you want to turn that into a slice of slices

1596191825
ifreund
you can do this, but you'd need to copy the array of pointers since slices arent the same size as pointers

1596191919
gruebite
yeah, i was thinking that was the solution

1596191924
gruebite
this is the cost of not wanting to allocate

1596191992
ifreund
aye, sometimes you have to deal with some [*:0] pointers if you want to avoid allocations

1596192009
gruebite
leaky abstraction

1596192020
gruebite
thanks :D

1596192029
ifreund
no problem, blame C :P

1596193047
gruebite
except i like C :D

1596193297
ifreund
same, but I like zig more

1596193476
gruebite
lol same

1596204073
daurnimator
has anyone looked into writing a yaml parser in zig?

1596204225
Nypsie
Its spec tells me I'd rather implement something different xD

1596204232
ikskuh
^=

1596204607
Snektron
Just implement the sane subset

1596204608
DarkUranium
TOML is far superior to YAML, IMO.

1596204610
Snektron
Same with xml

1596204662
Nypsie
I agree with you on that, DarkUranium. Also alot easier to configure in as a user. (imo)

1596204664
fengb
TOML is actually sane

1596204676
fengb
YAML is a nightmare to implement

1596204686
DarkUranium
I have an INI parser written in C somewhere, in 90 lines of code :)

1596204715
Nypsie
There are TOML and INI parsers in Zig.

1596204746
daurnimator
I just want to process some k8s stuff with zig

1596204754
daurnimator
there's no choice in the format

1596204773
daurnimator
but a language that easily generates static binaries would be awesome for the task....

1596204832
Nypsie
I see. Definitely haven't seen any yaml parses in Zig yet.

1596204838
Nypsie
parsers*

1596204874
DarkUranium
YAML is the new XML :P

1596204899
DarkUranium
(overhyped, and complex enough that nobody can parse it correctly)

1596204919
Snektron
At least yaml doesnt burn your eyes out

1596204919
Nypsie[m]
Does Yaml have validators like XML?

1596204986
fengb
YAML was never intended to be simple for the computer but rather simple for people

1596205004
fengb
Whether they succeeded there is a different matter >_>

1596205206
ikskuh
i think YAML is horribly readable

1596205731
DarkUranium
Snektron, I think "open & close tags" subset of XML is quite reasonable, to be honest.

1596205750
leeward
There must be a C yaml parser you could link to, if you just want to get something working.

1596205783
DarkUranium
(e.g. `<foo bar="baz">abc &amp; def</foo><!--comment-->` --- this pretty much demonstrates

1596205794
DarkUranium
(and I guess `<foo/>` is okay too)

1596205800
fengb
Donâ€™t forget the whitespace

1596205809
fengb
That sensitive yet not sensitive whitespace

1596205814
DarkUranium
A hyes.

1596205829
DarkUranium
leeward,

1596205838
DarkUranium
I've been thinking of making a TOML lib in a similar vein.

1596205862
Snektron
I hate all xml

1596205892
Snektron
You cant efficiently parse it because you need to verify tags, and it wastes bytes too

1596205895
DarkUranium
That's formatist!

1596205927
Snektron
At least the other formats look decent

1596205930
Snektron
Except json

1596205964
Nypsie[m]
Well, json was never ment for configuration either, was it?

1596205975
Snektron
Either use a human readable format for config or protocolbuffers for communication

1596205982
fengb
Semi-humans

1596205983
DarkUranium
They actually fucked up JSON.

1596205987
DarkUranium
JSON is not a subset of JavaScript.

1596205990
DarkUranium
(they had *ONE JOB*)

1596206008
fengb
What's not valid JS in JSON?

1596206022
Snektron
It shouldnt be. Think of all the people decoding json with eval

1596206022
DarkUranium
fengb, you can create some strings that are valid JSON, but invalid JS.

1596206031
DarkUranium
It has to do with some space characters, I forget which.

1596212048
dimenus
is there a master tracking issue for stage2?

1596215116
andrewrk
dimenus, there is a stage2 label, and

1596215184
andrewrk
I'll retire the "project" page and switch to exclusively labels after a little bit more progress is made

1596215545
danyspin97
can i catch the errors for an entire block? like { dosomething(); } catch |err| {};

1596215715
ifreund
danyspin97:

1596215765
ifreund
tldr, yes but you currently need to @as(error{OutOfMemory}!void, blk: { ... }, and errdefer doesn't really work right

1596215766
danyspin97
ifreund: nice, exactly this

1596215795
ifreund
it might be nicer just to make a new function currently

1596215808
danyspin97
i have array_list.append(allocator.dupe(u8, "mystring") catch |err| {}) catch |err| {};

1596215820
danyspin97
and I have like 5-6, it really clutters the code

1596215833
Nypsie[m]
In this case you should just use the "try" keyword

1596215847
danyspin97
try isn't for sending the error to the caller?

1596215862
ifreund
yes, make a new function to hold all the calls that can error

1596215865
danyspin97
I have pub fn main() void

1596215868
Nypsie[m]
I'd let the caller handle the error tbh

1596215869
ifreund
and use try within that function

1596215874
danyspin97
and that alloc are in the main

1596216096
danyspin97
how to convert from integer to string?

1596216120
Nypsie[m]
std.fmt.parseInt

1596216121
ifreund
std.fmt.bufPrint or allocPrint

1596216151
Nypsie[m]
Sorry

1596216164
Nypsie[m]
Mine was for string -> int, my bad

1596216171
ifreund
:D

1596216182
danyspin97
np xD

1596216192
danyspin97
i have almost finished benice

1596216211
danyspin97
then I will do some benchmark and 1 blog post explaining its code

1596216244
Nypsie[m]
Cool! Looking forward to it

1596218549
dimenus
andrewrk: thanks

1596218581
andrewrk
dimenus, it's not usable for nontrivial programs yet

1596218615
dimenus
understood

1596218757
andrewrk
I think my incremental compilation dwarf line numbers idea is going to work :]

1596219416
andrewrk
dwarf is really nice. I think I overestimated how difficult it would be to add debug info support to self hosted

1596219436
andrewrk
the DWARF ABI is much nicer than the llvm API anyway, heh

1596219499
fengb
andrewrk: can I get your thoughts on

1596219594
andrewrk
fengb, if it's not a pressing issue, I can tell you that will Just Work in stage2, including when using the optional LLVM backend, because we can handle the operations manually we know llvm won't handle

1596219610
fengb
Hmm okay

1596219621
fengb
I'll copy it out into my own project then. Thanks

1596219697
andrewrk
llvm/clang's goals are more like, "let's redo gcc but with a different license" and zig's goals are more like, "let's challenge some of the assumptions we have about low level systems programming, and come up with a better way for it to work"

1596219758
fengb
Rocking the boat

1596219799
andrewrk
in stage2 when llvm support is added, it will be pulling less weight than it is in stage1

1596219809
companion_cube
"redo gcc but in a modular way", too

1596219814
andrewrk
yeah, fair

1596219825
andrewrk
although if you're referring to llvm ir, doesn't gcc have gimple?

1596219846
companion_cube
well also the fact it's a collection of libraries :)

1596219862
companion_cube
(I don't know if gimple was really a public thing when llvm got started)

1596219867
andrewrk
gotcha

1596219913
companion_cube
really, what llvm gave us is a big crop of new languages (zig, rust, crystal, julia, etc.), and I find it quite exciting; of course it's also good to not be totally reliant on it

1596219922
andrewrk
agreed

1596219929
fengb
LLVM split because gcc wouldn't have a stable IR

1596219932
andrewrk
from zig's perspective, llvm was training wheels :)

1596219940
fengb
It was originally a backend plugin to gcc

1596219950
alexnask[m]
really? til

1596219950
companion_cube
it might still be the high-perf backend, andrewrk, right?

1596219958
andrewrk
yeah sure

1596219961
companion_cube
you're not going to rewrite all the optims of llvm :D

1596220030
andrewrk
I do foresee pure zig release builds having a couple optimization passes (think 80% of the perf for 20% of the work) and I foresee the compilation speed and less bloated compiler being so attractive that many people prefer it

1596220057
andrewrk
but the short-to-medium term plan is llvm backend for release builds, yes

1596220079
companion_cube
release-fast using llvm, release-{safe,small} using internal backend ;)

1596220095
andrewrk
even with llvm backend there's a reason to do this, which is that zig's optimization passes would be async/await/suspend/resume aware

1596220117
leeward
LLVM was offered as a path forward for GCC, and Stallman opposed it on the grounds that it was too easy to make proprietary extensions with a well architected plugin system.

1596220141
ifreund
heh

1596220144
alexnask[m]
Im going to start working on PE support for stage2 (Michel Larouche had started it but dropped it, he has made his code public though)

1596220144
andrewrk
the existence of gcc is important. I would be really concerned if it died and left us with only llvm

1596220151
ifreund
aye

1596220152
andrewrk
alexnask[m], exciting!

1596220179
pixelherodev
I agree here

1596220188
pixelherodev
I actually think Stallman made the right decision there

1596220196
pixelherodev
even if I disagree with his reasoning :P

1596220207
companion_cube
wait, they wanted to

1596220211
fengb


1596220212
leeward
The world is better off because LLVM forced GCC to mature, but it would be even more better if they had accepted the patches.

1596220225
companion_cube
I thought it's more that llvm became popular because gcc refused to be modular

1596220246
andrewrk
alexnask[m], are you planning to try to solve incremental compilation?

1596220251
fengb
Who knows at this point. Apple wouldn't have tossed millions of dollars at a GPL compiler chain

1596220274
leeward
Apple used GCC before they used LLVM.

1596220289
fengb
But they didn't really invest in it

1596220296
fengb
Clang was an Apple project

1596220300
alexnask[m]
andrewrk: Ideally yes

1596220310
andrewrk
awesome

1596220350
leeward
I don't think Apple was ever opposed to the GPL for their tool chain; they're just very pragmatic.

1596220370
fengb
They're anti GPLv3

1596220373
companion_cube
(oh, forgot swift in my list, duh)

1596220374
BaroqueLarouche
PS3 SDK used GCC and it stopped updating it when it switched to GPLv3

1596220379
leeward
fengb: Who isn't?

1596220386
pixelherodev
fengb: I don't think that's true

1596220400
pixelherodev
I think that if LLVM wasn't around, and GCC had been willing to work with them, Apple wouldn't have cared about the license

1596220407
andrewrk
alexnask[m], for ELF, the file format is flexible enough that I was able to use it directly for incremental compilation. if that works out for PE too, that's great. but if we need to store external metadata to make incremental compilation work, that's ok too

1596220411
fengb
It's hard to say now

1596220414
pixelherodev
Of course

1596220417
pixelherodev
It's all very hypothetical

1596220424
pixelherodev
And I'm not wasting today of all days on those

1596220508
andrewrk
alexnask[m], right now, there is external metadata related to incremental compilation that is kept in memory. the plan for making it persist on disk would be to serialize and deserialize that state that is currently in-memory-only. but I think it is ok to make it in-memory-only for now. it should be fairly straightforward to add serialization/deserialization support later

1596220588
andrewrk
I do think the in-memory support is nice though. So far it's pretty darn efficient

1596220651
andrewrk
fast too. it takes 30 milliseconds on my machine to run `./zig build test-stage2`

1596220666
pixelherodev
What?!

1596220669
pixelherodev
From start to finish?

1596220676
pixelherodev
Or after running it the first time?

1596220705
andrewrk
when the test harness is already built. so it measures a debug build of the self-hosted compiler, running every single stage2 test case (including compare_output tests where it has to run the program)

1596220727
alexnask[m]
wow, thats pretty insane

1596220771
andrewrk
I've been adding new test cases as incremental updates to single functions :D

1596221067
leeward
fengb: Geoff Keating is one counterexample regarding Apple's willingness to throw money at GCC.

1596221110
pixelherodev
Gotcha

1596223269
gruebite
more idiomatic to return a struct or to set pointer parameters?

1596223292
ikskuh
return a struct

1596223293
pixelherodev
Probably the former?

1596223295
pixelherodev
Yeah

1596223313
ikskuh
as we have optionals, it's convenient to use when the return value is not always there

1596223317
gruebite
cool, my intuition isn't off haha

1596223318
gruebite
yeah

1596223372
gruebite
i always have the issue of too many vectors across code bases

1596223407
gruebite
i almost feel linear algebra should be standard to prevent every application rewriting their own, and then writing code to convert between them

1596223549
gruebite
complex numbers are often part of a standard library

1596223585
protheory8-new-m
Hi, is there a workaround again std.mem.Allocator.resizeFn 'resize in place' guarantee? I kinda want to use realloc there.

1596223625
pixelherodev
protheory8-new-m: no

1596223633
pixelherodev
You can choose to not use Allocator if you want to

1596223645
leeward
You can use realloc directly.

1596223647
pixelherodev
If you're explicitly requiring realloc, might as well use allocation directly

1596223649
pixelherodev
Yeah

1596223716
protheory8-new-m
So what is the limit of c_allocator when reallocating?

1596223782
protheory8-new-m
I allocate slice of 4 u8 using allocator.alloc, what is the maximum I can reallocate to?

1596223792
alexnask[m]
c_allocator uses malloc_size on platforms its available on

1596223817
alexnask[m]
(or malloc_usable_size)

1596223927
protheory8-new-m
Yeah, that's what I did as well IIRC

1596223932
protheory8-new-m
Thanks for help

1596224776
gruebite
i cannot self reference enums? like: enum { a, b, last = b }

1596224785
pixelherodev
nope

1596224792
pixelherodev
extern enums I think can

1596225201
gruebite
oo, but can do const members on an enum

1596225217
pixelherodev
I might take today off and finish the PR and article tomorrow

1596225250
gruebite
:)

1596225277
Nypsie[m]
pixelherodev: Eleanor wanted to review the article btw. (Incase you missed it)

1596225284
pixelherodev
I saw

1596225292
Nypsie[m]
:)

1596225321
pixelherodev
I just need to make a few tweaks and them i'm linking it to them

1596226147
protheory8-new-m
So I think I made a Jemalloc wrapper for `std.mem.Allocator`, not sure if it works correctly though.

1596226965
protheory8-new-m
Currently hosted at

1596227123
alexnask[m]
Cool!

1596227672
andrewrk
yep, it's gonna work:

1596227728
andrewrk
I'm not aware of any other compiler that has done this before

1596227901
Snektron
maybe you should apply for the repl.it think, andrewrk

1596227904
Snektron
easy $10K

1596227933
Snektron
err, thing, the design-a-language hackathon

1596228048
Nypsie[m]
They ask you to keep working on it afterwards for 3months, would be a waste of Andrew's precious time I assume :P

1596228379
pixelherodev
lol

1596228389
pixelherodev
Please don't, that'd be more competition for me! ;)

1596228395
pixelherodev
And I don't think I'd win against you lol

1596228410
pixelherodev
andrewrk: you've forced my hand :(

1596228414
pixelherodev
Going to finish the PR today

1596228419
pixelherodev
So. Much. Rebasing.

1596228420
pixelherodev
Ugh

1596228789
gruebite
all your rebase?

1596229196
andrewrk
Snektron, I'm not really interested in designing languages, believe it or not. Zig is a means to an end for me

1596229214
andrewrk
the end being, of course, higher quality software

1596229245
Snektron
Turned out youre good at it though

1596229280
Nypsie[m]
Maybe an odd question, but do you still work on side projects (which are not Zig but written in Zig), like you mentioned in your blog once?

1596229581
andrewrk
I want to, but I'm feeling a lot of pressure to get stage2 done. I think I'll start doing that again once we can ship stage2

1596229587
pixelherodev
:(

1596229619
pixelherodev
I love the rate of progress of stage2, but that seems like a price a bit too high to pay to me

1596229652
andrewrk
I think if you took my ELF16 suggestion you wouldn't have any conflicts with the latest commits

1596229660
Nypsie[m]
I see, makes sense. Thanks :)

1596229671
pixelherodev
andrewrk: I'm working on it!

1596229672
pixelherodev
:P

1596229676
pixelherodev
Ah wait

1596229685
pixelherodev
No, yeah, I'm not going to do that, there's no point

1596229689
pixelherodev
I'll just deal with this until it's done

1596229702
ifreund
yeah make sure you don't burn out on stage2, we can be patient

1596229703
pixelherodev
ELF16 really

1596229715
Snektron
> I want to, but I'm feeling a lot of pressure to get stage2 done.

1596229721
pixelherodev
Having it be a separate linker backend doesn't make sense

1596229734
pixelherodev
Most of the .p16 => branches go with p32 anyways

1596229735
Snektron
You also deserve some time off once in a while though

1596229744
pixelherodev
for sure

1596229752
pixelherodev
We're not heartless here, Andrew! We can wait!

1596229756
andrewrk
yeah don't worry I'm taking care of myself

1596229771
andrewrk
it's self-imposed pressure

1596229819
pixelherodev
One might even go as far as to call it

1596229821
pixelherodev
;)

1596229829
ifreund
gah :P

1596229833
Snektron
nice

1596229833
fengb
Programmers tend to have a lot of pent up self-imposed pressure

1596229880
Snektron
I've worked on that actually. I used to drop every project after a week or so, now i can commit myself to actually finishing something once in a while

1596229890
shakesoda
fengb: artists, too

1596229902
leeward
Writing software is the closest one can get to being a wizard these days. Wizards are always workaholics.

1596229902
shakesoda
fengb: woe is the cursed individual who is both

1596229932
rom1504
what are stage1 and stage2 for zig ?

1596229941
pixelherodev
stage1 is the compiler you've probably used, and is written in C++

1596229943
shakesoda
stage2 is zig-in-zig

1596229946
fengb


1596229950
pixelherodev
Stage2 is the compiler that's being written within Zig to compile ZIg

1596229956
pixelherodev
Which is why it's also called self-hosted

1596229962
pixelherodev
Since we can compile it using itself

1596229978
fengb
Stage 1 is what we have right now: Zig compiler written in C++

1596229981
ikskuh
fengb: lul

1596229986
leeward
fengb: Exactly, except Lisp no longer has a monopoly.

1596229992
rom1504
ah I see, makes sense :)

1596230007
Snektron
leeward: yeah theres c++ templates now, too

1596230025
leeward
Snektron: I guess voldemort is a wizard too.

1596230039
rom1504
does zig stage2 use llvm ?

1596230055
Snektron
Not yet, and possibly also will not

1596230061
pixelherodev
Hopefully will not

1596230066
pixelherodev
It'll be optional at worst though, so yay

1596230072
ikskuh
i hope it will (be optional)

1596230077
ikskuh
i need those size optimizations :D

1596230079
andrewrk
pixelherodev, I think you're trying to do too much in 1 PR still

1596230085
ikskuh
^=

1596230093
rom1504
okay so it's really about rebuilding the whole thing, interesting

1596230103
pixelherodev
andrewrk: sure, but the ELF stuff is fine

1596230114
pixelherodev
ANd it's better than the SPU II one at least :P

1596230121
ikskuh
pixelherodev: make more and smaller PRs that depend on each other

1596230133
andrewrk
rom1504, yeah rebuilding the whole thing, with lessons learned, and making a big effort on performance and resource utilization

1596230134
pixelherodev
I'm working on it

1596230138
pixelherodev
My commit hygiene can use a bit of work too

1596230147
ikskuh
mine as well

1596230157
ikskuh
i just did "git add .; git commit -m "Snapshot"; "

1596230159
andrewrk
me too tbh

1596230173
fengb
Be like kristate: single commit per PR

1596230175
ifreund
git add -p is your friend

1596230206
ikskuh
Semantic Analysis [46/33081]

1596230208
ikskuh
what did i do?!

1596230246
andrewrk
stage1 is pretty inefficient with std.fmt.format

1596230302
pixelherodev
I'm like the anti-kristate

1596230307
ikskuh
fuck. i now have 32k compiler errors

1596230308
pixelherodev
I just wiped my place on the contributor "leaderboard" :P

1596230314
pixelherodev
I went from ~12 to not even on the list lol

1596230356
andrewrk
ikskuh, oh yeah I've been meaning to implement the deduplication for that. it should only emit 1 per AST node

1596230414
ikskuh
:D

1596230420
ikskuh
only in stage 2 please :D

1596230442
andrewrk
ikskuh, pixelherodev, is ELF16 documented somewhere?

1596230461
ikskuh
i think pixelherodev made that up :D

1596230470
andrewrk
hmmmmmmmm

1596230477
ikskuh
let's see if my code compiles or if i got another 32k errors :D

1596230501
andrewrk
why can't ELF32 be used for SPU Mark II

1596230518
ikskuh
i don't see the problem

1596230527
andrewrk
ok that's for sure the right thing to do then

1596230602
ikskuh
let me check what avr uses

1596230610
andrewrk
it's gotta be elf32

1596230620
ikskuh
blink1.elf: ELF 32-bit LSB executable, Atmel AVR 8-bit, version 1 (SYSV), statically linked, with debug_info, not stripped

1596230622
ikskuh
ye

1596230656
andrewrk
pixelherodev, you mad lad! use ELF32 you knuckle head!

1596230692
ikskuh
+1

1596230716
andrewrk
he's over here like "I have to keep rebasing my ELF16 code because Andrew keeps breaking it with ELF32 improvements" ðŸ¤£ ðŸ¤£

1596230745
ikskuh
andrewrk: I'm crazy atm :D

1596230757
ikskuh
"rewriting" my spu mk 2 emulator with every instruction comptime-unrolled

1596230777
ikskuh
so instead of doing decoding, i just do try jumptable[opcode]();

1596230778
ikskuh
:D

1596230847
shakesoda
sounds simpler/more legible

1596230865
shakesoda
certainly looks it

1596230899
ikskuh
looks like it's finally compiling :D

1596230927
andrewrk
ikskuh, it's the kind of thing that makes me feel pressure to get stage2 done, because it's a perfect fit for the zig language, but stage1 looks like a clown car trying to compile it

1596230968
ikskuh
but i accept any waiting time atm

1596230977
ikskuh
also, i found like 100 stage 1 bugs right now :D

1596230982
andrewrk
I'm sure

1596230993
ikskuh
./tools/emulator/emulator.zig:245:57: error: operation caused overflow

1596230993
ikskuh
.jump_relative => self.ip +%= 2 * output,

1596231005
ikskuh
that shouldn't even execute at comptimeâ€¦

1596231040
ikskuh
ohâ€¦

1596231045
ikskuh
i can't even

1596231051
ikskuh
zig comptime is amazingly weird :D

1596231059
ikskuh
switch() {} can return different types :D

1596231062
Sahnvour
stage2 will possibly not use LLVM ? what's planned for release builds ? (sorry i'm outdated)

1596231124
alexnask[m]
ikskuh: I think stage1 doesnt do peer type resolution (at least in some circumstances)

1596231128
andrewrk
llvm will be an optional dependency

1596231133
ikskuh
aaaah, too much evaluation :D

1596231146
ikskuh
for some instructions ".div => input0 / input1," this generates a division by zero

1596231151
ikskuh
yes, compiler! you are right! :D

1596231154
ikskuh
dang :D

1596231175
alexnask[m]
For example if you have an if else that reutrns an enum value or an enum literal, the type will not be resolved to the enum if the else branch is taken

1596231191
alexnask[m]
(I remember this because it was the source of a std.fmt bug)

1596231201
Snektron
invoking ub again, ikskuh?

1596231211
ikskuh
kinda? :D

1596231219
ikskuh
i just accepted that my emulator crashed on div by zero

1596231225
andrewrk
alexnask[m], the result location implementation in stage2 is looking squeaky clean so far

1596231225
ikskuh
because that'S what the CPU does anyways :D

1596231259
ikskuh
so now the emulator core has a evaluation check

1596231301
ikskuh
let's run that again

1596231312
pixelherodev
andrewrk: I am using ELF32!!!

1596231316
pixelherodev
That's literally what I'm doing!

1596231331
pixelherodev
What I'm calling ELF16 is literally just ELF32 that happens to use 16-bit pointers for generated code!

1596231359
andrewrk
I see, well I thought you were inventing a new format, which is why I didn't tell you to not introduce p16

1596231382
Snektron
Will the result location system in stage2 also work for general expressions? Like if i write `fn a() B { var b: B = undefined; b.x = 10; b.y = 20; return b; }`

1596231386
andrewrk
which is the source of the rebase conflicts. the p32/p64 corresponds to the ELF format not the arch ptr size

1596231395
pixelherodev
...

1596231405
pixelherodev
This is what I get for not asking for clarity and for making assumptions

1596231416
ikskuh
^=

1596231445
andrewrk
every time I wrote one of those switch statements, I thought to myself, "Cool, there are only 32 and 64 bit elf formats, so nobody will have to touch this switch statement again."

1596231452
pixelherodev
haha

1596231486
andrewrk
Snektron, the relevant issue here is

1596231486
pixelherodev
I'm going to finish the article and prefix it with "A lot of this depends on work that hasn't yet been merged, I suggest giving it a few days before working on this to avoid conflicts" or something

1596231492
pixelherodev
Then I'll split the PR up into pieces and get them all done

1596231503
pixelherodev
My goal is to get to the next round of review tonight

1596231514
leeward
Snektron: I hope so.

1596231573
pixelherodev
Ugh, I've started using nested tmux sessions fo rliterally everything

1596231580
pixelherodev
It's the only way to

1596231602
pixelherodev
(that took me less than ten seconds to figure out and doesn't require me poring through the manual)

1596231669
ikskuh
thanks to unrolling the emulator, i found a lot of bugs :D

1596231688
pixelherodev
ikskuh: mind sending that as a PR to my spu_ii branch's std.spu.interpreter? :P

1596231693
ikskuh
haha

1596231697
pixelherodev
No reason to duplicate work

1596231705
ikskuh
well

1596231709
ikskuh
the backported stuff, yeah :D

1596231714
pixelherodev
:)

1596231714
ikskuh
not the thing i'm currently building

1596231718
pixelherodev
For sure

1596231720
pixelherodev
just the core architecture

1596231721
ikskuh
that has roughly 5-10 minute compile time atm :D

1596231727
pixelherodev
holy mother forking what

1596231730
pixelherodev
WHY

1596231740
alexnask[m]
for science

1596231743
ikskuh
<alexnask[m]> for science

1596231746
ikskuh
FOR SCIENCE!

1596231789
Sahnvour
at last a language that compiles faster than C++ !

1596231809
pixelherodev
haha

1596231820
ikskuh
LLVM Emit Output...

1596231821
ikskuh
:O

1596231879
Sahnvour
ikskuh: by unrolling the emulator, do you mean the program it's running is embedded at comptime ?

1596231889
ikskuh
no

1596231899
ikskuh
unroll all instruction emulations into branchless versions

1596231905
ikskuh
by evaluating each valid opcode

1596231916
pixelherodev
jump table?

1596231918
ikskuh
yep

1596231922
pixelherodev
nice

1596231925
Sahnvour
is this online ?

1596231960
ikskuh
nah

1596231966
ikskuh
don't even know if it works :D

1596231988
ikskuh


1596231990
ikskuh
but that's the code atm

1596232058
andrewrk
oh that's a great use case for zig

1596232072
andrewrk
are we going to find out how this affects perf?

1596232077
ikskuh
andrewrk: yeah, true

1596232078
ikskuh
i hope so!

1596232080
pixelherodev
We'd better find out!

1596232082
pixelherodev
:)

1596232088
ikskuh
in theory, 1 branch is waaaay better than a lot :

1596232089
ikskuh
:D

1596232097
pixelherodev
Why is this an exceptionally better use case for Zig than anything else?

1596232102
pixelherodev
ikskuh: especially with branch prediction!

1596232108
Sahnvour
ah, if I get this right you're generating the functions evaluating opcodes ?

1596232108
pixelherodev
Ah right, are you going to use computed gotos?

1596232111
alexnask[m]
comptime everything

1596232128
ikskuh
Sahnvour: yep

1596232140
Sahnvour
cool

1596232148
andrewrk
pixelherodev, assuming (incorrectly) that the compiler handled it reasonably, the cost of this experiment is extremely low in zig, compared to say, c++

1596232154
pixelherodev
Gotcha

1596232159
andrewrk
cost of the experiment in terms of developer time

1596232165
pixelherodev
ikskuh: computed gotos should help even more if there's a good way to Zig them

1596232168
andrewrk
and maintenance of the codebase

1596232170
ikskuh
hehe

1596232176
ikskuh
pixelherodev: we don't need computed goto

1596232179
pixelherodev
Why not?

1596232183
ikskuh
we have guaranteed tail calls

1596232190
pixelherodev
...so?

1596232194
ikskuh
which is the same

1596232196
ikskuh
but with arguments :D

1596232197
pixelherodev
Ah right, that's a unconditional jump

1596232202
pixelherodev
Hmm

1596232213
pixelherodev
I think computed goto might actually help perf anyways

1596232218
alexnask[m]
Yeah this blew my mind too when xq showed me an example :P

1596232222
pixelherodev
Since it ties branch prediction to the previous instruction, no?

1596232237
pixelherodev
Hmm, this might do that too

1596232246
pixelherodev
Not 100% on the details of how tail calls would affect this TBH

1596232332
alexnask[m]
Iirc in a small experiment with the tail calls vs the computed goto the assembly was exactly the same (maybe some really minor deviations)

1596232394
pixelherodev
Cool!

1596232399
pixelherodev
That's even better!

1596232404
ikskuh
yeah, i think tail call was even faster :D

1596232419
pixelherodev
"Zig: the advantages of computed gotos without the work"

1596232421
pixelherodev
lol

1596232486
ikskuh
yeah, zig is really well tailored for a lot of stuff

1596232541
ikskuh
andrewrk: i really love how zig really does a good job at "better C"

1596232588
ikskuh
type system is great, the added features are right, and the additional control flow with error checkng and optionals just makes a lot of stuff a breeze <3

1596232640
andrewrk
<3

1596232663
pixelherodev
Yep

1596232691
pixelherodev
There's two or three other langs I'm keeping an eye on with the same goal

1596232692
gruebite
seriously

1596232705
ikskuh
pixelherodev: which are?

1596232711
alexnask[m]
V

1596232722
alexnask[m]
(just kidding)

1596232725
gruebite
haha

1596232756
ikskuh
real    4m22,391s

1596232765
gruebite
similar goals. hopefully they get there.

1596232767
pixelherodev
ikskuh: I'm working with DarkUranium on Coyote, which is sorta like a better C for scripting instead of compiled code

1596232793
pixelherodev
One of the others I've been asked to keep quiet about for now

1596232804
ikskuh
okay ^^

1596232807
gruebite
i'm looking at carp, zig, and haxe

1596232821
pixelherodev
I love that the programming lang scene is so active now

1596232830
pixelherodev
I don't like Rust as a language, but I love what it's accomplished

1596232836
alexnask[m]
Ive heard of carp, I think they were considering using zig cc as a cross compiler or smth

1596232839
gruebite
i 100% agree

1596232854
gruebite
although when i worked on a team using rust. i enjoyed it a lot more than doing it by myself

1596232871
andrewrk
the keep quiet one apparently has the exact opposite marketing strategy as V

1596232937
fengb
One thing I do love is how the extra control flows fit into expressions

1596232982
fengb
A lot of languages make stuff like "try" or even "return" into statements and it interferes with the code structure

1596232986
gruebite
i love anonymous structs

1596233004
fengb
Whereas Zig lets me do silly things like `orelse return error`

1596233015
alexnask[m]
Yeah orelse and catch are so good

1596233026
andrewrk
I hated java's try catch the same day I learned about it

1596233059
andrewrk
it's actively harmful to correct error handling

1596233063
ikskuh
andrewrk: zigs error handling is really standing out, but it's hard to explain to others

1596233080
gruebite
the error handling is absolutely painless

1596233121
ikskuh
yeah, exactly

1596233132
fengb
Go's explicitness with less boilerplate >_>

1596233142
Nypsie[m]
And error traces!

1596233144
fengb
Also slightly more explicit than Go but still

1596233144
gruebite
that's a goodway

1596233174
pixelherodev
More explicit than Go with none of the boilerplate

1596233176
pixelherodev
?

1596233177
DarkUranium
ikskuh, gruebite: maybe I should have a look at it, then.

1596233186
DarkUranium
The error handling.

1596233198
alexnask[m]
Yeah definitely : D

1596233200
ikskuh
yes!

1596233211
fengb
One caveat is that stage1 stack traces are getting kinda buggy :(

1596233211
pixelherodev
zig's error handling is the best I've ever used

1596233213
pixelherodev
It's not even a comparison

1596233222
gruebite
i agree

1596233282
andrewrk
fengb, it's fixable, I think I know what you're referring to

1596233313
alexnask[m]
Yeah the resizeFn usage of OutOfmemory made this worse too

1596233327
gruebite
error codes and error strings combined into unique members of sets, with a bunch of support

1596233342
andrewrk
I was thinking the function pointers of Allocator should maybe not use errors at all - that could be something the Allocator interface does

1596233373
DarkUranium
pixelherodev, how is it handled?

1596233379
DarkUranium
Error handling is something I haven't figured out yet for Coyote.

1596233387
fengb
So would there be separate "canResize" and "resize" functions?

1596233418
fengb
Or maybe returning a sentinel value

1596233424
alexnask[m]
Maybe returning an empty slice instead of an error?

1596233436
fengb
It currently returns a usize

1596233489
alexnask[m]
True, derp

1596233523
fengb
`return 0xaaaaaaaa` ðŸ™ƒ

1596233748
pixelherodev
DarkUranium: look at the docs ;)

1596233753
pixelherodev
It'll do a better job explaining than I could

1596233777
fengb
Black voodoo

1596233791
gruebite
part of it comes from using the error handling stuff too

1596233794
fengb
Andrew sacrificed a goat to unlock enlightenment

1596233886
Sahnvour
sacrificed his cabbage

1596233911
gruebite
not the cabbages!

1596233958
andrewrk
proper error handling tutorial

1596233962
DarkUranium
pixelherodev, it seems similar to what I had in mind for Coyote. Minus the inferrence, because there are certain issues with that.

1596234012
Sahnvour
memeification of Zig is the key to success

1596234034
Nypsie[m]
Look at that 3 finger technique

1596234057
fengb
Whereâ€™s the OG cabbage

1596234058
blinghound
there is 100% chance now that some of that clip will be in my dreams tonight

1596234087
pixelherodev
DarkUranium: that makes sense

1596234104
pixelherodev
A similar strategy minus inferred errors should be good for Coyote I think

1596234117
DarkUranium
pixelherodev, basically, I was thinking I could take advantage of the fact that option types need the storage for a pointer even if they don't have one --- and I could (ab)use that for errors.

1596234136
DarkUranium
In other words, T? could hold an error, too.

1596234153
gruebite
none is a special type of error?

1596234157
DarkUranium
(in a sense, `null` would then just be a "no error", then)

1596234183
DarkUranium
gruebite, yeah. It's a bit ugly, I know, but I don't want too many "special" types.

1596234185
pixelherodev
DarkUranium: zig allows optional errors :P

1596234223
gruebite
"?!" ?

1596234232
DarkUranium
gruebite, I already use !.

1596234245
gruebite
in chess notation, "?!" is a marker for a "dubious" move

1596234246
DarkUranium
pixelherodev, I did mention this in our conversation. Where T? would basically be a (tagged) union { T value; Error error; };

1596234247
alexnask[m]
?! is invalid gruebite

1596234256
alexnask[m]
!T is only valid as a return type

1596234266
alexnask[m]
But yeah ?(ErrorSet!T) is fine

1596234268
DarkUranium
alexnask[m], he's talking about my language.

1596234273
DarkUranium
A syntax proposal.

1596234274
gruebite
oooo

1596234285
gruebite
was talking about zig in this instance

1596234300
pixelherodev
DarkUranium: ahh, so instead of "null or T," it means "T or error"?

1596234302
gruebite
?(ErrorSet!T) makes sense

1596234311
DarkUranium
gruebite, in my design, at least, x! means "coerce this to a non-option type, or panic"

1596234322
pixelherodev
That's `.?` in Zig :)

1596234325
DarkUranium
pixelherodev, it's just an idea, but with the idea: yes.

1596234334
DarkUranium
pixelherodev, I also have .? (or maybe ?., undecided) :P

1596234336
pixelherodev
DarkUranium: definitely a good idea to write down

1596234339
DarkUranium
for foo?.bar?.baz

1596234357
gruebite
foo.?.bar.?.baz

1596234358
pixelherodev
So foo?.bar == foo!.bar?

1596234361
pixelherodev
(foo!).bar?

1596234363
alexnask[m]
this would return null if any in the cahin are null I assume?

1596234383
DarkUranium
pixelherodev, foo?.bar is `foo ? foo!.bar : foo.error`

1596234386
pixelherodev
Ahhhh

1596234411
pixelherodev
If foo is non-error, return it's bar member, otherwise get it as error

1596234412
DarkUranium
alexnask[m], or maybe (more usefully IMO, but otherwise the same boolean-test-wise) propagate the error, but yes.

1596234412
pixelherodev
Gotcha

1596234421
DarkUranium
pixelherodev, yeah.

1596234432
DarkUranium
C# has the same operator. Funnily enough, my idea of T? predates C#'s use of it :)

1596234435
pixelherodev
If we do this right, I'll have the killer language combo

1596234441
DarkUranium
But it turns out my syntax & semantics are almost the same, apparently.

1596234443
pixelherodev
Zig + Coyote instead of C + Lua

1596234448
DarkUranium
:)

1596234455
DarkUranium
Don't forget about my eventual CoyoteSL ;)

1596234459
pixelherodev
With the best part being that a lot of the syntax will be similar, yet different enough to not get confused

1596234462
pixelherodev
SL?

1596234467
pixelherodev
Shader lang? :P

1596234468
ikskuh
pixelherodev: where is LoLa in that equation? :D

1596234474
pixelherodev
ikskuh: what's LoLa?

1596234481
DarkUranium
pixelherodev, yes, Shading Lang. A subset of Coyote (obviously --- no heap, for one)

1596234482
ikskuh


1596234530
DarkUranium
pixelherodev, anyways, two more operators I've been toying with: One is a ?? b (this one was actually stolen from C#)

1596234536
DarkUranium
it means a ? a : b

1596234538
DarkUranium
Sorry;

1596234541
DarkUranium
a ? a! : b

1596234560
alexnask[m]
The elvis operator :)

1596234568
DarkUranium
And the subtly different a?:b, which is a ? a : b ... my issue is that it could be confusing to have both.

1596234581
alexnask[m]
Ah elvis is the second one : p

1596234582
Nypsie[m]
I believe Dart uses that as well

1596234590
pixelherodev
I think it's fine to have both

1596234600
pixelherodev
I'm not sure it's needed though

1596234604
DarkUranium
Nypsie[m], Dart has a few good ideas. But also a number of bad ones.

1596234609
pixelherodev
between the two, I'd stick with ??

1596234614
pixelherodev
?: doesn't seem needed

1596234624
DarkUranium
pixelherodev, it is, for non-option types ... no?

1596234632
pixelherodev
... maybe make ?? type-dependent?

1596234643
pixelherodev
For optional types, it's a ? a! : b

1596234648
DarkUranium
Guess I could.

1596234648
pixelherodev
For non-optional types, it's a ? a : b

1596234665
pixelherodev
Should we move to #coyote if it's not taken? :)

1596234682
pixelherodev
Neat, you made it already :)

1596234686
DarkUranium
Long ago :P

1596234771
gruebite
kotlin has elvis operator too

1596234804
gruebite
i like zig's orelse

1596234820
DarkUranium
lol

1596234827
DarkUranium
That sounds threatening.

1596234870
pixelherodev
Perfect!

1596234872
pixelherodev
I like that

1596238043
gruebite
it didn't take long for me to prefer zig's multiline strings over others, haha

1596238200
DarkUranium
gruebite, how do zig's multiline strings look like?

1596238313
gruebite
\\line 1

1596238315
gruebite
\\line 2

1596238381
alexnask[m]
main advantage: no indentation weirdness

1596238386
gruebite
yep

1596238429
DarkUranium
Hm, I see.

1596238716
andrewrk
it means that zig has line-independent tokenization

1596238750
andrewrk
pick any arbitrary byte of zig source code - advance to \n, and you can correctly tokenize the source code after that

1596239151
shakesoda
the `a ? a : b` talk reminds me of lua's `a or b` being nice because it isn't a weird special case, it's just how `or` works if a value is false-y

1596239463
shakesoda
dunno if the same would work for zig, but it's a behavior i like a lot

1596239516
shakesoda
and even if it would be fine for zig i don't feel this is really a pain point

1596239536
DarkUranium
One thing I miss in C is a bottom type.

1596239554
DarkUranium
So that I could do `return x ? x : error(...)`

1596239797
gruebite
i think zig's 0 sized types cover that base, yeah?

