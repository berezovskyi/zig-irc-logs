1768349288
andrewrk!~andrewrk@mail.ziglang.org
perhaps `std.meta.flex.Struct`, `std.meta.flex.Array`

1768352361
rvrb!~rvrb@156.146.51.230
andrewrk: here you go https://codeberg.org/ziglang/zig/pulls/30823

1768352474
rvrb!~rvrb@156.146.51.230
idk what "This pull request is broken due to missing fork information" means

1768352833
andrewrk!~andrewrk@mail.ziglang.org
rvrb: idk either. if necessary I'll just add your remote locally *shrug*

1768352923
andrewrk!~andrewrk@mail.ziglang.org
btw pro tip: if you move your example code from doc comment to `test FlexibleStruct { ... }` it will show up in autodocs as "example code"

1768352958
andrewrk!~andrewrk@mail.ziglang.org
you should be able to preview this with `zig std` locally. also you can preview docs by editing the code and then simply pressing "refresh" in the browser

1768399212
bblack!~bblack@wikimedia/bblack-WMF
so, I'm eventually going to have to deal with fs notification stuff via std.Io.  Probably by building some higher-level abstraction around inotify/fanotify on Linux, or whatever's available elsewhere, which brings me to:

1768399236
bblack!~bblack@wikimedia/bblack-WMF
1) Is it already planned to abstract this in std.Io eventually anyways, or will that always be something applayer?

1768399303
bblack!~bblack@wikimedia/bblack-WMF
2) Having implemented this manually before, I suspect that Io.File.Stat will want a field that covers the "device" part of the metadata in posix stat (st_dev and similar in whatever interface), to avoid edge cases.

1768399411
bblack!~bblack@wikimedia/bblack-WMF
when you end up manually checking (on a timer), or verifying that the notification wasn't spurious, and you want to validate something like the equality of inode+mtime+size or whatever sanity check makes sense... technically inode is only unique per-filesystem.  It's possible for the whole filesystem to swap out from under you (e.g. bind overlay mounts, etc), and for the replacement filesystem to have the 

1768399417
bblack!~bblack@wikimedia/bblack-WMF
same inode number for the same path, but with differing contents.  st_dev at least in theory resolves that ambiguity.

1768402339
bblack!~bblack@wikimedia/bblack-WMF
that moment when you refactored all the things, and you've whittled down the initial 19 compile errors to just 1, and you stop there because you know as soon as you fix that one, the compiler will get further and unlock a further 42 errors :P

1768402874
slowstatic63!~slowstati@user/slowstatic
just fork the compiler and hack at it until your project compiles :)

1768404032
bblack!~bblack@wikimedia/bblack-WMF
some sad day, someone will write a gcc plugin that asks Claude to fix the user's code until it compiles :)

1768404373
Gliptic!~glip@2a01:4f8:c012:91f3::1
I prefer the GHC bug that deleted the source files on compile error, teaches you a lesson

1768404836
slowstatic63!~slowstati@user/slowstatic
ghci --hardmode Main.hs

1768404847
slowstatic63!~slowstati@user/slowstatic
no errors only deletions

1768407800
rvrb!~rvrb@156.146.51.230
I would love source code transforms for things like const foo = Foo.init() to const foo: Foo = .init()

1768408270
clevor!sid649024@id-649024.hampstead.irccloud.com
lol

1768408371
clevor!sid649024@id-649024.hampstead.irccloud.com
I want the Zig compiler to be able to continue and at least show 17 errors instead of 1.

1768408539
rvrb!~rvrb@156.146.51.230
I think there is intent to do that, to the point that it runs even with compilation errors in debug mode by inserting traps at the error site

1768408562
rvrb!~rvrb@156.146.51.230
opt in I believe

1768408585
rvrb!~rvrb@156.146.51.230
I find that, quite exciting

1768408634
rvrb!~rvrb@156.146.51.230
I need my compile/run cycle stepping faster than my brain on 200mg of caffeine thanks

1768408744
clevor!sid649024@id-649024.hampstead.irccloud.com
Until someone makes a misguided Hacker News comment calling them warnings in disguise.

1768408758
rvrb!~rvrb@156.146.51.230
unsafe, unusable

1768408803
rvrb!~rvrb@156.146.51.230
it was like a month or two ago and I still can't get over someone on HN telling me it was disrespectful to the humanity of the user to use an unsafe language like Zig

1768408839
rvrb!~rvrb@156.146.51.230
reeling

1768408981
clevor!sid649024@id-649024.hampstead.irccloud.com
You can say the same thing about Rust if you include the `unsafe` keyword.

1768409005
clevor!sid649024@id-649024.hampstead.irccloud.com
If Rust were truly a safe language, then why does it have an `unsafe` keyword? Checkmate, atheists.

1768409709
ii8!~ii8@2001:19f0:7400:144b:1670:baf9:f4b:4508
rust is not memory safe even without the unsafe keyword

1768411433
Amun-Ra!~amun-ra@retro.rocks
but is have nice colors

1768412268
andrewrk!~andrewrk@mail.ziglang.org
bblack: I have poll and mmap work-in-progress, was planning on doing file system watching next

1768422462
bblack!~bblack@wikimedia/bblack-WMF
is it illegal to cancel an Io.Group while another threads is in group.await()?

1768422488
bblack!~bblack@wikimedia/bblack-WMF
I noticed Io.Threaded.groupCancel() has the assertion: assert(!pre_cancel_status.have_awaiter);

1768422520
bblack!~bblack@wikimedia/bblack-WMF
if so, I think I have some usage pattern ideas wrong :)

1768422573
andrewrk!~andrewrk@mail.ziglang.org
bblack: I believe this is answered by the doc comments

1768422582
andrewrk!~andrewrk@mail.ziglang.org
https://ziglang.org/documentation/master/std/#std.Io.Group.cancel

1768422645
andrewrk!~andrewrk@mail.ziglang.org
generally, it's recommended to use "structured concurrency" by doing it directly after Group.init in an unconditional defer

1768422855
bblack!~bblack@wikimedia/bblack-WMF
the pseudo-code of what I'm doing is like: fn { var group = .init; defer group.cancel(); [launch several threads via group.concurrent()]; group.await catch {}; }

1768422905
bblack!~bblack@wikimedia/bblack-WMF
but then inside one of the concurrent tasks of the group, I'm also canceling the group intentionally, to cause the whole the thing to come to a stop.

1768422924
bblack!~bblack@wikimedia/bblack-WMF
that's where I think my pattern is going off the rails :)

1768422968
bblack!~bblack@wikimedia/bblack-WMF
I'm canceling (from inside a group thread) while .await is waiting

1768423133
andrewrk!~andrewrk@mail.ziglang.org
in that case I think you might want to use Io.Select rather than Io.Group

1768423150
andrewrk!~andrewrk@mail.ziglang.org
then you can respond to a task finishing while the rest are still running, in the "parent" task

1768423171
andrewrk!~andrewrk@mail.ziglang.org
I believe this is also in the direction of "structured concurrency"

1768423176
bblack!~bblack@wikimedia/bblack-WMF
right, that makes sense, I did that in another place, but I was thinking differently about that problem

1768423204
bblack!~bblack@wikimedia/bblack-WMF
I made one of my Select union members be a ".exit => void" so that one of the Select threads could signal the parent through the queue to tear things down more-cleanly.

1768423228
bblack!~bblack@wikimedia/bblack-WMF
thanks!

1768424285
bblack!~bblack@wikimedia/bblack-WMF
andrewrk: oh right, this brings me back to: should Select have an "fn concurrent()"? or is that missing for some design reason I'm failing to glean?

1768424338
andrewrk!~andrewrk@mail.ziglang.org
bblack: hmm yes it looks like that is missing for no reason other than "todo"

1768433893
slowstatic!~slowstati@user/slowstatic
can zig's build system cache non-zig files and run steps for tools only when those files are modified?

1768434526
rvrb!~rvrb@156.146.51.230
slowstatic: check out https://ziglang.org/documentation/master/std/#std.Build.Step.Run.addFileInput and related methods on the Run step designed for this

1768434571
slowstatic!~slowstati@user/slowstatic
rvrb: thanks!

1768434574
rvrb!~rvrb@156.146.51.230
you'll need addOutputFileArg or addOutputDirectoryArg to handle caching output

