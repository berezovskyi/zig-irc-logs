1772077947
cow_2001!~username@user/cow-2001/x-5712099
zig's var i: u64 = n; while (i >= 0) : (i -= 1) f(i); is ALMOST like C's for (int i = n; i >= 0 ; i--) f(i);

1772077964
cow_2001!~username@user/cow-2001/x-5712099
is there something that goes sort of all the way?

1772078234
cow_2001!~username@user/cow-2001/x-5712099
i COULD just for (0..n) |i| f(n - i - 1);

1772107374
Earnestly!~earnest@user/earnestly
I wonder why for (n..0) doesn't work

1772107382
Earnestly!~earnest@user/earnestly
(Or why there is a reason it cannot)

1772107486
ifreund!2940d10f8b@user/ifreund
would be less readable

1772107492
ifreund!2940d10f8b@user/ifreund
also what are the semantics even?

1772107502
ifreund!2940d10f8b@user/ifreund
like, is it inclusive of the 0 or not?

1772107511
ifreund!2940d10f8b@user/ifreund
and what if both bounds are runtime-known variables?

1772107528
ifreund!2940d10f8b@user/ifreund
I doubt this will change from the status quo, while loops are already sufficient

1772107729
Earnestly!~earnest@user/earnestly
The same questions would apply to n..0, and so it would simply be defined; closed, open, whatever it doesn't really matter

1772107735
Earnestly!~earnest@user/earnestly
0..n*

1772107795
ifreund!2940d10f8b@user/ifreund
you can't just use the same .. syntax for both

1772107809
Earnestly!~earnest@user/earnestly
I'm curious now if there are any languages that use range syntax, which don't support reverse iteration

1772107852
Earnestly!~earnest@user/earnestly
ada does have the keyword reverse, so: for i in reverse 0..n loop

1772107891
Earnestly!~earnest@user/earnestly
ifreund: Hm, but why not?

1772107907
Earnestly!~earnest@user/earnestly
(zsh does, for example, including an optional interval)

1772107942
Earnestly!~earnest@user/earnestly
E.g.  print {10..1..2} => 10 8 6 4 2

1772108033
ifreund!2940d10f8b@user/ifreund
Earnestly: seems super bug prone, that's why

1772108057
Earnestly!~earnest@user/earnestly
How so?

1772108073
ifreund!2940d10f8b@user/ifreund
if you're working with constants, sure its fine but if one or both of your loop bounds are runtime know it becomes very confusing

1772108096
ifreund!2940d10f8b@user/ifreund
and potentially ends up iterating in either direction at runtime based on which is larger?

1772108114
ifreund!2940d10f8b@user/ifreund
this is not a feature that fits with Zig's design ethos

1772108153
ifreund!2940d10f8b@user/ifreund
the least footgunny way I've seen to do this is to require an explicit negative step size for backwards iteration

1772108159
ifreund!2940d10f8b@user/ifreund
i.e. (range 10 1 -2)

1772108186
ifreund!2940d10f8b@user/ifreund
but again, while loops are already fine

1772108200
Earnestly!~earnest@user/earnestly
I suppose Ada's approach is the best solution

1772108203
maskd!~maskd@user/maskd
yeah that's how Python does it

1772108232
Earnestly!~earnest@user/earnestly
I think rust does that as well now, although I'm not clear

1772108319
Earnestly!~earnest@user/earnestly
No, it seems rust needs .rev(), C# uses the ^ sigil on the end to signify reverse, swift uses <. So it seems like ifreund's suggestion of needing different syntax is shared by most langs that use ..

1772108364
Earnestly!~earnest@user/earnestly
If ada-style was used it'd probably look like: for reverse (n..0)

1772108439
Earnestly!~earnest@user/earnestly
cow_2001: The while loop seems more idiomatic

1772112694
dutchie!~dutchie@user/dutchie
you have to be careful with that sort of while loop though, the one you gave will always underflow, so you have to either use a signed int or change your condition to >= 1 and decrement in the loop body

1772112752
dutchie!~dutchie@user/dutchie
I'd do `for (0..n) |i| { const real_i = n - i - 1; f(real_i); }` (but with better names)

1772149785
clevor!sid649024@id-649024.hampstead.irccloud.com
Soo close to issue 31415!

