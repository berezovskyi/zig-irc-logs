1771201592
Affliction!affliction@idlerpg/player/affliction
"allocates an empty slice" why not init to &.{} ?

1771201622
Affliction!affliction@idlerpg/player/affliction
freeing an empty slice is a no-op so it can be unconditionally freed

1771201688
andrewrk!~andrewrk@mail.ziglang.org
Affliction: because the value is not observed until later initialized

1771212321
clevor!sid649024@id-649024.hampstead.irccloud.com
Someone told me "i hear if you say error payloads 3 times in front of a mirror andrew will crawl out of it"

1771212545
Affliction!affliction@idlerpg/player/affliction
oh nice, then I can buy him a beer, brb

1771253392
slowstatic_!~slowstati@user/slowstatic
Just read about the "juicy main" and std.process.Init changes, wow! this is so cool

1771274143
andrewrk!~andrewrk@mail.ziglang.org
slowstatic: happy hacking

1771274224
maskd!~maskd@user/maskd
is there an easy way to read from a stream until a delimiter where the delimiter is 2 bytes long? basically I want to read lines from stdin where each "line" ends with two newlines instead of one. I'm trying to implement something by tweaking takeDelimiterInclusve() but it's proving to be a bit of a pain. wondering if anyone has solved a similar problem before, I haven't been able to find anything online

1771274250
maskd!~maskd@user/maskd
I have a working solution where I just call takeDelimiterInclusive() and write to a separate buffer and then peek the next byte, which is perhaps better for readability but I wonder if there's a nice solution with only one buffer

1771275133
andrewrk!~andrewrk@mail.ziglang.org
maskd: perhaps a combination of fill() and std.mem.find()

1771275164
andrewrk!~andrewrk@mail.ziglang.org
assuming you have a maximum length between delimiters and willing to buffer that amount

1771275517
maskd!~maskd@user/maskd
yeah that's fine

1771275531
maskd!~maskd@user/maskd
conceptually the problem doesn't seem hard, maybe I'm just too tired to think about it now

