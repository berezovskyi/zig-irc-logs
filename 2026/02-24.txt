1771894248
agent314!~agent314@169.150.242.16
oh no i think i accidentally killed this channel somehow 

1771894254
agent314!~agent314@169.150.242.16
lol

1771896972
cowboy8625!~user@23.92.1.129
o/

1771899179
cow_2001!~username@user/cow-2001/x-5712099
this is so fast :(

1771926047
maskd!~maskd@user/maskd
I was just reading debug_allocator.zig and this bit of code (unrelated to actual allocation) puzzles me https://codeberg.org/ziglang/zig/src/branch/master/lib/std/heap/debug_allocator.zig#L321 this seems to be returning a pointer to stack memory, so why does it work? would it be any different if I assigned the struct to a `vtable` variable and then did `&vtable`?

1771926375
ifreund!2940d10f8b@user/ifreund
maskd: what happens there is that the vtable ends up in the global, read-only data section of the binary

1771926412
ifreund!2940d10f8b@user/ifreund
it is guaranteed that pointers to constant literals like that have a static lifetime

1771926438
ifreund!2940d10f8b@user/ifreund
if you were to assign the struct to a `var vtable = ...` local it would indeed be illegal behavior at runtime

1771926966
maskd!~maskd@user/maskd
interesting, I suppose that only works if the value is comptime-known?

1771926994
maskd!~maskd@user/maskd
is that documented anywhere? I couldn't find anything but I didn't search very hard

1771927793
ifreund!2940d10f8b@user/ifreund
maskd: yes, the value needs to be comptime-known

1771930011
maskd!~maskd@user/maskd
thanks for the clarification, I know I've used this a few times but somehow never stopped to ask myself why it's allowed

1771941090
lemons!~doggie@user/doggie-:49517
https://bpa.st/ITOA

1771941100
lemons!~doggie@user/doggie-:49517
is this assertion needed? 

1771970198
Sivecano_!~Sivecano@user/Sivecano
Is there currently just no way to do unix sockets with evented IO on linux or is there something I'm not seeing?

1771974102
lemons!~doggie@user/doggie-:49517
does ArrayList have a resize() that lets me set the values to something / can i fill an entire Array with zeroes

1771974120
lemons!~doggie@user/doggie-:49517
first thought was .items = @splat(0) but i dont know if that'd work

1771974719
sampsn!~gabriel.s@user/sampsn
sup

1771975115
sampsn!~gabriel.s@user/sampsn
exit

1771975117
sampsn!~gabriel.s@user/sampsn
quit

1771975120
sampsn!~gabriel.s@user/sampsn
lol

1771975127
sampsn!~gabriel.s@user/sampsn
first time on irc

1771975516
cow_2001!~username@user/cow-2001/x-5712099
now that i look at it, EnumIndexer gives us the index of an enum value compared to the others, not its value.  @intFromEnum() would accept any enum value, but EnumIndexer takes an enum type when it creates an indexer, so using that indexer is safer, type systemwise

1771975551
cow_2001!~username@user/cow-2001/x-5712099
is there an equivalent to @intFromEnum with that kind of type awareness EnumIndexer has?

1771975564
cow_2001!~username@user/cow-2001/x-5712099
i suppose i could write one

1771975702
cow_2001!~username@user/cow-2001/x-5712099
rip sampsn

1771975714
clevor!sid649024@id-649024.hampstead.irccloud.com
`const MyEnum = enum(u16) { fn toInt(self: MyEnum) u16 { â€¦ } };

1771975727
clevor!sid649024@id-649024.hampstead.irccloud.com
`

1771976753
cow_2001!~username@user/cow-2001/x-5712099
i want this to be a pile of tests showing how to do not so obvious stuff (at least to me) https://codeberg.org/kakafarm/mucking-about-with-ziglang/

