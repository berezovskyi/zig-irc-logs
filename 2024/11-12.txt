1731369796
andrewrk!~andrewrk@mail.ziglang.org
so the openDir() is in your own code? then you have the string at that site

1731370565
Earnestly!~earnest@user/earnestly
(plan9's fd2path is quite nice, but this has deeper purpose in relation to the "lexical file naming" issue, so called, and guarantees a rooted (absolute) path to every fd)

1731370657
Earnestly!~earnest@user/earnestly
cf https://9p.io/sys/doc/lexnames.html

1731372486
clevor!sid649024@id-649024.hampstead.irccloud.com
I would create a struct with both the path AND file descriptor.

1731382065
grayhatter!~grayhatte@user/grayhatter
hadronized: if I say inode, do you already know what that means, and why I'm saying it?

1731382332
grayhatter!~grayhatte@user/grayhatter
if not, the reason there isn't a trivial api to get a path from an open/valid directory file_discriptor, is an important implementation detail about linux file systems

1731382413
grayhatter!~grayhatte@user/grayhatter
if you're really just making a file browser, reconsider the problem your trying to solve. (providing the user with usable information) if they don't care about the fd, why does your code? i.e. why not just drop the idea of passing around an open Dir struct, and instead pass around just the path string?

1731387186
ksynwa!~kartik@2405:201:600a:f9b8:3e58:c2ff:fe28:23ff
What's "pointer capture" here? https://codeberg.org/ziglings/exercises/src/commit/8da60edb82b25ac913033b2f0edb63eea212c0d0/exercises/047_methods.zig#L87-L88

1731389997
voroskoi!924a802ee9@2a03:6000:1812:100::15c
ksynwa: *alien, as the comment says

1731422270
hadronized!~hadronize@2001:41d0:a:fe76::1
grayhatter: yeah I do know inodes

1731422278
hadronized!~hadronize@2001:41d0:a:fe76::1
I think you‚Äôre understanding the problem around

1731422289
hadronized!~hadronize@2001:41d0:a:fe76::1
the name is a property of a file

1731422302
hadronized!~hadronize@2001:41d0:a:fe76::1
it doesn‚Äôt mean it‚Äôs unique to it

1731422331
hadronized!~hadronize@2001:41d0:a:fe76::1
andrewrk: yes, I‚Äôm doing a couple of openDir, indeed

1731422339
hadronized!~hadronize@2001:41d0:a:fe76::1
the only issue really is for the first node

1731422352
hadronized!~hadronize@2001:41d0:a:fe76::1
for the rest, I just have a list of ‚Äúfile names‚Äù that I get when iterating on files in directories

1731422384
hadronized!~hadronize@2001:41d0:a:fe76::1
completely different topic, but I think I‚Äôm going to try to formalize my idea of ownership markers for Zig

1731422409
hadronized!~hadronize@2001:41d0:a:fe76::1
I just thought of the ‚ÄúZig can prevent leaks‚Äù and I think it‚Äôs not correct

1731422422
hadronized!~hadronize@2001:41d0:a:fe76::1
if we talk about memory leaks, then with a specialized allocator, sure

1731422436
hadronized!~hadronize@2001:41d0:a:fe76::1
but if we think about file descriptors or database connections, there is currently no way

1731422449
hadronized!~hadronize@2001:41d0:a:fe76::1
also, something that is even more of a problem to me; long running applications won‚Äôt see memory leaks

1731428945
grayhatter!~grayhatte@user/grayhatter
hadronized: as someone watching from just the sidelines, I'd advocate caution about anything that might make zig harder or more complicated to use or write. I.e. avoid making zig more rust like. I'm a fan of zig, precisely because it's not annoying like rust. To quote a friend "I can manage my own memory, thank you very much!" I reject the toxic and pervasive meme that it's impossible to not write

1731428947
grayhatter!~grayhatte@user/grayhatter
code with memory useage defects. 

1731430206
hadronized!~hadronize@2001:41d0:a:fe76::1
grayhatter: meme?

1731430224
hadronized!~hadronize@2001:41d0:a:fe76::1
yeah I mean, at this point, I‚Äôm still in the ‚Äúobservation‚Äù phase regarding Zig and how it evolves

1731430240
grayhatter!~grayhatte@user/grayhatter
idea that gets passed around, undergoing contant mutation/changes/updates

1731430245
hadronized!~hadronize@2001:41d0:a:fe76::1
I have a spare-time project (TUI) that I¬†started in Rust and now I‚Äôm writing it in Zig to compare

1731430266
hadronized!~hadronize@2001:41d0:a:fe76::1
grayhatter: yeah but the thing regarding memory safety is not a meme

1731430271
hadronized!~hadronize@2001:41d0:a:fe76::1
if you consider that a meme, I think you‚Äôre missing the point

1731430291
hadronized!~hadronize@2001:41d0:a:fe76::1
I can understand why Zig doesn‚Äôt want destructors

1731430297
hadronized!~hadronize@2001:41d0:a:fe76::1
but the current situation is just worse

1731430323
grayhatter!~grayhatte@user/grayhatter
"worse"... funny, I would have described it as 'better'

1731430324
hadronized!~hadronize@2001:41d0:a:fe76::1
‚Äúannoying‚Äù‚ÄØis not a very measurable term for engineering

1731430333
hadronized!~hadronize@2001:41d0:a:fe76::1
grayhatter: leaking memory and resources is better to you?

1731430334
grayhatter!~grayhatte@user/grayhatter
yes it is

1731430372
grayhatter!~grayhatte@user/grayhatter
hadronized: I don't have that problem... code I write doesn't leak memory, or other resources

1731430384
hadronized!~hadronize@2001:41d0:a:fe76::1
I could argue that C / Zig is super annoying;¬†having to deal with deallocating every items in an ArrayList before every .clear() if those items own m

1731430388
hadronized!~hadronize@2001:41d0:a:fe76::1
memory* is annoying

1731430404
hadronized!~hadronize@2001:41d0:a:fe76::1
grayhatter: ahah

1731430432
hadronized!~hadronize@2001:41d0:a:fe76::1
you can‚Äôt be serious when you say things like that

1731430436
hadronized!~hadronize@2001:41d0:a:fe76::1
that‚Äôs not how the industry works

1731430451
hadronized!~hadronize@2001:41d0:a:fe76::1
you will have to work with people who are not as smart and acute as you are.

1731430456
hadronized!~hadronize@2001:41d0:a:fe76::1
people do wake mistakes, you included

1731430463
hadronized!~hadronize@2001:41d0:a:fe76::1
bugs are actively written by software engineers

1731430467
hadronized!~hadronize@2001:41d0:a:fe76::1
not by magical fairies

1731430468
grayhatter!~grayhatte@user/grayhatter
hadronized: you could argue that. And I'd agree that's a totally sane take. For many people, they don't care about managing memory, they have more important things to do. Many people like python and javascript for that reason, it's just easier, and requires fewer specialized skills to do things correctly

1731430510
hadronized!~hadronize@2001:41d0:a:fe76::1
there‚Äôs a lot on the spectrum between Zig and Python‚Ä¶

1731430513
hadronized!~hadronize@2001:41d0:a:fe76::1
I‚Äôm not sure to follow the way you think

1731430521
hadronized!~hadronize@2001:41d0:a:fe76::1
you can completely have memory control and safety (what Rust does)

1731430542
grayhatter!~grayhatte@user/grayhatter
hadronized: that's the exact toxic meme that reject. It's a lie people like to tell so they can feel better about mistakes. It's just another form of, "it's not my fault, it's impossible to do it correctly... I shouldn't have to expend any effort into learning how to do something that many people consider hard"

1731430559
hadronized!~hadronize@2001:41d0:a:fe76::1
from a pure engineering point of view, currently, Zig is not a good fit for me, and I¬†thought about formalizing ideas to make it close the gap; without trying to make it like Rust

1731430567
hadronized!~hadronize@2001:41d0:a:fe76::1
if you just reject thath because it would make the language more complicated

1731430577
hadronized!~hadronize@2001:41d0:a:fe76::1
then why are we trying to enhance methods, languages and tools?

1731430583
hadronized!~hadronize@2001:41d0:a:fe76::1
are you afraid of learning something new?

1731430599
companion_cube!~simon@user/meow/companion-cube:68572
grayhatter: we have very solid evidence that malloc/free style of MM is impossible to do safely

1731430602
grayhatter!~grayhatte@user/grayhatter
people make mistakes, absolutely. I agree, but I don't agree that the only reasonable way is to make it impossible to make mistakes

1731430625
hadronized!~hadronize@2001:41d0:a:fe76::1
if you can‚Äôt statically write a bug, that bug will never end up in your application

1731430628
grayhatter!~grayhatte@user/grayhatter
companion_cube: you're definition of "proof" is different from mine

1731430630
companion_cube!~simon@user/meow/companion-cube:68572
allocators, the jury is still out imho, but it's definitely better

1731430633
hadronized!~hadronize@2001:41d0:a:fe76::1
I¬†don‚Äôt see what‚Äôs so hard to understand about that

1731430667
companion_cube!~simon@user/meow/companion-cube:68572
did I write "proof"?

1731430684
grayhatter!~grayhatte@user/grayhatter
"are you afraid of learning something new?" <- that's a strawman of the idea I'm trying to explain

1731430686
companion_cube!~simon@user/meow/companion-cube:68572
we have 50 years of very clear evidence on C

1731430732
hadronized!~hadronize@2001:41d0:a:fe76::1
grayhatter: I didn‚Äôt want that to sound like a strawman

1731430771
hadronized!~hadronize@2001:41d0:a:fe76::1
as I said earlier, I‚Äôm still in an observation phase

1731430775
hadronized!~hadronize@2001:41d0:a:fe76::1
so far, there are many aspects of Zig I¬†like

1731430782
hadronized!~hadronize@2001:41d0:a:fe76::1
but the ones I really don‚Äôt like are big blockers for me

1731430802
hadronized!~hadronize@2001:41d0:a:fe76::1
not because I think I need a safeguard when writing memory-based code

1731430825
hadronized!~hadronize@2001:41d0:a:fe76::1
but because I know I‚Äôm a human, not infallible, and that if the compiler doesn‚Äôt have my back from time to time, I¬†will eventually write bugs in Zig that could be caught at compile time

1731430840
hadronized!~hadronize@2001:41d0:a:fe76::1
refusing to talk about that just because it‚Äôs complex makes me frown

1731430888
grayhatter!~grayhatte@user/grayhatter
this is me refusing to talk? I even started only by advocating caution, not indending discouragement

1731430901
hadronized!~hadronize@2001:41d0:a:fe76::1
something to remember is that complexity falls into two classes:¬†incidental complexity, and accidental complexity; just ask yourself whether the complexity of the Rust type system is incidental or accidental regarding the problem it actually solves (spoiler:¬†no other language solves that problem, so that should help pick the class)

1731430948
hadronized!~hadronize@2001:41d0:a:fe76::1
grayhatter: yeah I see what you mean

1731430979
rockorager!~rockorage@2600:3c06::f03c:94ff:fea6:1f08
hadronized: you are talking about compile time checks that allocated resources are eventually freed?

1731430994
hadronized!~hadronize@2001:41d0:a:fe76::1
rockorager: yeah, I suggested on an issue the @ marker

1731430999
grayhatter!~grayhatte@user/grayhatter
I would like it if Zig could prevent more bugs, but given I've learned the skill of resource management, I don't have the same memory or resource management defects everyone enjoys claiming are impossible to avoid. I don't think it is impossible, and equally I don't view bugs as show stopping. I also don't agree that a memory leak bug, is more or less severe than some other bug.

1731431000
hadronized!~hadronize@2001:41d0:a:fe76::1
which is akin to linear types

1731431002
hadronized!~hadronize@2001:41d0:a:fe76::1
but weaker

1731431007
hadronized!~hadronize@2001:41d0:a:fe76::1
(you can‚Äôt have dangling @ types)

1731431048
hadronized!~hadronize@2001:41d0:a:fe76::1
grayhatter: are you a professionally trained engineer? 

1731431052
hadronized!~hadronize@2001:41d0:a:fe76::1
do you work for a software company?

1731431063
hadronized!~hadronize@2001:41d0:a:fe76::1
I work for Datadog, and I¬†see NPE¬†all the time (in Go for instance)

1731431096
hadronized!~hadronize@2001:41d0:a:fe76::1
it‚Äôs not only about yourself

1731431098
hadronized!~hadronize@2001:41d0:a:fe76::1
it‚Äôs about the industry

1731431104
grayhatter!~grayhatte@user/grayhatter
all of that said, I enjoy writing Zig, in large part because I don't enjoy fighting the compiler. With rust, I can't do something I know to be safe because the compiler, who's not as good as me,  can't prove that it's safe. IMO, that's a mistake. Zig won't let me do things it can prove is wrong. The zig compiler doesn't assert it's smarter than me, unless it actually is

1731431114
hadronized!~hadronize@2001:41d0:a:fe76::1
I remember a video presentation by Andrew stating he wants to make Zig one step forward for the industry

1731431116
hadronized!~hadronize@2001:41d0:a:fe76::1
not for himself

1731431121
grayhatter!~grayhatte@user/grayhatter
hadronized: I'm a security engineer at a FAANG

1731431124
companion_cube!~simon@user/meow/companion-cube:68572
sometimes though, rust is smarter than you :p

1731431131
companion_cube!~simon@user/meow/companion-cube:68572
(not always!)

1731431134
grayhatter!~grayhatte@user/grayhatter
companion_cube: rarely, not sometimes

1731431141
hadronized!~hadronize@2001:41d0:a:fe76::1
so you can‚Äôt really say ‚ÄúI don‚Äôt care that much about memory bugs because I have the skills to manage resources‚Äù

1731431154
hadronized!~hadronize@2001:41d0:a:fe76::1
companion_cube: it‚Äôs almost always smarter honestly

1731431165
companion_cube!~simon@user/meow/companion-cube:68572
if I use threads, yeah

1731431167
hadronized!~hadronize@2001:41d0:a:fe76::1
the only moment where it‚Äôs not is when it comes down to partial / mutual borrowing

1731431172
companion_cube!~simon@user/meow/companion-cube:68572
that's the real killer feature

1731431223
hadronized!~hadronize@2001:41d0:a:fe76::1
grayhatter: so you should know that many people will work on the code you write, and that you can‚Äôt expect people to deal with memory / resources the way you do

1731431238
hadronized!~hadronize@2001:41d0:a:fe76::1
on the same ideas, you do have a CI/CD to ensure no regression can happen

1731431244
hadronized!~hadronize@2001:41d0:a:fe76::1
you need a system to actually ensure people don‚Äôt mess up

1731431252
hadronized!~hadronize@2001:41d0:a:fe76::1
that‚Äôs why a smarter compiler helps on that matter

1731431276
grayhatter!~grayhatte@user/grayhatter
hadronized: I do care about bugs, I don't consider resource management bugs more severe than other bugs. e.g., rust code that's perfectly memory safe, but due to some application logic, it destroyed my data... a C program that leakes memory like a sieve is a much better option.

1731431307
hadronized!~hadronize@2001:41d0:a:fe76::1
grayhatter: this is completely orthogonal to the language

1731431311
companion_cube!~simon@user/meow/companion-cube:68572
rust will also help with application logic :D

1731431316
companion_cube!~simon@user/meow/companion-cube:68572
sum types and all that

1731431317
hadronized!~hadronize@2001:41d0:a:fe76::1
you can write bad logical code in Rust‚Ä¶ and in C‚Ä¶ and in Zig

1731431322
hadronized!~hadronize@2001:41d0:a:fe76::1
where are you going to with that weird argument?

1731431325
companion_cube!~simon@user/meow/companion-cube:68572
easy testing, etv

1731431328
grayhatter!~grayhatte@user/grayhatter
hadronized: does anyone else use the sway status bar I wrote in zig?

1731431329
companion_cube!~simon@user/meow/companion-cube:68572
etc

1731431385
grayhatter!~grayhatte@user/grayhatter
not every line of code needs to be written for big businesses who've lost the plot on what good engineering really is. It's ok for a language to target different goals.

1731431399
hadronized!~hadronize@2001:41d0:a:fe76::1
so Zig targets elits?

1731431404
companion_cube!~simon@user/meow/companion-cube:68572
zig is for hackers, for sure

1731431431
companion_cube!~simon@user/meow/companion-cube:68572
I doubt it'll reach the popularity of rust for this reason

1731431433
grayhatter!~grayhatte@user/grayhatter
I don't want speak for the authors of Zig... 

1731431439
ifreund!2940d10f8b@user/ifreund
zig is useful for a lot of different things

1731431440
grayhatter!~grayhatte@user/grayhatter
> Zig is a general-purpose programming language and toolchain for maintaining robust, optimal and reusable software.

1731431453
ifreund!2940d10f8b@user/ifreund
there's a lot of black and white thinking going on in this discussion

1731431460
hadronized!~hadronize@2001:41d0:a:fe76::1
companion_cube: honestly, I like the idea of making everything explicit

1731431488
hadronized!~hadronize@2001:41d0:a:fe76::1
my idea for @ (and that was done in a way not to introduce destructors) was exactly because I think a better alternative would be not to require destructors, but instead having the compiler whine a resource is not taken care of

1731431491
grayhatter!~grayhatte@user/grayhatter
ifreund: I wouldn't say it's black and white thinking, I'd say it's poorly articulated, or barely contextualized 

1731431492
hadronized!~hadronize@2001:41d0:a:fe76::1
it actually goes into the direction of Zig

1731431531
grayhatter!~grayhatte@user/grayhatter
hadronized: "complain" like a warning? or complain, like refuse to compile?

1731431550
hadronized!~hadronize@2001:41d0:a:fe76::1
what I really really really fear when I hear arguments from grayhatter (but I also read similar arguments from Andrew) is the confusion about Rust complexity; swapping incidental for accidental

1731431554
companion_cube!~simon@user/meow/companion-cube:68572
hadronized: have you looked at Odin? :)

1731431584
hadronized!~hadronize@2001:41d0:a:fe76::1
when I read people stating ‚Äúthe rust compiler is annoying‚Äù, I can‚Äôt help myself thinking ‚Äúyeah I much prefer fighting against customer tickets about bugs rather than spending 15 minutes more trying to understand why the compiler is yelling at me‚Äù

1731431586
hadronized!~hadronize@2001:41d0:a:fe76::1
and it makes me cringe

1731431599
hadronized!~hadronize@2001:41d0:a:fe76::1
especially because the last decades showed us why we need to think a bit more about safety

1731431603
hadronized!~hadronize@2001:41d0:a:fe76::1
companion_cube: yeah I did

1731431612
grayhatter!~grayhatte@user/grayhatter
hadronized: OH, do you believe that debugging is the hardest part of writing code?

1731431619
hadronized!~hadronize@2001:41d0:a:fe76::1
lately I¬†looked at Zig, Hare, Carbon, C3 and Odin

1731431638
hadronized!~hadronize@2001:41d0:a:fe76::1
grayhatter: no, I¬†think that I have used a debugger like 3 or 4 times since I started writing Rust (2014)

1731431650
hadronized!~hadronize@2001:41d0:a:fe76::1
and that it speaks millions times 

1731431677
o0x1eef!~user@user/o0x1eef
It's more like a technique that some people like and use, and others don't, for better or worse

1731431692
grayhatter!~grayhatte@user/grayhatter
hadronized: then I don't think I understand what "fighting customer tickets" actually means

1731431717
companion_cube!~simon@user/meow/companion-cube:68572
bugs in production that need quick fixing

1731431736
hadronized!~hadronize@2001:41d0:a:fe76::1
grayhatter: it was an analogy; I much prefer spending time ‚Äúwith the annoying compiler‚Äù that will catch many bugs at compile-time

1731431744
hadronized!~hadronize@2001:41d0:a:fe76::1
versus having to deal with the compiled code, causing error in production

1731431765
hadronized!~hadronize@2001:41d0:a:fe76::1
I think the Zig mantra says the opposite of that

1731431774
grayhatter!~grayhatte@user/grayhatter
I don't often have that problem :thinking:

1731431780
hadronized!~hadronize@2001:41d0:a:fe76::1
yeah, this:

1731431782
hadronized!~hadronize@2001:41d0:a:fe76::1
> Focus on debugging your application rather than debugging your programming language knowledge.

1731431790
hadronized!~hadronize@2001:41d0:a:fe76::1
that is something I don‚Äôt understand

1731431799
hadronized!~hadronize@2001:41d0:a:fe76::1
people prefer spending time debugging than reading compiler errors?

1731431814
o0x1eef!~user@user/o0x1eef
Or maybe you just got use to how Rust works and now you expect everything else to work like that too

1731431831
hadronized!~hadronize@2001:41d0:a:fe76::1
not like that, but yeah, that made the expectations higher

1731431852
hadronized!~hadronize@2001:41d0:a:fe76::1
for instance, for building a better resource management experience (hence why I¬†talked about formalizing my @ idea)

1731431892
rockorager!~rockorage@2600:3c06::f03c:94ff:fea6:1f08
hadronized: link to your proposal? Couldn't find it in my brief scrolling

1731431915
hadronized!~hadronize@2001:41d0:a:fe76::1
I don‚Äôt have a proposal just yet, just the comment I¬†made on the issue (give me 30s)

1731431955
grayhatter!~grayhatte@user/grayhatter
hadronized: I've written rust for a large "black box" reverse engineering project. I needed a list, that would have 1 writer at startup, many threaded readers, and it took me 2 days to try to figure out how to prove to the rust compiler that this RwLock<Arc<Box<Thing>>> was really safe to pass around. Granted, that was my own skill issue with the language. But It would have been 40m tops to write in

1731431957
grayhatter!~grayhatte@user/grayhatter
Zig.

1731432065
hadronized!~hadronize@2001:41d0:a:fe76::1
rockorager: https://github.com/ziglang/zig/issues/3690#issuecomment-2460002809

1731432084
companion_cube!~simon@user/meow/companion-cube:68572
and how long to debug the race conditions? :)

1731432138
hadronized!~hadronize@2001:41d0:a:fe76::1
yeah honestly, I could accept criticism about Rust for some things, but clearly not for its thread safety

1731432140
grayhatter!~grayhatte@user/grayhatter
trying to figure out the magical incantation to convince the compiler the code was safe, was me debugging my programming language knowledge. There's so much unimportant stuff I needed to know, remember, and use in order, just so that I could make the compiler happy. The code was objectively worse (more complicated) and a simple reading would prove it was safe to write that way... but the rust compiler

1731432142
grayhatter!~grayhatte@user/grayhatter
wasn't as smart as I was, (and I wasn't good enough at rust at the time) that I spent multiple powers of 2 more time fighting the language, than I spent writing/understanding my code.

1731432157
hadronized!~hadronize@2001:41d0:a:fe76::1
99%, if you struggle proving the code safe, then the code is likely not safe.

1731432160
hadronized!~hadronize@2001:41d0:a:fe76::1
99% of the time*

1731432186
grayhatter!~grayhatte@user/grayhatter
hadronized: did you just make up that 99% number, or do you have a study backing it up?

1731432195
hadronized!~hadronize@2001:41d0:a:fe76::1
Rust is becoming hard to think about, even for advanced users, when it comes down to pinned futures and async points; that is the part I admit where Rust is going a bit too far

1731432224
hadronized!~hadronize@2001:41d0:a:fe76::1
grayhatter: making it up based on just how often I see people stating what they do is safe, while it‚Äôs actually not

1731432235
grayhatter!~grayhatte@user/grayhatter
because that screams sample bias to me, People that enjoy rust, write code that rust likes. I suspect people who write C, or better yet, "correct asm" would write code that's correct, but rust claims is incorrect

1731432314
hadronized!~hadronize@2001:41d0:a:fe76::1
yeah I mean, I have had many examples in the past ~10 years of Rust experience where the compiler refused to compile, and after having fixed the code, I understood rustc just prevented me from shooting my feet

1731432319
grayhatter!~grayhatte@user/grayhatter
hadronized: so, the point where you admit rust might be going too far? that's what zig is trying to avoid. Becoming so complicated, that the language is hard to use. I just set my bar for where "too complex to be a good language", much lower than you do

1731432332
hadronized!~hadronize@2001:41d0:a:fe76::1
but sure maybe you do write safe code and Rust still requires a bit more knowledge to ensure it‚Äôs safe

1731432334
hadronized!~hadronize@2001:41d0:a:fe76::1
it can‚Äôt be perfect

1731432352
hadronized!~hadronize@2001:41d0:a:fe76::1
yeah clearly

1731432358
hadronized!~hadronize@2001:41d0:a:fe76::1
async/await is not something I¬†use very often

1731432370
hadronized!~hadronize@2001:41d0:a:fe76::1
and I know / understand the transformation Rust does on async code

1731432387
hadronized!~hadronize@2001:41d0:a:fe76::1
I have the state machine in mind and know that right before an .await, it‚Äôs going to have to put all the captured data in a closure-like structure

1731432392
grayhatter!~grayhatte@user/grayhatter
hadronized: question for you... if you have a simple program, where you alloc a bunch of memory, then exit() without calling free(). Is that a memory leak?

1731432394
hadronized!~hadronize@2001:41d0:a:fe76::1
so borrowing / ownership might get in the way

1731432412
hadronized!~hadronize@2001:41d0:a:fe76::1
grayhatter: depends on the OS

1731432418
hadronized!~hadronize@2001:41d0:a:fe76::1
most OS today will still reclaim the pages

1731432428
grayhatter!~grayhatte@user/grayhatter
name one that doesn't?

1731432474
hadronized!~hadronize@2001:41d0:a:fe76::1
when I worked at Ledger, we had an embedded OS that did not have a very good memory management scheme

1731432475
grayhatter!~grayhatte@user/grayhatter
That's an actual question, I've never heard of one

1731432504
hadronized!~hadronize@2001:41d0:a:fe76::1
grayhatter: but to me, the memory leak problem is not really important if you quit the application

1731432505
grayhatter!~grayhatte@user/grayhatter
yeah, I don't think that counts

1731432507
hadronized!~hadronize@2001:41d0:a:fe76::1
it‚Äôs important if you don‚Äôt

1731432521
hadronized!~hadronize@2001:41d0:a:fe76::1
like calling clear() on an ArrayList with owned data

1731432533
hadronized!~hadronize@2001:41d0:a:fe76::1
in Zig, currently, it will require the application to stop to actually detect the leak

1731432547
hadronized!~hadronize@2001:41d0:a:fe76::1
but if the application is long-living, it will just OOM

1731432558
hadronized!~hadronize@2001:41d0:a:fe76::1
so it‚Äôs a pretty weird example you took

1731432561
hadronized!~hadronize@2001:41d0:a:fe76::1
because Zig does the wrong thing here

1731432573
grayhatter!~grayhatte@user/grayhatter
hadronized: I disagree it does the wrong thing.

1731432577
hadronized!~hadronize@2001:41d0:a:fe76::1
tracking memory allocation / leaks on exit while you just tried to show me that it doesn‚Äôt really matter

1731432612
hadronized!~hadronize@2001:41d0:a:fe76::1
well, ensuring the memory is free via linear types (my @ thing), or destructors (Rust‚Äôs Drop) is far better IMHO

1731432622
hadronized!~hadronize@2001:41d0:a:fe76::1
you could favor the first one (linear types) for its more explicit nature

1731432631
hadronized!~hadronize@2001:41d0:a:fe76::1
since I do agree that hiding deallocations can be weird

1731432642
hadronized!~hadronize@2001:41d0:a:fe76::1
even though that argument crumbles very quickly

1731432649
hadronized!~hadronize@2001:41d0:a:fe76::1
defer is a good example of how it‚Äôs basically the same thing

1731432678
hadronized!~hadronize@2001:41d0:a:fe76::1
the only issue is that, if you forget to defer stuff.deinit();, then you have to wait until the program shuts down to actually see the beug

1731432680
hadronized!~hadronize@2001:41d0:a:fe76::1
bug*

1731432710
grayhatter!~grayhatte@user/grayhatter
Storing an allocatored pointer in an array list, then calling clear() is similar to -> fn leak(a: Allocator) !*usize { return try a.create(usize); } [...] `while (true) { _ = try leak(alloc); }

1731432745
hadronized!~hadronize@2001:41d0:a:fe76::1
yes

1731432754
grayhatter!~grayhatte@user/grayhatter
why should ArrayList, attempt to free that memory for you? how would it know that memory pointer doesn't exist else where?

1731432769
hadronized!~hadronize@2001:41d0:a:fe76::1
every time I need to clear an ArrayList(T) in Zig, I¬†keep having to remember whether I should loop on the items and deinit them first

1731432788
hadronized!~hadronize@2001:41d0:a:fe76::1
grayhatter: that‚Äôs the whole reason why I mentioned linear types / @ annotations

1731432893
grayhatter!~grayhatte@user/grayhatter
yes... you do have to remember... You should think about things before you do them... e.g. I have a notebook full of phone numbers and addresses, I'm about to burn the book, do I care about the numbers or addresses I've written in the book?

1731432932
grayhatter!~grayhatte@user/grayhatter
I don't think "understanding what the code you're writing is actually doing" is an unreasonable demand from a programming languge

1731432956
hadronized!~hadronize@2001:41d0:a:fe76::1
again, this is orthogonal

1731432967
grayhatter!~grayhatte@user/grayhatter
you can say "I shouldn't have to" and then you might be right, but then, python exists already

1731432971
hadronized!~hadronize@2001:41d0:a:fe76::1
you could be completely understanding that you have to unallocate it, and still forgetting.

1731432979
hadronized!~hadronize@2001:41d0:a:fe76::1
or maybe the control flow is slightly more complex

1731432989
Gliptic!~glip@2a01:4f8:c012:91f3::1
the compiler could remind me of what I need to think about

1731433015
hadronized!~hadronize@2001:41d0:a:fe76::1
anyway, maybe I‚Äôm just too dumb and asking way too much and should get back to play with sand and let grown up people do the real hacking in Zig

1731433027
hadronized!~hadronize@2001:41d0:a:fe76::1
I thought my weak-linear-type idea could be interesting to share

1731433032
grayhatter!~grayhatte@user/grayhatter
hadronized: that's just another strawman... but this time it's attacking you instead

1731433034
hadronized!~hadronize@2001:41d0:a:fe76::1
it was probably not

1731433121
grayhatter!~grayhatte@user/grayhatter
hadronized: for the record, I'm actually very interested in the idea and suggestion. Because from time to time I do have the thought that it might be useful to have some lifetime annotation here, when writing zig

1731433165
grayhatter!~grayhatte@user/grayhatter
I just don't want it to make the language harder to use

1731433181
hadronized!~hadronize@2001:41d0:a:fe76::1
don‚Äôt worry about that

1731433236
grayhatter!~grayhatte@user/grayhatter
hadronized: you saw the "useall" proposal right?

1731433259
grayhatter!~grayhatte@user/grayhatter
> Zig programmers should not be punished for using structured data.

1731433267
hadronized!~hadronize@2001:41d0:a:fe76::1
no I¬†haven‚Äôt

1731433272
grayhatter!~grayhatte@user/grayhatter
I think there's a way to frame the idea you're inventing as 

1731433289
grayhatter!~grayhatte@user/grayhatter
"Zig programmers should not be punished for using an allocated resource"

1731433293
hadronized!~hadronize@2001:41d0:a:fe76::1
I‚Äôm not really inventing the idea; it‚Äôs just a weakened version of ATS‚Äô proof system

1731433294
grayhatter!~grayhatte@user/grayhatter
https://github.com/ziglang/zig/issues/21879

1731433298
hadronized!~hadronize@2001:41d0:a:fe76::1
(way weaker; ATS is crazy)

1731433312
grayhatter!~grayhatte@user/grayhatter
hadronized: it doesn't exist in zig, that counts as inventing IMO

1731434775
grayhatter!~grayhatte@user/grayhatter
is there a way to specify a comptime null check without using anytype?

1731434848
grayhatter!~grayhatte@user/grayhatter
I.e. I will always know at comptime, if the value is nullable or not. Is there a way to express that other than `switch (@TypeOf(anytype))`

1731435864
rockorager!~rockorage@2600:3c06::f03c:94ff:fea6:1f08
anyone know why the package manager does not follow redirects for git+http{s} but does for http{s} packages?

1731435894
grayhatter!~grayhatte@user/grayhatter
because git can't return a redirect

1731435921
rockorager!~rockorage@2600:3c06::f03c:94ff:fea6:1f08
https://github.com/ziglang/zig/blob/1db8cade5ab5c05fa3c6a884e50947633ebcf065/src/Package/Fetch.zig#L946-L960

1731435922
grayhatter!~grayhatte@user/grayhatter
the behavior you're describing is http[s]+git

1731435966
rockorager!~rockorage@2600:3c06::f03c:94ff:fea6:1f08
Ah ok, so that's a limitation of git over https

1731436001
grayhatter!~grayhatte@user/grayhatter
no, I think you're correct, it does seem to support that behavior as well

1731436058
grayhatter!~grayhatte@user/grayhatter
what does curl say? does curl agree the http server is redirecting?

1731436088
rockorager!~rockorage@2600:3c06::f03c:94ff:fea6:1f08
I haven't tried curl but a browser does redirect

1731436107
rockorager!~rockorage@2600:3c06::f03c:94ff:fea6:1f08
https://codeberg.org/dude_the_builder/zg

1731436120
rockorager!~rockorage@2600:3c06::f03c:94ff:fea6:1f08
301 redirect to https://codeberg.org/atman/zg

1731436121
grayhatter!~grayhatte@user/grayhatter
oh, interesting, the package manager will see the redirect, but then still fail instead of following it?

1731436126
rockorager!~rockorage@2600:3c06::f03c:94ff:fea6:1f08
Yes

1731436133
rockorager!~rockorage@2600:3c06::f03c:94ff:fea6:1f08
That's what it looks like

1731436181
rockorager!~rockorage@2600:3c06::f03c:94ff:fea6:1f08
Yeah everythign I'm seeing says git will follow http redirects if you let it

1731436237
grayhatter!~grayhatte@user/grayhatter
IIRC the git protocol doesn't have a concept of a redirect. That's purely an http semantic. 

1731436375
grayhatter!~grayhatte@user/grayhatter
the behavior is probably intended

1731436394
rockorager!~rockorage@2600:3c06::f03c:94ff:fea6:1f08
That's what it looks like...but why?

1731436413
grayhatter!~grayhatte@user/grayhatter
git does follow the http redirect, but emits a warning, and zig requires all warnings to be errors

1731436455
rockorager!~rockorage@2600:3c06::f03c:94ff:fea6:1f08
It just seems counter intuitive that a redirect is ok if you pull a tarball but not allowed for git

1731436466
rockorager!~rockorage@2600:3c06::f03c:94ff:fea6:1f08
Either both should error or both should follow

1731436536
grayhatter!~grayhatte@user/grayhatter
don't tarballs require a sha, where git is more like a directory with a HEAD, and HEAD could point to any revision?

1731436595
rockorager!~rockorage@2600:3c06::f03c:94ff:fea6:1f08
zig hashes the download in any case though, doesn't it?

1731436629
grayhatter!~grayhatte@user/grayhatter
does it? I'd be suprised if zig hashed the whole git repo

1731436636
grayhatter!~grayhatte@user/grayhatter
what does your zig.zon look like?

1731436655
rockorager!~rockorage@2600:3c06::f03c:94ff:fea6:1f08
https://github.com/rockorager/libvaxis/blob/v0.5.0/build.zig.zon

1731436933
grayhatter!~grayhatte@user/grayhatter
rockorager: I agree with you, tar vs git shouldn't have different redirect behavior. I'd open an issue for it. It could be that the code you linked to just needs a comment explaining the decision. But any unexpected behaivor is a bug unless otherwise commented 

1731437094
rockorager!~rockorage@2600:3c06::f03c:94ff:fea6:1f08
grayhatter: will do. Got it down to a simple example

1731437099
rockorager!~rockorage@2600:3c06::f03c:94ff:fea6:1f08
zig fetch https://codeberg.org/dude_the_builder/zg/archive/v0.13.2.tar.gz

1731437101
rockorager!~rockorage@2600:3c06::f03c:94ff:fea6:1f08
vs 

1731437114
rockorager!~rockorage@2600:3c06::f03c:94ff:fea6:1f08
zig fetch git+https://codeberg.org/dude_the_builder/zg#v0.13.2

1731437124
rockorager!~rockorage@2600:3c06::f03c:94ff:fea6:1f08
first succeeds, second fails

1731437516
rockorager!~rockorage@2600:3c06::f03c:94ff:fea6:1f08
grayhatter: https://github.com/ziglang/zig/issues/21976

1731438024
andrewrk!~andrewrk@mail.ziglang.org
wow: https://git.savannah.gnu.org/cgit/guix.git/tree/gnu/packages/zig.scm?h=wip-zig-bootstrap

1731438378
o0x1eef!~user@user/o0x1eef
Nice :)

1731439447
ifreund!2940d10f8b@user/ifreund
very cool, It would be interesting to compare the wasm blob produced through this effort with what we've got committed to the repo

1731439574
ifreund!2940d10f8b@user/ifreund
probably not even the worst guix bootstrap path

1731439668
ifreund!2940d10f8b@user/ifreund
zig.scm isn't even as long as haskell.scm yet: https://git.savannah.gnu.org/cgit/guix.git/tree/gnu/packages/haskell.scm

1731439804
ekaitz!~Ekaitz@94.73.33.227
ifreund: the rust one is way worse, and each couple of weeks it gets worse

1731439846
ekaitz!~Ekaitz@94.73.33.227
the problem will be to catch up if the commits that change the path are not tagged

1731440209
BratishkaErik!fd46852e72@user/BratishkaErik
that is a lot of commits, ig it's very cool for guix users to know how much maintainers care about blobs and such, luck to them

1731440262
BratishkaErik!fd46852e72@user/BratishkaErik
ekaitz: btw you might find it useful (I hope so), wrote some small converter "CHOST and CFLAGS => Zig target and CPU models

1731440297
ekaitz!~Ekaitz@94.73.33.227
BratishkaErik: do you have a link for that?

1731440304
BratishkaErik!fd46852e72@user/BratishkaErik
sorry hit enter too soon, chost might be too gentoo-specific for you but CFLAGS should be universal

1731440387
BratishkaErik!fd46852e72@user/BratishkaErik
ekaitz: (warning: all in Bash) implementation: https://github.com/gentoo/gentoo/blob/ed835f88bc579f93b2370c0f0569ddbf1ba3f563/eclass/zig-utils.eclass , tests: https://github.com/gentoo/gentoo/blob/ed835f88bc579f93b2370c0f0569ddbf1ba3f563/eclass/tests/zig-utils.sh

1731440408
ekaitz!~Ekaitz@94.73.33.227
let me take a look

1731440431
ekaitz!~Ekaitz@94.73.33.227
this might be interesting for the zig-build-system in guix

1731440472
ekaitz!~Ekaitz@94.73.33.227
but I'm too swamped at the moment with other problems :((

1731440604
BratishkaErik!fd46852e72@user/BratishkaErik
hope for you they will calm down soon :)

1731440640
ekaitz!~Ekaitz@94.73.33.227
BratishkaErik: hehe i'm going to be a father soon so i don't think that's happening

1731440650
ekaitz!~Ekaitz@94.73.33.227
:)

1731440654
BratishkaErik!fd46852e72@user/BratishkaErik
oh what

1731440676
BratishkaErik!fd46852e72@user/BratishkaErik
sorry you were much younger in my mind, congratulations!

1731440693
ekaitz!~Ekaitz@94.73.33.227
much younger?

1731440700
The_Buhs!~The_Buhs@user/The-Buhs/x-5080862
BratishkaErik: I get excited every time I get an email about your Gentoo PR :P

1731440711
BratishkaErik!fd46852e72@user/BratishkaErik
ikd how to translate it properly, not literally much younger

1731440744
ekaitz!~Ekaitz@94.73.33.227
BratishkaErik: :) i'm 33 

1731440781
ekaitz!~Ekaitz@94.73.33.227
some would argue i'm still "very" young

1731440972
BratishkaErik!fd46852e72@user/BratishkaErik
:) but anyway I wish you and your family the best, may future days be filled with love joy and so on

1731441271
ekaitz!~Ekaitz@94.73.33.227
BratishkaErik: thank you mate

1731441283
ekaitz!~Ekaitz@94.73.33.227
same

1731441742
BratishkaErik!fd46852e72@user/BratishkaErik
:)

1731441820
BratishkaErik!fd46852e72@user/BratishkaErik
The_Buhs: are you talking about "GitHub PR" or "mailing list"?

1731441915
The_Buhs!~The_Buhs@user/The-Buhs/x-5080862
The GitHub PR, I‚Äôm subscribed to it on GitHub so I get emails whenever you push changes. Mostly just following cause I‚Äôm excited to get the zig eclass. I did see Sam mention the mailing list but I‚Äôm not on that 

1731441983
BratishkaErik!fd46852e72@user/BratishkaErik
would you like to test zig-ebuilder then? if you have latest zig ofc. just testing on any result and see if it produces working ebuild without hassle

1731442207
BratishkaErik!fd46852e72@user/BratishkaErik
actually, I was thinking on making it a little bit more distro-agnostic but before that I'd like to have some way to get at least description and license automatically for Zig projects

1731442242
The_Buhs!~The_Buhs@user/The-Buhs/x-5080862
<BratishkaErik> would you like to test zig-ebuilder then?

1731442242
The_Buhs!~The_Buhs@user/The-Buhs/x-5080862
sure :) I can later today

1731442281
BratishkaErik!fd46852e72@user/BratishkaErik
don't remember plans on licenses but I think REUSE would be great to adopt

1731442332
BratishkaErik!fd46852e72@user/BratishkaErik
The_Buhs: how much "later" are we talking about? it's unfortunately midnight for me :)

1731442446
BratishkaErik!fd46852e72@user/BratishkaErik
you can fill an issue with URL, outputted ebuild and what would you like to see added, removed or fixed in that automatic output here https://github.com/BratishkaErik/zig-ebuilder/issues at any time

1731442482
BratishkaErik!fd46852e72@user/BratishkaErik
got to sleep, good time of day everyone

1731442573
The_Buhs!~The_Buhs@user/The-Buhs/x-5080862
BratishkaErik: definitely a couple of hours üòÖ it's 14:15 for me so not until I'm done with work for today. I'll definitely let you know how it goes, though

1731449675
hadronized!~hadronize@2001:41d0:a:fe76::1
is there any possibility to lose the lazy compilation feature of Zig?

1731449680
hadronized!~hadronize@2001:41d0:a:fe76::1
or at least make it a two-stage step?

1731449692
hadronized!~hadronize@2001:41d0:a:fe76::1
i.e. ‚Äúcheck‚Äù the code, but perform dead-code analysis on it afterwards?

1731449714
hadronized!~hadronize@2001:41d0:a:fe76::1
it‚Äôs a refactoring nightmare when I have to plug in all the code I write without really having it plugged to main in the first place

1731449821
grayhatter!~grayhatte@user/grayhatter
_ = &thingUnderTest

1731449900
hadronized!~hadronize@2001:41d0:a:fe76::1
I do that; it doesn‚Äôt work

1731449911
hadronized!~hadronize@2001:41d0:a:fe76::1
I have the tests.zig file with comptime { /* EVERYTHING */ }

1731449919
hadronized!~hadronize@2001:41d0:a:fe76::1
but I keep getting surprised when I start using some functions in main

1731450333
rockorager!~rockorage@2600:3c06::f03c:94ff:fea6:1f08
I usually add a test { std.testing.refAllDecls(); } block when I‚Äôm starting something and not sure where it‚Äôs going

1731450453
hadronized!~hadronize@2001:41d0:a:fe76::1
ah, I‚Äôll have a look at that refAllDecls() thing

1731450460
hadronized!~hadronize@2001:41d0:a:fe76::1
is .always_tail available for @call()?

1731450469
hadronized!~hadronize@2001:41d0:a:fe76::1
I get a super weird compile error

1731450755
hadronized!~hadronize@2001:41d0:a:fe76::1
nvm

1731451291
hadronized!~hadronize@2001:41d0:a:fe76::1
ah

1731451304
hadronized!~hadronize@2001:41d0:a:fe76::1
.always_tail is just funky when it can‚Äôt do tail-recursion

1731451386
hadronized!~hadronize@2001:41d0:a:fe76::1
https://zigbin.io/1a26d0

