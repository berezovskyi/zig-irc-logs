1546130620
daurnimator
emekoi: as you seem to know how that repo works, any chance you could fix

1546130651
daurnimator
I'm used to ctrl+/ toggling comments for a line. it doesn't work in the zig syntax at the moment.,

1546131156
emekoi
daurnimator: that's weird because it works for me...

1546131164
emekoi
are you using the latest version?

1546131181
daurnimator
yep

1546131291
emekoi
the latest version from the from the repo?

1546131565
emekoi
yeah, because that should be fixed by

1546136754
andrewrk
emekoi, thanks for the sublime PRs

1546137145
daurnimator
emekoi: ah no. only the latest release

1546141582
knebulae
andrewrk: now that opaque types seem to be stabilized (according to the docs), any intention to revisit typedef like behavior (

1546142745
andrewrk
knebulae, why packed structs?

1546142770
knebulae
passing to/from C

1546142793
andrewrk
you probably want extern for that, not packed

1546142849
andrewrk
the current plan is to not have typedefs. you are welcome to make a proposal to re-introduce them

1546145095
knebulae
andrewrk: typedef is cleaner.  Consider pub typedef SegmentSelector: u16; vs pub const SegmentSelector = packed struct { data: u16, };  Plus all of the extra typing to use the single member value.

1546145132
andrewrk
how about pub const SegmentSelector = u16; ?

1546145159
knebulae
andrewrk: That works too.  I think typedef has too much baggage imho.

1546145174
andrewrk
that works now

1546145205
knebulae
andrewrk: oh.  I was not clear that I could do that.

1546145231
knebulae
I keep forgetting that types truly are first class citizens.

1546145253
andrewrk
:)

1546145269
andrewrk
almost first class. you can't use them at runtime

1546149754
knebulae
andrewrk: finally getting organized here, thought I'd share:

1546168243
daurnimator
is it possible to add methods to an opaque type?

1546168844
daurnimator
I guess the answer is 'wrap' it?

1546169383
daurnimator
So.... if I want to create a shared zig library, how should I be exporting the definitions?

1546172598
knebulae
daurnimator: I may be wrong here, as I'm still learning, but I believe --output-h coupled with --build-lib, with the functions properly marked as "export".

1546172630
daurnimator
knebulae: that would indeed generate a .h file... but is that the preferred form?

1546172662
daurnimator
I thought there might be some sort of 'stripped .zig file' form....

1546172671
daurnimator
(maybe only in andrewrk's brain)

1546173107
knebulae
daurnimator: well, shared libraries are just regular .dll, .so, or .dylib files, but other than .obj files, I'm not aware of any other "form" (i.e. there's no type of shared library / object that's unique to just zig).

1546173136
daurnimator
knebulae: correct. zig uses the standard library formats. but I thought it might have it's own 'header' format

1546173176
knebulae
daurnimator: got me too.  no headers.

1546173235
daurnimator
I feel like there should be some sort of format that just exposes signatures but not bodies.

1546173251
daurnimator
probably generated by the 'zig' tool somehow

1546173390
knebulae
daurnimator: if andrewrk ever forsees widespread zig use, the reality is that people (mostly companies) will want to distribute binary-only libraries, which will require some way to provide zig with function signatures other than exporting from one zig module, building a library and generating a c header, than consuming the c-header in another zig file :/

1546173423
daurnimator
knebulae: yeah that's pretty much my thought

1546173444
daurnimator
was hoping there would be an open issue for it or known plan

1546173654
knebulae
daurnimator: having the ability to generate a zig file with only declarations and signatures suitable for importing and then linking with a provided object file.

1546173758
knebulae
daurnimator: I think the new hotness is to avoid header files though. C# gets away with it because IL has a lot of metadata.  Not sure how rust handles it, but they don't have header files.

1546173868
daurnimator
Dpm

1546173876
daurnimator
Don't we need it for deep dependencies?

1546173905
daurnimator
If I write a library A that uses B and C internally (but never exposes it), then I don't want the user of my library X to need the .zig files for B and C installed

1546174278
daurnimator
very different question: how do I create an volatile array to six ints?

1546174324
daurnimator
error: invalid token: 'volatile'

1546174326
daurnimator
var args: volatile [6]c_uint = {request, a1, a2, a3, a4, a5};

1546174360
daurnimator
error: expected token ';', found ','

1546174362
daurnimator
var args: [6]volatile c_uint = {request, a1, a2, a3, a4, a5};

1546174372
daurnimator
^

1546174434
daurnimator
oh. is it: var args = []volatile c_uint{request, a1, a2, a3, a4, a5};

1546174969
knebulae
daurnimator: you did review the notes on volatile, correct?

1546174991
daurnimator
knebulae: you mean

1546175018
knebulae
daurimator: "Note that volatile is unrelated to concurrency and Atomics. If you see code that is using volatile for something other than Memory Mapped Input/Output, it is probably a bug."

1546175037
daurnimator
hrm..... for my case I don't know what I want then.....

1546175095
knebulae
daurnimator: then I'll have to ask the $25k question.  What do you want / what are you trying to do?

1546175121
daurnimator
knebulae:

1546175161
daurnimator
i.e. translate

1546175410
knebulae
daurnimator: daurnimator: can I please see an example of this macro's usage: VALGRIND_DO_CLIENT_REQUEST_EXPR

1546175448
daurnimator
knebulae:

1546175617
knebulae
daurnimator: it looks like valgrind has made this pretty straightforward.  It just needs a function pointer set.  All this macro is doing is marshalling the arguments from C to asm.  Zig should be able to do the same easily.

1546175660
knebulae
+ inserting the "magic" to signal valgrind (__SPECIAL_INSTRUCTION_PREAMBLE).

1546175920
knebulae
daurnimator: unfortunately, the two sections of documentation I need to help right now, Assembly & Atomics, are stubs :/

1546175939
daurnimator
knebulae: yep. I've been trying to figure it out from error messages and the standard library

1546175945
daurnimator
I think I have it now

1546175978
knebulae
daurnimator: nice

1546176677
daurnimator
:( getting error: couldn't allocate output register for constraint 'd'

1546177286
knebulae
daurimator: llvm is notorious for being fickle with inline asm, especially compared to gcc.  For some reason it doesn't want / cannot allocate EDX to be read as an 8-bit value.  There are other ways to accomplish this read that may compile; see:

1546177343
knebulae
daurimator: see the paragraph prior to the link too.

1546178324
daurnimator
knebulae: ah thankyou

1546178334
daurnimator
looks like llvm doesn't know the shorthand 'd'

1546178464
daurnimator
knebulae: this works :)

1546178471
knebulae
daurnimator: it should.  the x86 section mentions registers a, b, c, d as registers that may be 8/16/32/64-bit, but read as an 8-bit integer.  That's why, if you're in 64-bit code, I thought using a different access method might work (i.e. explicitly rdx).

1546178523
knebulae
daurnimator: nice job!

1546179543
daurnimator
Any info around on varargs and interop with va_start/va_end?

1546180222
knebulae
daurnimator: lol. that's what I've been asking for a bit.

1546180242
knebulae
daurnimator: it appears to work for non-string-like arguments.

1546180294
knebulae
daurnimator: here's an example:

1546180351
knebulae
daurnimator: that's not to say you can't take it one step back and use va_start and va_end macros yourself.

1546180401
daurnimator
knebulae: if I have a function in zig declared as: fn printfwrapper(format: [*]u8, args: ...) usize { .... }

1546180425
daurnimator
then how do I pass `args` through to the underlying function that expects a va_start-like pointer

1546180454
knebulae
daurnimator: declare it in C

1546180480
daurnimator
huh? how do I implement it then?

1546180490
knebulae
daurnimator: extern

1546180496
daurnimator
wut

1546180523
knebulae
daurnimator: well, if you can't get the function signature you'd like

1546180580
knebulae
daurnimator: sorry, I'm not being clear.  Doing too much at once.  You can pass args as a raw pointer.

1546180614
daurnimator
`@ptrToInt(&args)` gives me attempt to get pointer to size 0 object

1546180715
knebulae
try an opaque type?

1546180731
daurnimator
on what?

1546180744
knebulae
daurnimator: args

1546180758
daurnimator
what do you mean "try an opaque type" then

1546180774
knebulae
daurnimator: when I said declare it in C, I have been unable to figure out varargs yet in zig, so I defined my varargs function in C.

1546180786
knebulae
Then pass raw pointers to C-friendly structs.

1546180811
knebulae


1546180828
daurnimator
From my previous experience, varargs in zig were pretty simple: you just declare a function as taking `someargname: ...` as the last argument

1546180834
daurnimator
and then you can use `someargname` like a slice/array

1546180844
daurnimator
but now I need to interop with C

1546180946
daurnimator
or actually, I need to interact with system vararg ABI. not even C exactly...

1546180947
knebulae
daurnimator: I see the issue.  This is actually a problem in C as well (just google wrapping printf).

1546180971
knebulae
daurnimator: the answer is to use the va_start and va_end macros yourself.

1546180980
daurnimator
knebulae: how?

1546180989
daurnimator
knebulae: I'm writing pure zig here. no C compilation step

1546181068
knebulae
daurnimator: I'm afraid you will probably need access to the platform's underlying va_start and va_end macros.  Otherwise, you will need to duplicate the functionality of those macros in pure zig code.

1546181137
knebulae
daurnimator: I think this page will explain it nicely (hopefully):

1546181197
daurnimator
knebulae: I think va_start is usually a compiler intrinsic rather than a macro you can implement.

1546181285
knebulae
daurnimator: you are correct.  I'm old. :/

1546181310
knebulae
daurnimator: now get off my lawn!

1546181604
daurnimator
knebulae: it's my lawn >.<

1546181618
knebulae
lol

1546188555
Zaab1t
no do-while loop in zig?

1546188753
Zaab1t
I wrote my first Zig program

1546188817
Zaab1t
Its a translation of a small c program

1546188832
Zaab1t
I would love some feedback

1546188898
Zaab1t
Everything that could be cleaner, better written, uses wrong type, is stupid, doesnt follow style - be harsh on me :D

1546188904
Zaab1t


1546188955
Zaab1t
the while loops and bounds checking especially feels a bit awkward to me

1546190275
daurnimator
Zaab1t: use the continuation clause of while

1546190292
daurnimator
Zaab1t: while (i < 10) : (i += 1) {}

1546190332
daurnimator
Zaab1t: import std once, and then grab the things from it

1546191066
andrewrk
daurnimator, ooh exciting pull request

1546191250
daurnimator
andrewrk: I'm not quite sure how to best fit it into our default allocators

1546191279
daurnimator
andrewrk: it seems like it only supports two levels of pooling; whereas zig will let developers nest as many pools as they want...

1546191326
andrewrk
daurnimator, I'm considering that it might make sense to add valgrind-awareness to the language

1546191344
andrewrk
specifically, when you assign undefined to something, zig would do the valgrind annotation

1546191361
daurnimator
makes sense.

1546191371
andrewrk
this would solve the problem for all memory allocators, because of this:

1546191424
daurnimator
ooooo. I'll fix my PR to move things to there...

1546191494
daurnimator
any reason Allocator.free doesn't call Allocator.destroy?

1546192495
daurnimator
andrewrk: re pushed.... I understand what you mean about proper integration into the language though

1546192514
andrewrk
that would allow this to work at comptime as well

1546192539
andrewrk
I'll take a look though, thanks for this patch

1546192565
andrewrk
even if we end up going the language integration route, it looks like you've distilled the API from the .h file into simple to understand inline assembly

1546192582
andrewrk
which is in and of itself significantly helpful

1546192594
daurnimator
andrewrk: yeah, the first commit is manually converting the .h with inline assembly to zig for i386 and x64

1546192615
daurnimator
only for base, memcheck and callgrind. helgrind I've never used before and looks like lots of work.

1546192630
daurnimator
(well not lots of work, but half an hour or concentration)

1546192745
andrewrk
btw daurnimator, I'm up to 148 of 518 behavior tests passing in the copy elision branch

1546192758
daurnimator
that.... is not the high score I hoped for :P

1546192766
andrewrk
it's not a linear curve though

1546192778
andrewrk
it was 0 for 2.5 months

1546192864
daurnimator
andrewrk: have you heard the saying "the first 80% is done, only the second 80% to go" before?

1546192888
daurnimator
andrewrk: which I guess is me saying: it's probably an S curve.

1546193037
andrewrk
that's true. making progress on the test suite is good for my motivation though

1546193041
andrewrk
those 2.5 months were pretty brutal

1546193414
Zaab1t
just got an idea for how Zig could do classic for loops

1546193425
Zaab1t
if we want to keep for loops as for eachs

1546193439
andrewrk
Zaab1t, is it:  `var i: usize = 0; while (i < 10) : (i += 1) {}` ?

1546193465
Zaab1t
andrewrk: no isnt that already possible?

1546193469
andrewrk
yes

1546193477
andrewrk
forgive me, what is your idea?

1546193480
Zaab1t
well I have a worse idea!

1546193488
Zaab1t
while (var i: usize = 0) : (i < 10) : (i += 1) {}

1546193503
Zaab1t
(make while a disguised for loop)

1546193505
andrewrk
you want the variable declaration as part of the syntax of the while loop

1546193554
andrewrk
this accomplishes either:  one less level of indenting when using while loops, or eliminating the index variable from scope after the while loop is done

1546193593
andrewrk
both nice things, but a high cost of increased language complexity

1546193624
andrewrk
also I can't help but think that such a solution might be better if it worked for any variable

1546193646
andrewrk
I'd consider syntax to end variable scope without using indentation before I'd consider this while loop change

1546193682
Zaab1t
andrewrk: what have you considered for counting from x to y?

1546193707
andrewrk
var i = x; while (i < y) : (i += 1) {}

1546193826
andrewrk
rust lets you end a variable scope by declaring over it

1546194017
Zaab1t
`[x..y]` could be a slice of ℕ :p

1546194159
andrewrk
I want to have an open mind about this, but I really have a hard time understanding why this feature is so commonly desired

1546194169
andrewrk
I think people want their code to look elegant

1546194192
andrewrk
and zig's philosophy is: give up. you can't have that. but you can get the semantics correct, and you can do it in a maintainable, understandable way.

1546196610
Zaab1t
andrewrk: keep the open mind. I'm not saying what the better choice is. I'm not even thinking about fighting the case for my suggestions.

1546196658
andrewrk
Zaab1t, I will :) I know it's really important

1546196707
Zaab1t
You analysis is the same as mine; people want to write elegant code. Here's something to consider, but it's a bit hard to communicate over irc

1546196730
Zaab1t
because it may not be a very logical argument, its more about feelings

1546196837
Zaab1t
It's fun to write elegant code, so if Zig's philosophy is /give up/, then it may hurt Zig in the long run if it turns out that zig code isn't fun to write

1546196944
andrewrk
to be honest, fun is not one of zig's driving forces. zig will happily trade in fun for less bugs or more maintainable code

1546199947
oats
fwiw, I'm having plenty of fun

1546199963
oats
howdy everyone, hope you're having a pleasant sunday

1546199981
oats
how can I notate a function pointer type in zig?

1546200024
andrewrk
oats, it looks the same as a function definition, except with no body, and the parameter names are optional

1546200035
andrewrk
example: fn()void

1546200101
oats
so that's the equivalent of a pointer to a void -> void function in C

1546200126
andrewrk
yes

1546200130
oats
awesome, thanks

1546200162
andrewrk
and they work with pointer casting builtins. for example @intToPtr(fn()void, 0x1234) or @ptrCast

1546203367
andrewrk
daurnimator, 278 / 518

1546204040
Zaab1t
hi again, why is the return type of main !void or void and not u8?

1546204158
andrewrk
Zaab1t, u8 is a valid return type of main

1546204179
andrewrk
here's the code that calls main:

1546204194
Zaab1t
ah my assumption was just from the documentation snippets

1546204250
Zaab1t
wow surprisingly easy to read

1546204349
andrewrk
:)

1546205623
Zaab1t
andrewrk: im trying to read the contents of file. Is it correct that no documentation on this exists? currently trying to do it by reading

1546205866
andrewrk
Zaab1t, correct, you will have to look at examples and browse the standard library

1546205877
andrewrk
you may be interested in std.io.readFileAlloc

1546205904
andrewrk
or consider an approach that does not load it into memory all at once

1546205997
Zaab1t
andrewrk: I'm thinking a buffer and then a while loop that goes on until EOF, but it puzzles me a bit that there are no examples in file.zig

1546206005
Zaab1t
what examples are you referring to?

1546206622
andrewrk
examples in people's open source zig code, or examples in the standard library

