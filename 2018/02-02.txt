1517530335
benzrf
andrewrk: wtf is the "var" type

1517530927
zesterer
Why does Zig not accept tabs?

1517530981
benzrf
zesterer: tabs are evil

1517531014
zesterer
They're not. They're used in cases where whitespace alignment isn't required to be a specific width.

1517531055
benzrf
well, i'm not andrewrk, so ignore me :)

1517531065
zesterer
To enforce that at a compiler level is pretty damn obnoxious. Just saying.

1517531091
benzrf
i feel like ive heard of something else that rejects tabs

1517531094
benzrf
maybe it was Go or Rust?

1517531117
benzrf
(not saying this as justification, just seeing if anybody else remembers what that wouldve been)

1517531174
zesterer
Go and Rust both accept tabs.

1517531305
benzrf
hmm

1517531322
benzrf
maybe i was just thinking of giving warnings on tabs? shrug

1517531555
andrewrk
zesterer, see

1517531629
zesterer
I'm sorry, but there are many good reasons for using tabs in source code. It's not just a point of style.

1517531643
andrewrk
I'm not interested in debating

1517531658
andrewrk
there's 2 choices, we only want there to be 1 choice, so we made there only be 1 choice

1517531664
benzrf
i didn't expect this to work but i'm still disappointed

1517531676
zesterer
You're not interested in even making it produce a warning rather than an error that literally halts compilation?

1517531751
benzrf
ngl this seems a bit hardheaded

1517531773
andrewrk
feel free to continue the discussion on #544

1517531784
andrewrk
people in this channel can read #544 if they want to see a discussion about tabs vs spaces

1517531820
benzrf
i don't think it's really about tabs vs spaces

1517531857
benzrf
i'm all for thumbing my nose at windows users, but i feel like if you're gonna do that you should come out and say that's what you're doing

1517531863
benzrf
er, re: line endings

1517532632
zesterer
andrewrk: I have provided my arguments on the issue. I have also forked Zig and added a patch, should you wish to accept it.

1517532695
andrewrk
thank you zesterer

1517532922
benzrf
andrewrk: out of curiosity, what are the future plans for providing a proper spec for zig

1517532943
andrewrk
to do it

1517532946
benzrf
heh

1517532961
benzrf
man, does llvm ir even have a proper spec....

1517532982
andrewrk


1517533011
benzrf
obviously you should properly write a formal spec in coq ;)

1517533227
zesterer
As an additional point, I have a developer friend that is partially sighted. He has to use very large font sizes when working, and it infuriates him no end when developers use soft-tabs, since it means he ends up scrolling code a lot since he can't tell his editor to display tabs as a single character's width.

1517533282
andrewrk
zesterer, I don't want that point to get lost, can you add it to your case on the issue?

1517533289
zesterer
andrewrk: Sure

1517533412
zesterer
[Not talking to anybody in particular] Apart from anything else, spaces are not indentation. They're padding. The two are totally distinct, and spaces were never intended to act as identation. If you're using them as such, you're such them incorrectly.

1517533485
andrewrk
this is a discussion that has the potential to get repeated many times; I request that we can have it on the issue so that, however it gets resolved, people questioning the decision can read the full discussion

1517533730
benzrf
man

1517533743
benzrf
the compile time stuff seems like it'd be really hard to properly spec

1517533792
benzrf
just implement a true type system...... you know you want to ;)

1517533807
benzrf
well, that would also be very hard to spec, i guess

1517535142
MajorLag_
the more I play with comptime the more difficult I find it to reason about. that might change over time.

1517535436
hopppetosse
andrewrk: have you managed to get your tetris example building on windows? I'm also using libpng in tick, and build fails with

1517535476
andrewrk
hopppetosse, no, I had different problems with libpng

1517535487
andrewrk
that's interesting though, looks like a bug I haven't seen yet

1517536179
hopppetosse
I've only got release versions of llvm and zig on my windows machine, so I haven't yet tried to figure out what's going on

1517536231
hopppetosse
I'mnot even sure if the error is resolved in linux

1517536269
andrewrk
let me check

1517536587
andrewrk
hopppetosse, after the latest commit to tetris it works on linux

1517536602
andrewrk
libpng is kind of hostile to windows, I realized

1517536630
hopppetosse
I'm gonna try port

1517536638
andrewrk
cool

1517536659
andrewrk
does it depend on zlib?

1517536686
hopppetosse
no dependencies I think

1517536699
hopppetosse
all it does is decode the png

1517536715
andrewrk
this would be a good case for translace-c if it were a little further along

1517536739
hopppetosse


1517536750
hopppetosse
turns out the full pkg does encoding too

1517536761
hopppetosse
still no deps =)

1517536891
andrewrk
hopppetosse, it would be a roundabout way to do it, but you could try improving translate-c enough to do this port automatically

1517537062
hopppetosse
That would actually be pretty sweet

1517537079
hopppetosse
I haven't looked at the translate-c code yet

1517537716
MajorLag_
I found translate-c really helpful in getting an SDL2 binding going. Only had to correct a few things (like SDL_RWclose)

1517537720
MajorLag_
But I imagine macro-heavy code would cause more issues

1517537802
MajorLag_
andrewrk, do you know if Zig can even link properly with Mingw libs? Last time I tried it ended badly.

1517537956
andrewrk
I think it used to, but then I neglected that code for the msvc linking code

1517537986
zesterer_
Out of interest, what's the thinking behind disallowing passing structs / enums / unions by value? I can understand it makes the compiler internals a little simpler, but does it have value?

1517538006
zesterer_
To stop implicit copying?

1517538101
andrewrk
zesterer_,

1517538122
andrewrk
but yes, to avoid implicit copying, and to have there be one canonical way to do things

1517538157
andrewrk
I don't think it actually makes compiler internals less complicated

1517538179
andrewrk
I'll file the issue

1517538213
zesterer_
andrewrk: Okay. A pattern I very often use is to have a function that constructs a type and returns it. Something like create_x_from_y(y). I'd assume this would break any such syntax?

1517538284
andrewrk
return type as a struct is idiomatic. see also

1517538311
hopppetosse
I had issues building generic containers because of this - I had have to use &const T instead of T for the same code to work on user defined structs and primitive types

1517538381
zesterer_
andrewrk: Cheers for answering that

1517538413
zesterer_
andrewrk: I actually mapped out a plan for a language I was going to write a few months ago, and it looks surprisingly similar to Zig.

1517538433
andrewrk
I hope I can fulfill your use case

1517538555
zesterer_
andrewrk: If you're interested, here are a few example programs I drew up. I think the only major difference is that my language would have had support for anonymous structs.

1517538581
hopppetosse
zesterer: all structs in zig are anonymous =9

1517538642
zesterer_
hopppetosse: By that, I mean that they can be generated inline. One could do: function(<a, b>, c)

1517538673
andrewrk
what does that do?

1517538714
andrewrk
{0} and {1} in fmt specifiers is a good idea

1517538755
andrewrk
a, b = b, a;  how do you make this work?

1517538788
andrewrk
implicit heap allocation is a major departure from zig

1517538803
zesterer_
As I say, this wasn't a plan: there are some elements of the syntax that are contradictory or ambiguous. I was just brainstorming.

1517538828
andrewrk
ah

1517538961
hopppetosse
"{0} and {1} in fmt specifiers is a good idea" -> Agreed

1517539046
zesterer_
So much so that I implemented that syntax in C++ in a previous kernel's utility code using variadic templates. It was typesafe, but had a tendency to produce way too much code and had some runtime overhead if aggressive optimisations weren't enabled

1517539150
zesterer_
I like how methods in Zig as little more than namespaced functions. Makes a lot more sense to me than implicitly declaring an identifier like "this" to deal with self-referencing.

1517539182
andrewrk
in zig you can likely copy-paste a block of code from one place to another and have it work verbatim

1517539194
andrewrk
that's one reason for that

1517539214
zesterer_
Sensible decision

1517539352
zesterer_
I also like how you've included a bunch of built-in utility functions for querying types at compile-time. It struck me as madness at how C++ relied on the <type_traits> header to provide features like that, yet wasn't properly available in a freestanding environment.

1517539395
MajorLag_
andrewrk, is there reasoning behind the inconsistent capitalization of builtin functions or was it just an oversight? @TagType/@tagName.

1517539449
andrewrk
I'm not 100% happy with how that turned out, but it's following the style guide

1517539459
andrewrk
which says that functions are capitalized if they return a type

1517539530
andrewrk


1517539530
MajorLag_
so @typeOf should be too then?

1517539553
andrewrk
yes

1517539575
andrewrk
kind of annoying to have @sizeOf and @TypeOf

1517539585
andrewrk
but to be consistent it should be @TypeOf

1517539597
andrewrk
I'm open to style guide modification proposals

1517539660
andrewrk
(I believe @typeOf existed before the style guide and I haven't updated it yet)

1517539661
MajorLag_
I'm trying to avoid bikeshedding the hell out of all these proposals

1517539777
MajorLag_
is there a way to get the active field (value of the active field ideally) of a union?

1517539819
zesterer_
andrewrk: If you're going to enforce anything, you should be enforcing camelCase and TitleCase on public functions and structs, not preventing people using tabs in their code. At least then you're making sure that the interface between libraries is consistent.

1517539911
MajorLag_
On the one hand, I kinda agree. Whitespace should either be significant or not. On the other hand, it's hard to think of something that matters less.

1517540002
andrewrk
MajorLag_, if it's a union with a provided (or auto) enum tag, then yes

1517540009
zesterer_
Whitespace is purely cosmetic. It doesn't alter the interface between bits of code (like identifier case does), it doesn't lead to spaghetti code, it can be automatically corrected by any half-decent editor. If there's anything that should be permissible, it's whitespace styles.

1517540086
zesterer_
andrewrk: So does "defer" work even on early function returns? If so, that's a bloody neat feature.

1517540092
andrewrk
one thing that's planned is passing --fmt, which would apply zig fmt to the files during the compilation (and overwrite the file contents with the reformatted code). this would allow tabs (and convert them to spaces)

1517540152
andrewrk
zesterer_, yes, defer runs on scope exit. note that this is different than in go, where it runs at the end of the current function, which requires a heap allocation per defer

1517540165
andrewrk
sorry not per defer, but in general, requires hidden heap allocation

1517540183
MajorLag_
Go does a lot of that

1517540196
zesterer_
It's one of the things that really put me off Go

1517540244
zesterer_
I'm definitely warming to Zig far more than I am most languages, so congrats on building something so decent

1517540256
andrewrk
errdefer runs at scope exit if and only if you returned from the function with an error from inside the scope

1517540263
MajorLag_
The GC, the ASI, the lack of a union type... overall, I didn't hate Go, but it has some things I'd rather not deal with.

1517540266
andrewrk
thanks zesterer_

1517540311
MajorLag_
Yeah, after I got to using Zig I'm finding I really like it for the most part. And the parts I don't may just be because they feel a little too different from C.

1517540316
andrewrk
and we have a keyword for this

1517540339
zesterer_
andrewrk: Side note: I see that Zig has a neat monadic error syntax. Are there plans to extend that to all types in a similar manner to Rust's type-safe payload enums? Or is that not within the scope of the language?

1517540343
andrewrk
which parts are those MajorLag_

1517540344
andrewrk
comptime?

1517540378
andrewrk
zesterer_, can you elaborate? extend what exactly to all types?

1517540438
zesterer_
andrewrk: enum MyEnum { Foo { foo: u32 }, Bar { bar: f32 } }

1517540453
zesterer_
Tagged unions that don't break the type system, like in Rust

1517540462
andrewrk
ah, that's here:

1517540482
MajorLag_
The things I bring up. They're mostly little things and generally I've found your reasoning to be pretty solid, or that part of the language is still in flux.

1517540511
andrewrk
summary: union {  }  is a C-like union, but it has runtime safety via a secret field (which you do not have access to)

1517540533
zesterer_
andrewrk: As it should be :)

1517540549
andrewrk
union(enum) { }  is a tagged union. in this case the tag type is auto generated, but you can pass an enum type in place of `enum`, and then you can do rust-style semantics on it

1517540579
zesterer_
andrewrk: I assume it's impossible to check a tagged union field without first asserting that the tagged union is of the type you think it is?

1517540612
andrewrk
it doesn't block you from doing that. but you are encouraged to switch on the value (equivalent of rust's match) to destructure it

1517540645
zesterer_
Would be nice if it gave something like the internal type or an error

1517540681
zesterer_
i.e: "my_tagged_union.my_member" yields "%MyMemberType"

1517540720
andrewrk
here's code that does that:  switch (value) {Enum.Item => |x| x, else => error.WrongField}

1517540814
zesterer_
Okay. So not forcing type system honesty at a language level like Rust does then. That's fine too

1517540851
andrewrk
right. In the same way that you should avoid @ptrCast if you can, you should avoid accessing a union(enum) via a field directly if you can

1517541009
zesterer_
Okay. Not sure how I feel about that. ptrCast() is different in that it's not the sort of thing that you use as a shortcut. But if you're prototyping code, it's quite possible you decide to skip the union(enum) check because you're

1517541050
andrewrk
one note is that if that production code is running in ReleaseSafe mode, it would at least crash if the wrong field was ever accessed

1517541095
zesterer_
Reasonable I guess, but doesn't really fit with the "Compile errors are better than runtime crashes." from the Zen.

1517541158
andrewrk
fair point

1517541173
MajorLag_
On the other hand, it means that if I need speed and don't care so much about safety (probably because I developed in release-safe and have a reasonable assurance that it's ok), I'll appreciate knowing there's no invisible costs.

1517541192
MajorLag_
Oh, nevermind, you were complaining about the crash vs compile error

1517541196
zesterer_
I think it would make a lot of sense to return a %Type. That way, the developer is forced to consider the possibility of problems

1517541200
MajorLag_
which is a legit point

1517541263
zesterer_
Like it doesn't make sense to have a %void returned on something like printing text to the console incase stdout fails, yet no error on something like accessing a union(enum) which is way more likely to go horribly wrong

1517541264
andrewrk
this is similar to the ?? prefix operator on nullables. it asserts that the item is not null, and returns the payload

1517541291
zesterer_
andrewrk: Yes, effectively

1517541491
zesterer_
You could argue that there's the runtime overhead of checking the tag, but that's kind of irrelevant: If they're using a union(enum) and not checking the tag, they shouldn't be using the union(enum) in the first place since they clearly don't care that the union(enum) can take more than one type value. Might as well just use a straight type.

1517541511
MajorLag_
that's fair I think

1517541564
MajorLag_
unless I want it tagged elsewhere, but I have some tight loop that needs to not check them. Seems like kind of an edge case.

1517541616
zesterer_
MajorLag_: In which case, you should probably just take a reference to the union(enum)'s internal value rather than checking the entire enum(value) every time in the loop

1517541643
zesterer_
Or better yet, just unpack the thing. I'm sure the optimiser can get rid of that later anyway.

1517541646
MajorLag_
I'm probably iterating over a large number of unions in this case

1517541674
MajorLag_
though in all honesty I can't think of a reason I'd be doing that and not wanting a tag.

1517541675
zesterer_
MajorLag_: In that case, why are you using a lot of union(enum)s if they're all clearly of the same type?

1517541701
zesterer_
Might as well just use a single tag rather than an identical tag for literally all of the things you're iterating.

1517541721
MajorLag_
first thing that comes to mind: a bunch of different Entity structs that have unions of their subtypes. Of course that's a bad example since I'd want a tag.

1517541786
zesterer_
My point is that the ONLY places you should be using an union(enum) is somewhere where there's genuine runtime ambiguity about the type contained within it. If that's the case, then checking the tag before using it is ALWAYS essential to avoid horrible problems

1517541802
zesterer_
*uncertainty, not ambiguity

1517541829
MajorLag_
and if I knew they were all of the same type (perhaps I pre-sorted them) and really needed to do this, I can abuse @offsetOf and @intToPtr/@ptrToInt

1517541849
zesterer_
MajorLag_: If you really want to, although that's a horrible thing to do :D

1517541876
MajorLag_
Maybe, but I derive particular joy from abusing @intToPtr/@ptrToInt.

1517541903
andrewrk
MajorLag_, did you also find @fieldParentPtr ?

1517541914
MajorLag_
I know of it, I haven't had to use it yet.

1517541940
zesterer_
Hearing about the oddities that old CPU architectures have with address / integer incompatibility make me deeply fear code like that

1517541967
zesterer_
andrewrk: I saw that. Not 100% sure that purpose it would have though?

1517541978
andrewrk
look for its use in the standard library

1517541989
zesterer_
andrewrk: The same could be achieved with just a simple subtraction? Or is it just syntax sugar?

1517542005
andrewrk
it's slightly safer than @ptrCast + @offsetOf

1517542017
andrewrk
useful for OOP-like things

1517542042
zesterer_
Fair enough

1517542047
hopppetosse
@fieldParentPtr is very similar to the container_of macro in linux

1517542057
andrewrk
yeah I was thinking of renaming it to @containerOf

1517542102
zesterer_
Or just parentOf()?

1517542128
hopppetosse
built-in functions should keep the @

1517542150
zesterer_
Although tbh "parent" doesn't make so much sense since it's usually used in terms of data reference relationships so I see your point

1517542171
zesterer_
hopppetosse: '@' was intended to be implicit ;)

1517542229
hopppetosse
someone suggested removing the @'s from built in funcs recently, and I think I got overly sensitive =P

1517542278
hopppetosse
they already got rid of my sweet sweet sigils and '->' in the name of 'readability'... please, no more!

1517542294
hopppetosse
On a more serious note, I'm quite liking the new sigil-less error handling, so thanks =)

1517542301
andrewrk
:)

1517542312
hopppetosse
Not sure how I feel about the -> removal

1517542313
andrewrk
hopppetosse, have you experienced error return traces yet?

1517542323
andrewrk
there's a syntax problem with return types

1517542332
hopppetosse
yeah, I saw the discussion

1517542350
andrewrk
we can potentially add back in -> if everybody loves it

1517542354
hopppetosse
it does make the code look cleaner though, I just thought that -> was a good visual anchor

1517542378
andrewrk
but I want to solve the syntax issue at the same time, so that this can be the last breaking change to return types

1517542423
hopppetosse
I'm not sure what you mean by error return traces

1517542431
andrewrk
I need to make a blog post about these

1517542433
zesterer_
andrewrk: What's "->"?

1517542434
andrewrk
it's something I invented

1517542445
MajorLag_
I'm ok either way, but -> seems redundant.

1517542455
andrewrk
zesterer_, function prototypes used to look like your language with ->, until last weekx

1517542475
zesterer_
I'm on team "->".

1517542482
andrewrk
noted

1517542489
hopppetosse
yeah, it's redundant, but visually useful

1517542502
hopppetosse
just like the enforced indentation and curly braces

1517542514
hopppetosse
one makes it good for machines, the other for humans

1517542514
zesterer_
Minimalism at the cost of clarity if not a good idea

1517542541
zesterer_
Even the UNIX philosophy has its limits

1517542546
MajorLag_
As long as you don't go to the length of enforcing style I'll be ok.

1517542570
andrewrk
style won't be enforced, but we will provide `zig fmt` if one wants to opt-in to the canonical style

1517542571
hopppetosse
I'm pretty sure I'm on team -> but please not any time soon.... I just spent far too much time removing ->'s from tick

1517542585
hopppetosse
though the annoying thing was putting in the explicit void return type

1517542589
andrewrk
sorry  hopppetosse

1517542600
andrewrk
I know that was annoying, I did it for the zig std lib

1517542614
hopppetosse
it was kinda my fault, I assumed my regex-fu was sufficient to get it done automatically

1517542631
zesterer_
Does Zig have anything akin to rustfmt? It would be trivial to write a script that goes around adding "->" back into everything

1517542651
hopppetosse
zigfmt would be great

1517542665
andrewrk
here's what zig fmt supports so far:

1517542670
andrewrk
PRs welcome...

1517542685
zesterer_
Really tempted to create zigfmt now

1517542697
hopppetosse
I've just finished my uni semester, I should have more free time over the next month

1517542821
hopppetosse
I was actually going through the self-hosted code the other day

1517542828
hopppetosse
that's a nice looking parser

1517542837
andrewrk
non-recursive too!

1517542847
zesterer_
Is Zig's syntax deterministic? Can it be read by a recursive decent parser without ambiguity?

1517542892
andrewrk
yes. the c++ parser is recursive descent. the self hosted parser is equivalent to recursive descent, but uses an explicit stack instead of recursion

1517542930
zesterer_
Nice. Apologies if I'm not using the right terms. When it comes to compiler design, I'm largely self-taught.

1517542985
zesterer_
If I get a spare day or two, I'll give building a parser a go. That way, we can easily build up a syntax tree to spit out some nice formatted Zig for any revision of Zig

1517543027
andrewrk
zesterer_, a new parser?

1517543037
andrewrk
why not contribute to the official hosted parser?

1517543044
andrewrk
*official self hosted parser

1517543061
zesterer_
andrewrk: Perhaps a forking of the original into a separate repository is more suitable? That way it can be reused by community tools pretty easily

1517543074
zesterer_
andrewrk: We can have nice IDE tools

1517543083
andrewrk
I mean, we could just make the official parser part of the standard library

1517543086
andrewrk
there's no reason not to

1517543092
zesterer_
That makes a lot of sense

1517543131
zesterer_
You'll have to excuse me with all these questions.

1517543146
zesterer_
Is there documentation for the contents of the standard library? I couldn't seem to find any.

1517543176
andrewrk
no. I'm banking on the automatic doc gen for that (inspired by rust doc)

1517543184
andrewrk
and that's only going to be implemented in the self hosted compiler

1517543219
andrewrk
here's the self hosting strategy btw:

1517543227
zesterer_
Okay. I'll just look through the source and take educated guesses. I assume there are distinct freestanding and hosted components of it?

1517543270
andrewrk
zesterer_, it relies on lazy top level declaration analysis. so the line between freestanding and os-dependent is blurry

1517543279
andrewrk
any function which does not depend on OS specific code works

1517543291
andrewrk
and if you accidentally depend on an OS in freestanding mode, you'll get a compile error

1517543344
zesterer_
Right. Maybe in future separating freestanding into something similar to Rust's core module is a good idea?

1517543353
andrewrk
to what end?

1517543363
andrewrk
I mean, what for?

1517543372
MajorLag_
this comptime struct reflection is starting to look pretty decent. I can definitely make use of this for debugging.

1517543438
zesterer_
andrewrk: The more the standard library grows, the more dependent on hosted stuff any freestanding implementation becomes. The compiler still has to parse available functions to determine whether we're allowed to use them presumably?

1517543452
andrewrk
nope

1517543465
andrewrk
it's fully lazy. if you have a compile error in a function you never call, you don't see the compile error

1517543477
andrewrk
if you don't use a function from foo.zig, foo.zig is not even loaded from disk

1517543500
andrewrk
in other words, what you already have to do for generics, we do for every function

1517543553
zesterer_
ooh you have elfy stuff in the standard library? That's cool. Very cool.

1517543582
andrewrk
zesterer_, try this code:  test "aoeu" { unreachable; }

1517543584
andrewrk
zig test test.zig

1517543588
MajorLag_
I can attest to not seeing errors in unused code

1517543590
andrewrk
you can see the elf/dwarf code in action

1517543609
andrewrk
MajorLag_, this has a downside too, I acknowledge. I have plans to make this better

1517543617
zesterer_
andrewrk: I can guess at what that does. Unless it's something weird and unexpected?

1517543625
andrewrk
just prints a stack trace

1517543670
hopppetosse
speaking of the unused code thing, how would you feel about including a compile flag to enable unused functions checks?

1517543691
andrewrk
hopppetosse, I need to make an issue for this too. I'm still writing up the other one

1517543711
zesterer_
Also... I invented an allocator for my kernel that's pretty fast and incredibly simple to implement and has support for free() too. I've not seen the design used anywhere else, which I thought a little weird. Fancy me writing it up for Zig's standard library some time?

1517543737
andrewrk
zesterer_, definitely. there's std.heap which will end up having a variety of allocators to choose from

1517543740
MajorLag_
I could use some more function reflect, so I can print out the while function signature, and preferably it's name or something. Very much on the "it'd be nice to have" list though.

1517543753
MajorLag_
s/while/whole/g

1517543785
andrewrk
MajorLag_, it's definitely planned. feel free to make an issue, maybe I'll have some inspiration on the airplane tomorrow :)

1517543811
MajorLag_
and access to the hidden union tag would let me print the value of those too. right now I just print the union and it's member types.

1517543852
zesterer_
MajorLag_: Can you not just print @TagType(my_union)?

1517543872
MajorLag_
if the union isn't tagged?

1517543879
MajorLag_
I mean, enum tagged.

1517543894
andrewrk
writeup for the parameter passing issue:

1517543905
andrewrk
I think I figured out how we can have runtime noalias safety

1517543921
andrewrk
which makes me want to turn noalias on by default for all pointer parameters (you'd be able to disable it per function)

1517543944
MajorLag_
generally speaking I'm all for safety as long as I can disable it.

1517543949
andrewrk
that would destroy the only thing rust has going for it in terms of performance vs zig

1517544022
andrewrk
MajorLag_, ahhh I see why you wanted access to the secret field

1517544025
MajorLag_
Except for unions, I can basically print out an entire struct as it would appear in source, plus the values of each field. Which is great.

1517544038
andrewrk
would you expect the printing code to work in --release-fast mode?

1517544057
MajorLag_
Yeah, I can see how that'd be an issue for secret field

1517544084
MajorLag_
It could be special cased to say "sorry bro, we're in release mode" and fall back to what it does now.

1517544185
andrewrk
MajorLag_, in gdb if you print a union, it prints every possible value

1517544196
andrewrk
e.g. here's what it would look like if it were A, here's what it would look like if it were B

1517544197
MajorLag_
I feel like I may go down the rabbit hole of adding netcode to this toy raycaster just to experiment with comptime encoder/decoder generation.

1517544225
andrewrk
if you do I'll try to fix the comptime bugs we found

1517544237
MajorLag_
andrewrk, won't that get dangerous if any of them are pointers? I suppose I don't have to try and follow pointers that are in a union though.

1517544238
andrewrk
I mean try to fix them in time for you to do your thing

1517544270
andrewrk
yeah, gdb doesn't follow pointers

1517544320
MajorLag_
Currently I do follow pointers. I like that I have so much information I can tag my outputs with ? or & or even ?&&&&&[]u8 or whatever if that's how it's accessed.

1517544405
MajorLag_
I think before I do any netcode though I should see about adding some version of this to fmt. fmt is a little limited right now.

1517545022
tjpalmer
I didn't follow why pointer sigil needs to change, but is * also off the books? Using * like C might have its downsides, but it's familiar to people. And you also show using * to capture pointers, like |*whatever| {...}, in the docs, though I haven't tried that use case yet.

1517545064
tjpalmer
I wasn't sure why it was * there and & elsewhere.

1517545244
GitHub14
[zig] zesterer opened pull request #734: Made Zig support tabs (master...master)

1517545363
zesterer_
tjpalmer: Personally, I think '@' after the expression should be used for dereferencing. It gets rid of what I all "chain ambiguities" in C.

1517545430
zesterer_
For example, the expression "*a.b.c" leaves it ambiguous as to which result the dereference applies to. We know it applies to the last one, but then that leaves ugly syntax like this: "(*a.b).c"

1517545472
zesterer_
A better alternative is this to place the reference after the pointer, leading to nice syntax like this: "a.b.c@" or "a.b@.c"

1517545478
zesterer_
*dereference

1517545519
zesterer_
andrewrk: Thoughts about the above? ^

1517545530
benzrf
lol @ "*dereference"

1517545569
zesterer_
benzrf: Oh God I didn't notice that :D

1517545575
benzrf
i thought the issue was just with the take-a-reference operator

1517545581
benzrf
since it overlaps with the reference-type operator

1517545598
zesterer_
Oh? I admit, I didn't read the whole conversation

1517545621
MajorLag_
andrewrk: so @offsetOf doesn't work for unions, which makes sense, except that unions have that secret field (and probably do some alignment stuff), so I can't just ptrCast to get at the values.

1517545625
benzrf
if i write "&foo" there's an ambiguity of whether i mean the type of pointers to the type foo, or whether i mean a pointer to the variable foo

1517545633
benzrf
strictly speaking

1517545639
benzrf
im not sure it's actually that much of a problem

1517545649
benzrf
er, i /assume/ this is what the issue is about anyway >.>

1517545691
zesterer_
benzrf: Urgh yeah, that's not nice.

1517545700
benzrf
the issue arises since type expressions are value expressions

1517545702
zesterer_
'~' is way better for that

1517545708
benzrf
is that a c++ ism

1517545753
benzrf
22:00 <zesterer_> Tagged unions that don't break the type system, like in Rust

1517545758
benzrf
what do you mean by that :p

1517545760
benzrf
er, :o

1517545813
zesterer_
benzrf: In Rust, it's impossible to circumvent the type system without 'unsafe'. The syntax forces you to consider that a tagged union may not be of the type you think it is.

1517545827
benzrf
wait

1517545838
zesterer_
i.e: The compiler will get upset if your match expression doesn't account for edge cases

1517545840
benzrf
oh, you mean "(tagged unions that don't...), like in rust"

1517545852
benzrf
and not "tagged unions that don't (break, like in rust)"

1517545880
zesterer_
Yes :D

1517545885
benzrf
ah

1517545895
zesterer_
Damn the English language and its syntax ambiguities

1517545940
benzrf
well, i guess the comma technically disambiguates

1517545983
zesterer_
I think there's technically still ambiguity even with the comma :\

1517546017
benzrf
comma associates less tightly than space

1517546138
benzrf
22:58 <andrewrk> which makes me want to turn noalias on by default for all pointer parameters (you'd be able to disable it per function) 22:59 <andrewrk> that would destroy the only thing rust has going for it in terms of performance vs zig

1517546141
benzrf
this is still wrong

1517546155
benzrf
noalias only accounts for stuff that happens within a lexical scope

1517546161
benzrf
rust has

1517546183
benzrf
oh wait actually let me double check what noalias does exactly before doublign down

1517546289
tjpalmer
I was refering to point type sigil because I through andrewrk said he had to change it. While postfix dereference has its virtues, I'm concerned about any churn that's not vital. (I really want to see 1.0, though I have to admit coroutines rock.)

1517546299
tjpalmer
Pointer type, I meant.

1517546380
benzrf
andrewrk: yeah - unless im misunderstanding, doing "*foo = 3; some_func(foo); return *foo" is not safe to turn "return *foo" into "return 3"

1517546401
benzrf
but in rust, global guarantees and distinguishing between mutable and immutable pointer types means you can safely do stuff like that

1517546437
tjpalmer
On breaking change (in std) recommendations, while I've never used a custom allocator in C++, I'm concerned that C++ folks will complain about function-pointer-based allocators, since my understanding is that allocator template parameters in c++ wouldn't need function pointers.

1517546438
MajorLag_
I wonder if the better way to go about it wouldn't be to just add some kind of builtin instead. var foo = @type(i32); var bar = &foo; var baz = @type(&foo); or something like that.

1517546479
benzrf
that doesnt make snse to me MajorLag_

1517546502
benzrf
first: are you proposing a new syntax that goes inside @type?

1517546509
benzrf
distinct from expression syntax  i mean

1517546524
tjpalmer
Maybe standard cost of allocation far outweighs that, but if it came back to bite, it could require std reworking. Again, I've never used custom allocators before, so I have no experience. But I'm off the other conversation topic. Just wanted to get it out there.

1517546538
benzrf
actually hmm i guess that could work

1517546554
benzrf
capture variables in the scope but dont otherwise allow expression syntax?

1517546569
benzrf
although id definitely think itd be a good idea to use a unique construct instead of a pseudo-function-call

1517546577
benzrf
given that it'd be parsed differently

1517546580
zesterer_
tjpalmer: With regards to what you say about "churn": it's better to make changes now while the language has fewer adopters and less dependent code. Make as many breaking changes as possible now such that the resultant language is sensible and stable by the time the user base grows

1517546913
MajorLag_
benzrf, basically the idea is that no matter what happens inside @type(), it will return a type, and anything that happens outside it or it's builtin bretheren (@typeOf, @MemberType, etc) isn't.

1517546966
zesterer_
MajorLag_: That seems like it major breaks the idea of consistent syntax

1517546971
zesterer_
*majorly

1517547006
MajorLag_
maybe, I'm just not wild about a new sigil

1517547049
zesterer_
What else is the sigil used for?

1517547180
MajorLag_
it's the pointer sigil, it's just ambiguous in certain cases if you want a pointer type or a pointer to a variable of type type.

1517547215
benzrf
yeah those cases arent terribly common

1517547261
MajorLag_
well I'll keep thinking. maybe I'll have a better idea.

1517547319
MajorLag_
I'm unclear on this: does type type exist at all in runtime?

1517547365
zesterer_
In my language-that-was-not-to-be, I used prefix '@' for referencing and postfix '@' for dereferencing. AFAIK, there aren't any syntax ambiguities (although I might have missed something)

1517547380
MajorLag_
Odin does that with ^

1517547511
MajorLag_
Ok, so a quick test says no. type type only exists at runtime. Given that, I don't think having to wrap type assignments in @Type is that bad, because they're already special.

1517547922
zesterer_
It seems like a lot of syntactic cruft and breaking of the parser just to avoid using '~'.

1517547967
zesterer_
It means Zig can no longer be parsed by a recursive decent parser, which adds a load of complication to the compiler

1517548147
MajorLag_
s/runtime/comptime/

1517548166
zesterer_
Or rather it can, but you have to make a special case for the @type() function in the parser code rather than later on in compilation

1517548213
zesterer_
Which is weird and annoying and also breaks the intuition humans have for how the language works too

1517548237
MajorLag_
Not being a compiler writer, I'll take your word for it about parsing. It just seems strange to me to have & for normal values and ^ for type values.

1517548342
MajorLag_
Though admittedly, on reflection, it does make sense that "this is a pointer to a thing" and "give me the address of a thing" are separate.

1517548365
zesterer_
Trust me, not having context-free ambiguity is awesome in a language. It means you don't have to make the parser way more complex by keeping track of what identifiers are as you parse (or otherwise bake functions like @type() into the parser itself). That means faster compilation, easier to write formatting and syntax tools, and generally just a lot of extra good stuff

1517548791
MajorLag_
In some other languages that do this sort of thing, type isn't a special type so much as just a const pointer to a struct with information about a type. Which does seem easier to reason about.

1517548847
MajorLag_
but they have different ways of doing generics, so they don't need to do (@typeOf(x))(y) or anything like that.

1517548871
MajorLag_
I guess I'll just see how it shakes out.

1517561865
zesterer_
Does an ordinary type implicitly caste to a tagged union if the tagged union contains that type?

1517561944
zesterer_
i.e: Can I do this? "fn f(val: TaggedTypeContainingI32) void {}    { f(0); }"

1517562072
tiehuis
you need to explicitly specify the tag

1517562128
zesterer_
:-\

1517562195
zesterer_
Ooh, Zig support variadics? Cool.

1517562218
tiehuis
were you expecting something along these lines:

1517562316
zesterer_
tiehuis: I was

1517562335
zesterer_
tiehuis: Although not including it is understandable due to ambiguity between similar variants

1517562373
tiehuis
yeah, it would only really have a use case on specific variants which would be a bit inconsistent

1517562403
tiehuis
plus it also means you don't know what tag is being assigned at the initialization site without referring back to the declaration

1517562411
tiehuis
which is a point against readability/explicitness

1517562481
zesterer_
In that case, I have one more question: is 'var' what I think it is? Does it allow you to infer both the type and the data of a value without having to explicitly pass both to a function?

1517562540
tiehuis
yes, it pretty much allows you to pass anything to a function

1517562571
zesterer_
Perfect

1517562595
tiehuis
it's useful at the moment for duck-typing and getting some pseudo polymorphism i find, and for some simple wrapper functions which may have slightly different actions based on the type

1517562731
zesterer_
Zig doesn't support overloading, does it?

1517562740
tiehuis
no

1517562814
zesterer_
In which case, var becomes useful for that.

1517562823
zesterer_
In some cases

1517562906
tiehuis
yeah, for simple cases where it changes only based on type. the math functions use var extensively for f32 and f64 on the same functions

1517562934
tiehuis
pretty much _Generic in c, but a bit more powerful

1517563021
zesterer_
Actually, full overloading is probably possible with variadics. They'd be evaluated at compile-time after all.

1517563153
tiehuis
yes. small note though, var args at comptime aren't working:

1517563165
tiehuis
eventually

1517563237
zesterer_
Ah. That is a shame.

1517580850
andrewrk
zesterer, I'm also considering removing var args functions and adding tuples

1517580875
zesterer
andrewrk: As in variable-length tuples?

1517580881
andrewrk
yes

1517580906
andrewrk
std.debug.warn("a = {0}, b = {1}", [a, b]);

1517580915
andrewrk
not sure what the tuple syntax would be, but there's one idea

1517581081
andrewrk
a tuple has comptime known length and types, and runtime known values

1517581103
zesterer
I assume it'd be created inline?

1517581124
andrewrk
what do you mean?

1517581195
zesterer
Doesn't matter. I misread something earlier

1517581220
zesterer
Would it support destructuring? Destructuring is cool. Really intuitive syntax sugar.

1517581434
andrewrk
yes

1517581466
andrewrk
var a, const b = [x, y]

1517581483
andrewrk
most useful to initialize multiple variables from a block

1517581495
zesterer
Nice. That sounds like it could create some very pretty, very clean code

1517581526
zesterer
Also (I'm sure you know this already) it would be nice if there was a more idiomatic way to print to stdout than doing "var stdout_file = try io.getStdOut(); var stdout_file_stream = io.FileOutStream.init(&stdout_file); const stdout = &stdout_file_stream.stream; stdout.print("Hello, World!\n");"

1517581538
zesterer
:D

1517581540
andrewrk
are you looking for std.debug.warn?

1517581557
andrewrk
if you are actually trying to print to stdout, don't you care about whether the pipe fails?

1517581612
zesterer
I do, but they should probably be accumulated into a single error that is returned by a std.print() function. Something generic like PipeFailedError.

1517581667
zesterer
In 99% of cases, you don't need to know or care

1517581678
zesterer
For those 1% of cases there is the current syntax

1517582006
andrewrk
getStdOut can fail on windows

1517582161
zesterer
I understand that. All of those errors (errors when getting the stdout file handle, errors when writing to the pipe, etc.) could be combined into a single PipeFailure error which makes syntax simpler.

1517582301
andrewrk
that API is less powerful

1517582321
andrewrk
handling errors is easy, just do it

1517582339
MajorLag_
andrewrk: not sure how I can get the possible values for a union in reflection. @ptrToInt/@intToPtr gives strange results, presumably because of alignment and/or secret field. @offsetOf doesn't work, which I think you'd mentioned.

1517582520
andrewrk
MajorLag_, I'll think about it. I don't have an answer for you right away

1517582611
MajorLag_
No rush.

1517582625
zesterer
andrewrk: Power at every opportunity if often not the best solution to a problem. It seems needlessly unreasonable to require that 4 separate lines of code, none of them particularly short, must be manually called before a program may print to the screen using stdout.

1517582632
zesterer
andrewrk: Example of what I'm proposing:

1517582681
zesterer
Or, even better, have a dedicated error for each kind of failure but still pass it through the one print function

1517582702
andrewrk
on windows that makes an unnecessary syscall for every call to that function

1517582705
zesterer
Make the stdout stream a singleton, of course

1517582722
andrewrk
that's not concurrency-safe

1517582771
andrewrk
hm that last thing, might be ok

1517582792
zesterer
And of course Zig has no global constructors so calling it on program start is impractical (and adds overhead)

1517582899
zesterer
Hmmm. This problem must have an elegant solution.

1517582947
andrewrk
really, 90% of the time people want std.debug.warn

1517582973
andrewrk
and the other 10%, just have the 2 lines, it's not that bad. you're going to set up stdout 1 time over the course of an entire project, and then never touch that code again

1517582986
andrewrk
and then there's no hiding how the underlying OS APIs actually work

1517583044
zesterer
Perhaps you're right. Can "Expose the problem space transparently" become a Zen objective? :D

1517583077
andrewrk
yes

1517583118
andrewrk
I like that a lot actually

1517583261
zesterer
I don't think it's explicitly covered by any of the others

1517583279
zesterer
"Edge cases matter" only partially covers it

1517583356
GitHub89
[zig] corngood opened pull request #738: WIP: make lld include paths private (master...cygwin-fixes)

1517585617
zesterer
andrewrk: How's this for an acceptable alternative? Certainly simplifies the syntax.

1517586668
andrewrk
I don't think that compiles

1517586850
GitHub130
[zig] andrewrk closed pull request #738: WIP: make lld include paths private (master...cygwin-fixes)

1517586852
GitHub69
[zig] andrewrk pushed 2 new commits to master:

1517586852
GitHub69
zig/master 15eb28e Andrew Kelley: Merge pull request #738 from corngood/cygwin-fixes...

1517586852
GitHub69
zig/master 4ec856b David McFarland: make lld include paths private...

1517586969
zesterer
andrewrk: Compiles fine on mine. Only change I've made from the master branch is reenabling tabs as whitespace. Other than that, it's all working Zig.

1517587346
andrewrk
let me look again

1517587383
andrewrk
oh, I see

1517587412
andrewrk
what about the other useful methods of OutStream? what about if you wanted to pass a std.io.File of stdout?

1517587692
zesterer
Then you're stuffed. This is just a helpful wrapper for stdout specifically. Although I'm sure it could be adapted accordingly.

1517589763
MajorLag_
I'm curious what the correct behavior of @offsetOf should be when it is fed a 0 byte field.

1517593276
MajorLag_
My problem with comptime is that it isn't obvious what will run at comptime vs runtime. I thought @offsetOf throwing a compiler error is something I wouldn't be able to branch my way out of, for instance.

1517593297
MajorLag_
Could just be because I'm not used to it I guess.

1517595380
andrewrk
MajorLag_: why couldn't you branch your way out of it?

1517595396
andrewrk
In fact you can branch your way out of compile errors

1517597819
MajorLag_
Yeah, I know that from trying, but it the logic of it wasn't obvious to me. It seemed to me that the values would be filled in at comptime while the branch would happen at runtime. I see now it's more like anything that requires a comptime value to evaluate happens at comptime.

1517603999
noonien
andrewrk: Hello, have you given vtables/interfaces any thoughts recently?

1517610459
hoppetosse
noonien: I'm not sure what the plans are, but I'm convinced it can be implemented as a library =P

1517610490
noonien
i don't see a point in implementing it as a library

1517610506
noonien
from what I can tell, the stdlib can greatly benefit from them

1517610567
hoppetosse
Yeah, I agree with you completely, I was just trying to make a point about how much can already be accomplished

1517610584
hoppetosse
There's definitely been discussions about interfaces/traits

1517610640
hoppetosse
Zig has a sort of "trait pattern" - look at the Allocator type

1517610644
hoppetosse
struct

1517610644
noonien
i had a quick glance at the stdlib code, handling streams seems to be as bad as c++, if not even worse

1517610673
hoppetosse
the stdlib is young a lot needs to be ironed out

1517610704
hoppetosse
the language itself isn't fully ironed out, but it's been evolving at a great pace

1517610816
noonien
yeah, i've noticed the pattern of structs with function fields, seems rather cumbersome

1517610900
noonien
streams seem to be handeled in the same way

1517610928
hoppetosse
yeah, I guess you could call them manual vtables

1517610992
hoppetosse
I've been meaning to ask andrewrk about this too actually

1517611043
noonien
i've suggested taking inspiration from go interfaces. i really like that any type that satisfies the interface automatically implements it

1517611165
hoppetosse
it goes well with zig's compile-time duck typing ideas

1517611239
noonien
just wanted to ask if any futher thought has been given, since if the stdlib matures further, i'm afraid the current pattern of callback tables will have more adoption

1517613021
hoppetosse
andrewrk: are tuples necessarily incompatible with vararg params?

1517613134
hoppetosse
I'd very much like to be able to store sets of function arguments

