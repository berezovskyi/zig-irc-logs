1528418521
JinShil
Does Zig have any way to model bitfields as fields/properties rather than methods?  Thinking about modeling memory-mapped IO registers in a microcontroller.

1528418548
andrewrk
JinShil, yes

1528418598
andrewrk
hmm looks like I need to add the docs for packed structs

1528418650
andrewrk
JinShil,

1528418653
andrewrk
I'll add this to the docs

1528418991
JinShil
That's pretty cool.  Definitely an improvement over C.

1528419051
andrewrk
I believe this project makes use of the feature, if you want to see code examples:

1528419127
JinShil
Just to offer a comparison, I'm currently invested in D and model registers this way (

1528419157
bheads____
is there a reason why argument list isn't just a const []u8[]?

1528419173
andrewrk
JinShil, ah that's nice

1528419228
andrewrk
bheads_, yes. 2 reasons:

1528419254
andrewrk
1. posix provides `[][*]null u8`. to convert that into `[]const []const u8`, we would have to allocate memory

1528419316
andrewrk
2. Windows provides GetEnvironmentStringsW which returns `[*]null u16`. to convert that into `[]const []const u8` we would have to allocate memory

1528419393
andrewrk
so if you use std.os.argsAlloc and pass an allocator, you get back a `![]const []u8`

1528419405
andrewrk
and that works on all platforms

1528419490
andrewrk
JinShil, I believe that MajorLag1 is working on a field tag proposal, which could be used to add bit offset annotations to packed structs and could then be verified at comptime

1528419502
bheads____
Okay I see that function now, std is a little tricky to find things (or the proper thing to todo)

1528419519
bheads____
also might want to checkout CommandLineToArgvW

1528419521
andrewrk
bheads_, I totally agree. that's going to be an ongoing issue until we have autogenerated docs

1528419537
JinShil
andrewrk, Thanks, I'll be watching for it.

1528419541
andrewrk
I've seen that. we have a correct implementation of CommandLineToArgvW in std

1528419566
andrewrk
bheads_, ...which is used by std.os.argsAlloc

1528419723
MajorLag1
Yeah, I'm still thinking about that proposal. I tried a bunch of ideas using existing language features to do what I wanted and they were all pretty unweildy. Now I'm thinking through the proposal to see if there's a language feature that'll get us there with a little tweaking before I go all out and propose a new sigil or builtin something like that.

1528419737
bheads____
looks like zig is splitting it, not api, but thats okay

1528420048
MajorLag1
It might be as simple as allowing void fields to have duplicate names. Or having typeInfo know the name used for a type alias.

1528420988
andrewrk
bheads_, did you find a difference between zig's split behavior and CommandLineToArgvW?

1528421596
bheads____
I havn't seen a difference, was just pointing out that the winapi has a function for that.  Not sure is the windows version does anything special.

1528421839
andrewrk
right now the policy about calling windows APIs are: avoid calls for things that we don't need the system to do. for example, unicode decoding and encoding. there is no reason to introduce an external dependency for this

1528421882
andrewrk
this has the best performance, the fewest dependencies (and thus installation headaches), and allows using the functionality at compile-time

1528421943
bheads____
sounds good, I didn't see it as a problem :)

1528421970
bheads____
would zig ever what to support switching on strings?

1528422023
MajorLag1
wait, did I miss allocations working at comptime?

1528422060
MajorLag1
oh wait, you were just talking about splitting the arg string, not retrieving it.

1528422178
andrewrk
bheads_, before I answer that question I want to explore what it looks like to implement perfect hashing at comptime in userland

1528422261
bheads____
but your open to the idea? cause thats a feature from D I miss

1528422566
andrewrk
sure I'm open to the idea. but if there is not a really satisfying way to implement it reliably and optimally, then it would fall into the category of nice-to-haves that zig is missing in order to stay simple

1528422599
bheads____
I am down with that

1528422634
andrewrk
e.g. if it encourages people to rely on it instead of using enums, that's a problem. at least with an if-else chain of comparisons, the performance looks closer to what it really is

1528422658
andrewrk
on the other hand if we figure out a killer perfect hashing solution or some other satisfying implementation, then it might make sense

1528422754
bheads____
yeah, I just ended up with lots of else ifs mem.eql

1528422876
bheads____
does anyone watch Jonathan Blow's Jai video at all?  What do you think about it not using parans in if statements?

1528423017
MajorLag1
I watch Jon all the time. Like right now for example. My personal opinion is that if statements without parens are slightly harder to read, but it isn't a big deal.

1528423050
MajorLag1
I also prefer Allman style, so I'm weird like that.

1528423059
bheads____
yeah thats what I felt, it seemed really easy to miss understand that condition from the block

1528423249
bheads____
I also dont like the implicit it iterator on for loops, to much like perl

1528425764
GitHub132
[zig] andrewrk pushed 1 new commit to master:

1528425764
GitHub132
zig/master f0b6dac Andrew Kelley: add implicit casts from `*[N]T`...

1528425931
donpdonp
zig! zig! zig! just doing a zig-cheer for all this new development. thx andrewrk

1528426236
donpdonp
the top post on Lobsters!

1528426611
JinShil
Suppose I wanted to use std.fmt with an ARM cortex-M microcontroller, and I wanted the output to be sent over a UART (serial port).  I suspect there's some code in the std library that needs to be ported.  Is there a platform abstration layer/file somewhere?

1528427688
MajorLag1
std.os

1528427923
MajorLag1


1528429405
MajorLag1
aw, #991 bit me

1528429736
thither
Does zig hold a different niche from rust? I saw andrewrk's video on YouTube from March and zig was compared against many systems programming languages (and some other types of languages), but rust was not mentioned.

1528429799
thither
One thing that really caught my attention was the ability to very quickly interface with existing C libraries - which is something rust doesn't do so well.

1528429829
donpdonp
thither: this might be useful

1528429833
thither
(the quick part - once the wrapper is written all is well)

1528429842
thither
donpdonp, thanks

1528429954
JinShil
thither, Andrew did briefly discuss Rust in that video during the Q & A

1528429977
thither
JinShil, ah, okay. I'll go back and check the Q&A out

1528430209
donpdonp
my own take on why zig is that zig is a "better C". ie i can actually make the leap from knowing some C to seeing how zig improves on it.

1528430252
donpdonp
rust's pointer ownership on the otherhand strikes me like learning german while flying upside down.

1528430288
thither
donpdonp, does zig offer the "fearless concurrency" that rust claims to have? Ownership is part of that.

1528430341
donpdonp
i read somewhere that zig has some coroutine support but its not documented yet. afaik 'fearless concurrency' would be a high level feature to build with zig

1528430383
donpdonp
im happy with a sane type system, arrays that know their length, and non-nullable pointers. that alone should move the industry forward :)

1528430469
donpdonp
so to compare with go, zig has coroutines but not channels for thread message-passing. maybe thats coming, i dont know.

1528430893
donpdonp
there's probably a clib that does both. (actors)

1528437032
GitHub89
[zig] tiehuis pushed 1 new commit to master:

1528437032
GitHub89
zig/master ffb089a Marc Tiehuis: Fix json parser comma after empty object case

1528437035
tiehuis
donpdonp: this should fix that json issue you were having

1528437053
donpdonp
tiehuis++ thx

1528437895
andrewrk
JinShil, I have an example of this (although it may have bit rotted a bit) here:

1528437920
andrewrk
in summary std.fmt.format takes a callback function, in which you could write to UART

1528438099
andrewrk
thither, you may be interested in watching this ambitiously named issue:

1528438174
JinShil
Wow, exactly what I was looking for.

1528438238
andrewrk
JinShil, cross reference that with

1528438245
andrewrk
(the actual std.fmt.format API)

1528438260
JinShil
Yep, I'm seeing it now.

1528438563
JinShil
My question was a bit mor general though.  I'm thinking about a cohesive way to port the standard library to a currently unsupported platform.  The code in std.os looks right, but I'd have to experiment to know for sure.  At least I know where to look and have some idea of what to look for and how to proceed.  Thanks.

1528439313
JinShil
I think Zig's doing a lot of things right.  It's not exactly what I'm looking for right now, but I think it has a bright future.

1528439694
JinShil
I'm wondering, is

1528442514
GitHub99
[zig] Hejsil pushed 1 new commit to master:

1528442514
GitHub99
zig/master bf3d1c1 Jimmi HC: Allow access of array.len through a pointer

1528447413
JinShil
Is there no function overloading in Zig?

1528451716
nc-x[m]
JinShil: AFAIK no.

1528451789
nc-x[m]
That is one thing I would love to see in Zig. IMO it makes code easier to write. Also GoToDefinition in editors can help with readability issues if anyone has them

1528454973
very-mediocre
Is there a way to check if a variable is `undefined`? The `==` operator isn't supported for `undefined`

1528455035
very-mediocre
i.e. var x = undefined; if (x == undefined) x = 1;

1528455367
tiehuis
very-mediocre: no, undefined is just to specify that the value should not be initialized on declaration

1528455381
tiehuis
it still has a value, its just indeterminate until you actually explicitly set it

1528455399
tiehuis
if you need a way to have a possibly empty type you'd need to use a nullable

1528455425
very-mediocre
I see, thanks.

1528455441
very-mediocre
FYI things like `const x = undefined` make no sense

1528455565
very-mediocre
(I'm sure you guys know that already)

1528455683
tiehuis
yeah, that is never used as fasr as i can see any code besides one test case in the compiler

1528456874
MajorLag1
I dunno, doesn't one of the crypto libraries out there use uninitialized memory as part of its seeding process? I vaguely recal that some ambitious programmer used valgrind on it and eliminated a bunch of warnings at the cost of causing every debian install in the world to generate the same first ssh key, or something. In that case something like `const x: u32 = undefined;` makes sense at least.

1528456981
MajorLag1
JinShil, nc-x[m], personal opinion: I don't like the idea of relying on fancy editor features for readabilitty.

1528457089
king_button
Wow the number of patreons have increased enormously since Andrew posted about quitting his job to work on Zig

1528457110
nc-x[m]
Yeah I can agree that readability is subjective but i would prefer function() to function1arg(), function2arg() etc

1528457211
JinShil
Yeah, I think function overloading improves readability because you don't have to be so redundant; you can see by the nature of the call what's going on, you don't need to specify it in the name to disambiguate it.

1528457271
very-mediocre
MajorLag: good point, I've read about that as well, although I'm not a crypto guy. Seems unsafe to me!

1528457298
very-mediocre
MajorLag1 rather*

1528457377
king_button
Loci, a language that looks just like C++ but improves on it, also decided against method overloading. What's clear in any case is that C++ has too much implicit conversion which makes method overloading a pretty bad idea.

1528457406
king_button
But I do like method overloading myself

1528457429
king_button
Why did I just call it method overloading instead of function overloading? Oh well.

1528457466
MajorLag1
Function overloading has some fair arguments in its favor, but I will point out that you can do something similar in Zig today using var and varargs, you just have to handle it more manually.

1528457557
JinShil
Yeah, I saw the example with var, and even played with it, so actually Zig does have function overloading, just in a different way.

1528457582
bheads_
Tuples will improve that situation as well

1528458146
very-mediocre
Is there currently an equivalent to the preprocessor, i.e. sections that should only run in debugmode?

1528458186
MajorLag1
if(builtin.mode == builtin.Mode.Debug)

1528458211
very-mediocre
awesome, thank you

1528458227
very-mediocre
Apologies for asking these mundane questions, the docs are a bit hard to navigate currently

1528458243
MajorLag1


1528458268
MajorLag1
Not a problem. For some stuff there isn't even docs yet.

1528458297
very-mediocre
It's actually not covered in that section

1528458297
MajorLag1
...adn the section I linked doesn't even mention this

1528458303
very-mediocre
yeah :)

1528458346
MajorLag1
you can see it in use here:

1528458358
MajorLag1
...kinda

1528458467
MajorLag1
ah, ok, here's what I was looking for:

1528458503
very-mediocre
Right

1528458721
bheads_
anyone run intol a compile issue with deuplicate symbol: _start

1528459113
Braedon
Guess who just spelt 'kernel' as 'kernal' and had to physically turn on a windows computer and run to see the error

1528459258
MajorLag1
Been reading too many C64 manuals lately?

1528459999
bheads_
anyone had an issue with:  duplicate symbol: _start   in gcc Scrt1.0  and boostrap.zig

1528460132
bheads_
hummm its realted to using the heap.c_allocator

1528460190
tiehuis
what is your command-line invocation?

1528460233
bheads_
zig run src/main.zig

1528460240
tiehuis
okay, add '--library c'

1528460255
bheads_
makes sense, but the error message is miss leading

1528460279
tiehuis
i think there was a reason it wasn't more specific here, can't recall

1528463149
king_button
How do I exit early out of a program?

1528463421
bheads_
std.os.exit(0)

1528465798
king_button
I can't seem to create an enum of signed integers even when explicitly specifying enum(i32), I just get "expected unsigned integer, found i32"

1528465852
king_button
btw how do you port C enums over manually?

1528466183
bheads_
I think you need an extern enum

1528467846
bheads_
is there are string to int function in the stdlib?

1528468190
bheads_
nm found parseInt in std.fmt

1528471333
andrewrk
bheads_, I think there may be some things we can do to assist in that situation, but the fundamental nature of linking object files together sadly leaves it ambiguous why a symbol is missing, so there's a limit to how helpful the error messages can be

1528471375
andrewrk
this is why - for non libc builds - you can put `extern "libname"`

1528471410
andrewrk
this lets zig know where we expect to find all the functions, which lets us have more useful diagnostics as well as cross compile for windows with no SDK

1528471493
bheads_
I was just confused why importing the c_allocator caused the error, that was all.  It makes sense now

1528471689
bheads_
does anyone what a thread safe logging library?

1528471768
bheads_
wow I cannot type, does any one

1528473217
very-mediocre
Is there a standard library reference anywhere? I'm interested in things like dynamic array concatenation (wondering if I should roll my own)

1528473366
andrewrk
very-mediocre, not yet, you'll have to resort to grep

1528473452
very-mediocre
Alright. Namespaces match the directories like in golang, right?

1528473511
andrewrk
not necessarily

1528473543
andrewrk
you could start by looking at std/index.zig to see what all is available

1528473600
very-mediocre
will do. ty

1528473626
andrewrk
very-mediocre, for what it's worth, I believe that the functionality you described does not exist in std lib

1528473656
very-mediocre
I see

1528473706
very-mediocre
I'll consider rolling my own at some point but I'm still a noob, I've yet to work out the heap allocation story (e.g. C++ "new")

1528473810
andrewrk
you'll want to get a *std.mem.Allocator  and then call allocator.alloc(Type, count)

1528473864
andrewrk
as a library or utility code, accept  *std.mem.Allocator as an arg. if you're trying to make one in your main function, try following this pattern if it makes sense to do:

1528473886
andrewrk
otherwise, if you need a general purpose allocator and you're linking to libc, use std.heap.c_allocator

1528473896
very-mediocre
understood

1528473904
andrewrk
otherwise, you'll have to roll your own general purpose allocator, or wait until zig std lib gets one :)

1528473930
very-mediocre
I'd like to do it as part of learning zig if time would allow :]

1528476280
very-mediocre
Maybe silly question: why is it that nullable struct fields can't be accessed with the . operator?

1528476295
very-mediocre
"type [...] does not support field access"

1528476312
very-mediocre
the other non-nullable fields can be accessed fine

1528476329
very-mediocre
I'm sure it's a safety feature but I'm unclear on the alternative. Should there be a getter function for it?

1528476393
very-mediocre
Ahh, the function returned `?type` also, making it return `type` seems to resolve the issue. I'm a bit unclear on how this works

1528476474
very-mediocre
tl;dr: a struct of type `myType` gotten from a function that returns `?myType` doesn't let you access its nullable fields

1528476530
andrewrk
very-mediocre, you need to either handle the case when it could be null, or assert that it is non-null

1528476562
very-mediocre
The non-nullable fields can be accessed, even if the struct itself might be null

1528476610
andrewrk
hmm if you show me a code example I can maybe explain better (or maybe you found an issue)

1528476610
very-mediocre
I'm confused why this restriction only applies if both the struct and the field i'm attempting to access are both nullable

1528476640
very-mediocre
I'll prepare a simplified example soon

1528476679
very-mediocre
the current code I'm working on has escalated a bit (attempting to implement lz77 encoding as a learning exercise)

1528477076
very-mediocre


1528477102
very-mediocre
andrewrk: accessing the `struct.z` gives the error

1528477136
very-mediocre
if `get_struct` is changed to return `SomeStruct` instead of `?SomeStruct` then the error doesn't occur

1528477195
very-mediocre
I suspect there's a reason for this but I'm unclear why `?SomeStruct.?z` is guarded against but not `SomeStruct.?z`

1528477208
very-mediocre
also `?SomeStruct.x` is fine

1528477231
very-mediocre
OK, maybe I'm stupid

1528477303
very-mediocre
it just occurred to me this might be like the struct needs to exist before accessing one of its fields... but then `?SomeStruct.x` should complain too

1528477319
very-mediocre
sorry for spamming, thinking out loud a bit.

1528477394
andrewrk
very-mediocre, try the code I left in a gist comment

1528477443
very-mediocre
It works, but then why does `?SomeStruct.x` not complaing

1528477472
very-mediocre
should it not be the same error? (Need to handle that SomeStruct might be null before attempting any field access)

1528477487
andrewrk
show me an example where it works but it shouldn't?

1528477563
very-mediocre
posted on gist

1528477600
very-mediocre
It lets you access .x and.y (non-nullable fields) even though I'm not handling that the struct itself may be null

1528477625
andrewrk
I get `error: type '?SomeStruct' does not support field access` for both of them

1528477664
very-mediocre
huh :|

1528477668
very-mediocre
I think I made a mistake somewhere

1528477719
very-mediocre
ok

1528477721
very-mediocre
my apologies

1528477725
andrewrk
no worries

1528477726
very-mediocre
it's complaining about `?SomeStruct.x`

1528477737
very-mediocre
I was so sure it wasn't complaining in that scenario

1528477761
very-mediocre
sorry! :]

1528477776
andrewrk
there are quite a few known bugs right now - I don't blame you for double checking assumptions

1528477780
andrewrk
no worries

1528478254
bheads_
I was wondering what people are using (editor/ide) to code zig in?

1528478267
bheads_
Right now I am just using ranger and vim

1528478311
andrewrk
I use vim. I think tiehuis uses vscode. some folks use spacemacs or emacs or something like that

1528478386
very-mediocre
bheads_ i'm using vscode

1528478432
bheads_
andrewrk, do you have a vim syntax file for zig?

1528478469
andrewrk
bheads_,

1528478476
andrewrk
it even supports running zig fmt on save

1528478507
bheads_
amazing

1528478673
king_button
I have a question about function pointers. Is there no way to call them without this syntax: ptr.*()

1528478675
bheads_
highlighting is always such a big difference

1528478732
king_button
because lots of c libraries like opengl and vulkan want to be called through function pointers, at least for best performance (in the case of vulkan anyways).

1528478895
andrewrk
king_button, you can call function pointers with fn_ptr()

1528478972
king_button
I get "type '*fn() void' not a function" - I might be doing something wrong?

1528479018
andrewrk
I might need to open an issue for this - fn() is already a pointer

1528479029
andrewrk
`*fn() void` is a double pointer

1528479031
king_button
ah

1528479040
king_button
whoops

1528479054
king_button
makes sense

1528479815
bheads_
andrewrk, is there a way to get a calling functions file name and line number?   Writting a simple runtime logger

1528479914
andrewrk
bheads_, how this will work: fn log(location: var, comptime format: []const u8, args: ...) { // ...

1528479926
andrewrk
at the callsite:  log(this, "blah");

1528479936
andrewrk
oops, you need `comptime` on location.

1528479963
andrewrk
and then - and this is not implemented yet -you'll be able to extract source file, line, column, and more info from the location parameter

1528480004
bheads_
okay so the idea is this has the comptime info

1528480030
andrewrk
yes

1528480031
bheads_
but its not implemented, so I can wait on that

1528480079
andrewrk
`this` is a bit of an experiment right now. I'll probably change it to `@this()` and make the semantics more well-defined

1528480096
bheads_
gotcha

1528480135
andrewrk
but the idea is that it references a particular scope at comptime. so you'd be able to find out lots of things about that scope, including file, line, column

1528480164
bheads_
nice

1528480286
bheads_
I wonder if @scope() would be less confusing for people migrating

1528480427
andrewrk
I realized it's actually AST node, not scope, so even more specific would be @thisAstNode()

1528480492
andrewrk
I can't help but wonder if there is a better way to log out a reference to a particular line of code

1528480495
bheads_
so really it would have all the info in the node

1528480597
andrewrk
for example the log function could be marked "noinline" and then collect the return address (which is a single usize). That can go in the log message, with also some info to identify the source code version (perhaps the commit hash). Then later when analyzing log files, you could use debug info to translate the return address into file, line, column

1528480627
andrewrk
this would avoid bloating the binary with source file and line number information converted to strings

1528480667
bheads_
interesting, but I doubt NOC wants to translate log files

1528480675
andrewrk
yeah that's fair. what's NOC/

1528480679
andrewrk
?

1528480686
bheads_
network operations center

1528480691
andrewrk
I see

1528480693
bheads_
IT folks

1528480735
bheads_
also, not fun when I get sent a 10gig gz of logs for the last 30 days looking for an error

1528480737
bheads_
lol

1528480759
andrewrk
yeah. the binary bloat may be worth the log analysis benefit

1528480813
bheads_
besides I would think the comptime format strings would be just as bad

1528480909
andrewrk
comptime format strings don't make it into the binary

1528480961
andrewrk
sorry that's not true. they will make it into the binary because the code references them at runtime, e.g. "foo: {}" - the runtime code will have a const slice of "foo: "

1528481015
bheads_
right, and is it a FSM that it gets turned into?

1528481078
andrewrk
it gets turned into a linear series of function calls

1528481088
andrewrk


1528481109
andrewrk
scroll down to the part after "Zig partially evaluates the function and emits a function that actually looks like this"

1528481138
bheads_
ah, nice!

1528481167
bheads_
I guess the state machine code I saw was the comptime parsing of the format string

1528481176
andrewrk
yes exactly

1528483047
bheads_
is cas and atomic load the only syncing premitives right now?

1528483115
andrewrk
also

1528483145
andrewrk
I don't think there are any atomics missing, other than the ergonomics mentioned in the above docs

1528483149
bheads_
right, was looking for a locking mutex, but I can just do a spin lock

1528484078
bheads_
does os.file support openWrite for appending?

1528484154
andrewrk
no

1528484160
andrewrk
but you should be able to seek to the end

1528484190
andrewrk
if I remember correctly that is more portable

1528484307
GitHub61
[zig] andrewrk pushed 1 new commit to master:

1528484308
GitHub61
zig/master 39fa313 Andrew Kelley: disable some implicit casts for unknown length pointers...

1528484327
andrewrk
Pointer Reform issue is done

1528484350
andrewrk
a couple more breaking changes and then I'm going to focus hard on the self hosted compiler

1528484652
bheads_
nice!

1528485397
clownpriest
woop woop

1528486714
thither
andrewrk, self hosted compiler will be lit

1528486879
andrewrk
I have some ambitious goals for it

1528486899
thither
Oh?

1528486911
andrewrk


1528487127
clownpriest
dope

1528487168
thither
So much caching

1528487552
andrewrk
thither, idea being that if you have a 10 million line codebase, and you update 1 function, all that should have to happen is updating 1 tiny .o file which contains that function, and re-linking. potentially even using .so files instead of .o sometimes to skip the re-linking step (really, it means doing the linking step at runtime lazily)

1528487622
thither
andrewrk, sounds like it'll be faster than rustc :P

1528488238
zovt
can I create a stack-allocated array with length computed at runtime?

1528488245
zovt
or must I allocate for that?

1528488321
zovt
const word = dict_iter.next() ?? unreachable;

1528488326
zovt
whoops

1528488363
zovt


1528488514
andrewrk
zovt, no, I removed alloca

1528488531
andrewrk


1528488568
zovt
dang, thanks for the heads up

1528488577
zovt
how's full time zigging going?

1528488586
andrewrk
development pace has accelerated

1528488610
zovt
awesome :D

1528488758
andrewrk
zovt, if the value is known at runtime, then heap allocation is almost certainly the correct place for the memory

1528488779
rom16384
I've just cloned and tried to build zig on a mac, but the last test step fails with "c.zig:1:9: error: C import failed, 'inttypes.h' file not found". Is the build broken?

1528488820
andrewrk
rom16384, sounds like you have a working zig build, but the tests that test interaction with libc are failing, because you do not have libc headers available on your system

1528488828
rom16384
ok

1528488835
andrewrk
so you can do everything except --library c and @cImport

1528488892
andrewrk
rom16384, do you have gcc or clang available, and can you build hello world with one of them?

1528488929
rom16384
I'm using clang and I have xcode installed

1528488964
andrewrk
where is clang finding libc? can you look for stdlib.h on your system?

1528489021
rom16384
Under the XCode dirs, for example: /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/c++/4.2.1/tr1/stdlib.h

1528489041
rom16384
I forgot to install the latest version of the command line tools, I'm doing that now

1528489051
andrewrk
I think that should solve it

1528489056
rom16384
yeah

1528489062
andrewrk
however we may consider trying to look for libc under xcode paths

1528489082
andrewrk
if it works, I don't see why not

1528489086
rom16384
What is the recommended compiler on a mac, gcc?

1528489096
andrewrk
for compiling zig stage 1?

1528489103
rom16384
yes, I guess

1528489107
andrewrk
it must be the same compiler as used to build llvm & libclang

1528489113
rom16384
ok, got it

1528489120
andrewrk
so, probably whatever is your default system compiler|

1528489158
andrewrk
note that zig does not depend on a c compiler

1528489204
andrewrk
it does not depend on a system C compiler being installed - only the libc files, and even then only for --library c

1528489227
andrewrk
at runtime anyway, of course zig stage 1 must be built from source

1528489275
zovt
rom16384: I think you can `brew install zig` if you just want 0.2.0

1528489285
zovt
at least that worked when I tried it yesterday, ymmv

1528489299
rom16384
I just saw that zovt on the page, I don't know how I could have missed it

1528489304
zovt
not sure if that will pull any needed dependencies though

1528489318
zovt
nice :)

1528489320
rom16384
Anyway after updating XCode's command line tools the tests are running

1528489356
andrewrk
I would recommend master branch though. at this point 0.2.0 is using incorrect syntax and there have been 534 commits to master since 0.2.0

1528489378
zovt
whew, crazy

1528489386
rom16384
andrewrk: That's why I trying going straight for the repo

1528489523
zovt
andrewrk: do you maintain a log of syntax changes that happen somewhere?

1528489561
andrewrk
zovt, I've been putting that off until I write release notes

1528489570
andrewrk
but maybe it makes sense to write those notes as breaking things happen

1528489583
zovt
is 0.3.0 getting cut soon?

1528489586
andrewrk
I'll at least start doing that after 0.3.0 (scheduled for mid-september)

1528489593
zovt
nice

1528489801
thither
Who funds zig?

1528489889
andrewrk
it's crowd funded

1528490656
clownpriest
is there a way to tell the compiler to just do arithmetic with overflows on all operations in a block (or just in a function)?

1528490669
zovt
tip for anyone hacking zig in emacs: rust-mode tends to work pretty well

1528490683
clownpriest
without having to call @mulWithOverflow or @addWithOverflow on each operation

1528490733
andrewrk
clownpriest, use the % variants of operators:

1528490749
clownpriest
thanks!

1528491157
zovt
the gdb support is pretty sweet right now

1528491570
MajorLag1
oh boy, pointer reform is done. that's probably worth a blog post. something like "why we fundamentally changed our pointer syntax".

1528491663
andrewrk
MajorLag1, (semi-joking) I'll put it in line behind coroutines

1528491685
andrewrk
MajorLag1, also to be clear I left null terminated pointers for another issue

1528492142
clownpriest
is there a way to have debug.warn() output an int in hex format?

1528492180
andrewrk
"{x}"

1528492326
clownpriest
cool thanks

1528492563
zovt
are you guys using any cpp features in the stage1 compiler? From the code I've seen it all looks very c-like

1528492613
andrewrk
templates, llvm API, and libclang API

1528492633
zovt
gotcha

1528494910
MajorLag1
andrewrk, probably best to wait until that's in then.

1528496414
zovt
andrewrk: is discussion about whether or not to support hard tabs to take place specifically on

1528496435
andrewrk
please do it on 544

1528496454
zovt
sounds good

1528496464
thither
andrewrk, do you work on zig full time?

1528496498
andrewrk
thither, yes, as of yesterday

1528496502
thither
:O

1528496505
thither
Congratulations!

1528496550
andrewrk
thank you. we can celebrate once I'm not living off of savings :)

1528497125
GitHub116
[zig] tiehuis opened pull request #1081: Add arbitrary-precision integer to std (master...bigint)

1528498492
GitHub97
[zig] isaachier opened pull request #1082: Fix error handling in Buffer::fromOwnedSlice (master...buffer-fixes)

1528498509
zovt
andrewrk: if / when do you plan on phasing out the stage1 compiler and focusing solely on the self-hosted one?

1528498521
willllll
is there an easy way to print a C string? I'm trying warn("{}", c"whatever"), but (understandably) just getting the bytes

1528498570
andrewrk
zovt, the stage1 compiler will forever be maintained

1528498588
andrewrk
however there will be a subset of functionality that it does not need to support. it only has to be able to build stage2

1528498644
andrewrk
willllll, hm I think we need to add another format character for that use case, perhaps warn("{c}", c"whatever");

1528498653
andrewrk
it would be pretty straightforward, just need to do it

1528498716
willllll
Hah, I didn't intend to suggest a language feature ;) , do you think in the meantime using c's printf or something would be the way? I'm not doing anything serious

1528499603
andrewrk
willllll, it wouldn't be a language feature, just a small code addition to the state machine in the std.fmt.format function

1528499607
andrewrk
you can do it in userland :)

1528499616
andrewrk
yes you can use c's printf

1528500302
GitHub41
[zig] andrewrk closed pull request #1082: Fix error handling in Buffer::fromOwnedSlice (master...buffer-fixes)

1528500304
GitHub174
[zig] andrewrk pushed 1 new commit to master:

1528500305
GitHub174
zig/master 1a9d2f3 isaachier: Fix error handling in Buffer::fromOwnedSlice (#1082)

1528500903
MajorLag1
willllll: There's a function in std.c to get a `[]const u8` from a c string. It doesn't allocate or anything, it just gives you a slice covering the string's bytes.

1528501049
andrewrk
oh yeah, that's right. I think that's the recommended way to print c strings.

