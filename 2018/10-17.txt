1539771875
very-mediocre
After reading that tuple discussion, I have a kneejerk reaction to want to generalize arrays, structs and tuples as a single thing since they are all just sequences of fields...

1539773063
Hejsil
very-mediocre, well they do have some differences

1539773086
Hejsil
You can't iterate over fields of tuples and structs at runtime

1539773106
very-mediocre
That's an implementation detail.

1539773110
very-mediocre
Conceptually you "could"

1539773135
Hejsil
Well, if it's effects userspace, then it is not an implementation detail

1539773139
Hejsil
affects*

1539773155
very-mediocre
I don't mean it like "it's a hidden behind-the-scenes thing"

1539773180
very-mediocre
I mean it's the status quo, but things

1539773188
very-mediocre
that's what i mean by implementation detail here.

1539773295
Hejsil
I'd love to see this combined abstraction, I just think we lose some "nice to haves"

1539773315
Hejsil
Slices would never work

1539773329
very-mediocre
Yeah, it's really just a kneejerk reaction

1539773346
very-mediocre
I've never seen any respectable language do it

1539773354
Hejsil
The ultimate abstraction! []u8

1539773359
very-mediocre
haha

1539773457
very-mediocre
technically everything is like an iterable dictionary

1539773470
very-mediocre
conceptually that is

1539773497
very-mediocre
you could represent structs, arrays and tuples that way

1539773499
Hejsil
I think, one could get far by having namespaces, []u8 and functions

1539773533
Hejsil
Let's say we can define a unique type like this: const Point = distinct [4]u8;

1539773546
Hejsil
And we could add methods to this type through comptime refelction

1539773559
Hejsil
Now, you can basicly implement structs in userland

1539773577
very-mediocre
right

1539773661
very-mediocre
I feel like there's always a compromise when you use a struct vs a tuple

1539773710
very-mediocre
it's really all just mixed data with possible padding

1539773741
very-mediocre
I'm OCD about there not being an ideal solution

1539773802
Hejsil
What do you think of the tuple proposal though? I'd like to get some opinions before I start working on it (andrews opinion is not enough!)

1539773827
very-mediocre
I'm a big pontificator, I do a lot of "academic" type thinking so maybe my opinion sucks

1539773833
very-mediocre
That said, I like the proposal a lot.

1539773882
very-mediocre
It's good that you can use the bracket accessor to access tuple fields by index, and cast tuples to arrays

1539773899
very-mediocre
but that also makes me OCD because I can't unsee that array is a special case of tuple

1539773966
Hejsil
I don't think "cast to array" is gonna be in the initial implementation, as we don't know of the usecase for that yet

1539773989
very-mediocre
maybe the reason you don't know the use case for that, is that array is just a special case of tuple :)

1539774000
Hejsil
:)

1539774010
very-mediocre
so if you had a function that accepts an array, and elsewhere you have a tuple...

1539774016
very-mediocre
you're better off changing the function to accept a tuple

1539774035
very-mediocre
in order to accept the "elsewhere" value as a param

1539774047
Hejsil
Imagine writing [32]u8 as a tuples though :)

1539774061
very-mediocre
I did imagine it

1539774072
very-mediocre
You'd write provide the 32 somehow

1539774075
very-mediocre
instead of writing each one

1539774090
Hejsil
tuple.{u8} ** 32 :)

1539774096
very-mediocre
yeah

1539774116
Hejsil
I don't think we're going to unify tuples and arrays, because we have slices

1539774122
Hejsil
And slices only work on arrays

1539774130
Hejsil
So tuples are not a strict superset

1539774266
very-mediocre_
got disconnected

1539774281
very-mediocre_
tuples are not currently a strict superset, but in theory they could be

1539774285
very-mediocre_
i'm only talking theory here :)

1539774313
Hejsil
Righto

1539774328
very-mediocre_
I noticed there's quite a bit of friction in many languages when using a mix of structs/tuples/arrays

1539774344
very-mediocre_
even dynamic languages like horrible PHP

1539774384
very-mediocre_
I suffered immensely last week working on a legacy REST API for work, because some functions returned objects while others returned arrays

1539774413
very-mediocre_
and both were used to represent the same kinds of data

1539774468
very-mediocre
Similar things happen in JS and TypeScript too

1539774483
very-mediocre
with Object literals vs. es6 classes, etc

1539774638
very-mediocre
It drives me crazy that there are so many ways to represent the same kinds of data..

1539774648
very-mediocre
Maybe no solution exists but that's annoying.

1539774678
Hejsil
I think this is where best practices come in

1539774684
Hejsil
All data could be []u8

1539774696
Hejsil
But really, if certain section could be given a name

1539774702
Hejsil
Then a struct is probably better

1539774724
Hejsil
I get the pain, but I don't think there is a solution

1539774737
very-mediocre
Yeah but there's always that problem of, say a library takes an array for something

1539774744
very-mediocre
while another uses tuples

1539774771
very-mediocre
and yet another might use a struct to represent the same dataset

1539774797
Hejsil
At least tuple<->array could have a wrapper func that at most, does a memcpy in Zig

1539774842
Hejsil
Or, tuple->array, I can imagine

1539774855
Hejsil
But array->tuple is probably harder/not possible to write

1539774866
very-mediocre
That feels like an overhead that exists in code but not in concept

1539774889
Hejsil
Yea

1539774894
very-mediocre
Stuff like vec3, Point, etc

1539774906
very-mediocre
I've seen them as classes, structs, arrays, tuples

1539774931
very-mediocre
Wouldn't it be great if that distinction could be eliminated?

1539774959
Hejsil
I don't think tuples should be used for vec3 :)

1539774974
Hejsil
but struct<->array is a problem yes

1539774976
very-mediocre
Why not?

1539774987
Hejsil
Arrays does everything the tuple does

1539775011
very-mediocre
the field names in vec3 or vec4 are interchangeable, you'd store xyzw or rgba

1539775018
Hejsil
But I guess, some api could take a generic tuple.{f32,f32,f32} and you want to pass your vec3

1539775042
very-mediocre
Well if arrays do everything tuples do, then why do you need tuples?

1539775052
Hejsil
For vec3, i ment

1539775054
Hejsil
Not in general

1539775055
very-mediocre
ah

1539775060
Hejsil
My bad

1539775071
very-mediocre
yes actually I also had a brainfart there

1539775081
very-mediocre
obviously the "mixed fields" thing is huge.

1539775091
very-mediocre
I'm not expressing myself well today

1539775109
very-mediocre
My overall point is I question the need for all 3 of tuples, arrays and structs to exist

1539775132
very-mediocre
there's a lot of overlap and it opens up a lot of different ways to do some of the same things

1539775166
Hejsil
True. They only reason tuple is being considered is that they can replace varargs and give multible return types

1539775178
very-mediocre
Yeah, and I really like that

1539775226
very-mediocre
Although sometimes I wonder if we are stuck in the boundaries of things we've seen other languages do.

1539775235
Hejsil
Actually, maybe we don't need tuples

1539775296
Hejsil
If we could deconstruct structs, then we have multiple return values and inferred structs could (in theory) do what tuples do for varargs (a little more verbose)

1539775312
very-mediocre
I like that, if only as a thought exercise

1539775404
Hejsil
I'll give this some thought. One of the goal of Zig is "only one obvious way to do things" after all

1539775447
very-mediocre
Is there a reason why structs that have the same fields are not considered equal?

1539775583
Hejsil
Same name+type yes?

1539775593
very-mediocre
Yeah

1539775671
Hejsil
Their might be two structs which have the same fields, but which mean different things

1539775688
Hejsil
I can't really think any other reason

1539775714
very-mediocre
OK. Sorry for bashing you on the head with this btw

1539775724
Hejsil
Np, lol.

1539775725
very-mediocre
I'm an insufferable debater, I debate everything infinitely.

1539775747
Hejsil
If we think of structs, and kinda the same a enums, it make sense

1539775772
Hejsil
const FireNuke = enum.{Yes,No}; const CleanHouse = enum.{Yes,No};

1539775783
Hejsil
These enums should probably not be equal

1539775789
very-mediocre
Yeah, you're right.

1539775795
very-mediocre
Should be the same for structs then.

1539775805
Hejsil
Well, maybe not, but this is how I see it

1539775813
Hejsil
Structs have a lower chance of collision

1539775816
very-mediocre
Allows the compiler to prevent the programmer from using weird types, it makes the code harder to read

1539775910
very-mediocre
It would probably be harder to read if someone passed `FireNuke.Yes` to a something that took a less nukey enum type, say, GoToSleep with .{Yes, No}

1539775921
very-mediocre
I can envision similar situations for structs.

1539776050
MajorLag
I had a crazy idea a while back to unify struct/union/enum into a namespace type. You could just arbitrarily declare reular fields (struct), alternate views of them (union), and constants (enum) in one block. Adding tuples to that would just mean allowing fields to be indexed by declared position I suppose. Probably not actually a helpful way to do things though.

1539776078
very-mediocre
>crazy idea -> my favorite kind of idea :)

1539776274
MajorLag
Come to think of it, inferred structs and accessing struct members by index is all you need to replicate a tuple. Maybe we don't need a special type?

1539776287
Hejsil
^

1539776291
Hejsil
Good point

1539776328
Hejsil
Or, well. You'd have to call warn like this: warn("{}{}", .{.a = u8(1). b = " " })

1539776345
Hejsil
And you don't need to have indexing on structs, as we have @field

1539776354
Hejsil
+ @typeInf

1539776360
MajorLag
ok, so you also need anonymous position-only fields... at that point maybe a special type is better.

1539776424
Hejsil
Or maybe not. Maybe this is better: warn("{a:x}, {b:x}", .{ .a = u8(0), .b = u8(1) })

1539776441
Hejsil
Free named position independed fmt

1539776448
MajorLag
hmmm

1539776461
Hejsil
You just can't call warn without the names

1539776476
Hejsil
But this is easier to read and debug

1539776494
very-mediocre
MajorLag: the problem is iirc zig might reorder struct fields internally

1539776507
MajorLag
actually you could still call warn without the names, because you can get the fields by position from `@typeInfo`

1539776536
MajorLag
I don't think reordering is an issue, indexing by position would be against the declared position.

1539776553
MajorLag
which typeInfo already does I think.

1539776587
very-mediocre
Well I agree wholeheartedly then with this, it's kind of what i was saying, they are really all the same thing

1539776610
very-mediocre
a struct is just a tuple with named field accessors

1539776648
very-mediocre
and an array is a tuple with the same field types

1539776665
MajorLag
right, the real question is "are they different enough that it's useful to separate the concepts"? I'm honestly not sure.

1539776677
very-mediocre
Yeah, that's exactly the question that's driving me crazy

1539776703
very-mediocre
and so far I have spared the chatroom another argument that is now a dead horse

1539776715
very-mediocre
interfaces.

1539776745
MajorLag
well that one does have a 49-post thread already.

1539776759
very-mediocre
Yep, but it ties into structs/tuples

1539776770
Hejsil
I've removed the tuples from my notes and incorporated the idea discussed here:

1539776810
very-mediocre
One point of annoyance is if a library that exposes a function that takes a [4]u8 param for example, and you want to use it with another library that has the relevant data represented as a tuple with 4 values...

1539776816
very-mediocre
or a struct...

1539776832
very-mediocre
Some forms of interfaces can address that.

1539776920
euantor
Nim's idea of concepts is a pretty nice way to solve that

1539776938
euantor


1539777119
MajorLag
My own though, detailed in the thread, is that we can just pass an `fn(type)bool` to `var` which can determine the suitability of a type using arbitrary inspection. `const isIterator = trait.hasFn("next"); fn func(iter: var<isIterator>) void {}`; No new language constructs, just a small extension to var.

1539777123
very-mediocre
Hejsil: having field names for warn sounds good, but for some uses wouldn't you want it the passed thing to be iterable?

1539777178
very-mediocre
MajorLag: that's awesome

1539777203
very-mediocre
I had similar thoughts when reading that Concepts link

1539777216
very-mediocre
since comptime is a thing in zig

1539777221
Hejsil
very-mediocre, have an example. Not sure i understand

1539777282
Hejsil
Also, what is your github handle. I wonna post this counter proposal, and give credit :) (MajorLag too, but I'm pretty sure you are @tgschultz)

1539777298
MajorLag
yes, I am the infamous @tgschultz

1539777331
very-mediocre
Hejsil: I meant: `warn("{b} {a}", .{ .a = u8(1), .b = "yo" });` <-- the ability to use .a and .b here in the warn function is great, but for things other than `warn` it's unnecessarily verbose to have to write .a and .b

1539777367
very-mediocre
I'm nodefish on github

1539777427
Hejsil
That is true

1539777448
Hejsil
We can't have our cake and eat it too

1539777503
MajorLag
Allowing structs to have unnamed, position-index-only fields could get weird. I think that's the strongest argument for a separate tuple type.

1539777526
MajorLag
But then all it really does is save some verbosity, so... I dunno.

1539777550
very-mediocre
If we "zoom out" we can think of all of these things as dictionaries

1539777563
very-mediocre
perhaps you could declare a struct like

1539777579
very-mediocre
{ .a = u8(1), u8(5) }

1539777583
very-mediocre
and have the second field be at index 1

1539777597
very-mediocre
but this is somewhat scary for readability

1539777638
very-mediocre
it also makes structs iterable, which I don't know if that's cool or horrible

1539777671
MajorLag
To be fair, they already are via `@typeInfo`. My arbitrary type I/O code relies on it.

1539777697
very-mediocre
hm right, but then there is implicit behavior that is somewhat against the zen of zig if structs are directly iterable

1539777789
very-mediocre_
(disconnected) e.g. if you have a struct that is basically a tuple (arraylike set of data), you'd want to iterate through the data fields only but not any methods

1539777871
MajorLag
well....maybe they don't have to be directly indexable like an array. The meta code for implementing a fieldIndex function isn't bad. We could prvide that in meta.zig, then we just need a way to have unnamed struct members I think.

1539778000
very-mediocre_
I hope the user experience wouldn't end up like the infamous

1539778904
very-mediocre
MajorLag: upon further reflection, I really like what you proposed for "Concepts"

1539778919
very-mediocre
passing a constraint function would be great.

1539778931
MajorLag
thanks. I thought it fit the zen pretty well.

1539778959
Hejsil
I agree too. It's pretty good

1539778963
very-mediocre
It's also very close to the various shenanigans people have been doing to try and make interfaces happen

1539778977
very-mediocre
in the sense that it's an arbitrary comptime check

1539778991
very-mediocre
so it's a nice natural conclusion to that thought process

1539779044
very-mediocre
and it opens up doors for things like interfaces should users want them.

1539779205
Hejsil
One can even define constraints that works on multible args: fn add(a: var, b: var<canAddWith(a)>) AddResult(a, b) { return a + b; }

1539779248
Hejsil
Or, it would probably look like this: fn add(a: var, b: var<canAddWith(@typeOf(a))>)

1539779294
very-mediocre
euantor dropped that Concepts link just in the nick of time :)

1539779309
very-mediocre
and saved us all from the impending interface discussion

1539779323
very-mediocre
Hejsil that is awesome

1539779375
very-mediocre
I hit a brick wall previously trying to do something like this in totally the wrong way

1539779404
very-mediocre
my idea for interfaces was to be able to write functions like, IsAShape, which returned a union type of all implementers

1539779446
very-mediocre
and thus you'd be able to pass, say, a boxed Circle and then unbox it in the function body

1539779472
very-mediocre
alas, this doesn't work because you can't use `comptime var` in the top level context so such a union is impossible.

1539779523
very-mediocre
MajorLag's idea removes the need for a "parent type" to be generated at comptime (whether interface or abstract class), which is impossible

1539779572
very-mediocre
so you should write a proposal :)

1539779623
Hejsil
He mentioned it here:

1539779624
Hejsil
:)

1539779654
very-mediocre
Should be a separate proposal probably

1539779667
very-mediocre
It opens up interfaces and varargs and probably many other things

1539779687
MajorLag
Maybe I'll put something together later today if my workload is light enough.

1539779723
very-mediocre
Get a couple more opinions first maybe, I can never tell if my judgment is crazy or not :)

1539779735
very-mediocre
but I have to say I would really like to use that feature in code.

1539779948
Hejsil
I like how the Zen of Zig basically says "you can't solve every usecase with a new feature, because we wonna be simple". It forces people to be creative and come up with simple and orthogonal concepts

1539780244
Hejsil
Maybe var should always take a parameter: fn a(b: var<any>) void

1539780308
very-mediocre
Hm, can't think of any reason why not actually

1539780351
very-mediocre
that elevates `var` to the same level of strictness as normal function params

1539780392
Hejsil
A good reason for this, is that the default should not be the hardest to reason about.

1539780410
Hejsil
With var<something>, nothing is the default, and the user have to choose

1539780494
very-mediocre
yeah that makes sense

1539780578
Hejsil
Going even further, maybe paramter types can be of type `type` or `fn(type)bool` :)

1539780589
Hejsil
Removing var completly

1539780609
Hejsil
But that might be weird

1539780617
very-mediocre
wouldn't that indicate that you're passing a function as the param, rather than it being a comptime checking function?

1539780661
Hejsil
No. @typeOf(fn(type)bool) == type. @typeOf(canAdd) == fn(type)bool

1539780688
Hejsil
So far, params look like this fn f(name: any_expr_evaluating_to_type)

1539780703
Hejsil
fn f(name: <type>) this for short

1539780720
Hejsil
I propose this: fn f(name: <type or fn(type)bool>)

1539780739
Hejsil
So an expression that evaluates to fn(type)bool

1539780743
very-mediocre
I see

1539780758
Hejsil
But it was hard to explain, so it's probably hard to understand

1539780772
Hejsil
So, maybe var<func> is better

1539780777
very-mediocre
Yeah it is

1539780783
very-mediocre
@typeOf(fn(type)bool) == type <--- this is not intuitive

1539780786
MajorLag
I think var<fn> communicates clearly that the parameter is a comptime-variable type. I don't think that is the case with a naked fn.

1539780796
Hejsil
Agreed

1539780804
Hejsil
Was just throwing it out there

1539780896
Hejsil
@typeOf(fn a(T: type) bool {}) == fn(type)bool. @typeOf(fn(type)bool) == type. @typeOf(type) == type (I think)

1539780956
very-mediocre
This flies over my head somewhat

1539780967
very-mediocre
I don't get this: @typeOf(fn(type)bool) == type

1539781000
MajorLag
`fn(type)bool` is a type. It's the type of a function that takes a type parameter and returns a bool.

1539781012
very-mediocre
ah, a type of a function is a type?

1539781026
very-mediocre
OK, I am grossly unfamiliar with some of zig's type system

1539781040
very-mediocre
Spend too much time getting brain damage from legacy PHP codebases :)

1539781047
Hejsil
Lol

1539781108
Hejsil
i8, []u8, struct{}... all have @typeOf() == type

1539781114
Hejsil
This is how Zig generics work

1539781119
very-mediocre
Yes that I know

1539781121
euantor
Looks like I dropped that link just in the nick of time before I went out for lunch

1539781164
very-mediocre
brainstorming is an art

1539781189
very-mediocre
it's like those moments in that old TV show "House" where he figures out the diagnosis while doing something unrelated

1539781212
very-mediocre
Just seeing the word "Concepts" made me think back to the interface shenanigans i was doing

1539781245
very-mediocre
(in a different way, otherwise I might have reopened the existing interface discussion)

1539781347
euantor
Nim has hit some stumbling blocks along the way to implementing them, but they did start implementing them fairly late in the game

1539781461
very-mediocre
Nim is so in flux all the time, you'd think I designed it

1539781494
very-mediocre
(being an insufferable "devil's advocate)

1539781515
very-mediocre
It's gonna be cool when it hits 1.0 if they manage to cut out a lot of the fat

1539781568
very-mediocre
last time I checked there were a lot of incongruent ideas in Nim

1539781598
very-mediocre
some really good ones, but at some point they need to coalesce into a language.

1539781652
euantor
I've written a fair bunch of Nim code, but I'm hedging my bets between it and Zig

1539781693
euantor
Nim has some nice features, but things keep changing constantly - such as the now pivot towards destructors and such rather than GC

1539782315
Hejsil
You can quote me on this: "A programming language cannot be turning complete, if you cannot write an ugly hack in it"

1539782358
Hejsil
(I really hope this is true, or I'll look stupid) :)

1539782804
very-mediocre
define "ugly hack"

1539782905
very-mediocre
If you were a mean person, you could make a killer comeback here

1539782958
Hejsil
Well, that can be debated (ugly hack) :)

1539782983
Hejsil
Ooh, i get the second one now

1539783016
very-mediocre
:)

1539783106
Hejsil
Hmmm. That make me think. Could you "breed" programs :)

1539783115
Hejsil
made*

1539783179
Hejsil
"Breeder program": Takes two programs, and makes a third one

1539783193
very-mediocre
Hejsil, I think it's time for the talk

1539783202
Hejsil
Lol

1539783215
very-mediocre
You see, when a compiler loves a userland program very much...

1539783241
Hejsil
No, you stop that!

1539783244
Hejsil
I was more think, compiled programs :)

1539783273
Hejsil
And if "Breeder" somehow outputs a "working" program, that is probably an ugly hack

1539783331
very-mediocre
The Breeder would qualify as a compiler

1539783336
Hejsil
True

1539783352
Hejsil
Hmm. I guess there is no reason that the inputs should be compiled

1539783362
Hejsil
Hold op

1539783366
Hejsil
Gcc is a breeder

1539783388
Hejsil
All compilers are breeders (if the can compile more that one file)

1539783441
Hejsil
I should probably just leave

1539783444
very-mediocre
lol

1539783456
very-mediocre
stick around, you're making me look good

1539783472
Hejsil
Idk if that is a good thing

1539783472
very-mediocre
not an easy feat!

1539783509
Hejsil
git merge, is a breeder

1539783516
Hejsil
I'm done now

1539783592
Hejsil
I take back this: "that is probably an ugly hack"

1539783638
very-mediocre
it was valid when you had binaries in mind maybe

1539783752
andrewrk
Hejsil, I think that destructuring structs based on variable names is problematic given that we don't allow shadowing

1539783784
Hejsil
andrewrk, I was thinking in terms of position and not name

1539783798
andrewrk
ahhh ok

1539783808
andrewrk
I misread your comment

1539783935
andrewrk
Hejsil, ok now I'm thinking about how easy it would be to re-order fields and introduce a bug

1539783960
Hejsil
We can never win, can we? :)

1539783984
andrewrk
I like that you solved all the important use cases without tuples

1539783989
andrewrk
I think you're on to something here

1539784016
Hejsil
Well, MajorLag and very-mediocre where very helpful on this one

1539784028
andrewrk
indeed - I read the log

1539784039
andrewrk
so multiple return values from a function/block would be a struct, in order to get mixed types, yes?

1539784052
Hejsil
Yes

1539784091
Hejsil
And, most of the time, names are more useful than no names. fn findMinMax() struct{min: T, max: T} is better than using a tuple

1539784110
andrewrk
agreed

1539784122
Hejsil
Maybe we don't even need deconstructing of structs

1539784130
andrewrk
I'm completely with you in that we'd rather not have tuples, we just have a handful of important use cases

1539784131
Hejsil
Or...

1539784156
Hejsil
var a, const b = .  requires deconstructing

1539784182
andrewrk
I think the printf example with the struct initializer is adequate - just at the boundary of "too much API friction" but not quite over the line yet

1539784264
Hejsil
When you need to format many values, my proposal even outshines it's friction because the fmt string can refer to names

1539784265
andrewrk
the goal with multiple return values is to avoid use of `undefined`

1539784269
Hejsil
Which helps readability

1539784277
andrewrk
agreed

1539784305
andrewrk
an API which is more cumbersome to type, but handles even the complicated cases the same way as the simple ones, is in line with zig's philosophy

1539784339
Hejsil
I'd say multiple return values also allows const variable to actually be const, which I think is important

1539784350
Hejsil
Because "communicate intent"

1539784363
andrewrk
yes that's important too

1539784384
andrewrk
I wonder if just having anon struct initializers would solve the multiple block return value use case

1539784401
andrewrk
because they can have runtime values

1539784424
andrewrk
just return an inferred literal from a block and then access the fields. why does there need to be 2 variables?

1539784455
andrewrk
s/inferred literal/anonymous struct initializer/

1539784468
Hejsil
Idk the name of this feature either :)

1539784498
Hejsil
anonymous initializers/inferred initializer/anonymous literal/inferred inferred literal

1539784532
Hejsil
The only usecase i can think of is const a, var b =

1539784536
andrewrk
ah right

1539784548
andrewrk
that's a good point

1539784554
Hejsil
But maybe that is so rare, that it is not worth it

1539784600
Hejsil
Also @Manuzor just posted an interesting syntax for return types: fn sum(a: i32, b: i32 -> i32) { return a + b; }

1539784897
andrewrk
hm that is indeed interesting

1539784961
Hejsil
We could have used these proposals before I changed everything :)

1539784978
Hejsil
But then again, a git revert, could probably fix most of it back

1539785082
andrewrk
Hejsil, now you see why I was personally putting that change off :)

1539785089
andrewrk
I'm not going to get in your way though!

1539785120
Hejsil
I don't think people would have gotten all these great ideas without me ruining Zig for them :)

1539785153
Hejsil
My change sparked the discussion!

1539785159
Hejsil
It makes Zig better in the end!

1539785169
andrewrk
:)

1539785178
Hejsil
Even if MajorLag will have to change all his code again!

1539785184
andrewrk
it was for great justice

1539785188
Hejsil
Indeed

1539785205
bheads
If we did this would we be able to define the struct in the return?  fn foo() struct.{min: i32, max: i32} {}

1539785216
very-mediocre
It was to move zig

1539785234
Hejsil
bheads, pretty sure we can already do this

1539785253
Hejsil
The problem was always error sets and initializers

1539785258
andrewrk
yeah that already works, the problem is that we don't have anon struct initializers

1539785260
Hejsil
Never struct/union/enum decls

1539785280
andrewrk
so you have to name your anonymous struct in the initializer which defeats the point of it being anonymous

1539785293
Hejsil
This too ^

1539785313
bheads
okay, so would we get that with the innfered initilizer

1539785319
Hejsil
Yes!

1539785321
andrewrk
Hejsil, what if we have anon array initializers but no tuples

1539785342
andrewrk
var a, const b = blk: {  break :blk .{expr1, expr2} };

1539785360
Hejsil
What happens if we pass that to var?

1539785371
andrewrk
segfault

1539785373
Hejsil
Or stores it: var a = .{expr1, expr2}

1539785374
andrewrk
just kidding. it would work

1539785374
Hejsil
Lol

1539785402
Hejsil
How would that work with multiple different types.

1539785444
bheads
it would have to be a struct then

1539785450
bheads
maybe a default naming

1539785464
Hejsil
I don't think default naming is a good idea

1539785478
very-mediocre
or indexable structs, which brings us full circle to the whole convo today

1539785478
bheads
then you would have to name the,

1539785485
Hejsil
We don't want this to work: const a: struct.{a: u8, b: u8} = .{1, 2};

1539785495
andrewrk
agreed

1539785555
very-mediocre
Why is it bad that you have to name them

1539785565
very-mediocre
Hejsil argued above that named is better than unnamed for mixed data

1539785575
andrewrk
Hejsil, it could be a "tuple" type in the same way that a "comptime_int" has to have its value known (and the value is not in the type), it has to have its member types known, but they are not in the type

1539785627
bheads
extra verbose is all

1539785639
andrewrk
very-mediocre, it's bad that you can re-order struct fields and cause bugs accidentally

1539785644
Hejsil
Hmmmm. Seems like we just got varargs back, but used in a different place

1539785674
Hejsil
(the implementation that is)

1539785677
very-mediocre
andrewrk: such re-ordering would be explicit though

1539785699
very-mediocre
it applies to anything ordered and named, such as function params

1539785704
bheads
plus if this is used to replace varargs, you now have to name all of the args

1539785729
andrewrk
very-mediocre, how would you destructure a struct into variables?

1539785753
very-mediocre
ok, for destructuring you have a point

1539785779
andrewrk
destructuring structs is ok, but the destructuring syntax has to redundantly say which fields they're getting and not just rely on position

1539785962
Hejsil
Maybe destructuring is just a bad idea. Unless we do it with field names, there is no way to catch the bug where two fields changed order

1539786021
very-mediocre
could varargs allow one to pass arrays or structs?

1539786043
Hejsil
pass them where?

1539786082
very-mediocre
bheads wrote: `plus if this is used to replace varargs, you now have to name all of the args`

1539786112
very-mediocre
i figure in the use case where you'd use a tuple, you'd instead use a struct

1539786116
very-mediocre
and in other cases an array

1539786137
Hejsil
Ye, that's probably the plan

1539786177
very-mediocre
so you'd have to name the fields only in the tuple-esque use case (struct)

1539786183
very-mediocre
maybe that's not so bad.

1539786220
bheads
in may cases the name is meaning less

1539786227
bheads
the position is what is in portant

1539786247
bheads
like a join function

1539786250
very-mediocre
if you're returning data as a bundle, is it not related data?

1539786277
Hejsil
join would use []const u8 and .{"a", "b"}

1539786294
Hejsil
So no names here, as we can accept an array

1539786308
Hejsil
varargs usecase is printf

1539786326
bheads
why does join only join strings?

1539786341
Hejsil
Well :)

1539786343
Hejsil
That depends

1539786347
Hejsil
what are you trying to join

1539786354
bheads
all base types

1539786368
bheads
numbers string arrays of strings

1539786374
very-mediocre
good point, that's a tuple, straight up. :/

1539786377
Hejsil
Well, wouldn't you use format for that

1539786395
bheads
no cause my join sends it over a socket :)

1539786417
Hejsil
Then implement fmt to send over the socket :)

1539786428
andrewrk
you can already do that with OutStream

1539786444
bheads
the goal of the function is not important, I want a vararg that I will iterate over

1539786464
bheads
with mixed types

1539786475
Hejsil
Well, we have to figure out if such a function would ever exist in code

1539786476
Hejsil
A usecase

1539786492
very-mediocre
MajorLag suggested earlier that a userland function can be provided for iterating over struct fields

1539786501
Hejsil
^

1539786515
very-mediocre
I don't know if I like that though.

1539786556
Hejsil
That's how warn/fmt would be implemented with the latest proposal on removing varargs

1539786565
andrewrk
I think the "typeless tuple" idea is worth exploring

1539786590
bheads
so on fmt you would have to name all of the fields

1539786617
Hejsil
That's what is discussed now at least

1539786620
Hejsil
Nothing is final

1539786653
Hejsil
andrewrk, as a replacement for varargs, or for multiple returns?

1539786662
Hejsil
Isn't varargs a tuple?

1539786685
Hejsil
I think we'll end up with the same implementation if we go the "typeless tuple" idea

1539786693
Hejsil
as varargs that is

1539786717
Hejsil
But idk, I don't have the full picture of this "typeless tuple" thingy

1539786739
bheads
So far the only ligit purpose of mixed types if printing functions

1539786753
bheads
not having tuples in most languages has really limited our imaginations

1539786785
very-mediocre
it feels wrong to have mixed types in most cases

1539786790
very-mediocre
maybe it's even "wrong" for printing ultimately

1539786799
very-mediocre
are you printing a uint, or a u8 representation of a uint?

1539786818
very-mediocre
maybe it's the programmer's responsibility to provide an array of u8s to print

1539786823
very-mediocre
instead of a mixed list.

1539786853
bheads
I dont think so, cause you then end up with lots of extra temp memory at the call site

1539786856
Hejsil
very-mediocre that would require the construction of a string. fmt does not do this

1539786880
very-mediocre
I mean it's the programmer's responsibility to pass pre-converted items to the print function

1539786913
bheads
you also lose some memory optimization

1539786922
very-mediocre
yeah, but it feels more "right" despite running worse

1539786935
Hejsil
Idk about that

1539786944
bheads
well haskell reels right sometimes

1539786951
bheads
doesnt mean its good

1539786964
very-mediocre
I just find it weird that the print function has to care about converting the params it receives into something printable

1539787001
bheads
then call print(fmt(... ))

1539787024
very-mediocre
that's my point, then you don't need mixed lists

1539787036
very-mediocre
what you pass to print is an array of []u8

1539787055
Hejsil
Sadly, what we like, and what is efficient/fast is different, and certain systems have to care

1539787057
bheads
you do if you want to optimize the fmt

1539787154
very-mediocre
ok so conversely, then, are we sure mixed lists of things are only useful for printing?

1539787178
bheads
thats the only good use case I have found so var...

1539787193
bheads
lots of code uses tuples as annon structs...

1539787208
bheads
which is bad

1539787222
bheads
so yeah I do think we want that

1539787226
bheads
I dont****

1539787310
bheads
maybe tuples are a bad idea

1539787471
very-mediocre
somehow everything is really just contiguous memory, yet no one representation really nails it

1539787507
bheads
humm, most tuples are strong const

1539787541
andrewrk
if it works, then printf looks roughly the same as today, and it gets us multiple block values, and it isn't really an alternative to structs

1539787541
andrewrk
so there's no cognitive dissonance

1539787580
bheads
I can live with naming the fields for print and fmt

1539787591
bheads
it has some benifits

1539787644
bheads
I was tring to thing of a cases where you only cared about the order, but cant think of any that are mixed types

1539787759
very-mediocre
I guess if there is associated data that isn't part of the "concept" of what the main return value is

1539787778
very-mediocre
yet is associated somehow, e.g. an error

1539787799
bheads
zig already has a better what to deal with errors

1539787802
very-mediocre
you don't really want to pollute your returned struct with that field

1539787813
very-mediocre
yes I know, but let's say "errorlike" things are not always zig errors

1539787820
bheads
so warnings

1539787820
very-mediocre
say a return status from an XmlHttpRequest

1539787835
bheads
right but you would always have that

1539787838
bheads
and what that

1539787842
very-mediocre
you don't want it to pollute your data struct

1539787863
bheads
but you would

1539787879
very-mediocre
say your data struct is a Model in MVC

1539787881
very-mediocre
then you wouldn't

1539787888
very-mediocre
I mean, sure, you could architect around it

1539787910
bheads
thats an abstraction above the http request, the code that made the request should be checking for a 200

1539787913
very-mediocre
but it's still conceivable that some cases exist that we can't think of that warrant multiple mixed return types

1539787928
bheads
yeah and a struct gives you that

1539787934
very-mediocre
eh I guess.

1539787937
very-mediocre
ok, I tried

1539787943
bheads
yeah I know

1539787944
very-mediocre
I can't think of any mixed data that feels "correct"

1539787947
very-mediocre
lol

1539787953
bheads
thats what I feel right now

1539787965
bheads
tuples finds feel wrong

1539787978
euantor
The response from an XmlHttpRequest would be a XmlHttpResponse struct, with a headers/status field, and a body field

1539787990
bheads
yup and the response code

1539788003
very-mediocre
Yeah, I'd architect it as such. I work with that stuff 24/7 so I know it can be done neatly.

1539788041
very-mediocre
I kind of scrambled to find an "errorlike" type

1539788043
bheads
ugh the OCP framework I maintain puts everything in a java HashMap<String, Object> ....

1539788045
very-mediocre
that didn't fit zig errors

1539788074
very-mediocre
lol

1539788077
very-mediocre
That's JavaScriptesque

1539788083
very-mediocre
everything in JS is an associative array

1539788093
bheads
its lazy 90's java

1539788123
bheads
to many people working on a code base, so no way we can use strong typed data structs

1539788146
bheads
so lets play the guessing game on data stored in the session and pipeline!

1539788189
bheads
also XmlHttpResponse would probably return socket errors for its error types

1539788199
very-mediocre
Yeah, true.

1539788205
bheads
maybe returns errors on 400s or 500s

1539788211
very-mediocre
My example was ill-conceived

1539788221
bheads
I get what you were trying to go at

1539788236
very-mediocre
XmlHttpRequest in js environments does throw errors on 500

1539788242
very-mediocre
there's an onerror handler

1539788247
bheads
right

1539788250
very-mediocre
So, I got nothing

1539788254
very-mediocre
I don't know when you'd use mixed data.

1539788269
bheads
so far formatting is the only good use case...

1539788321
very-mediocre
I can't unsee how "wrong" it is now, that the print function needs to know what a struct is, what a u32 is, etc

1539788329
bheads
most cases you want them to be the same type

1539788448
very-mediocre
the few cases that come to mind use dynamic memory

1539788458
very-mediocre
and they are bad designs

1539788837
bheads
I think if we got innfered initilizers for arrays, struct, unioms, and enums we can remove varargs and we would get multiple return types

1539788875
bheads
return syntax may need to be tweaked

1539789656
very-mediocre
maybe really crazy idea: add tuples but they must be mixed

1539789729
very-mediocre
this avoids the problem of 1 api using an array while another uses a tuple to represent the same thing

1539789768
very-mediocre
although they still overlap with structs...

1539789778
very-mediocre
ok, I'm done for now.

1539789835
bheads
lol

1539791432
bheads
I wonder if the usage of var tp say you want a "tuple

1539791439
bheads
will be a problem

1539791470
Hejsil
You mean this? fn a(b: tuple) void

1539791506
bheads
well I though there were example of  warn(fmt: []u8, args: var) void {}

1539791516
Hejsil
I think, with something like MajorLags proposal for var, we can have this instead: fn a(b: var<isTuple>) void

1539791532
bheads
ah is that for the interface work

1539791558
Hejsil
Ye, i like MajorLags idea for this. Again, nothing final, but it looks good

1539791566
bheads
my assumption is the isTuple is a comptime function checking the type

1539791571
Hejsil
Yea

1539791582
bheads
nice

1539791616
bheads
very simular to D's static ifs

1539791639
bheads
thats just a more compact and parameter focued version

1539791705
bheads
would b: const<isTuple> also make sense?

1539791722
Hejsil
what would that do?

1539791735
bheads
same but b is const in the function scope

1539791754
Hejsil
B is already const in function scode (if it is a parameter)

1539791763
Hejsil
b*

1539791791
bheads
using var for const is confusing to me

1539791817
Hejsil
Oooh, right. var in functions is different from var on variable decls

1539791825
bheads
yep

1539791829
bheads
its mean changes

1539791837
bheads
meaning***

1539791850
bheads
I really need to slow down my typing.

1539792022
bheads
in fact the more I think about, I am not sure what is and isn't const in params

1539792035
Hejsil
Everything is const in paramters

1539792074
Hejsil
fn a(b: u8, c: *u8) is basicly this: fn a(const b: u8, const c: *u8)

1539792110
bheads
I need to do a test

1539792203
bheads
nice, I have been using zig so far and never ran into that error...

1539792234
bheads
I guess that means I have been following good programing practices and didn't even notice

1539792241
Hejsil
:)

1539792353
bheads
okay then so the only odd things is that var has two meanings, but thats minor

1539793308
tolitius
is it ok to ask 101/beginner questions here or there is a better channel/way?

1539793613
Hejsil
tolitius, go ahead. Here is probably the best place to ask :)

1539793777
tolitius
great, thanks. I going through the doc examples and the first struct ("const Timestamp = struct {...}") from "Doc comments" section does not compile:

1539793780
tolitius
error: expected token '.', found '{'

1539793788
tolitius
const Timestamp = struct {

1539793789
tolitius
^

1539793823
tolitius
$ zig version

1539793824
tolitius
0.3.0+eeb4f376

1539793838
bheads
Thats a new change that went live yesterday in the master branch

1539793841
tolitius
probably something really elementary

1539793846
bheads
you need to put a . there

1539793851
bheads
struct.{.. }

1539793851
Hejsil
Aaah right. The website has not been updated to newest syntax

1539793855
tolitius
ah.. k, so the docs are not updated?

1539793857
Hejsil
andrewrk!

1539793876
Hejsil
We have them updated locally, but it just needs to be put on the site

1539793888
tolitius
got it

1539793899
tolitius
why the '.'?

1539793924
bheads


1539793927
Hejsil
But yeah, struct/enum/union/error containers changed. You have to have <container>.<body>

1539793958
bheads
syntax ambiguity

1539793966
tolitius
I see, looks like I have to also do

1539793969
tolitius
"return Timestamp.{ .seconds = 0, .nanos = 0 }; "

1539793975
bheads
correct

1539793975
Hejsil
Indeed

1539793977
tolitius
when creating it

1539793993
tolitius
great, thank you

1539794039
bheads
I thought the docs online got auto deployed

1539794474
tolitius
should I open an issue about auto deployable docs (as my first contribution? :) )

1539794493
tolitius
or this is just a glitch

1539794634
Hejsil
Might as well

1539794648
Hejsil
Open an issue that is

1539795272
tolitius
done: #1660

1539796645
tolitius
is there a way to have assert show what the actual value was on failure?

1539796673
tolitius
i.e. "assert(foo == 42)" just says foo was not 42, but does not say what it was

1539796778
Hejsil
No. Using a debugger is probably your best option

1539796860
very-mediocre
you could implement something similar to JS test frameworks

1539796906
very-mediocre
e.g. assert(something).toEqual(42)

1539796924
very-mediocre
you'd have to add types using generics though

1539796955
Hejsil
True, but a debugger is probably easier to do :)

1539796968
very-mediocre
yep. :]

1539797074
tolitius
I see, was curious if it's in the language itself. will go with what's built in, this is not really a problem just "would be good to have" since the runtime knows the value anyway

1539798590
ltr_
hello everyone, im trying to compile zig against libc++ but im stuck with errors about cmath functions/symbols not defined, ie. isfinite, anyone had a similar error?, it is not related with zig it self but i want to know if it is common.

1539803722
Jenz
What's the zig equivalent of e.g. gcc -D foo=bar ?

1539805917
bheads
Jenz, maybe your looking for this?

1539806379
Jenz
Ah, yes quite, thanks bheads

