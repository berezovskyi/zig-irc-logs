1523840270
GitHub110
[zig] alexnask opened pull request #925: Added ReleaseSmall mode. (master...release_small)

1523840892
andrewrk
alexnask, does it have an effect on your test case?

1523840932
alexnask
with the SizeLevel set to 2, it does, yes

1523840945
andrewrk
neat, how much?

1523840952
alexnask
E.g. a sample application that calls std.debug.warn goes from 13 KB to 10 KB

1523840960
andrewrk
cool

1523840968
andrewrk
PR looks good, I'm happy to merge this as soon as it passes the tests

1523840997
alexnask
Should really have tested before opening the PR :P

1523841871
JinShil
Hello, I just found Zig through

1523841898
JinShil
However, one thing that I couldn't find covered in the documentation was Zig's answer to code reuse.

1523841969
JinShil
I like programming in D primarily because of its modeling, code reuse, and metaprogramming features (mixins and templates specifically)

1523841985
JinShil
It probably the primariy reason I don't care for Rust.

1523842080
JinShil
I like Zig's approach to simplicity, but how can we achieve great code reuse in Zig the way it can be achieved through inheritance, mixins, and templates in other languages.

1523842082
JinShil
?

1523842103
andrewrk
hi JinShil

1523842168
andrewrk
it sounds like you're asking about language features rather than package managers

1523842187
JinShil
Yes, I'm not looking for libraries if that's what you mean.

1523842229
andrewrk
I'm not sure I understand the question

1523842266
JinShil
I want to be able to easily mix in (for lack of a better word) features of one struct in another without having to rewrite functions and such to forward calls to an encapsulated struct.

1523842272
JinShil
At tleast that's one use case.

1523842296
andrewrk
oh I see. you're specifically asking about inheritance (or similar)

1523842325
JinShil
Yeah, not specifically inheritance, but something that allows me to reuse code.  Inheritance is just one feature.  There are many others.

1523842335
JinShil
Consider the issue being discussed here for Rust:

1523842337
andrewrk
you could put code in a function to allow reuse

1523842406
andrewrk
I don't mean to be difficult

1523842418
andrewrk
it sounds like there is a very specific use case you're referring to and I'm trying to understand what that is

1523842430
JinShil
No worries.  I appreciate you engaging me.

1523842445
andrewrk
here is one pattern:

1523842453
JinShil
Trying to think of a way to better articulate my thoughts.  Thinking...

1523842470
andrewrk
"child" classes of Node have the field `base: Node` in them

1523842519
JinShil
studying the code...

1523842528
andrewrk
it's something you can do in C

1523842544
alexnask
@JinShil Are you looking for something like Rust traits?

1523842597
JinShil
Rust traits are more like interfaces IMO.  I'm looking for way to reuse implementation code, not just signatures.

1523842605
JinShil
Just a moment.  I will show you a good example...

1523842638
alexnask
Ah, so for example in D you would mixin a bunch of methods in your structs

1523842652
JinShil
Yeah, take a look at this:

1523842662
JinShil
It's like ineritance without classes.

1523842725
JinShil
You can see how it's "mixed in" to a "derived" struct here:

1523842771
JinShil
Just one statement and you get all the fields, methods, etc... of the base, and you can even override some features of the base with the vtable implementation.

1523842791
alexnask
right, you could do much of the same but I don't think there is any way to mixin additional bits of AST (at least yet)

1523842827
alexnask
So that you can automatically generate the required methods and vtable bindings

1523842838
andrewrk
so Missile gets the RigidBody functions?

1523842848
andrewrk
and fields

1523842884
alexnask
Actually, I think auto constructing the vtable may be possible but making the wrapper functions to call into it can't I thin

1523842893
andrewrk
what's the difference between that and having rigid_body be a field of Missile?

1523842912
JinShil
Yeah, right.  It gets all the functionality of RigidBody, and the methods can even be overridden in Missile

1523842930
andrewrk
ability to override stuff

1523842988
JinShil
The difference is encapsulation (you don't have to expose the RigidBody as a field of Missile, and if you do choose to encapsulate RigidBody, you don't have to write all the methods that simply forward to RigidBodies members.

1523843029
JinShil
I guess what would be nice is some way to do the following 3 things:

1523843043
JinShil
1. Add Rigid Body as a child of Missile.

1523843053
andrewrk
you wouldn't have to write all the methods if it was a field - you'd use a pointer to the rigid_body field where a RigidBody was required, and use @fieldParentPtr to get the Missile ptr from a RigidBody ptr

1523843057
JinShil
2.  Automatically expose all public methods of RigidBody in Missile

1523843083
JinShil
3.  Override methods of RigidBody in missile.

1523843119
andrewrk
here's the relevant issue to track:

1523843145
JinShil
Yep that's it.  Will keep an eye on it.

1523843165
andrewrk
I won't close it until I've written a GUI in zig

1523843172
alexnask
noice

1523843180
JinShil
Yes, GUI would be a great use case.

1523843205
andrewrk
fair warning though: my goal is to make a GUI without having to add a language feature, and then triumphantly close the issue

1523843213
andrewrk
but I'll keep an open mind

1523843214
JinShil
haha

1523843514
JinShil
Ok, based on your answers, I'll assume that Zig doesn't have much more than what C provides for this use case.  It appears others are trying to influence you with Rust's traits and Go's interfaces.  Add me the queue with D's mixins :-)

1523843521
alexnask
@andrewrk The PR now passes the tests btw

1523843529
MajorLag
move.zig was inspired by a Java library, so it has tended towards an oop inheritence-hierarchy kind of structure. That is a bit painful to deal with in zig, but not quite as bad as I'd expected. One thing that has helped is leveraging comptime to create new derivations of a base type with minor changes automatically.

1523843545
alexnask
@JinShil Reflection/reification of types is planned

1523843559
andrewrk
JinShil, your synopsis is correct, and I have noted your queue position :)

1523843569
JinShil
lol

1523843577
andrewrk
MajorLag, I'm guessing @field would help?

1523843581
alexnask
To build types with imperative code at compile time, this covers lots and lots of the mixin usecases

1523843607
andrewrk
alexnask, yeah - @reflect and @reify are planned. That might actually make mixins possible in userland

1523843634
JinShil
Hmm. Is the a proposal for those documented yet?

1523843640
alexnask
Depends of if any declaration can be reified or types only, I don't think it's that clear in the issue

1523843658
MajorLag
For isntance, where Scene2D has a group of Actions like "MoveBy", "MoveTo", "RotateBy", "Fade", etc, I have one implementation: "ChangeAction". ChangeAction is a comptime function that generates a new action type with a comptime parameter list of which variables the action will be changing.

1523843660
andrewrk
JinShil, some of the comments here:

1523843674
alexnask
But if every declaration is possible, then it's as easy as parsing strings into an AST, mapping that into builtin structures and reifying

1523843694
alexnask
And you basically have D mixins

1523843699
andrewrk
in summary: @reflect(T) returns at comptime full information of type T, and @reify(T) is the inverse - it turns a description of a type into an actual type

1523843704
MajorLag
ex: `pub const MoveToAction = move.ChangeAction(Actor, Actor.fromHandle, f32, true, move.MemberList{"x", "y"});`  `pub const ScaleByAction = move.ChangeAction(Actor, Actor.fromHandle, f32, false, move.MemberList{"scale"});`

1523843714
JinShil
Cool!

1523843729
andrewrk
so you could construct a struct at comptime and return that from a function

1523843746
andrewrk
construct a struct *type*, I mean

1523843779
alexnask
@MajorLag Could you link to move.zig please?

1523843789
MajorLag
is @field the one that is meant to allow accessing a struct member by a comptime name-string, or creating a new field in a struct?

1523843801
MajorLag
It isn't public anywhere yet

1523843809
alexnask
It's about the former

1523843833
alexnask
Creating a new field in a struct could be done with @reflect/@reify

1523843858
MajorLag
I use @intToPtr( @ptrToInt + @offSetOf ) for @field right now.

1523843859
GitHub123
[zig] andrewrk pushed 5 new commits to master:

1523843859
GitHub123
zig/master 6492763 Alexandros Naskos: Fixed test build code

1523843859
GitHub123
zig/master 1c85050 Alexandros Naskos: Set SizeLevel to 2 in ReleaseSmall mode

1523843859
GitHub123
zig/master 253ecd5 Alexandros Naskos: Added ReleaseSmall mode

1523843861
andrewrk
alexnask, thanks! congrats on your first PR

1523843862
GitHub2
[zig] andrewrk closed pull request #925: Added ReleaseSmall mode. (master...release_small)

1523843868
alexnask
Thanks :)

1523843932
andrewrk
MajorLag, oh right. I forgot you figured out how to do that. @field will also work for other kinds of field access though, in addition to struct fields

1523843949
andrewrk
essentially it's the `a.b` syntax but the `b` is a comptime string

1523843979
MajorLag
that would come in handy.

1523844217
alexnask
Something like

1523844342
MajorLag
If you have `info`, wouldn't that already have the member counts and names in it? You could just do something like `for(info.members) | member | { if(mem.eql(u8, member.name, name) ...`

1523844351
andrewrk
alexnask, watch out for

1523844353
andrewrk
you're bound to run into it

1523863204
GitHub129
[zig] andrewrk pushed 1 new commit to master:

1523863205
GitHub129
zig/master caefaf7 Andrew Kelley: std.debug: dumpStackTrace & friends use DirectAllocator...

1523866025
GitHub38
[zig] tiehuis closed pull request #921: Add exp/norm distributed random float generation (master...ziggurat)

1523866026
GitHub102
[zig] tiehuis pushed 1 new commit to master:

1523866027
GitHub102
zig/master c7cb5c3 Marc Tiehuis: Add exp/norm distributed random float generation

1523873069
alexnask
I'm getting errors running zig build on windows with the latest master prebuilts

1523873079
alexnask
I'll take a look and find out why

1523873479
Dodo
a really nooby question... how does 'zig init' work?

1523873784
alexnask
Id there an init command? I don't think so

1523873807
alexnask
crinkler doesn't recognize the object files while link.exe does, bummer :/

1523873867
alexnask
Ah well it probably takes 32 bit stuff, woops :P

1523873903
Dodo
zig build --init

1523873931
Dodo
however I dont know what it does ^^

1523873942
alexnask
Ah, I wasn't even aware of that, I assume it creates a simple build.zig file that compiler stuff find in src/

1523873942
Dodo
it creates some kind of 'build.zig' file

1523873945
alexnask
Yes

1523873954
alexnask
By then running 'zig build'

1523873963
alexnask
It will make an executable

1523873972
Dodo
but Im creating a lib ;o

1523874017
alexnask
Sure, instead of addExecutable in your buildzig file you should use addSharedLibrary and everything should run smoothly

1523874026
Dodo
oh :D

1523874053
Dodo
Zig\itertools\build.zig:3:28: error: function with inferred error set must return at least one possible error

1523874058
alexnask
I don't think there are any docs yet, you can take a look at std/build.zig if you want to see what the signatures are

1523874072
Dodo
is that error supposed to pop up?

1523874087
alexnask
Can you post your build.zig file in gist?

1523874093
alexnask
Or pastebin/w.e

1523874148
Dodo


1523874166
Dodo
now I have changed absolutely nothing to the file, maybe I should?

1523874264
alexnask
Let me take a look and I'll get back to you in 2 secs

1523874278
alexnask
Ah, I see, the !void should be void

1523874289
alexnask
Idk why it would generate that

1523874300
alexnask
!void means a return type of (void or error)

1523874309
alexnask
but it never returns an error so the compiler complains

1523874345
Dodo
ew

1523874346
Dodo
hahahaha

1523874380
Dodo
whoa

1523874430
Dodo
without a /src directory, the compiler doesnt like you ^^

1523874588
alexnask
well, your build file looks for ./src/main.zig so.. :p

1523875549
Dodo
"Invalid token: 'var' ": var nxt = iter.next();

1523876062
alexnask
Does anyone know if the bultins and compiler runtime are linked into the object file in build-obj mode?

1523876072
Dodo


1523876122
alexnask
@Dodo I don't think nested functions are supported, the usual workaround is to create an empty struct with your function and use it from there

1523876155
alexnask
Like you could have const Iter = struct {  fn filter(...) { ... } }; then use Iter.filter instead of filter

1523876181
alexnask
You are also missing semicolons on your returns

1523876181
Dodo
mhh

1523876194
Dodo
._.

1523876217
Dodo
its been a long time I've actually written 'return ....;'

1523876226
alexnask
Welcome back to C-style land :p

1523876287
Dodo
and even when I did need to write a return, I mostly could do this:

1523876291
alexnask
Also, why is your iterator of type "type"

1523876321
alexnask
Yes I like the rust-style last expression is returned

1523876336
Dodo
I dont know actually, I really dont know what a good way is to create an Iterator...

1523876337
alexnask
I actually used to work on

1523876357
alexnask
Well, the "type" type is the type of... types :P

1523876392
alexnask
You should probably take a "var" which basically means you accept any kind of argument since you don't know the exact type of your iterator

1523876441
alexnask
Or you could make an Iterator(comptime T: type) type with a vtable, then use @fieldParentPtr for "subclasses" of the iterator

1523876442
Dodo
one of my thoughts is to create a function called 'iter', that you can give anything that has a .next() method, and from there on you'd be able to chain

1523876451
alexnask
let me find a good example of this pattern

1523876495
Dodo
so you'd end up like 'iter(myitter).filter().map().take_while()' or something

1523876495
alexnask
yes, you could do that but there are tradeoffs

1523876555
Dodo
unless there's something like Interfaces that I don't know of yet?

1523876608
alexnask
There aren't but there is a pretty standard pattern people use (it's all over the standard library, for example)

1523876632
alexnask
I'll send you some link to std code and write a basic one for Iterators

1523876648
Dodo
cool! :D

1523876726
alexnask
Take a look at std/mem.zig for the "Interface" declaration and std/heap.zig for some implementations to get the basic idea

1523876949
Dodo
ah yeah

1523876964
Dodo
brb, lunch is ready!

1523877979
alexnask
@Dodo Here is an example:

1523878041
alexnask
Note that you must always take the iterator field by reference before using it, otherwise you will copy the iterator vtable but not the iterator state, if that makes sense

1523878083
alexnask
You can add some kind of protection in debug mode (see

1523878866
alexnask
I just added a Map iterator too for an example of something that is not that trivial

1523878909
Dodo
ah yeah

1523878947
Dodo
but it's a commonly used function of Iterators ^^

1523878977
alexnask
Yes, just to show some metaprogramming techniques :0

1523878979
alexnask
:) *

1523879004
alexnask
I'm pretty sure I can make it just take a function and infer the types from there

1523879009
alexnask
Let me try :P

1523879098
Dodo
this looks so much more..intimidating than I expected honestly

1523879143
alexnask
It's kinda clunky because there is no interface type in zig, you have to make it yourself like you would in C.

1523879168
alexnask
But it's a really useful pattern and if you get how it works it's pretty easy to implement/use.

1523879184
Dodo
I've  never really worked in C ^^

1523879204
alexnask
I see

1523879222
alexnask
Basically you make a vtable type by hand (In this example, Iterator(T))

1523879255
alexnask
Then your implementations provide their functions and have a vtable field (the "it" field here) and fill it up with the function implementations

1523879275
alexnask
And you use @fieldParentPtr to go from a vtable pointer to a pointer to the implementation

1523879278
Dodo
In school we had a little bit of Java, then I quickly realized that I liked python more, and then someone from school told about Rust,,, and thats it

1523879318
alexnask
This is basically handmade traits, without language support

1523879331
Dodo
yeahh

1523879368
alexnask
Just ask away if you don't get some part of the code :)

1523879381
alexnask
I'm pretty sure all that will be abstracted away once we have @reflect and @reify

1523879386
Dodo
(btw, !sometype means 'error or sometype', right>)

1523879390
alexnask
Yes

1523879401
Dodo
wouldn't it be nicer to have an Iterator return ?sometype

1523879438
alexnask
It's pretty much the same thing I think but I'm not too sure waht would happen if sometype is nullable itself

1523879489
Dodo
well that would just nest nullables?...? I don't know?

1523879495
alexnask
I used an error to make it clearer that nullables are allowed to be part of the iterator but you can try using a nullable for sure

1523879643
alexnask
I updated the gist with a version of Map that takes a single function argument btw

1523879709
Dodo
is there a nice loop, unwrap the nullable, but if its null then break

1523879737
alexnask
You can do 'const val = it.next() ?? break;'

1523879738
Dodo
*is there a nice way to loop...

1523879747
alexnask
In a while(true) loop

1523879792
Dodo
yay!

1523879806
alexnask
I expect once there are some more metaprogramming features available much of this will be abstracted away

1523879851
Dodo
allright, now Im going to try and make 'filter' work

1523880051
Dodo
can I check at compiletime if the predicate (or function passed into filter) has a returntype of bool?

1523880108
alexnask
Yes, take a look at the updated gist at Map

1523880116
alexnask
It first checks you passed in a function

1523880130
alexnask
Then, you can just use FunctionType.ReturnType to get a "type"

1523880140
alexnask
So you can do FunctionType.ReturnType == bool

1523880179
alexnask
(and @ArgType for argument types, .arg_count for argument count)

1523880750
Dodo
ugh I have a brace error somewhere :3

1523880923
Dodo
error: expected token '{', found 'fn'

1523881108
Dodo


1523881113
Dodo
what am I forgetting there?

1523881256
alexnask
What is the linecount on the error?

1523881311
Dodo
:63:1

1523881319
Dodo
but I didnt pastebin my whole file

1523881346
alexnask
you're missing the return type of filter

1523881364
alexnask
Idk if that error is caused by that, it should be a bug if it is

1523881384
Dodo


1523881387
Dodo
thats better

1523881410
Dodo
it complains at the 'fn Range()' line

1523881463
alexnask
Wierd, can you try changing line 16 to "fn filter(comptime predicate: var) type {" ?

1523881496
Dodo
that seems to do it

1523881523
alexnask
That's a confusing error message... Probably deserves a bug issue request

1523881530
alexnask
Btw, your filter implementation has a bug ;)

1523881532
Dodo
well, ofcourse it complained, I didn't provide a return type...

1523881537
Dodo
oh no!

1523881540
alexnask
Sure but it should tell you that

1523881548
alexnask
Not that it expects a brace :p

1523881582
Dodo
oh my predicate takes 'val' ?

1523881598
Dodo
so I cant even return 'val' since I would've moved out of it?

1523881633
alexnask
No, I don't think that's an issue

1523881662
alexnask
I can give it away but I suggest you try it out on a couple of testcases :)

1523881920
Dodo
for now Im getting another error :3

1523881920
Dodo
main.zig:41:20: error: use of undeclared identifier 'InPutIt'

1523882085
Dodo
or I cant even type...capitals

1523882092
alexnask
InputIt != InputIt :D

1523882101
alexnask
InPutIt** woops

1523882172
MajorLag
FYI: you don't need to do `it.next() ?? break` in a while true loop, you can just use the while loop itself to unwrap: `while(it.next()) |*val| {}`

1523882272
alexnask
Ah, true

1523882291
Dodo
thats nicer indeed

1523882426
Dodo
const T = @ArgType(FnType, 0); <--- @ArgType of 0 is mostly a reference, so that doesnt really help much here

1523882526
Dodo
so if @ArgType(FnType, 0) is an &sometype, can I get the 'sometype' out of that ?

1523882555
alexnask
T.ChildType == sometype

1523882567
alexnask
or .Child, not 100% sure

1523882605
Dodo
can you also check at compiletime that @ArgType(FnType, 0) is a reference to whatever?

1523882613
alexnask
You should probably write some function UnwrapArg(comptime ArgType: type) type that checks to see if you have a pointer type (though typeids) and unwraps it

1523882635
alexnask
You can use @typeId like I do to check wether the argument is a function

1523882659
alexnask


1523883000
Dodo
9: error: expected type 'Iterator(usize)', found 'type'

1523883012
Dodo
expected type '&usize', found '&const usize'

1523883152
Dodo


1523883320
alexnask
Change 'const val' to 'var val' for the second error

1523883391
alexnask
The first one is probably at the call site

1523883421
Dodo
var filter = &Filter(bigg).init(it).it;

1523883468
alexnask
Where is the error coming from?

1523883488
Dodo
.input_it = InputIt,              ^

1523883504
alexnask
right, should be .input_it = input_it

1523883518
alexnask
You're trying to assign the type instead of the argument that was passed in ;)

1523883575
Dodo
._.

1523883583
Dodo
it compiles now!

1523883595
Dodo
but when I run it it does nothing :(

1523883611
alexnask
That must be the bug I was talking about

1523883613
Dodo
this is so much harder than I thought It'd be

1523883634
alexnask
This one is a logic bug, the rest is getting used to the language

1523883699
alexnask
Hint: When should filter terminate? (return null)

1523883764
alexnask
(and when should it return a non-null value?)

1523884016
Dodo
when the Iterator filter filters over has no more items, filter itself should return null, and when the predicate is false...

1523884029
Dodo
the item should be forgotten, but filter should continue

1523884036
Dodo
which it does not currently

1523884230
alexnask
Exactly :)

1523884253
alexnask
It just terminates on the first item that should be filtered out

1523884346
Dodo
while(self.input_it.next()) |*val| { if (predicate(&val)) { return val; } }, but that complains about the &const ... again

1523884539
Dodo
whats the difference between &... and &const ... ?

1523884594
alexnask
One is a pointer the other is a pointer to a const

1523884655
alexnask
|*val| captures by pointer btw, so yo ushould be able to call predicate(val)

1523884689
Dodo
yeahh I noticed that

1523884700
Dodo


1523884768
Dodo
expected type '&usize', found '&const usize <--- where is this &const popping up from?

1523884786
alexnask
I assume the |val| capture defines val as const

1523884789
alexnask
A quick workaround is using &const usize for your predicate

1523884795
alexnask
Since It should not mutate the value anyways

1523884833
alexnask
It's actually more correct, sadly there is currently no way to check if a Pointer type is const or non const to enforce it and give a clearer error message

1523884871
Dodo
okey, it compiles

1523884881
Dodo
however this is the output:

1523884900
alexnask
You're capturing by pointer and printing out the pointer ;)

1523884902
Dodo
oh while consuming I still used the ptr

1523884978
Dodo
but now if you wanted to go crazy and map, filter, and some other stuff on an Iterator.... you have to write quite some stuff, and you cant really chain

1523885048
alexnask
var map_it = &Map(addOne).init(&Range(0, 10).init().it).it;

1523885059
alexnask
etc.

1523885066
alexnask
Not the prettiest, it works though ;)

1523885365
alexnask
Do I don't quite see what you mean

1523885474
Dodo
well what would be nice to be able to write is like 'iterator.map(somefunc).filter(somepredicate).map(someotherfunc)'

1523885492
alexnask
I updated my gist with Filter, Map, Range, Repeat, a reset feature and examples using integers and structs if anyone is interested btw

1523885496
Dodo
now, that would kind of nest from the inside out

1523885516
alexnask
You can add those as functions to Iterator

1523885543
alexnask
And use the types you made

1523885634
Dodo
on line 72, what is the type of val?

1523885681
alexnask
should be &const T

1523885704
alexnask
I pass it by value to the predicate and struct get upgraded to &const T automatically

1523885729
alexnask
So it works for scalars and structs (with by value semantics for scalars, by reference for structs)

1523885741
Dodo
huh woa'

1523885772
alexnask
I'll write an example Iterator method to do chaining like yo udescribed ;)

1523885989
Dodo
what about DoubleEnded Iterators? :P

1523886059
alexnask
Well, you would write a new interface

1523886112
Dodo
xD

1523886121
Dodo
oh, one function that is nice to have too is zip!

1523886134
alexnask
Hmm, the issue would be in your iterator type functions, they would need to retrn types that work with both the ForwardIterators and BidirectionalIterators

1523886226
alexnask
Also, chaining is still  ugly since you need to keep all of yor iterators on the stack, so yo can't jst initialize one and return a reference to the iterator vtable in a function

1523886261
alexnask
But I'm sure there could be some workaround

1523886318
alexnask
Perhaps with an inline function? Not sure what the behaviour is (if it will keep the stack variables of the inlines function or not)

1523886426
alexnask
Probably not

1523886974
Dodo
if `iter_a` is an Iterator, can I write "const iter_a_type = @typeOf(iter_a.next());"

1523887008
Dodo
or would that already call .next() ? :3

1523888098
MajorLag
A thought: leverage comptime to create a pipeline instead of chaining itorator objects. `var result = pipeline(iterator, filterFn, mapFn, reduceFn);` pipeline would use inline while loops to pass the output of the iterator through the provided fns.

1523888333
MajorLag
...I think the only problem with that is a few missing comptime features, like inferred return type and varargs

1523888353
alexnask
@Dodo That should work withot calling it in runtime

1523888386
alexnask
@MajorLag Yes it shold be doable as is, I was just wondering if I could make it work with the current thrown together design :p

1523888399
alexnask
I tried fixing comptime varargs but the code is really confusing

1523888431
alexnask
Since I'm not familiar with zig internals, I will get back to it at some point after I get more familiar by fixing other bugs and adding some features

1523888549
alexnask
Inferred return types would be great too but most of the time you can just write a helper type function and then use @typeof(this).ReturnType in the function body.

1523888600
Dodo
comptime is magic :3

1523888670
alexnask
Running code at compile time is great, yes :) I especially like the zig way of treating everything as a value at compile time, soo powerful

1523888990
Dodo
no tuples?

1523889018
MajorLag
not yet

1523889032
Dodo
mhh guess Ill make my own struct then for now

1523889283
alexnask
We just need @reify for tuples, it can be written into the standard library

1523889301
alexnask
Although andrewrk was considering removing varargs and adding tuples at a language level

1523889737
andrewrk
I'm becoming more and more convinced this is a good idea

1523889766
andrewrk
var args is buggy because it's not a simple concept

1523889898
alexnask
Yes, it would remove a bunch of non trivial code for handling varargs from the compiler for sure

1523893094
Dodo
const Tuple = struct {         t1: item_a,         t2: item_b,     }; <--- printing this is weird

1523893246
MajorLag
andrewrk: there's no timing functions hidden in std somewhere I'm not seeing are there? As in, getTicks or QueryPerofmanceCounter.

1523893286
Dodo


1523893449
andrewrk
MajorLag, no, but an addition to add this would be most welcome

1523893517
andrewrk
on linux it's clock_gettime, potentially with the vdso optimization

1523893693
MajorLag
I was kinda hoping to avoid implementing it myself, but I'll take a look. As I recall, the vdso is mapped to a fixed location as an elf so right?

1523893713
andrewrk
as a first pass you can do without vdso optimization

1523893735
MajorLag
true, but I may as well see how much extra effort would be required for it while I'm at it

1523893835
andrewrk
looks like the answer is here:

1523895155
Dodo
alexnask: , .Zip() and .Chain() here:

1523895719
Dodo
one thing that would be nice to say would be 'comptime Chain(usize).init(iter1, iter2)'

1523895731
Dodo
error: expected type '&Iterator(usize)', found '&const Iterator(usize)'

1523896015
alexnask
Zigerator? Nice name :D

1523896045
Dodo
I needed to come up with something! Zig + Iterator = Zigerator

1523896051
alexnask
&const T should be compatible with &T no?

1523896059
alexnask
woops no

1523896063
alexnask
I meant the opposite :P

1523896095
alexnask
Actually yes, you should be able to pass a non const pointer to a const pointer argument

1523896157
Dodo
so this whole thing breaks:

1523896170
Dodo
error: expected type '&Iterator(usize)', found '&const Iterator(usize)'

1523896421
alexnask
Does it work if you use a comptime block around all 3 variable declarations?

1523896459
alexnask
Seems like the compiler thinks the Ranges are const

1523896559
Dodo
mh nope, same error

1523896596
alexnask
Btw the way you wrote Chain and Zip is fine but you don't get runtime polymorphism. I would suggest either having runtime polymorhpsim for all the iterator types or for none

1523896610
alexnask
Let me try it out for 2 mins, I'll get back to you

1523896857
Dodo
Im not sure I understand 'runtime polymorphism'? you mean that Zip/Chain now both only have a next method, and never say they are an Iterator(sometype)

1523897104
alexnask
Indeed, that means you cannot write some function that takes an unknown type of iterator at runtime

1523897153
Dodo
mhhhh okey, well, Ill add some kind of .it field then

1523897188
alexnask
That is a design choice, you could just use generics and do everything at compile time and it will be (a bit) faster, you just lose the runtime polymorphism

1523897215
alexnask
It's like using templates in C++ instead of virtual functions, if you've ever used C++ before.

1523897235
Dodo
what would it be compared to Rust? trait objects?

1523897253
Dodo
I basically dont know any C/C++ ^^

1523897295
alexnask
Yes, rust trait objects appear to be some form of dynamic dispatch (aka runtime polymorphism)

1523897324
alexnask
Basically, using a 'var' parameter everywhere will create a new function at compile time for each type used

1523897336
Dodo
so how would I make Chain/Zip be able to virtually dispatch?

1523897360
alexnask
While doing the whole Iterator vtable thing is like doing an impl of some trait in rust

1523897382
alexnask
You would add an iterator field and initialize it like in Map etc.

1523897446
alexnask
You can think of the Iterator struct as a rst trait

1523897462
alexnask
And adding a field + initializing it is like implementing the trait for some type

1523897516
alexnask
It's just a table of functions with the same type, rust just automatically gets the original self pointer for you while we do it manually with @fieldParentPtr

1523897703
Dodo
I seemed to have crashed the .exe :O

1523897933
Dodo
Need to look into this haha, this is not good!

1523897938
Dodo
but for now there's dinner, bye!

1523899095
alexnask
error: expected type '[]u8', found '[4]u8'

1523899100
alexnask
Is this a bug or expected behavior?

1523899194
alexnask
Ah, forgot a const somewhere

1523899665
andrewrk
Dodo, gdb and valgrind are great tools for figuring out what's wrong

1523900076
alexnask
@andrewrk Is there any way to get a listing of a struct's methods?

1523900090
alexnask
I'm trying to make some automatic vtable system

1523900100
andrewrk
I don't think that's currently possible. This would be exposed with @reflect

1523900651
Dodo
alexnask, is it true that if I dont put a '&' in front of the Iterator, the whole things blows up?

1523900700
alexnask
Yes, you will copy the vtable's value so @fielParentPtr will fail

1523900720
alexnask
I'm writing a small library for easier vtables, it uses a whole different design

1523900922
Dodo
now it should work with virtual dispatch

1523900985
Dodo
tho I'm not sure if I like things like '&Zip(usize, usize).init(filter, other).it;', I'd much rather write "&Zip().init(filter, other).it"

1523901048
Dodo
but zip(usize, usize) is clear what it zips over...but for long nested types that gets verry annoying I think

1523901250
Dodo
oh, .enumerate(), almost forgot :3

1523902756
alexnask
With just @field (assuming it would work for methods too), something like:

1523902788
alexnask


1523902946
alexnask
Basically, auto-generated vtable pointers + different storage methods wrapped into an "interface"

1523903007
Dodo
that'd be nice

1523903109
alexnask
It can still be done by hand this way, has some advantages

1523903118
alexnask
Here's a proof of concept:

1523903479
alexnask
Anyway, back to making crinkler work :P

1523903499
Dodo
Crinkler?

1523903521
alexnask
It's a "compressing linker" for Windows

1523903533
Dodo
ahh ha

1523903540
alexnask
Pretty much a linker + executable packer in one, I'm trying to make a simple 4KB demo

1523903552
alexnask
(in zig)

1523903679
Dodo
doesn't that involve crazy shenanigans?

1523903693
alexnask
Yes, one of which is using clinker ;)

1523903721
alexnask
Zig seems pretty suited since it comes with dead code elimination out of the gate and is low level

1523903756
Dodo
yeahh

1523903772
alexnask
+ all the comptime stuff will be useful too

1523903959
Dodo
what about fields of a struct, will they get automatically be optimized in the right order?

1523904003
alexnask
are you referring to packing or hot/cold data?

1523904052
Dodo
I've seen that in C, if you mess up the order of your fields, your struct might become really big, while it really could be smaller if the order of the fields was switches a little

1523904069
alexnask
Ah, yes you are talking about packing.

1523904077
alexnask
There is a 'packed' keyword for structs that will pack them as tightly as possible

1523904078
Dodo
I wonder how that's done in Zig, does that happen automatically"? or do you need to do it manually

1523904089
Dodo
ohh

1523904097
alexnask
Or rather, it will preserver the field order and byte sizes

1523904151
Dodo
because if you have a fully generic struct, that's nice to have I guess

1523904392
alexnask
It's mostly for interacting with other systems

1523904401
alexnask
For example, some file format header

1523904438
alexnask
Can be represented with a C struct, and if you do it right and you tell your compiler to pack it you can just cast a chunk of memory into that struct

1523905274
andrewrk
Dodo, zig provides no guarantee about order of fields in a struct (unles you use packed or extern) so that we can optimize the layout

1523905281
andrewrk
however no layout optimization is currently done

1523905335
andrewrk
alexnask, the 4k restriction is about executable code size rather than runtime memory size, right?

1523905365
andrewrk
I believe that packed structs could potentially cause larger binaries, since their fields will be unaligned, and therefore bit-shifting instructions may be required to access fields

1523905571
Dodo
this is getting big already :O

1523906432
MajorLag
andrewrk, is it intended that the tests are included in the linux-x64-static zig tarball?

1523906490
andrewrk
MajorLag, no

1523906551
andrewrk
MajorLag, I just downloaded the most recent one from ziglang.org and I don't see the tests in it

1523906593
MajorLag
yeah, they aren't. turns out my sftp client was showing me old data

1523906598
Dodo
type '?Tuple(usize,usize)' is not copyable; cannot pass by value

1523906614
andrewrk
MajorLag, I only recently started putting a Cache-Control HTTP header, which may address that

1523906616
Dodo
how...do I `move` items then?

1523906654
andrewrk
Dodo, see

1523906676
andrewrk
if you want a copy of the thing you'll have to manually do a copy

1523906678
Dodo
so that means I cant make my 'Filtermap' adapter work

1523906697
MajorLag
andrewrk, it's SFTP on my linux-dev vm, so I doubt it. WinSCP just likes to cache directory content lists.

1523906710
Dodo
since Filtermap takes a function that takes an `owned` item, and returns another item

1523906721
Dodo
fn(T) U basically

1523906749
andrewrk
T implicitly casts to &const T

1523906873
Dodo
what is the type of a nullable? need to do some comptime checking :3

1523906894
MajorLag
the TypeId is builtin.TypeId.Nullable

1523907043
andrewrk
Dodo, see also

1523907243
Dodo
so how'd I write functions that .Filtermap takes if I cant take struct by value?

1523907581
andrewrk
Dodo, taking a struct by const ptr and immediately copying it is equivalent to taking a struct by value

1523907609
Dodo
but my Iterator returns me owned items ;o

1523907688
Dodo
or hang on

1523907947
alexnask
@andrewrk The 4KB restriction is on the executable yes

1523907963
alexnask
And you can only link against default windows libraries (+ opengl or directx)

1523908570
alexnask
@andrewrk Can I completely remove the panic handler?

1523908729
andrewrk
alexnask, it should go away when compiled with --release-small

1523908742
andrewrk
assuming you never call @panic()

1523909095
alexnask
Ok, good, I'll check it out to be sure.

1523909119
alexnask
Btw, with build-obj I assume the compiler_rt and builtin object files are included in the produced output?

1523909128
andrewrk
alexnask, this doesn't work now, but when I do some reorganization, you'll be able to have your panic handler have a body of @compileError("panic called") and you'll get a compile error everywhere a panic is possible

1523909146
andrewrk
this would be insanity to do in debug mode, but could make sense to do in release-small or release-fast mode

1523914470
andrewrk
alexnask, here's a demonstration of a minimal .o file, with panic being deleted:

1523914478
andrewrk
I don't think you can get better than 1 byte :)

1523914500
alexnask
heh, nice :)

1523914538
alexnask
I'm getting undefined references when linking with crinkler, weird

1523914560
andrewrk
I'm guessing that crinkler has tested primarily against msvc and not LLD

1523914572
alexnask
The only libraries we need are kernel32 and user32 right?

1523914580
andrewrk
err, msvc and not llvm

1523914583
alexnask
Sure, the object files should be compatible though

1523914610
andrewrk
you see std/windows/index.zig right?

1523914618
andrewrk
e.g. pub extern "kernel32" stdcallcc fn CloseHandle(hObject: HANDLE) BOOL;

1523914639
andrewrk
this "kernel32" on the extern keyword causes zig to generate kernel32.lib at link time and include it on the command line

1523914658
andrewrk
if you do build-exe you can find these artifacts in zig-cache/

1523914662
alexnask
Yup, I looked at the library path detection code too

1523914667
alexnask
to make sure I'm using the right ones

1523914698
andrewrk
can I see the error messages?

1523914705
alexnask
The weird thing is that I'm getting undefined references of symbols with underscores

1523914709
andrewrk
and the invocation line

1523914713
alexnask
And all those symbols should be in kernel32

1523914715
alexnask
sure 1 sec

1523914721
andrewrk
also you tried --verbose-link to see the link line we would give to LLD , yeah?

1523914731
alexnask
Yes I looked at the lld command too

1523914768
alexnask


1523914787
alexnask
It's probably clinker's fault, I may try to link against some older SDK

1523914873
andrewrk
alexnask, did you use the zig-generated kernel32.lib or the msvc-provided one?

1523914900
alexnask
I use the msvc one, I though zig just copied it over

1523914909
andrewrk
you also need libc or zig's generated builtin.o

1523914926
alexnask
Ah ok, compiler_rt.obj too I assume?

1523914930
andrewrk
zig is actually generating minimal .lib files with only the entries that you actually call

1523914945
andrewrk
this lets us produce windows .exe files on other platforms

1523914949
alexnask
Nice, I'll try using the zig-cache ones then

1523915033
andrewrk
yes compiler_rt.obj is also required in the same way builtin.obj is. it's possible that you don't end up needing them, in which case the unused symbols would be omitted once

1523915044
andrewrk
you can work around it by putting the .o files in .a files first

1523915055
andrewrk
oh, actually I don't know how it works on windows

1523915086
alexnask
Right, now I remember why I didnt use the zig-cache kernel32.lib, crinkler doesn't appear to handle ar archives well

1523915113
alexnask
Anyways, thanks for the help I'll try out a couple of things

1523915128
andrewrk
kernel32.lib is an ar archive?

1523915137
alexnask
file says so

1523915147
alexnask
kernel32.lib: current ar archive

1523915182
andrewrk
hm. odd. that's generated by LLD from a .def file

1523915240
alexnask
I could try using link.exe to generate it and give it a shot

1523915257
alexnask
LLD may just not care and use ar archives

1523915317
andrewrk
it's not the underscores is it?

1523915332
andrewrk
is zig messing up the underscores of the kernel32 fn names?

1523915400
alexnask
Are there supposed to be underscores? I don't see how lld and link.exe would accept them

1523915412
alexnask
If it was wrong, I mean

1523915439
andrewrk
I mean it's just part of the name. so if there was a mismatch you would get undefined symbol errors, just like you are now

1523915458
andrewrk
that's what dllimport and dllexport do, just mangle the names of things

1523915470
alexnask
Ah ok I though C symbols had no name mangling

1523915481
andrewrk
sadly on windows DLLs they do

1523915481
alexnask
That's why the underscores surprised me

1523915490
andrewrk
I remember I tried to solve this correctly a few months ago, and I thought that I had succeeded, but unfortunately I don't remember all the details

1523915570
andrewrk
oh I think this might be relevant

1523915572
andrewrk


1523917687
MajorLag
so um... zig seems unable to find the vcruntime path even though I'm passing it the absolute path via --msvc-lib-dir

1523917835
alexnask
Nice managed to get it down to just undefined '__imp__LoadLibraryA@4'

1523917842
andrewrk
MajorLag, it's probably looking for a specific file

1523917851
alexnask
Which is weird since it's in kernel32 but doesn't appear to be in the def file

1523917918
andrewrk
alexnask, the zig generated one?

1523917939
MajorLag
andrewrk: here's the thing, backreving to 0.2.0.9df2a6a5 works fine

1523917956
alexnask
@andrewrk Yup

1523917965
alexnask
actually, let me make sure

1523917977
alexnask
But I don't think building the .lib overrids the .def

1523918007
andrewrk
does the .def have it in there?

1523918024
alexnask
Nope

1523918054
alexnask
ExitProcess

1523918054
alexnask
, HeapCreate,

1523918054
alexnask
WriteFile

1523918054
alexnask
GetLastError,

1523918054
alexnask
, GetStdHandle,

1523918055
alexnask
HeapAlloc,

1523918057
alexnask
HeapReAlloc,

1523918059
alexnask
HeapFree,

1523918061
alexnask
GetConsoleMode,

1523918063
alexnask
GetFileInformationByHandleEx

1523918063
MajorLag
andrewrk: actually... old version fails too, it just doesn't report it except as an exit code...

1523918067
alexnask
woops

1523918155
MajorLag
which is weird, I know this was working yesterday because I was using c_allocator

1523919087
alexnask
Huh

1523919119
alexnask
Managed to link by using lib.exe to generate kernel32.lib then link against that library + the system kernel32.lib

1523919157
alexnask
Which is weird, if I only link against the system kernel32.lib I get undefined references :p

1523919251
alexnask
2.278 bytes with 10 calls to std.debug.warn

1523919256
alexnask
Not bad

1523919659
alexnask
1.5KB for the whole demo code and data... sounds good :P /s

1523920192
alexnask
Windows .lib files are ar archives after all btw, not quite sure why it's not working with the lld generated lib

1523921672
MajorLag
andrewrk: using process monitor, it doesn't look like zig is respecting my commandline passed paths.

1523922258
MajorLag
as in, it doesn't even appear to attempt to look for them.

1523922535
alexnask
@MajorLag Did 'zig build' break for you too on windows in one of the latest releases?

1523922561
alexnask
It appears to run into an unreachable while running the build executable on my machine

1523922573
MajorLag
yeah, not sure which one. The older version I thought worked actually doesn't, but because of how it errored that wasn't obvious to me yesterday.

1523922604
MajorLag
but my problem is different than yours, zig ignores the paths I'm passing it to the runtime and kernel32.lib

1523922660
alexnask
I'll try it out too in a couple of minutes so we can see if it reproducible

