1648600175
energizer!~energizer@user/energizer
where does error.StreamTooLong come from?

1648600200
energizer!~energizer@user/energizer
i don't see any definition https://github.com/ziglang/zig/search?q=streamtoolong

1648602473
squeek502!~squeek502@user/squeek502
energizer, error sets can be inferred, so it comes from any function that returns error.StreamTooLong (various std.io.Reader functions)

1648602629
energizer!~energizer@user/energizer
squeek502: so generated docs will (eventually) look at the source of a function and see what errors it returns so i can read them and handle them casewise?

1648602745
energizer!~energizer@user/energizer
or, how do i know what errors i'm suppressing with `try

1648602906
squeek502!~squeek502@user/squeek502
energizer, if you switch on the error without handling any errors, it will give you compiler errors for all the missing error cases

1648602931
squeek502!~squeek502@user/squeek502
catch |err| switch (err) {}

1648603005
energizer!~energizer@user/energizer
are they namespaced at all?

1648603052
squeek502!~squeek502@user/squeek502
no, afaik all errors with the same name are treated as equal

1648603068
squeek502!~squeek502@user/squeek502
error sets are a bit different though

1648603119
squeek502!~squeek502@user/squeek502
see the lang ref for better info: https://ziglang.org/documentation/master/#Errors

1648603338
energizer!~energizer@user/energizer
"However, each error name across the entire compilation gets assigned an unsigned integer greater than 0. You are allowed to declare the same error name more than once, and if you do, it gets assigned the same integer value." first reaction is i dont like this

1648603480
energizer!~energizer@user/energizer
why not have a namespace

1648611453
energizer!~energizer@user/energizer
https://github.com/ziglang/zig/blob/4b9fd57aa86a480f2afd6ba117fcc7ef6eace572/lib/std/io/reader.zig#L201

1648611463
energizer!~energizer@user/energizer
why not just return the empty buffer, instead of null?

1648612286
andrewrk!~andrewrk@mail.ziglang.org
energizer, I don't think that function is going to survive a std lib audit

1648612367
energizer!~energizer@user/energizer
ah ok

1648612825
andrewrk!~andrewrk@mail.ziglang.org
I'm thinking a better way to go will be to have delimiter based functions be methods of a BufferedReader

1648612867
andrewrk!~andrewrk@mail.ziglang.org
this way we can do it more efficiently than reading one byte at a time, ideally even with SIMD

1648612944
andrewrk!~andrewrk@mail.ziglang.org
then the answer to "wheres the readline function of Reader?" will be "that's the wrong abstraction for reading lines from a stream"

1648613701
nektro!~meg@75-164-221-110.ptld.qwest.net
would removing BufferedReader and making Reader always use a buffer be bad?

1648615055
tleydxdy[m]!~tleydxdy@2001:470:69fc:105::16a3
suppose read triggered some hardware

1648615700
braewoods!~braewoods@user/braewoods
nektro: i suppose depends on what is the data source. buffers don't really make sense in some cases.

1648615716
braewoods!~braewoods@user/braewoods
e.g., special files in some cases.

1648615777
braewoods!~braewoods@user/braewoods
i'm mainly thinking of linux /sys special files which usually return data generated by kernel space code so it might vary from one read to the next

1648618469
bgiannan!4529@2a01:4f8:141:1272::2
haze, no i didn't?

1648625510
hugbubby!~hugbubby@49.207.215.73
Is there a standard library function for encoding byte strings in hex? I see hexToBytes() but I want the opposite

1648625726
ikskuh!~xq@2a0d:5940:6:163::ad7e
std.fmt.format (and variants) + "{}" + std.fmt.fmtHexSliceUpper (or Lower)

1648625728
tleydxdy[m]!~tleydxdy@2001:470:69fc:105::16a3
probably std.fmt?

1648625922
hugbubby!~hugbubby@49.207.215.73
ok, any simple way to create a buffer over a byte slice that fulfills whatever "writer anytype" requires? 

1648626033
ikskuh!~xq@2a0d:5940:6:163::ad7e
std.fmt.fixedBufferStream() for static, std.ArrayList() for dynamic

1648626675
motiejus!~motiejus@2001:470:69fc:105::38fb
does stdlib have an Allocator which can accept `[]u8` as the backing array?

1648626745
ikskuh!~xq@2a0d:5940:6:163::ad7e
std.heap.FixedBufferAllocator

1648626791
motiejus!~motiejus@2001:470:69fc:105::38fb
uh, exactly what I need. I was looking in `std/heap/*.zig`, not in `std/heap.zig`. Thanks!

1648626806
motiejus!~motiejus@2001:470:69fc:105::38fb
this is amazing.

1648626813
hugbubby!~hugbubby@49.207.215.73
FixedBufferAllocator is really fast, right? I try to use it everywhere I can

1648626820
hugbubby!~hugbubby@49.207.215.73
It makes reducing dynamic allocations so much easier

1648626885
motiejus!~motiejus@2001:470:69fc:105::38fb
oh wow it's so simple

1648626899
ikskuh!~xq@2a0d:5940:6:163::ad7e
yes, but: it's a bump allocator

1648626907
ikskuh!~xq@2a0d:5940:6:163::ad7e
it has not implemented any "free" operation

1648626966
hugbubby!~hugbubby@49.207.215.73
Gotcha. So I need to fully deinit() if I want to reuse the memory, right?

1648627009
ikskuh!~xq@2a0d:5940:6:163::ad7e
nah

1648627013
ikskuh!~xq@2a0d:5940:6:163::ad7e
just override it :D

1648627024
hugbubby!~hugbubby@49.207.215.73
wym

1648627045
ikskuh!~xq@2a0d:5940:6:163::ad7e
the fixed buffer allocator doesn't have a deinit() functioni

1648627058
ikskuh!~xq@2a0d:5940:6:163::ad7e
allocation will only give pointers to the buffer you passed in

1648627064
ikskuh!~xq@2a0d:5940:6:163::ad7e
so each allocation is a portion of that buffer

1648627093
ikskuh!~xq@2a0d:5940:6:163::ad7e
the buffer is stored somewhere else tho

1648627107
ikskuh!~xq@2a0d:5940:6:163::ad7e
if you use a local variable, it is freed by returning from the fn

1648627188
ikskuh!~xq@2a0d:5940:6:163::ad7e
the fba itself is basically struct { buffer: []u8, offset: usize = 0 }

1648627215
ikskuh!~xq@2a0d:5940:6:163::ad7e
and alloc(size) { defer offset += size; return buffer[offset..offset + size]; }

1648627235
ikskuh!~xq@2a0d:5940:6:163::ad7e
(very simplified, but that's the idea)

1648627263
ikskuh!~xq@2a0d:5940:6:163::ad7e
so you don't need to free any allocations, just "assume the memory is free again" if you are sure you don't need any of those allocations anymore

1648627263
hugbubby!~hugbubby@49.207.215.73
Is there an implementation of FBA in the stdlib that does keep track of what segments of the buffer are in use and is able to free those?

1648627289
ikskuh!~xq@2a0d:5940:6:163::ad7e
no

1648627300
ikskuh!~xq@2a0d:5940:6:163::ad7e
i guess you can use the general purpose allocator

1648627315
ikskuh!~xq@2a0d:5940:6:163::ad7e
with a backing allocator that is an FBA

1648627348
ikskuh!~xq@2a0d:5940:6:163::ad7e
brb

1648627362
ikskuh!~xq@2a0d:5940:6:163::ad7e
but can you explain your goals? maybe there's an alternative solution to it?

1648630501
ikskuh!~xq@2a0d:5940:6:163::ad7e
re

1648669878
haze!~haze@user/haze
bruh keyword when

