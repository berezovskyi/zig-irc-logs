1566345613
donpdonp
its just the amount of bytes for the struct, but not initialized (0xaaaaaa)

1566345619
andrewrk
donpdonp, consider this: var thing: Thing = undefined; const thing_ptr = &thing; thing_ptr.* = init();

1566345731
andrewrk
using an allocator is the same thing; you're just skipping to the second line, and the memory is on the heap

1566346047
fengb
andrewrk: is there a way to generate a lookup table at comptime? Like inline loop inside a switch...

1566346105
andrewrk
fengb, you might get some ideas from this:

1566346239
fengb
My usecase is each field has a unique int and I need to jump back into the field

1566346269
donpdonp
okay now im back to the canonical fn init() Self

1566346487
fengb
Hmm... would it be expensive to loop through per match?

1566346564
fengb
I guess I should test it out

1566346571
andrewrk
fengb, you should be able to take advantage of comptime fn call caching

1566346602
Tetralux
donpdonp: Note that it's undefined in the sense that it's not initialized to anything in particular; it's

1566346707
Tetralux
YAY

1566346731
Tetralux
Making progress :p

1566346841
donpdonp
well thats enough Zig for today. thx again Tetralux, andrewrk for helping me level-up in zig.

1566346858
Tetralux
o7o7

1566346864
Tetralux
Welcome.

1566351299
daurnimator
Are there any companies out there using zig yet?

1566353347
fengb
Does fengb tech count? >_>

1566360572
marler8997
I could try to sneak some code into our printers at HP :)

1566360600
marler8997
Then you could say that HP uses Zig...lol

1566362094
hspak
Couple questions on arrays: does '[_]' mean size is set at compile time? And second, if I want to store an array of strings of arbitrary length, what's an acceptable way of doing that? I think I want a [][]u8, but grepping the stdlib doesn't come back with much so not sure...

1566362106
daurnimator
hspak: yes it does.

1566362123
daurnimator
hspak: yes you want [][]u8 which is a slice of slices of u8

1566362232
hspak
daurnimator: thanks :)

1566362455
nero57
When I modified my zig source, and then I executed zig build, the generated target file seems not the newest version, and I must remove the zig-cache folder, and then execute zig build again, the target file is now the latest version.

1566362475
nero57
Is there any way to update the generated object file at compile time?

1566362524
nero57
Or is there any way to update the generated target binary file at compile time?

1566362658
nero57
Btw, I am trying zig in MacOSX.

1566368006
bgiannan
can i create type 'aliases'?

1566368151
nero57
I didn't find a type alias in the document

1566368232
daurnimator
bgiannan: what do you mean by "aliases"? you can just pass types around at comptime. if you mean distinct types, that's an open proposal I think.

1566368301
bgiannan
you're right i can just do: `const MyNewType = std.ArrayList(i32);` ?

1566368345
nero57
Type assignment can be considered an alias

1566368448
nero57
Is there any way to turn off caching when executing zig build?

1566369513
bgiannan
it it possible to use a type as a key of an hashmap?

1566369530
bgiannan
something like: std.AutoHashMap(type, ...)

1566373092
daurnimator
bgiannan: types are only really available at comptime. you could probably build a monstrosity of a comptime recursive function to dispatch on type....

1566374091
bgiannan
how about using @typeName as a key? would it be reliable?

1566376298
samtebbs
nero57: If you're using zig build-* the try adding --cache off

1566376303
samtebbs
then*

1566376336
bgiannan
I don't really get this error:

1566376374
samtebbs
You're passing a const map but it expects a non-const

1566376391
samtebbs
The type description is long but that's the only difference I can see

1566377272
bgiannan
yes but i don't know how its const

1566377297
bgiannan
and it seems to be complaining about the member `instances` of self

1566377444
samtebbs
bgiannan: Are you using a master build? It compiles for me

1566377477
bgiannan
downloaded master from the ziglang.org/download

1566377482
bgiannan
yesterday

1566377493
bgiannan
downloading again

1566377601
bgiannan
no change (0.4.0+81c441f8)

1566377642
bgiannan
i'm doing `zig test file.zig` btw

1566377649
bgiannan
maybe it compiles with just zig build

1566377748
samtebbs
Oh right I was doing build-obj, lemme try with test

1566377860
samtebbs
Oh I get it

1566377870
samtebbs
The map is declared as const, which means you can't change it

1566377902
samtebbs
`const registry = ...`

1566377902
bgiannan
where?

1566377913
bgiannan
ah

1566377916
bgiannan
tried it earlier

1566377919
bgiannan
same error

1566378035
samtebbs
The parameter to register is const by default

1566378047
samtebbs
Parameters are always const in Zig

1566378079
samtebbs
See if you can pass `self` as a pointer instead

1566378200
samtebbs
Yep that works with some added trys in the right places

1566378423
nero57
I write my build.zig, and use zig build to build my project, is there any method to pass --cache off in build.zig?

1566378465
bgiannan
well yes but i would have to call it like that? -> Registry.register(&register, instance)

1566378471
nero57
when I run zig build --cache off, it tell me:

1566378477
nero57
Unrecognized argument: --cache

1566378664
ntgg
I'm getting error: integer value 64 cannot be implicitly casted to type 'u4' with setting enum values

1566378667
samtebbs
bgiannan: Nope you don't have to

1566378679
nero57
It seems that the `std/build.zig` not handle the `--cache` argument.

1566378742
bgiannan
samtebbs, can you show me your working modified version?

1566378794
samtebbs
bgiannan:

1566378824
bgiannan
thx

1566378908
bgiannan
ah didn't know about `_ = ...`

1566379314
samtebbs
bgiannan: Yeah it's useful. I used to use `var ignored = ...`

1566381097
bgiannan
what's the difference between native and foreign endian?

1566381849
samtebbs
Do you know the differences between big endian and little endian?

1566381860
bgiannan
yes

1566381878
bgiannan
hum native == endianness of the current machine?

1566381879
samtebbs
So native endian is whatever the native endianness is for your platform

1566381884
bgiannan
alright

1566381889
samtebbs
And foreign is the opposite

1566387431
bgiannan
u8 can't be compared with '==' ?

1566389829
PMunch
Hi everyone. We have an interesting (hopefully) proposal for you! Since last years FOSDEM conference the people over in #nim have been talking about creating a developer room for small/new/unknown languages. The room will feature presentations about parts of the language, or specific cool projects done in a language. If anyone from the Zig community wants to join in on the effort, come join us over in #fosdem19newerlangs.

1566390393
alexander92
hey guys since last years FOSDEM conference the people over in #nim have been talking about creating a developer room for smaller/newer languages. The room will feature presentations about parts of the language, or specific cool projects done in a language. If anyone from the Zig community wants to join in on the effort, come join us over in #fosdem19newerlangs

1566390871
Tetralux
bgiannan: It can.

1566390887
bgiannan
Tetralux, i had another issue, figured it out since :)

1566390923
Tetralux
Good, good.

1566390945
Tetralux
Also, I'm amused that the pair of you, alexander92, PMunch, said word-for-word the exact same thing.

1566390988
bgiannan
most errors are helpful, but a few i encountered are a little misleading

1566391001
alexander92
yes, i am very lazy and very copy-pastey :P

1566391095
Tetralux
bgiannan: Yeah - many of them IME could give you much more context and suggestions.

1566391404
PMunch
You cheat alexander92

1566393810
bgiannan
Is it normal that @alignOf(fn (args: ...) void) is 0 ?

1566393824
bgiannan
I'm trying to make a ArrayList of functions

1566393963
fengb
That doesn't look right

1566394013
fengb
I don't think you can use varargs dynamically

1566394062
bgiannan
why not?

1566394119
fengb
Because it's a compile time only construct

1566394145
fengb
When working with memory directly, the compiler needs to know how to put variables on the stack

1566394168
fengb
Varargs basically say "anything goes" so the compiler needs to do it at the callsite

1566394177
fengb
Which doesn't exist at compile time in function pointers

1566394216
bgiannan
i get the error  even without varargs

1566394246
fengb
std.debug.warn("{} {}\n", usize(@alignOf(fn (args: ...) void)), usize(@alignOf(fn (args: u8) void)));

1566394260
fengb
This outputs align=8 on the second function for me

1566394275
mq32
random mq32 question appears: is there yet a way to create compile time lists or similar (for type registries)

1566394325
bgiannan
fengb,

1566394330
fengb
You can make a comptime array. Things that use memory/allocators directly are kinda locked though

1566394359
fengb
This is varargs: fn (args: ...) void

1566394373
fengb
The error message could be better... but varargs are being removed at some point in the future

1566394393
samtebbs
PMunch, alexander92: That would something andrewrk could discuss when he comes online

1566394397
bgiannan
ah right when i tested without i removed them at one place only

1566394406
bgiannan
thx fengb

1566394448
fengb
np

1566394473
fengb
So... I wouldn't recommend it but you can fake varargs with an OpaquePointer. It'd be like passing in void* in C

1566394521
PMunch
samtebbs, great, be sure to let him know if we're not around

1566400266
kristoff_it
Hi, I'm trying to write a function that needs to handle HashMap types. I need to get key and value types but doing T.KV.key doesn't work, presumably because .key is a struct field and not a declaration inside KV. Is there an easy way to do that without resorting to @typeInfo?

1566400294
kristoff_it
THis is the error that I get `error: container 'std.hash_map.KV' has no member called 'key'`

1566400524
samtebbs
kristoff_it: KV is a type, so you need to use an instance of the type instead

1566400550
samtebbs
The `Entry` struct has an instance of KV

1566400625
samtebbs
What are you trying to do with the map?

1566400682
fengb
You could do std.HashMap(YourKey, YourValue).KV

1566400699
fengb
But you should probably assign std.HashMap(YourKey, YourValue) to a const for easier use

1566400732
kristoff_it
samtebbs: thanks, I'll try that. I'm writing a redis client and I'm toying with the idea of having the parser understand basic types + the ones in the stdlib, so if you try to get a hashmap key from redis, the parser should be able to deserialize it both as a struct (assuming the field names match) or in a HashMap of the right kind

1566400768
kristoff_it
depending on what the user asks for

1566400919
fengb
Oh did you want the declaration? That'd be std.meta.fieldInfo(type, "fieldName")

1566401064
kristoff_it
yes that's what I want

1566401089
kristoff_it
but I see that the std.meta code also goes through @typeInfo

1566401107
fengb
Yeah, it iterates through the fields

1566401113
kristoff_it
anyway, thanks, this definitely faster than iterating over the fields myself

1566401133
fengb
np

1566401135
kristoff_it
is there a big reason why doing .KV.key cannot work?

1566401169
fengb
KV.key is a struct field

1566401204
fengb
For "pub const key = 1;" in the middle of structs

1566401213
fengb
Like static members in Java

1566401242
fengb
field isn't the right word. Declaration?

1566401392
kristoff_it
yes I'm aware of the difference between a struct field and a "namespaced" declaration inside a type. I think declaration fits and it's what the language calls those (e.g. @hasDecl)

1566401572
kristoff_it
I was just wondering if there is any ambiguity (or other problem) in letting references to a struct field return the field's type

1566402044
nero57
Is the const declaration in a function is stored in the function stack frame?

1566402598
samtebbs
kristoff_it: Oh so you wanted the type of KV.key

1566402657
samtebbs
There is `@typeOf` but I'm not sure if it would help here

1566404305
bgiannan
somehow i had to add `--library c` to run a test that uses the c_allocator on linux but not on macOS

1566404546
andrewrk
bgiannan, libc is always linked on macOS because it is the syscall ABI

1566405232
bgiannan
ah makes sense thanks!

1566405489
Tetralux
Q: How do you get a list of keys in a HashMap?

1566405492
Tetralux
Just iterate it?

1566405601
dimenus
yep

1566405722
Tetralux
If you want to write a fn that works on any map, say encoding to MsgPack for instance, you want to have a reasonable interface convesion.

1566405758
Tetralux
Is it reasonable to say "It must have an iterator that returns *KV where a KV is essentially a tuple of a key and its value?

1566405799
Tetralux
"If it doesn't have that, it's not a map."

1566405843
dimenus
.next() returns a *KV

1566405906
dimenus


1566406234
donpdonp
I was surprised there was no hashmap function that returned []KV to use with for(slice) |value| { }

1566406281
Tetralux
It's because that would have to copy every element and allocate it.

1566406283
Tetralux
That's not fast.

1566406310
Tetralux
Personally, I'd like to be able to for(iterable) but.... .v.

1566406359
donpdonp
for(iterable) would be better, that would be a new language feature yes?

1566406385
gonz_
It wouldn't necessarily be better at all

1566406404
gonz_
Suddenly when you see `for` you can't guarantee anything about what's happening.

1566406580
Tetralux
.. because the iterator can do anything.

1566406597
Tetralux
.. whereas for on a slice

1566406614
fengb
foriter keyword :P

1566406624
Tetralux
.. and calling .iterator manually is meant to communicate to you that it could do whatever.

1566406639
Tetralux
I'd argue that doesn't really matter much though.

1566406646
torque
I don't understand how `for (iterable)` is appreciably different than `while (keys.next())`

1566406648
Tetralux
Like - you still don't know what it's doing without looking.

1566406662
Tetralux
torque: That's basically my point.

1566406673
Tetralux
I don't know about anyone else here, but I never write a for loop.

1566406676
Tetralux
They're all whiles.

1566406679
Tetralux
Because of this.

1566406692
torque
is that a problem?

1566406699
torque
are you some kind of loopist

1566406717
Tetralux
XD

1566406731
Tetralux
for (map) |entry| { ... }

1566406731
Tetralux
vs

1566406746
Tetralux
var it = map.iterator(); while (it.next()) |entry| { ... }

1566406756
Tetralux
There's no point writing a for loop

1566406758
Tetralux
Even for a slice

1566406763
Tetralux
If you change it to literally anything else

1566406769
Tetralux
You have to change the entire structure of the loop.

1566406775
Tetralux
That's friction I can do without.

1566406801
Tetralux
If you start with it being a slice and then realise it needs to be an ArrayList, for example.

1566406817
Tetralux
May as well just write a while loop to begin with.

1566406961
fengb
It's 2 lines

1566406990
donpdonp
yeah thats funny id say the 'var it = ' shows why a for loop is preferable

1566406998
bgiannan
i can't seem to be able to define a function inside a test?

1566407034
donpdonp
as a programmer i would like for(anything_array-ish) |item| { } to "just work" on slices or maps or any thing array-ish.

1566407066
fengb
bgiannan: functions can only be inside of structs or top level files atm

1566407073
donpdonp
because its concise. i dont want to create an iterator variable and manage it.next() (I have to remember its 'next')

1566407082
Tetralux
bgiannan: You cannot declare a fn in any local scope, no. You will though when/if we get anonymous fns.

1566407090
torque
conciseness is not part of the zig philosophy though

1566407095
bgiannan
Tetralux, noted

1566407104
Tetralux
.. which isn't an

1566407119
Tetralux
torque: Is it

1566407134
Tetralux
Like, what I just said might sound a little harsh, but.

1566407150
fengb
bgiannan: a common pattern is doing "const Foo = struct { fn bar() }; Foo.bar"

1566407151
torque
that's extremely minor syntactic sugar that in theory could hide a lot of complexity. if you're advocating iterators, imo operator overloading is in the same vein and makes much more sense

1566407182
fengb
It's kludgy but lets you define functions in any scope

1566407216
Tetralux
torque: With respect, I think I might value your time more than you do :)

1566407227
Tetralux
And also general mental health xD

1566407252
Tetralux
Friction is a terrible thing in something you use ever day.

1566407254
Tetralux
every*

1566407334
gonz_
We already have tons of languages that care lots about removing friction from the act of writing code

1566407338
torque
friction is very important. it prevents people from sliding around uncontrollably

1566407349
gonz_
And almost none that care about people who read code

1566407427
Tetralux
torque: There are other ways to have control authority without friction xD

1566407439
Tetralux
The very idea that friction is desirable is a terrible idea.

1566407456
Tetralux
It makes doors squeak.

1566407459
Tetralux
You don't want that.

1566407476
fengb
This metaphor is breaking down

1566407563
gonz_
"Friction" is not a desirable value. You may have more friction in a language when your top priority values are *not removing friction*, however.

1566407643
Tetralux
Iterating over a structure's data is something you do all the time in any imperative language.

1566407669
Tetralux
Surely it's not too much for a programmer to understand that iterating over a slice is a lot simpler than iterating over an arbitrary struct?

1566407715
Tetralux
Not to mention that fact that making something you do literally all the time not completely trivial is deliberately making the programmer's life harder.

1566407761
gonz_
I'm pointing out that it's possible to prioritize things other than the writing of code, is all.

1566407766
gonz_
It's very under-valued

1566407794
Tetralux
And I'm saying that for loops should be as trivial as struct field dereferencing xD

1566407806
torque
I disagree with a lot of the terminology you've used anyway

1566407812
Tetralux
Except also not handicapped.

1566407834
Tetralux
torque: That's okay. The terminology isn't the important part.

1566407853
torque
well it is, because it's the main thrust of your argument

1566407870
torque
I don't think looping over a data structure is nontrivial as it stands

1566407886
Tetralux
Depends on the structure.

1566407902
torque
depends on the interface provided by the structure

1566407917
Tetralux
I'll note that I'd accept this syntax instead:

1566407939
Tetralux
while (map.iterator()) |entry| {}

1566407953
gonz_
There's a lot of emotion in the argument, first of all. Something is handicapped, making the life of a programmer harder, "[it's] a terrible thing...", etc.

1566407954
Tetralux
Still not what I want, but better.

1566407996
Tetralux
gonz_: I think we're talking at cross purposes; saying that forcing anyone to do busy work for something that you do all the time is not controversial

1566408014
Tetralux
.. which is what I mean when I say it causes friction.

1566408023
gonz_
I think you see friction only when writing a first draft

1566408031
gonz_
Whereas friction can also be about making changes

1566408040
Tetralux
I mean both things.

1566408045
gonz_
And I don't see a whole lot of that perspective from the majority of your arguments

1566408047
Tetralux
The abilty to make changes is part of the second one.

1566408122
Tetralux
I'm not sure I quite understand your point.

1566408176
gonz_
Fair enough. What exactly are you arguing for with regards to `for`/`while`. Let's just establish that first.

1566408329
Tetralux
It's a couple of related things: 1) I never use for, even for slices, because it's more resistant to changing the code to using a type with a custom iterator than is worth it.

1566408344
Tetralux
But for is simpler to type, and communicates the intent just as clearly.

1566408502
Tetralux
I'm kinda blanking on what the part is right now.

1566408515
Tetralux
the second part*

1566408549
donpdonp
for

1566408549
donpdonp
sts for a boolean and id like that to stay non-smart.

1566408590
Tetralux
Right.

1566408627
gonz_
I don't think the minimal friction of having to change to a `while` is meaningful. I think the friction of reading code and not knowing what goes in a `for` matters more.

1566408640
torque
>for(expr) supports .next() (or some other test for what is iterable)

1566408664
torque
this has the problem that it requires the language to be aware of a userspace interface

1566408710
torque
of course you already have functioning iterators with `while` so the benefit seems to be very minor anyway

1566408713
gonz_
I don't feel too strongly about this issue in particular, but I think it displays the same pattern as everything else; an over-emphasis on the programmer right now.

1566408728
Tetralux
torque: If that's the problem, I'd suggest removing for altogether.

1566408756
Akuli
i don't think having a programming language be aware of userspace stuff is bad, i quite dislike how java's int and long are "primitives" and you can't use them like you can use objects

1566408781
Tetralux
In practice, no-one would need to use `for` in real code unless they ONLY EVER wanted to have a slice.

1566408785
Tetralux
Which they can't ever know

1566408789
Tetralux
Because things change over time.

1566408815
Tetralux
It's also worth noting that there is a more powerful way to implement an iterator than repeatedly calling next.

1566408836
donpdonp
torque: i see, maybe its not a small change at all :)

1566408896
Akuli
so this `var iter = something.getIterator(); while (iter.next()) |val| { ... }` would change to this `for (something.getIterator()) { ... }` ?

1566408917
Tetralux
Either that, or just `for (something) {}` depending on how you did it.

1566408936
Akuli
(forgot |val| from my for  loop)

1566408937
donpdonp
Akuli: or a step further, if there were a standard for getting the iterator then for(something) |item| {}

1566408946
Tetralux
Personally, I don't really like having to have a whole extra struct and making that work to do something that so simple as iterating over it.

1566408955
Akuli
donpdonp, i think that would be a bit too much magic for zig

1566408973
Akuli
i'm used to it in python, but it's not a thing i would want in zig

1566409017
donpdonp
Akuli: i can understand that, but whats the test for the expr in for(expr) to see if its an error-union or an iterator-type?

1566409017
Tetralux
You could always make iterating a slice be `for (slice.iterator()) |item| {}` too... ;)

1566409032
Akuli
what does the error-union thing do anyway :D

1566409046
Tetralux
It breaks when it returns an error.

1566409050
Tetralux
Otherwise it keeps looping.

1566409062
Akuli
calling it in the beginning of each loop?

1566409070
Tetralux
I believe so.

1566409073
andrewrk
while and if are the same; only difference is with while, control flow continues

1566409103
donpdonp
var valueOrError = doit_maybe(); if (valueOrError.error) { err; } else { var winner = valueOrError.value}; that simplifies into if(doit_maybe()) |value| {} else |err|

1566409124
Tetralux
^

1566409132
donpdonp
folding the temporary variable into for looks like avoiding the temporary iterator varaible into for o^O

1566409186
donpdonp
which is why for(iterator) is so attractive looking :)

1566409240
Tetralux
Also, you actually don't

1566409268
Tetralux
If you could mark a fn as an iterator.

1566409295
Tetralux
generator fn iterate(self: *Self) ElementType {}

1566409324
Tetralux
Well - maybe that's a bad example.

1566409339
Tetralux
Maybe more like - though maybe this isn't the best way exactly - but

1566409409
Tetralux
Well---okay--- my first thought was something like

1566409422
Tetralux
fn next() @iterator {}

1566409444
Tetralux
And then Zig's for loop goes "Does this thing have a fn marked as the iterator?"

1566409473
Tetralux
But that's a little funky.

1566409486
Tetralux
Because then you'd have to do the same thing with 'next'.

1566409497
Tetralux
But I don't really like having the extra iterator struct anyway.

1566409499
gonz_
And then the programmer goes "Does this thing have a fn marked as the iterator?"

1566409545
Tetralux
That's true, but you could just assume it did and get a compile error xD

1566409592
Tetralux
The compromise position is `for (map.iterator()) |entry| {}`

1566409614
Tetralux
But I'd like to force slices to need that too.

1566409616
Tetralux
You know

1566409625
Tetralux
Because you don't want for to need to understand userspace code.

1566409641
mikdusan
i haven't sussed it out enough but i'd like to see compiler recognize loop trait for a struct. it might be 2 funcs, one for const and one for non-const and trait would identify func name

1566409648
Tetralux
To be clear - I don't want to do that.

1566409673
Tetralux
mikdusan: I think that's kinda the same as iterator struct.

1566409685
Tetralux
Honestly, I'd prefer a slightly novel way.

1566409726
Tetralux
Essentially, the for loop identifies a member fn for the type, say it looks for `.iterate`

1566409730
donpdonp
the zig docs refer to Allocator as an interface, so it seems an Iterator interface is doable in zig as it is today. I'm not sure if its efficient to have for(expr) test for it.

1566409741
Tetralux
And it passes a comptime-known function pointer to it.

1566409770
Tetralux
.iterate is then implemented to iterate over the structure, and @inlineCall that function pointer, passing the current element in, at the appropriate point.

1566409787
Tetralux
The idea being that there is no function call at runtime.

1566409797
Tetralux
To either .iterate, or the function ptr.

1566409809
Tetralux
Both are just gaurenteed to be inlined.

1566409836
Tetralux
The benefit of this is that the iterate's code is literally just documenting how you iterate the structure.

1566409864
Tetralux
.. but in the form that you'd write it, if you just knew how the structure worked.

1566409883
Tetralux
.. and then the programmers that use the code can just use the for loop.

1566409908
Tetralux
Not only that, but it's one function for the entire iteration procedure.

1566409916
Tetralux
And it's much shorter.

1566409930
Tetralux
And is exactly the code you wanted to write, and almost no-more.

1566410217
Tetralux
Something like this, say:

1566410476
Akuli
what would it do if you use 'a' or 'list' or some variable in { } of the loop? magic?

1566410560
Tetralux
It would work as expected, because the call to iterate never happens. That's @inlineCall as well.

1566410624
Tetralux
It basically just pastes the content of .iterate into the caller, replacing the for loop you wrote, behavior-wise.

1566410665
Tetralux
It's no more magic that for loops currently are.

1566410681
Tetralux
Except that you can fill out the body of what it does in user code.

1566410691
Tetralux
no more magic than*

1566410715
Tetralux
.. and write the iteration code in the way you would to iterate the structure, and no more.

1566411266
Tetralux
[Updated paste.]

1566411318
Akuli
i like how you don't need to create a separate ArrayListIterator struct or similar

1566411335
Tetralux
That is exactly what I love so much about this approach.

1566411351
Tetralux
I've always hated having to do that in every language that does it.

1566411354
mikdusan
what would it look like if iterate can return an error?

1566411369
Tetralux
As well as how the way you write such an iterator is very different from how you'd iterate over it otherwise.

1566411392
Akuli
python's yield does a somewhat similar thing

1566411404
Akuli
class ArrayList: def __iter__(self): for i in range(self.len): yield self.at(i)

1566411417
Tetralux
Akuli: .. accept of course that Python's way is slower.

1566411418
Tetralux
;)

1566411423
Akuli
yeah it is

1566411427
Tetralux
mikdusan: I'm not sure you'd need it to?

1566411432
Tetralux
Can you give an example?

1566411445
Akuli
a failing iterate() would be a bit weird imo

1566411499
Tetralux
You could always allow for on an error union to work like while does currently on an error union. /shrug.

1566411515
mikdusan
Tetralux: std.process.ArgIterator

1566411554
Akuli
hmm now that doesn't seem weird at all

1566411610
Akuli
/ prints 8 (1+2+4)

1566411612
Akuli
// prints 8 (1+2+4)

1566411621
Akuli
lol i had a similar thing in a comment today, i had written:  -1 + 2 = 0

1566411656
Tetralux
Akuli: it even said 7 to begin with an I changed it cause I thought it was wrong LUL

1566411664
Tetralux
Yeah - I'm not sure iterating should fail.

1566411689
Tetralux
We don't support while(errUnion) else {} right?

1566411697
Akuli
ArgIterator is a real-life example where a failing iterator makes sense

1566411739
Tetralux
Well remember, you have control what it'd do.

1566411746
Tetralux
Well

1566411752
Tetralux
"You" = "the person who wrote the iterator"

1566411801
donpdonp
for(iterable) might be moot with async enabling array_list.for(process_each_item_function)

1566411809
Tetralux
Ugh.

1566411822
gonz_
Tetralux: Error unions work with `while (...) { ... } else |err| { ... }`

1566411842
gonz_
Or what did you mean?

1566411857
Tetralux
gonz_: Yeah - okay - in that case, mikdusan, you could just give for an else branch for if iterate returned an error.

1566411862
Tetralux
That's a possiblity.

1566411931
Tetralux
You could also `for(try list) |item| {}` but maybe that's a little too weird?

1566411944
Tetralux
I dunno - I'd prob be okay with it.

1566411960
Tetralux
`try for (list)` is another option.

1566411975
Tetralux
But `for (list) {} else |err| {}` is the simplest compromise.

1566412017
Tetralux
gonz_: What happens to an error if you use while(errUnion) and don't have an else?

1566412024
Tetralux
Does the error get lost, or does it compile error?

1566412048
Tetralux
Presumably the latter?

1566412184
Akuli
hmm, since if and while are mostly same thing, does this work:  if (foo) : bar=123 { ... }

1566412226
gonz_
Tetralux: If the thing you're using can return an error whatever you're doing in the loop has to be able to use that error union.

1566412247
gonz_
So compile-time error

1566412301
gonz_
So you're checking for it somewhere, either where you're passing it to in the loop or immediately in the loop itself.

1566412395
Tetralux
gonz_: Okay good. That's what I hoped.

1566412403
Tetralux
In that case, it can work the same here.

1566412418
Tetralux
for (list) |item| { ... } else |err| { ... } // must have an else.

1566412427
Tetralux
( .. if it can fail.)

1566412623
gonz_
I misspoke slightly; the actual `while` is what is checked. But yes, compile-time.

1566412795
gonz_
Has anyone used the stb libs with Zig?

1566412832
gonz_
Do they generally translate cleanly? I know I saw someone's project use `stb_` something at some point but can't remember if it was `image` or something else.

1566412890
gonz_
(In case people are wondering what I'm referring to:

1566412938
andrewrk
gonz_, you can use them like this:

1566412968
andrewrk
translate-c isn't feature-complete enough to translate the header files directly into zig but it should be possible eventually

1566412994
gonz_
Coolio

1566413000
Mr_Slurpy
Hello, I'm trying to compile the "vulkan-triangle" example but I keep getting a `error: no member named 'install' in struct 'std.build.LibExeObjStep'` among other errors. Does anyone know how to fix this?

1566413019
andrewrk
Mr_Slurpy, you'll need to use a master branch build of zig

1566413059
andrewrk
there are master branch builds available on ziglang.org/download

1566413159
Mr_Slurpy
Ah ok. Would the package from the AUR work? Or I have to download it manually?

1566413235
andrewrk
I'm not sure what version the AUR package is

1566413236
gonz_
andrewrk: The array is passed to what is basically `zig cc`? I.e. you could put `"-D STBI_NO_PSD"` in that array to define that?

1566413246
andrewrk
Mr_Slurpy, you can use `zig version` to find out

1566413267
andrewrk
gonz_, yes

1566413279
Mr_Slurpy
It seems to be 0.4.0

1566413288
Mr_Slurpy
I guess ill dl it manually

1566413312
andrewrk
at this point there have been 1136 commits to master since 0.4.0

1566413352
gonz_
What did the last release cycle end up at in total?

1566413358
gonz_
That's a truck-load of commits

1566413376
andrewrk


1566413391
mikdusan
git rev-list 0.3.0..0.4.0|wc -> 876

1566413409
andrewrk
I also put it in the release notes:

1566413491
andrewrk
oh, oops, I linked the wrong one

1566413558
andrewrk
heh, looks like I need to adjust the update_download_page code now that std.fmt changed

1566414977
Tetralux
Hmmm.

1566414998
Tetralux
Suppose you want to remove an element from std.ArrayList while iterating over it.

1566415009
Tetralux
A well-defined thing that you might want to do.

1566415029
Tetralux
Currently, you could iterate by index and manually do the removal.

1566415052
Tetralux
(See my PR that adds that functionality to the struct:

1566415059
Akuli
be careful with off-by-one issues though

1566415081
Tetralux
Akuli: .. which is why you don't wanna do it yourself.

1566415086
Tetralux
You want the struct author to do it.

1566415087
Akuli
python is kinda shitty at this, e.g. what does this pring?

1566415092
Akuli
it prints [2, 4]

1566415099
Tetralux
I'm not sure how you'd be able to do this without the iterator.

1566415111
Tetralux
Jai does it by having a 'remove' keyword.

1566415134
Tetralux
Akuli: Yeah - that's how you don't bother implementing it xD

1566415190
Akuli
tbh i would be happy with an assert that the list length doesn't change while looping

1566415209
Tetralux
Problem with that is you actually might want to remove an element while looping.

1566415212
Tetralux
And you probably will.

1566415216
Tetralux
Because it's efficient to do so.

1566415219
Akuli
then loop with indexes :D

1566415235
Tetralux
Indeed, but it's a fairly basic operation.

1566415236
Akuli
removing an element from middle of an array is O(n) anyway

1566415242
Tetralux
It is not.

1566415243
Akuli
and not a thing i need very often

1566415245
Akuli
it is

1566415246
Tetralux
See swapRemove.

1566415253
Akuli
you need to shift the remaining items left

1566415257
Tetralux
You do not.

1566415269
Tetralux


1566415288
Akuli
but this screws up the order

1566415291
Tetralux
It's only slow if want to preserve order.

1566415301
Tetralux
You don't necesarily care about order.

1566415307
Akuli
if you don't care about the order, then why would you use an array in the first place?

1566415312
Tetralux
....

1566415321
Tetralux
Because you want to keep track of multiple things? xD

1566415325
Akuli
why not a set?

1566415330
Akuli
(i started as a python programmer)

1566415337
Tetralux
It's not about uniqueness.

1566415341
Tetralux
It's about order.

1566415347
Tetralux
You don't care about either thing.

1566415355
Tetralux
You just have a list of items, and you want to process them.

1566415358
Akuli
hmm, so you would use an array for an unordered collection of possibly non-unique items?

1566415368
Tetralux
All the time.

1566415377
Tetralux
That's my main use of arrays

1566415379
Akuli
how do you count the occurences of an item in it? O(n)?

1566415386
Akuli
or check whether it contains an item?

1566415396
Tetralux
You keep track as you add stuff to it.

1566415399
Akuli
i would use a hash table with count integers as values to have both of those be O(1)

1566415435
Tetralux
If I care about order, I normally use a linked list.

1566415445
Tetralux
That way prepending and appending are O(1).

1566415455
Tetralux
OR

1566415464
Tetralux
I keep them ordered as I insert them.

1566415489
Tetralux
But that's pretty rare that I care.

1566415517
Tetralux
Normally, unordered is fine, and if I need ordered, I either keep them ordered when inserting, or call sort at the appropriate moment.

1566415524
Tetralux
The latter is usually enough.

1566415538
Tetralux
Depends on item count of course.

1566415580
Akuli
thanks, i hadn't thought of arrays as a thing usable for order-doesnt-matter cases before

1566415591
Tetralux
I'm kind of surprised xD

1566415591
Akuli
unless the data is small and O(n)-ness doesn't matter ofc

1566415605
Tetralux
Though I guess I shouldn't be.

1566415614
Tetralux
There's many things like that that aren't necessarily obvious.

1566415620
Akuli
i'm still a bit worried about finding something from the array

1566415641
Tetralux
Short answer is: Avoid needing to.

1566415646
Akuli
ik but still

1566415691
Tetralux
I don't often need to linearly search an array.

1566415719
Tetralux
And times I do, I don't expect to have to search through all of it.

1566415726
Tetralux
The item I want should be near one end.

1566415733
Tetralux
So just start at that end.

1566415761
Tetralux
Basically, try to architect the program so that you don't need to care about it.

1566415814
Tetralux
And if you think you need to use a slow algorithm, like sort, or keeping order, or "does it contain this", then think about it for a bit and see if you could do rework how the list is used to not require t hat.

1566415842
Tetralux
The bone-headed example being: If I really need to know if this thing is in the list, use a map.

1566415848
Tetralux
OR

1566415854
Tetralux
Use the index into the array as the key.

1566415857
Tetralux
Then an array is fine.

1566415860
Tetralux
.. and faster.

1566415868
Tetralux
Much faster.

1566415910
kristoff_it
Damn I'm millimeters away from a working PoC redis client. I'm trying to use `connectUnixSocket` since it seems to be the only available networking facility available in the standard library but on macOS it causes compile errors. Does anybody know if it's completely broken or it's something minor? Does anybody know if it works on linux?

1566415931
Tetralux
We don't have networking yet - so I'd expect nothing to work xD

1566416229
Akuli
you can create some socket code in c and compile it with zig code afaik

1566416250
Akuli
connectUnixSocket sounds like an AF_UNIX thing, you want AF_INET

1566416253
Akuli
(i think)

1566416277
fengb
connectUnixSocket looks like old async code that probably wasn't updated yet

1566416304
kristoff_it
ok so it's not just the darwin codepath that wasn't updated

1566416389
kristoff_it
Akuli: I don't know about that honestly, sorry, I'm a dirty python programmer by nature so I just know that I started Redis with the --unixsocket option to make it accept connections using a unix socket and I was trying to use that

1566416407
Akuli
oh then you really do want a unix socket

1566416415
kristoff_it
related question: I can't just open the unix socket as a file and write / read to it, can I?

1566416429
Akuli
have you ever programmed with python's sockets? they are easier to get started with than sockets in c

1566416452
Akuli
i think you need to open it with socket() and connect() instead of open()

1566416618
Akuli
kristoff_it, nice video, if you have never programmed with sockets:

1566416689
Akuli
unix sockets are similar to AF_INET, they just look like files on the file system and their addresses are paths

1566417105
kristoff_it
thanks for the pointers

1566417809
fengb
andrewrk: is there a way to override the generated generic debug symbols?

1566417842
fengb
'types.FromVarintCast(i64,coder.Sint64Coder,(struct types.FieldInfo constant))' this would be much more helpful as 'types.Sin64(1)'

1566418916
gonz_
Did we have a way to deal with not being to zero-initialize C-structs?

1566418932
gonz_
I seem to remember seeing a solution in an issue at some point

1566419318
gonz_
And yes, I know they're just normal structs, but I'm trying to zero-init them and just change the parts I need.

1566419481
Tetralux
Made a proposal:

1566419646
kristoff_it
oh my god this is why I never wanted to deal with certain apis... why the hell does sockaddr_in have a len field while the connect api also asks for a len parameter

1566419652
kristoff_it
what's going on

1566420189
FireFox317
kristoff_it: The network api of the zig std is not final yet and I think there are some big changes coming in the next release cycle

1566420258
fengb
I think he's dropping into the raw posix layer

1566420507
kristoff_it
I currently have this code

1566420565
kristoff_it
anybody that's used to this stuff see any obvious error?

1566420572
FireFox317
Ah my bad, i see

1566420601
gonz_
Is there a cleaner way to do this currently?

1566420615
gonz_
This seems to work fine

1566420629
gonz_
And then you just set the fields you need to set after, emulating typical C behavior

1566420776
kristoff_it
written this way I think you would not respect alignment for certain types. If you do it the other way around (first create a var x: T = undefined) and then you zero it by casting x to bytes, then you should be fine.

1566421070
kristoff_it
uhmm I'm trying it myself and I seem to be wrong, I don't get any error even when trying with weird types

1566421224
gonz_
Considering that, though, you mean something like this?

1566421279
fengb
I think it memcopies the 0s into the resulting location, so alignment will eventually be respected

1566422195
kristoff_it
gonz_: something similar yes, I think mem.toBytes creates another copy, while I meant to write directly to `value` (using your variable names), so you would need to `@memSet(@ptrCast([*]u8, &value), 0, @sizeOf(T))`

1566422200
kristoff_it
and then you return `value`

1566422213
kristoff_it
anyway, your original code seems to work

1566422222
kristoff_it
btw I was able in the meantime to connect

1566431220
mikdusan
Tetralux: does it makes sense to consider const vs. non-const in the loop construct? i'd love to be assured that there is a universal way to say "iterate and intend to modify elements"

1566431302
mikdusan
`for (list) |*e| {...}` ?

1566431355
Tetralux
You could require a non-const pointer to the struct, or struct value to remove stuff.

1566431360
Tetralux
But yeah

1566431378
Tetralux
Doing *e to mean "I am able to remove this" is nice for the purposes of easily changing it.

1566431411
mikdusan
along those lines... would that require 2 iterate functions? eg. `iterate()` and `iterateConst()`

1566431440
Tetralux
There's no difference in implementation of the iteration.

1566431442
Tetralux
So I'd hope not.

1566431454
Tetralux
It's literally just "am I allowed to remove or not?"

1566431476
Tetralux
The

1566431547
Tetralux
Personally, if you're faffing around with the data in the fields of a struct, you should know what you are doing.

1566431566
Tetralux
So you should probably be one of that struct's methods, or you should know what you're doing.

1566431611
Tetralux
Being able to remove an element can be prevented by using *const T, but I'm not sure how useful that is really.

1566431717
Tetralux
Certainly, being able to iterate by pointer could be a comptime parameter to iterate.

1566431730
Tetralux
And that's how it'd give you a pointer to the item.

1566431798
Tetralux
Also, you can infer whether you want to be able to remove or not - you're using `remove x` :p

1566431812
mikdusan
currently in the realm of fn arguments the compiler decides value/reference when const... for perf reasons

1566431826
mikdusan
and when non-const you signal intent with `*`

1566431849
mikdusan
i

1566431909
Tetralux
Zig would know statically if you wanted to possibly remove, whether you wanted to do it keeping order or not, etc.

1566431940
Tetralux
The express point of the mechanism is that it is

1566431962
Tetralux
It would know btw, because you'd be using the remove keywords.

1566431978
Tetralux
If you never did - it would know it could do the equivalent of using .iteratorConst in my PR.

