1568937638
andrewrk
_Vi, not including C code. that's something that could be worth exploring

1568937658
andrewrk
zig is uniquely positioned to make LTO across C and Zig "just work"

1568937681
andrewrk
because it can do it without surfacing LTO as a user concept, it can be an implementation detail

1568937699
andrewrk
`build-exe` does not specify the object file format, or even that object files must be created at all

1568937729
_Vi
I expect cross-language LTO to also work for foreign code from *.a files not built by `zig cc`. Like `Zig <-> C <-> Rust`  LTO.

1568937735
mikdusan
true. one issue they had was llvm versions produced by clang vs rust. so zig has it all lined up same version

1568937962
telemach
ah, found it, if anyone else is interested

1568937971
_Vi
What variable naming scheme is supposed to be used in Zig to simulate shadowing? `var x = ...; var x2 = ...; var x3 = ...;` or `var x = ...; var x_ = ...; var x__= ...;`?

1568938019
andrewrk
is this an abstract question or do you have an actual use case?

1568938033
andrewrk
this is not an issue

1568938071
andrewrk
I don't mean to be rude, I mean that I have written a lot of zig code and this has not been an issue in practice

1568938169
fengb
It can be a little hard to pick up

1568938198
_Vi
For example, in first part of a function someting is `?T`. Then it is established that it is not `null`, and the rest of the function continue with the same thing, but in non-optional form.

1568938252
andrewrk
call it opt_thing and then you can use thing if it's not null

1568938282
_Vi
Means prefixing identifier with type-related things?

1568938308
andrewrk
not necessarily. I don't think these abstract questions are going to have satisfying answers

1568938328
_Vi
E.g. something starts as "ptr_opt_widget", then it later it is "opt_widget" and finally "widget". Later "cloned_widget"...

1568938351
andrewrk
I sincerely, honestly do not see a problem here

1568938359
_Vi
Is there a code style document for Zig?

1568938382
Tetralux
_Vi: That instance, there's a pattern of `var thing = opt_thing orelse ...;`

1568938411
Tetralux
I've run into that as well.

1568939814
_Vi
Is it a bug that "inline while loop" test (

1568940200
_Vi
Probably yes, filed:

1568941141
_Vi
"stdcallcc" -> Why calling conventions are keywords? If new calling convention gets added late, does that mean new keyword will be added (invalidating identifiers)?

1568941282
_Vi
Maybe better `callcc("stdcall")`?

1568941299
andrewrk
_Vi,

1568941310
andrewrk
anyone want to place bets on whether

1568941500
_Vi
I'd bet that not (but only a little sum).

1568941716
_Vi
What is closest analogue of closures in Zig? Or are there real closures, but I haven't yet reached that place in documentation?

1568942724
donpdonp
zig got a nice mention in the llvm9 release notes.

1568942916
stratact
üéâ

1568944926
stratact
andrewrk: I think the Azure CIs in my PR are stuck in a loop waiting for the next avaliable agents. It's been going on for 45 minutes now, how can I reset them?

1568945305
mikdusan
wow i just realized enum supports bound functions

1568945517
Tetralux
??

1568945604
mikdusan
Tetralux:

1568946079
Tetralux
Ahh!

1568946097
Tetralux
Yeah - I had a moment of wondering that a while back and tried it xD

1568946153
andrewrk
stratact, the CI is for me, not you :P test locally

1568946185
andrewrk
the point of the CI is so that I don't have to ask people whether they tested locally, it just does the testing

1568946516
stratact
I realized that a couple of hours ago since that was the point of my 2nd PR and fair enough. Other than the need to merge std/fs_ext.zig into std/fs.zig, I want to know what other kinds of things I should clean up or do to enhance the work, if need be.

1568946683
mikdusan
Tetralux: using enums like that. such a perfect place for conversions and mapping functions. it's things like this i love about zig

1568947911
stratact
How come `==` is not allow for []const u8?

1568948048
fengb
Probably because it‚Äôs ambiguous whether you want to compare the pointer or do a memcpy

1568948109
Tetralux
More likely that it's slow.

1568948127
Tetralux
I don't know about anyone else, but I've

1568948143
Tetralux
I'd do a.ptr == b.ptr.

1568948170
Tetralux
I have found myself wanting to == slices though.

1568948176
fengb
But it also doesn‚Äôt overload operators

1568948204
fengb
So the only non overloaded behavior is pointer + len check (pretend it‚Äôs a struct)

1568948212
fengb
But that‚Äôs probably not what you want

1568948228
brodeuralexis
Is there any way to obtain generic information of structs at comptime ?

1568948229
brodeuralexis
Supposing I have `Matrix(usize, usize, T)`, can I have something like `fn matrix_add(a: Matrix(infer N, infer M, infer T), b: Matrix(N, M, T)) Matrix(N, M, T)` ?

1568948272
Tetralux
Only by passing comptime T: type

1568948285
Tetralux
And then b at the rettype is T

1568948292
Tetralux
But yeah that would be nice.

1568948300
Tetralux
Honestly I'd like that.

1568948395
brodeuralexis
I came upon this problem trying to implement some linear algebra data structures and wanted the help of the type system to catch bugs.

1568948435
brodeuralexis
Heck, you could replace `infer T` with `var T`, so no new keyword gets added.

1568948504
Tetralux
For reference, Odin does this with `matrix_add(a: $MATRIX/Matrix($N, $M, $T), b: MATRIX) MATRIX` IIRC.

1568948538
Tetralux
In the body, MATRIX is the matrix type, and M, N, T are the type parameters to Matrix.

1568948645
brodeuralexis
Though I understand Odin's syntax, I can't explain why I do not like it :P

1568948682
Tetralux
I like that you don't have to think about the type before you type it.

1568948686
Tetralux
You just write it out.

1568948718
Tetralux
I want a generic type, so long as its a Matrix, with type params N, M, and T -- oh and also return a value of that same type.

1568948724
Tetralux
It flows quite well.

1568948781
Tetralux
I also like that the main difference between it and the normal case is that you have the '$'.

1568948809
Tetralux
I find it quite elegant.

1568948846
brodeuralexis
Now I think I like it a little more ;)

1568948953
Tetralux
Oh - I didn't type the last part

1568948959
Tetralux
'$' = 'comptime' :)

1568948962
Tetralux
XD

1568949009
Tetralux
Well - no - "generic type"

1568949017
Tetralux
I should really go to bed soon...

1568949035
Tetralux
No-one saw anyting.

1568949104
brodeuralexis
Goodnight

1568949155
Tetralux
I ain't gone yet xD

1568949468
brodeuralexis
Maybe I should go to bed then.

1568949625
andrewrk


1568949768
mikdusan
congrats. üëç

1568949876
brodeuralexis
(y)

1568950272
andrewrk
alright, now it's just bug squashing until the release

1568950298
andrewrk
it's time to pay the pied piper

1568950348
hspak
Oooh nice Zig shoutout in the release notes:

1568965139
mq32
hspak, yeah that sounds like a good promotion :)

1568966329
_Vi
Zig tends to output large chunk of uninitialized memory in compiler error messages when encountering bugs...

1568966432
mikdusan
stage1 compiler mostly never frees any heap

1568966683
_Vi
It's not excuse for outputting it to stderr.

1568966738
mikdusan
oh i misunderstand what was meant by "output"

1568966856
mikdusan
but no, zig doesn't tend to do that. empirically that garbled stderr is quite rare.

1568969026
Pwipwi
hello all, I'm trying to build an array with [_], but it tells me _ is an undeclared identifier

1568969042
Pwipwi
also, I'm trying to create a "c style" array

1568969063
Pwipwi
const Fn = extern fn () void;export const init_array linksection(".init_array") = [_]Fn {  init_module};

1568969072
Pwipwi
I'm having no luck so far

1568969182
mq32
Pwipwi, which version of zig are you using?

1568969192
Pwipwi
0.4

1568969199
Pwipwi
when I remove export, it compiles

1568969204
Pwipwi
but I need it exported

1568969285
mq32
you should use the current master branch

1568969292
mq32
(precompiled on the website)

1568969297
mq32
it is much improved over 0.4

1568969347
Pwipwi
ok effectively, that works

1568969355
Pwipwi
well, it compiles at least :)

1568969408
Pwipwi
it however still doesn't do what I want. :(

1568969435
Pwipwi
bonus question : is it possible at all to do a relative import of a c header ?

1568969439
mq32
what do you want to achieve?

1568969563
Pwipwi
I want to write a nodejs extension using zig

1568969619
Pwipwi
I'm managing to create a dynamic library, but I can't seem to have the module "self-register", which it seems to do by having the `napi_module_register()` function called at library load time

1568969660
Pwipwi
so I created a function that does exactly that, which I intend to call when my library loads, but no dice.

1568969719
Pwipwi
is it possible to link against libc on the command line ?

1568969731
Pwipwi
(I'm trying to do a printf for debugging)

1568969816
mq32
yes

1568969826
mq32
but you can also print with std.debug.warn()

1568969844
Pwipwi
--library c, found that

1568970341
Pwipwi
if I do a std.debug.warn, should it display something if I am in a terminal ? No matter how it is called

1568970342
Pwipwi
?

1568970463
Pwipwi
ok sorry for the constant spam, anyway I managed to have my function called. It would seem that calling my function something else than "init_module" did actually work

1568970469
Pwipwi
I have

1568970494
mq32
do you have extern calling convention of your function?

1568970507
mq32
if you want to call it in .init_array

1568970522
Pwipwi
I suppose c if that makes any sense

1568970623
mq32
yeah, c calling convention

1568970660
Pwipwi
I still don't get why the name would be an issue

1568970693
mq32
it should not be the name, but the calling convention that will change

1568970716
Pwipwi
I declared them the same, with a plain extern

1568970748
mq32
how is Fn declared in your example?

1568970761
Pwipwi
const Fn = extern fn () void; ?

1568970789
Pwipwi
I then have a `export fn _register_my_module() void {`

1568970800
Pwipwi
which ceases working whenever I rename it as init_module

1568970816
Pwipwi
... maybe there is a symbol that I'm shadowing if I do so ?

1568970883
mq32
huh, weird

1568971772
Pwipwi
IT WORKS

1568971776
Pwipwi
I DID IT YAY ME

1568972045
Pwipwi
by the way, I did it all by going into `node_api.h`, which is laden with macros everywhere which they want you to use

1568972059
Pwipwi
I suppose there is no way of calling those from zig ?

1568972069
Pwipwi
(I just created the objects and called the functions)

1568972143
Pwipwi
is there a way to dump the result of a .h file interpretation by zig ?

1568972171
mq32
i think it's somewhere in the zig-cache directory

1568972190
Pwipwi
oh, I suppose then that it's not zig code

1568972226
Pwipwi
oh it is

1568972278
mq32
i'm interested in how well my small C library will translate to zig

1568972341
Pwipwi
well so far it's pleasantly surprising

1568972845
Pwipwi
how do I add an include path ?

1568972856
Pwipwi
so far I've been putting the complete path to my header

1568972870
mq32
-I i think

1568972905
mq32
-isystem [dir]               add additional search path for other .h files

1568972924
Pwipwi
ah I grepped include, missed that

1568972971
Pwipwi
say mq32, how far do you think zig is from having an functioning stage 2 compiler with auto complete support ?

1568972984
Pwipwi
a*

1568972984
mq32
i have no idea

1568972997
mq32
i think it's still a big pile of work

1568973009
Pwipwi
I'm kinda grokking the idea of doing a temporary one in javascript for vscode

1568973016
Pwipwi
I really miss having autocomplete

1568973142
daurnimator
Pwipwi: have you tried tabnine?

1568973164
Pwipwi
no, never heard of it

1568973168
Pwipwi
is it any good ?

1568973181
daurnimator
yeah its sort of scarily good

1568973206
Pwipwi
with zig even ?

1568973380
Pwipwi
¬´ Nonetheless, there are some situations where you would rather use a semantic completer than TabNine. For example, if you don‚Äôt know what methods are contained in the class Math, you could type Math.and see what suggestions are provided by the semantic completer. ¬ª

1568973391
Pwipwi
unfortunately that's precisely my use case :D

1568973571
daurnimator
Pwipwi:

1568975492
Pwipwi
how does one consume a zig library ?

1568975500
Pwipwi
just doing @import is enough ?

1568975511
Pwipwi
even when they go through a build phase and all ?

1568975519
Pwipwi
this part is still a little obscure to me

1568975581
lluchs
add it to the build.zig

1568975595
Pwipwi
is there some docs for the whole build thing ?

1568975606
lluchs
like: exe.addPackagePath("somelib", "path/to/somelib.zig");

1568975624
lluchs
and then you can do @import("somelib")

1568975664
daurnimator
Pwipwi: ^ this works via `--pkg-begin`/`--pkg-end`

1568975693
daurnimator
it should get easier to manage once we get the package manager...

1568976182
Pwipwi
are there closures in zig ?

1568976208
mq32
nope

1568976363
Pwipwi
is it then possible to wrap functions at compile time to create another function ?

1568976382
Pwipwi
I'm trying to define some nicer structs to use with the node api

1568976395
Pwipwi
of course, I have to supply pointers to functions that handle the native types

1568976414
Pwipwi
I would like to not have to see them ever, and only deal with functions that handle my defined types

1568976979
bgiannan
you can wrap functions in structs but they won't have access to anything other than their parameters and global variables

1568977006
Pwipwi
the struct is callable ?

1568977043
bgiannan
no

1568977063
Pwipwi
ok

1568977083
Pwipwi
can it be converted to a pointer to a function callable by c code ?

1568981753
daurnimator
bgiannan: blank comment?

1568981888
bgiannan
refresh

1568981914
bgiannan
huh misread you daurnimator

1568981984
bgiannan
there

1568981991
bgiannan
now it makes sense

1568982019
daurnimator
bgiannan: what if you move

1568982032
daurnimator
bgiannan: also .? is safe in zig safe modes.

1568982050
fengb
I actually really dislike how complicated the Swift thing looks

1568982059
bgiannan
what do you mean by safe then?

1568982110
bgiannan
fengb, i don't like a lot of complex features swift has but i think they got the concept of optionals right

1568982132
fengb
The syntax doesn‚Äôt solve the problem imo

1568982137
daurnimator
bgiannan:

1568982164
bgiannan
daurnimator, that's not safe as i mean it then, just more useful for the developer

1568982171
fengb
It just muddles it. The zig one has awkward nesting but it‚Äôs a lot more readable

1568982213
bgiannan
fengb, what are you thoughts on swift's optional chaining?

1568982301
fengb
Eh... it‚Äôs always bothered me since ObjC

1568982302
bgiannan
daurnimator, in Swift I avoid `!` (which is `.?` equivalent) because it inevitably leads to nil-unwrapping in production because somebody used it wrong or moved code using it

1568982325
fengb
I‚Äôd prefer a different operator

1568982411
bgiannan
daurnimator, i actually set up our linter to block compilation if `!` is not used in a few whitelisted cases

1568982573
fengb
I guess my beef with Swift is that it uses a let, 2 assignments, a comparison, and finally a block. It looks like it‚Äôs trying to do 3 different things as one giant statement

1568982596
ceymard
hello everyone, does anyone know how can I supply a function linked to a struct as a callback ?

1568982599
fengb
It works, but it looks like it‚Äôs just kludged together

1568982603
bgiannan
fair enough but i think it's needed for the few reasons i just described

1568982684
mq32
hey

1568982711
mq32
fengb, how would you solve the following problem:

1568982724
mq32
i have an API that has an internal message reception system

1568982743
mq32
now if the user of the API wants to access the messages, i could provide the following:

1568982760
mq32
SDL-Style Event pumping (You poll for every single event and get a struct pointer=

1568982779
mq32
or i make it callback based which would make memory management easier (callback receives memory,but does not own it)

1568982816
mq32
right now, i'm more towards the second option, as it makes memory management more easy, but i think about how the callback(s) are designed

1568982828
mq32
one callback per event type or one callback for all events accumulated

1568982871
fengb
Whenever I hear callback, I would think async could be better :P

1568982885
mq32
pure C api doesn't support async ;)

1568982890
fengb
So I‚Äôm Go, I‚Äôd use a channel

1568982896
fengb
Oh

1568982918
mq32
i don't want any dependencies to language features like async/channels

1568982922
daurnimator
mq32: always "pull" and provide notifications

1568982954
mq32
daurnimator, can you elaborate that?

1568982958
mq32
right now, my API is this:

1568982992
daurnimator
mq32: i.e. your api should have a `give_me_some(&output_buffer, max_items)` and a `give_me_a_filedescriptor_that_will_poll_readable_when_you_have_some()`

1568982997
mq32
Error pumpEvents(Connection*, EventHandler *, void *)

1568983075
mq32
problem with your approach is that i have to copy owned memory into output_buffer

1568983085
mq32
so user has to make sure that this memory will be released after a call to give_me_some

1568983102
mq32
(also i cannot rely on structures like file descriptors)

1568983120
daurnimator
that's fine. it can be up to the caller to do: `for output_buffer[0..max_items] |item| free_item(item)`

1568983137
mq32
hmm

1568983162
daurnimator
mq32: on unix you can always have a file descriptors; on windows use an EVENT

1568983172
mq32
on "undefined" you cannot have anything like that :D

1568983179
mq32
would still require some heap allocations and i want to prevent that

1568983187
daurnimator
mq32: on linux in particular you would use an `eventfd` if your process is not driven by an underlying fd.

1568983209
daurnimator
mq32: then the size of your items needs to increase

1568983221
mq32
to probably unknown size?

1568983231
daurnimator
you could go netlink style where the items are variable size

1568983233
mq32
item could be 1 byte or 1MB

1568983258
mq32
also i already have memory allocated internally for the items

1568983272
mq32
so it would be nice to get to reuse this memory

1568983351
daurnimator
mq32: if it's really worth it you can pass out handles to the memory.... again have a look at netlink

1568983561
ceymard
is there a way to create function dynamically ?

1568983587
daurnimator
ceymard: no

1568983596
daurnimator
well; at comptime yes. runtime no

1568983602
ceymard
ok

1568983606
mq32
daurnimator, what do you mean by "netlink" exactly? i can only find some spars docs on that term that referens to linux manpages

1568983609
ceymard
so no possible way to tie data with a function

1568983615
daurnimator
mq32: that's it

1568983641
ceymard
I can't have a function part of a struct, which when given as a pointer will be able to use the struct ?

1568983650
mq32
hm, can you point me to the right resource? right now i found only generic stuff, nothing about memory handling or similar

1568983650
daurnimator
mq32: netlink is how you e.g. can listen to your firewall logs

1568983815
fengb
Hmmmm, we could use async frames as adhoc fat function pointers

1568983827
daurnimator
mq32: rfc3549 ?

1568983835
bgiannan
ceymard,

1568983849
daurnimator
mq32: though that's not super helpful

1568983875
fengb
fieldParentPtr still depends on a pointer reference inside the struct

1568983885
ceymard
oh, that's pretty sweet

1568983901
ceymard
I saw mentionned on the archives that someone made a closure-like thing at comptime

1568983910
ceymard
I'd like to see code where functions are dynamically generated

1568983926
fengb
Allocators are the best example in std

1568984007
ceymard
fengb: right, so this doesn't help me after all since I don't have the field's address but the function's

1568984039
fengb
Functions in Zig are like C. They‚Äôre always global and statically defined

1568984061
fengb
Er... not always global but definitely static memory

1568984064
ceymard
so I can't wrap a function of a given type to transform its arguments and call another one

1568984074
mq32
daurnimator, i think i will go with the pump(callback) method, this will make both using and implementing the library simple

1568984096
fengb
So you need to manually pass in a pointer reference

1568984134
daurnimator
mq32: callbacks are always fraught with danger..

1568984152
daurnimator
mq32: unless you are super super high performance; just use a pull model and use the heap where you need...

1568984163
ceymard
I'll try to describe better what I mean ; in a library I'm using, a function expects a function pointer as an argument. The passed function expects certain arguments of certain types. I find it a chore to deal with those types. So I'd rather have them transformed into other types and call another function that handle the nice types.

1568984175
mq32
daurnimator, in what way are callbacks fraught with danger?

1568984183
ceymard
And I'd like to do so rather transparently.

1568984202
ceymard
but it seems that there's no solution for me. :)

1568984219
daurnimator
mq32: e.g. what if I want the lifetime of the argument you give me to outlive my callback invocation

1568984238
mq32
then you are free to do the copy yourself

1568984247
daurnimator
mq32: also things around indicating errors; long jumping out; potentially needing to go back to the mainloop (e.g. if I need to prompt the user for a decision)

1568984276
daurnimator
mq32: can I then stop the pumping somehow?

1568984294
daurnimator
(to let me handle this event without proceeding to the next item?)

1568984379
daurnimator
not to mention issues around threading.... e.g. will my callback always be called in the current thread?

1568984382
fengb
ceymard: I think what you need is a function allocated in process memory, which doesn‚Äôt exist yet. There‚Äôs a proposal for closures but nothing concrete

1568984393
ceymard
I thought so

1568984393
mq32
yeah exactly that is the reason why i started this discussion ;) get some input on implementation styles

1568984393
daurnimator
(where the "current thread" is the one where I called pump?)

1568984410
mq32
that's what i have the pump function for

1568984419
mq32
you invoke the function in the thread you want to process your callbacks

1568984429
daurnimator
mq32: do you pump one or many?

1568984442
mq32
yet deciding on it

1568984448
mq32
probably only one

1568984454
ceymard
is it possible to extend a type with functions in another module ?

1568984456
daurnimator
pumping one is usually pretty bad for performance. pumping many is usually bad for developer experience.

1568984475
mq32
(time) performance isn't a thing i care about at this point

1568984479
ceymard
for instance, I get a struct from this c library. Can I add functions to it so that I can call it message-style without messing with the underlying type ?

1568984484
mq32
event density is about "1 / second"

1568984484
daurnimator
mq32: then use the heap as I recommended earlier....

1568984492
mq32
heap hurts me more than time

1568984504
mq32
a lot more (i plan to do embedded, so only 32k Heap)

1568984511
mq32
where parts of the message are already on the heap

1568984520
mq32
so i cannot duplicate stuff just to make a nicer API

1568984536
mq32
at best, the whole library is zero-alloc inside

1568984607
mq32
got to get some food, brb

1568985740
ceymard
how can I remove the optional part of a type ?

1568985792
ceymard
rather, is it normal that the compiler does not accept to assign a non optional variable to an optional field of the same type ?

1568985866
mq32
re

1568986043
ceymard
ok nevermind I was doing multiple c imports of the same file which of course messed things up

1568986105
ceymard
and I found that @typeInfo(my_type).Optional.child did what I wanted in the first place

1568987494
Tetralux
mq32: Why not just have a message struct instance somewhere which gets used for returning the message, but will be overwritten by a call to pump; then if the user wants to keep the message around they copy it.

1568987538
Tetralux
.. otherwise you just reuse the same struct instance all the time.

1568987602
mq32
yeah, this will work for known-size messages

1568987636
Tetralux
I mean, messages are always of known maximum length right?

1568987646
Tetralux
If they were >32K, you'd already break.

1568987665
Tetralux
If you know all messages are <512 bytes, you could just set aside a buffer of that size.

1568987679
Tetralux
You'd then return a ptr to it from pump

1568987684
Tetralux
If it's null, no more messages yet.

1568987720
mq32
Tetralux, yeah, but i have user-input in those messages

1568987728
mq32
so messages may be a whole text document ^^

1568987752
Tetralux
I mean, you already will be forced to truncate or error if their message is too long.

1568987785
Tetralux
Enforce that and limit it, or have a built-in way for the payload to be spread over multiple messages.

1568987786
mq32
yes, but i would really like to prevent having any message twice in RAM

1568987829
mq32
but i got an idea how i can uncouple the library better

1568987845
mq32
push-semantic, but with inversion-of-control

1568987875
Tetralux
I'd definitely go with `while (pump()) |msg_ptr| {}` for getting them

1568987882
Tetralux
I'm not sure what inversion of control means here xD

1568988039
mq32
you provide the library with the actual message contents :D

1568988049
mq32
instead of making something in the library pull the messages

1568988099
Tetralux
Seems ideal.

1568988134
mq32
yeah

1568988143
mq32
having a walk solves IT problems quite good :D

1568988302
fgenesis
probably relevant:

1568988378
fengb
"(and callbacks are bad)"

1568988380
fengb
:P

1568988384
mq32
hey fgenesis

1568988391
fgenesis
haio.

1568988447
Hirezias
Hello, I have a sample of code wich results in segfault and probably would'nt even compile :

1568988542
fengb
It shouldn't compile. ".value = [1]u8{'a'}" shoved a []const u8 into a []u8

1568988562
fengb
You're reassigning static string data in this case

1568988570
Hirezias
My intuition is that the array in wich t has its slice is in read only memory, as a constant, even if its type is mutable.

1568988584
Hirezias
:)

1568988589
fengb
Yep

1568988618
fengb
Need to assign the underlying .value array an actual var

1568988639
fgenesis
hoooly crap golbolting this example turns out as a lot of code

1568988680
Hirezias
Something strange with zig for me is that when you do const a: u32 = 3; and var b: u32 = 3; the types of a and be are the same (equality of @typeOf returns true).

1568988699
fengb
0.4.0 errors out correctly

1568988706
fengb
So there's been a regression :/

1568988721
Tetralux
Anyone else able to build with master right now?

1568988746
Tetralux
Only it looks like it wants to find llvm-config but it doesn't seem to be in the LLVM release binary now?

1568989378
Tetralux
Hmm.

1568989395
Tetralux
Looks like you have to get the version from "Building Zig on Windows" - it's not clear to me why.

1568992633
_Vi
"place bets on whether #3260 will pass CI on 1st try" -> Looks like my pessimistic guess was wrong.

1568992711
ceymard
how can I have the equivalent of a void* pointer ?

1568992716
_Vi
For learning Zig, is it better to update to new LLVM9-based nightly from downloads or stay with older version for a bit?

1568992723
_Vi
ceymard, `*c_void`?

1568992745
ceymard
_Vi : "unknown-length pointer to opaque" comes up a lot in compilation errors

1568992751
ceymard
when I use that

1568992764
mq32
ah yeah

1568992772
_Vi
ceymard, What do you want to use `void*`-like pointer for?

1568992775
mq32
you cannot use a c-style pointer to an opaque type

1568992785
mq32
just use a "normal" pointer to that type

1568992794
ceymard
I don't know this type in advance

1568992809
ceymard
I'm interacting with a C library which gives me void* pointers

1568992822
mq32
const Unknown = @OpaqueType(); const PointerToUnknown = *Unknown;

1568992826
ceymard
this is to help me store data along function pointers that I give it

1568992841
Tetralux
There's also *c_void if you need it.

1568992879
Tetralux
But yes, generally you can also do mq32 suggests.

1568992890
ceymard
mq32: this produce slightly less errors, but I still can't store this pointer as a struct member

1568992896
fengb
OpaqueType if you can control it in Zig. It‚Äôll give you much better type checks than c_void

1568992907
mq32
you should be able to

1568992914
ceymard
oooh mq32 didn't see the pointerto

1568992916
ceymard
sorry

1568992922
Tetralux
xD

1568992944
Tetralux
Yeah - opaque types are by definition 'of unknown size' so you can only refer to pointers to them.

1568992970
ceymard
this is quite complex

1568992981
ceymard
the whole "let's talk with C" thing ain't trivial

1568992999
Tetralux
What's making it hard for you?

1568993083
fengb
It‚Äôs simple if you code exactly like C üôÉ

1568993293
ceymard
haha

1568993317
ceymard
Tetralux: the fact that I haven't coded in C for maybe 13 years now, and the whole pointer casting shenanigans

1568993334
ceymard
which brings me to my new question ; I can't seem to convert a function address to *c_void

1568993346
ceymard
"error: cast discards const qualifier"

1568993355
ceymard
@ptrCast(?*c_void, original_function)

1568993360
ceymard
are functions const by default ?

1568993402
ceymard
also, completely not related, I'm doing this : export const init_array linksection(".init_array") = [_]extern fn () void{

1568993404
ceymard
_register_my_module,

1568993406
ceymard
};

1568993418
ceymard
which works for certain with ELF in linux, but which I suppose won't so much in windows

1568993428
ceymard
am I correct ?

1568993438
mq32
ceymard, probably, yes

1568993447
ceymard
dang.

1568993451
mq32
.init_array is just something that your entry point of the library executes

1568993456
mq32
in windows, you can do that in DllMain

1568993466
ceymard
aha, linksection("DllMain") ?

1568993491
mq32
no, it's a function that gets called when you attach/detach a DLL

1568993497
mq32


1568993520
ceymard
ok, noted.

1568993602
ceymard
I settled by doing @intToPtr(?*c_void, @ptrToInt(original_function))

1568993616
ceymard
which I suppose is the atomic warhead in casting world.

1568993640
ceymard
I'm having the time of my life

1568993771
_Vi
ceymard, There is always a sledgehammer solution: convert pointer to usize and treat it as a number.

1568993895
Tetralux
ceymard: You can't @ptrCast(*c_void, function) ?

1568994005
ceymard
Tetralux: no

1568994052
Tetralux
Hmmm.

1568994067
Tetralux
I'm not sure not.

1568994109
ceymard
inversely, there a c function that wants a void** parameter

1568994113
ceymard
to get back my function

1568994120
ceymard
trying to cast it is hellish

1568994157
halosghost
sounds fun

1568994178
fgenesis
i remember tunneling function pointers through java via JNI, as 64bit-longs

1568994188
fgenesis
that was fun (not)

1568994200
halosghost
my only experience casting something like a void** is for dlopen to be standards-compliant

1568994268
halosghost
*(void **)(&p.setup) = dlsym(handle, "setup");

1568994271
halosghost
:P

1568994284
halosghost
what a lovely construction

1568994438
ceymard
groovy

1568994456
halosghost
though, that's clearly not Zig :)

1568994527
_Vi
Are there plans to make distributed enumeration mechanism that is currently used for errors to be available for other purposes?

1568994532
ceymard
I'm crashing zig a lot

1568994869
ceymard
amazingly, it works

1568994882
ceymard
I have barely any idea of what I'm doing

1568994889
ceymard
and it does what I want it to do

1568994899
ceymard
what a wonderful feeling

1568995032
_Vi
ceymard, That feeling can be deceptive: security vulnerabilities are created this way.

1568995102
fengb
Zig shouldn‚Äôt be crashing that much :(

1568995143
ceymard
fengb: I suppose not

1568995166
ceymard
but I guess when the compiler starts spouting a bunch of nonsense onto my screen, it means it crashed ?

1568995178
ceymard
have had that a couple of times already

1568995214
ceymard
_Vi: certainly, but I don't care about them that much while I'm learning how to use this thing :)

1568995277
fengb
Oh I'm not doubting you. Stability has been a bit spotty since the latest features

1568995299
_Vi
fengb, Does it also output binary memory content on stderr on crashes for you?

1568995356
fengb
I haven't seen it but it's been an issue in this channel :/

1568995440
_Vi
Shall there be proper crash handler for Zig compiler, with customized message with invitation to create an issue?

1568995499
andrewrk
today is the first I've ever heard of this binary memory content thing

1568995646
fgenesis
andrewrk: someone posted a paste with binary "error message" 1-2 days ago too

1568995673
andrewrk
hmmmmmm

1568995913
Tetralux
Random thought: anyone thought of having successdefer, as it were?

1568995970
andrewrk
D thought of it. I don't think it's warranted

1568995983
mq32
Tetralux, any usecase?

1568996005
Tetralux
I didn't make a note of any of the ones I've come across unfortunately.

1568996012
Tetralux
But it's essentially the same usecase as errdefer.

1568996017
Tetralux
Except, obviously the opposite.

1568996034
Tetralux
I want something to happen, but only if we return without error.

1568996044
Tetralux
I cannot currently express that.

1568996052
Tetralux
At least with just deferring.

1568996085
Tetralux
More importantly, "something must happen upon return, but not if there's an error"

1568996133
fgenesis
"defer [on error|succes|...] <expr>

1568996177
Tetralux
[err|ok]defer <expr>

1568996250
mq32
"ok ~~google~~ defer, order me a pizza!"

1568996273
Tetralux
I'm not sure what that would do, but that would be amazingly cool.

1568996386
andrewrk
it feels like everybody is thinking of new features to add, while I'm trying to think about what features we can remove

1568996421
Tetralux
Incidentally, should using 'var v = ...' be faster than 'const v = ...' --- is that expected?

1568996432
Tetralux
Only it seems like it in my test case.

1568996578
halosghost
interesting

1568996579
halosghost
I wouldn't think so

1568996589
halosghost
but I'm still on the periphery of this language's dev :)

1568996600
andrewrk
const is always better

1568996617
Tetralux
I tend to always use var because I don't wanna go back and make the things I want mutable, mutable.

1568996627
Tetralux
I usually do that as a final pass.

1568996629
Tetralux
If at all.

1568996665
andrewrk
you're gonna have a hell of a time upgrading your code base when #224 is implemented

1568996696
Tetralux
If you do that, I might stop using Zig.

1568996701
Tetralux
Fair warning.

1568996740
Tetralux
Well - 'stop' is a strong word.

1568996751
Tetralux
But I will dislike that change quite a lot.

1568996766
Tetralux
I'd rather you renamed const to let.

1568996775
_Vi
andrewrk, "today is the first I've ever heard of this binary memory content thing" -> It is also visible in the new issues I recently filed.

1568996784
Tetralux
That's still a tad painful to type, but still easier than const.

1568996817
companion_cube
wow, an error, not a warning?

1568996848
fgenesis
re: #224, better would be to have a warning instead of an error

1568996848
Tetralux
Truthfully, I'd rather Zig just automatically turned all variables that are not mutated to be const automatically.

1568996857
fgenesis
+1 Tetralux

1568996868
_Vi
Are there ignorable errors in Zig (which you can selectively mute)?

1568996879
andrewrk
no, zig has only errors

1568996884
companion_cube
just turn`const` into `let`, and `var` into `mutable_variable`

1568996888
mq32
andrewrk, brainfart on #224: make debug builds allow var when const would be possible as well. don't know if this just encourages people to deploy debug builds

1568996892
companion_cube
you'll see what people use by default üòá

1568996901
andrewrk
companion_cube, yeah that's not a bad idea

1568996904
_Vi
Lack of warnings and treating "code cleanness" issues as errors feels to golang-ish.

1568996907
_Vi
*too

1568996913
mq32
because most of the code i write like "var x = /* initial value i will calculate later */" and then code stuff that depends on x

1568996915
stratact
I agree, something like #224 could warn rather than error

1568996935
andrewrk
the only reason #224 isn't already implemented is that it's tricky to detect correctly because of comptime branches

1568996939
fgenesis
imo #224 is a handrince to iteration and development. it's ok for final code, but not while developing and testing

1568996949
mq32
what fgenesis just said

1568996949
_Vi
Such nitpicky errors also do not play well with generics / generated code.

1568996950
fgenesis
*hindrance

1568996957
Tetralux
+100 fgensis.

1568996962
fgenesis
_Vi, totally this

1568996985
_Vi
The "unreachable code" error is also a problem.

1568996994
companion_cube
not sure why it's a problem for generics

1568997001
fgenesis
oh gosh how much i hated that error when i was doing java

1568997004
Tetralux
Making a non-changing variable to const is an optimization at best - and in the example I have in front of me it seems like a slight hinderance.

1568997010
fgenesis
(in java, unreachable code is an error)

1568997035
_Vi
There should be [at least] two classes of problems with code. One of the classes should be ignorable on various scopes.

1568997094
Tetralux
On my branch for iterator removal procedures for ArrayList, this simple testing code shows a degradation between using const and non-const.

1568997097
Tetralux


1568997110
_Vi
Ultimately such errors may end up telling you: "error: your code is too abstract. Keep it simpler, not everybody is as smart as you."

1568997159
_Vi
I prefer Zig to be Rust, but more direct, explicit and low-level; not Golang, but more direct, explicit and lowlevel.

1568997229
fgenesis
what about if(comptime ... -> false) {code}

1568997234
fgenesis
does this count as unreachable code?

1568997248
fgenesis
i mean anything that's in an if but that turns out false at compile time

1568997269
mq32
_Vi, i hope zig never gets to be Rust :D

1568997301
andrewrk
if you like where zig is at now, you'll probably like where it's going. it's not going to be fundamentally different in the future

1568997314
mq32
andrewrk, i hope so!

1568997336
companion_cube
rust without traits or borrow checking would be perfect :P

1568997341
halosghost
andrewrk: I definitely like many of your architectural decisions

1568997342
andrewrk
I'm aware of the issues with refactoring and development/iteration, and I've used go & rust for non trivial projects

1568997346
fgenesis
andrewrk: in any case, don't be like the C++-committee and actually listen to your users :P

1568997442
andrewrk
just a reminder though, zig has always prioritized the time of people reading code over the time of people writing code. that does give license for annoying errors, if it means that you can be confident of more assumptions when reading code. that's the reason for no variable shadowing, for example

1568997473
andrewrk
knowing that all variables are either const, or mutated, is a pretty useful thing to be able to rely on when reading a large codebase

1568997509
andrewrk
writing code is O(1), reading code is O(N), where N is people

1568997563
fgenesis
but if writing code is too hard nobody will do it

1568997583
_Vi
andrewrk, Generics/codegen sometimes mean that the code is difficult in any case.

1568997593
andrewrk
fgenesis, of course, there is a balance

1568997630
_Vi
For #224 (unused `var`-ness): it also means that you need to change `var` to `const` when commenting out code, then back after uncommenting.

1568997667
_Vi
At this rate unused `consts xxx = @import...` may also become an error.

1568997674
fgenesis
same goes for an "unrachable code" when temporarily disabling a function by slapping a return near the top

1568997696
_Vi
On of solutions is lax "dev mode" builds and stricter "publish mode" builds.

1568997723
_Vi
For example, I typically use `#[allow(unused)]` when develop code in Rust, but remove it at some point when it matures.

1568997724
fgenesis
all of these things are candidates that belong in a dev mode, exactly what _Vi said

1568997752
fgenesis
i mean even LaTeX has \sloppy :D

1568997762
_Vi
This turns off nagging of all sorts of unused things: unused imports, vars, non-constness, parameters, unhandled errors, etc.

1568997823
fgenesis
or maybe a dev mode should be the default, because new people use defaults, and nothing else

1568997827
_Vi
Mere enabling of such mode may emit compiler warning (so that one would want to turn it off, not just live with it forever).

1568997834
fgenesis
so extra strict-ness as opt-in seems like the right way to do it

1568997836
andrewrk
I'm closing IRC to fix bugs

1568997844
fgenesis
yay bugs

1568997846
mq32
andrewrk, sounds reasonable!

1568997892
_Vi
fgenesis, "dev mode should be the default" -> not sure. There should be incentive to turn if off eventually.

1568997917
companion_cube
isn't --debug already kind of a dev mode though?

1568997940
_Vi
For example, Zig package central (when it exists), should not accept devmode-only code.

1568997951
fgenesis
companion_cube: kind of, you're correct

1568997976
_Vi
companion_cube, It's about runtime things. Sometimes you need to iterate and tinker with the code with optimisations on.

1568998004
_Vi
companion_cube, And inserting `return;` early in function is often needed think when debugging performance problems.

1568998013
companion_cube
ah, good point

1568998015
companion_cube
bisecting‚Ä¶

1568998017
_Vi
companion_cube, (which is prohibited by "unreachable code" rule)

1568998027
companion_cube
maybe we should just have `zig --sloppy` indeed

1568998045
companion_cube
(forbidden in releases and all)

1568998062
fgenesis
for the central code repo, definitely forbidden

1568998068
_Vi
`zig --sloppy` + "don't publish sloppy packages on Zig repository" sounds good.

1568998117
_Vi
companion_cube, All of `--release-fast`, `--release-safe` and `--release-small` should work with `--sloppy` as well, as sloppy hacks may be needed to debug speed or executable size issues.

1568998139
Tetralux
Important question: In what way is var instead of const sloppy?

1568998151
Tetralux
Also, I just updated my paste.

1568998162
_Vi
Tetralux, Reader of the code spends time to see where is it modified and not finding any place.

1568998186
Tetralux
If you're interested what might be a slight perf decrease with const vs var. :)

1568998207
fgenesis
Tetralux: link again?

1568998213
Tetralux


1568998230
Tetralux
I'm open to the idea that I'm doing something wrong, but :)

1568998235
_Vi
Is there a proper Zig online playground? (not just godbolt)

1568998248
fgenesis
since when is godbolt not a proper playground

1568998264
_Vi
fgenesis, Does it run the code or tests and show stdout/stderr?

1568998276
fgenesis
optionally, yes

1568998285
Tetralux
fgenisis: How?

1568998293
Tetralux
fgenesis*

1568998298
Tetralux
I've never seen that option.

1568998299
fgenesis
i've seen the option i think but never used it; it's faily new iirc

1568998344
_Vi
fgenesis, If yes and it is supposed use case of godbolt, then specialized godbolt-backed UI may be provided to act as a Zig playground. But I usually assume godbolt is when you need to insect asm / llvm ir.

1568998348
_Vi
*inspect

1568998388
_Vi
Using it for generic Zig noob playground may be misuse of godbolt's resources.

1568998427
fgenesis
it runs on AWS sooo

1568998460
Tetralux
_Vi: Have you ever done that?

1568998470
Tetralux
Checked to see where it's modified?

1568998473
_Vi
Tetralux, What? Running code on godbolt?

1568998491
Tetralux
const vars :p

1568998547
_Vi
Tetralux, In Zig? Unlikely. For example, I reached

1568998622
Tetralux
I ask because I have the opposite logic; if it's const, I just go "Oh - they don't modify this", and if it's non-const, I just assume that it can be modified -- not that it

1568998660
_Vi
Tetralux, Rust, for example, has `unused_mut` warning. When you declare variable as mutable, but use this mutability.

1568998672
Tetralux
But as I said, I use mutable vars everywhere - just because it strains my fingers to actually type const vs var, _and_, the real reason, I don't want to discover I need it to be mutable and have to break my flow and change it.

1568998685
_Vi
Tetralux, Obviously, such warning is ignorable both at large scope and for individual var level.

1568998697
Tetralux
Indeed, I've come across that warning myself.

1568998732
_Vi
Tetralux, "var" may be OK for things that

1568998762
_Vi
Tetralux, If a thing is by principle immutable then better to use `const` even if `var` is accepted.

1568998796
Tetralux
I've never come across a bug because something is mutable and wasn't, that I can recall.

1568998827
Tetralux
and should not have been*

1568998850
Tetralux
So far as I know, using const over var has never solved any of the problems I have encountered.

1568998860
_Vi
Tetralux, This is not question of bug vs correct code. It is question about what unfamiliar reader of the code would feel.

1568998881
Tetralux
I do not read code by whether things are immutable or not.

1568998901
Tetralux
Using const would obviously mean that I knew you didn't change it.

1568998905
_Vi
The fact that `var` is shorter than `const` can act against Zig goals of readable code.

1568998941
_Vi
If it were `variable`, nobody would use it instead of `const` just to save typing, I suppose.

1568998977
_Vi
Such thing is called "Syntactic salt" in Rust discussions.

1568999004
Tetralux
If I had to type const or variable, I'd not use Zig xD

1568999033
_Vi
Just shorten `const` to `co`. It would look weird although...

1568999070
fgenesis
DECLARE VARIABLES a,b,c; ADD a TO b GIVING c

1568999112
fgenesis
_Vi: first thing co triggers in my head is something to do with coroutines. plz no

1568999138
Tetralux
I hate to say it, but Jai doesn't have this problem.

1568999150
Tetralux
x := 0; // mutable.

1568999153
Tetralux
x :: 0; const.

1568999153
_Vi
Good middle ground may be: 1. Use `var` for things that are mutated at least once (or 0 or more times if sloppy mode);   2. Use `const` for things that are mutated 0 times; 3. Use `@allowConst var` for things that can be mutated 0 and more times, even in non-sloppy mode.

1568999206
fgenesis
wat

1568999260
Tetralux
I don't know who you're saying wat to fgenesis xD

1568999267
_Vi
fgenesis, Shall I explain whats and whys?

1568999293
fgenesis
wat = i just read 4 lines of irc about const and my brain derped

1568999399
_Vi
The goals are: 1. To use familiar words like `var` and `const`; 2. To suppress usage of `var` where `const` suffices; 3. To allow temporary opt out of "2."; 4. To allow "escape hatch" if one really needs var that may be not mutated.

1568999484
fgenesis
yes but it's already way too complicated for what it is

1568999501
fgenesis
pile rules upon rules like this and eventually you end up with c++

1568999513
_Vi
fgenesis, Which part is complicated?

1568999517
fgenesis
yes

1568999531
fengb
What's wrong with what we have right now?

1568999581
_Vi
fengb, Looming doom of #224 ( add an error for using `var` when one could have used `const`)

1568999612
_Vi
And the problem it is trying to solve (using `var` instead of `const`)

1569004864
vegai
just remove vars altogether, they're the source of all bugs anyway :P

1569004885
vegai
just bindings, bindings everywhere

1569004908
vegai
I hope it's obvious I'm kidding

1569005264
fengb
Let's remove mutation altogether

1569005459
Tetralux
fengb: Do so at your peril >)

1569006097
scientes
_Vi he leffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffft?

1569006129
scientes
I wouldn't worry about their resources as long as you aren't using it from a script, and godbolt is open source and you can run it locally if you want

1569006872
Tetralux
andrewrk: #3037 updated and passing.

1569007331
andrewrk
wow, I did not realize testing foreign architectures with qemu was this easy

1569007354
andrewrk
it's literally just `qemu-riscv64 ./the_program`

1569007409
andrewrk
it works with gdb too: `qemu-riscv64 -g 9000 ./the_program` (another terminal) `gdb ./the_program -ex 'target remote localhost:9000' -ex 'continue'

1569007438
andrewrk
this is a total game changer, I'm going to add -Denable-qemu to zig build

1569007446
scientes
andrewrk, you don't even have to do that if you set up binfmt_misc

1569007475
scientes
oh, but didn't know you could use gdb with qemu-user-static like that, that is awesome

1569007654
andrewrk
ok I have a plan for how to get a lot more test coverage of other architectures now

1569007683
scientes
cause ptrace doesn't work for obvious reasons

1569007709
Tetralux
andrewrk: That...... sounds awesome.

1569008218
Tetralux
I find it interesting that doing `-target riscv64-windows` gives you `lld: error: .\test.obj: unknown file type`

1569008224
Tetralux
Which makes no sense??

1569008238
Tetralux
Turns out,  `riscv64-linux` works fine though /shrug

1569008244
Tetralux
Seems like a bad error to me.

1569009871
wilsonk
asdf

1569009875
wilsonk
woops :)

1569010079
mq32
password is safe

1569010117
andrewrk
I would never guess that password, I use dvorak

1569010145
companion_cube
is that why you type so fast?

1569010176
mq32
i think it's more than andrewrk is either using Cherry MX Blue or a buckling spring keyboard

1569010182
mq32
at least it sounded like he does in the streams

1569010319
scientes
I actually didn't like dvorak much

1569010323
scientes
didn't find it any better

1569010346
scientes
12345, thats the type of password someone uses on their luggage

1569010366
companion_cube
you mean 54321?

1569010380
companion_cube
(unlike 12345, it's totally impossible to guess)

1569010396
scientes
companion_cube, its a spaceballs reference

1569010415
scientes
Linux has a few of those

1569010419
scientes
in the source code

1569010432
companion_cube
üòÖ

1569011581
stratact
Wait, why am I getting this build error?

1569011585
stratact
CMake Error at cmake/Findllvm.cmake:19 (message):

1569011586
stratact
unable to find llvm-config

1569011622
andrewrk
if you're working on master branch of zig you'll need to update your LLVM/clang libraries

1569011629
andrewrk
llvm 9 released yesterday

1569011661
stratact
Oh f*** I hope FreeBSD 12-STABLE gets the llvm 9 upgrade soon

1569011746
scientes
stratact, considering that FreeBSD is build with llvm 9 some version of FreeBSD will

1569011815
stratact
I'm going to do a system upgrade to see

1569011896
andrewrk
stratact,

1569011904
andrewrk
I just did this yesterday on FreeBSD, it worked fine

1569011972
Tetralux
That happens if you get the LLVM release from LLVM.org

1569011979
Tetralux
Use the ones from "Building Zig on Windows"

1569011989
Tetralux
(If that's what you're doing)

1569012035
scientes
andrewrk, feel free to push back more if there is stuff I overlooked, I want you to be as productive as possible

1569012060
andrewrk
there's also

1569012101
stratact
Well at least I have ways to do it locally but I'm still going to an OS upgrade if I can get the latest llvm globally.

1569012118
andrewrk
the release was yesterday, there's a 0% chance that it's in pkg already

1569012128
mikdusan
also i have a freebsd script that builds from llvm-project mono-git-repository if you want it

1569012173
stratact
andrewrk: llvm is in the freebsd source, I'm rebuilding the whole OS again from the latest svn revision :)

1569012183
andrewrk
interesting

1569012348
mikdusan
ports head for freebsd has: llvm90-9.0.0.r4_1 which is (9.0.0 rc4)

1569012425
stratact
interesting, so I can have 2 versions installed?

1569012550
mikdusan
i suspect you can have 3 versions. one that is the system default. and two more that are suffixed like "/usr/local/llvm80" and "/usr/local/llvm90"

1569012619
stratact
Awesome!

1569012743
andrewrk
if anyone is bored and wants to play with godbolt:

1569013067
stratact
mikdusan: I got a question, from doing the STABLE svn branch upgrade, I noticed this compiler output, "c++  -target x86_64-unknown-freebsd12.1" ... assuming I'm getting 12.1 early, would I still be able to run Zig?

1569013174
mikdusan
when building zig, use the same compiler that built LLVM,

1569013209
mikdusan
freebsd ports LLVM is using the default system compiler (I presume)

1569013253
mikdusan
and when building Zig without any options or env vars overring things, it will use "c++" as well

1569013269
stratact
Gotcha

1569013397
andrewrk
hmmm:

1569013422
andrewrk
why is it deleting stage2_panic body?

1569013463
mikdusan
and calling std.special.panic without 2nd arg?

1569013550
mikdusan
just a hail-mary from me because i don't really understand it: "LLVM will now remove stores to constant memory (since this is a contradiction) under the assumption the code in question must be dead."

1569013608
stratact
brb

1569013807
andrewrk
even shorter:

1569014153
andrewrk
minimal:

1569014507
andrewrk
problem is `tail` implies that callee does not access allocas from the caller. since we pass slices as pointers currently this is an issue

1569014578
mikdusan
tail call? "Both markers imply that the callee does not access allocas from the caller"

1569014586
mikdusan
oh you beat me to it lol

1569015134
stratact
The OS upgrade didn't solve the problem, but `pkg install llvm90` did üòÅ

1569015158
andrewrk
I stand happily corrected :)

1569015469
josuah
hello!  is there an -offtopic or less official channel?  I have questions but do not want to clutter a dev channel.

1569015518
fengb
Feel free to ask in here

1569015594
josuah
oh well then...  I read the documentation and watched this:

1569015694
josuah
but I am getting curious about the C++ omnipresence, given I had the impression zig did not stive to ressemble it

1569015773
josuah
is C++ just a temporary step for having a full zig implementation?  It might still be required for bootstrapping even then I suppose.

1569015790
josuah
after all, it is built on top of LLVM, which is C++ itself

1569015806
andrewrk
josuah,

1569015868
josuah
thank you! I only watched at the mailing list and forgot about GH issues.

1569016413
stratact
Heh, I really like how I can make my types generic by integers. Generic types through functions is brilliant.

1569016442
stratact
The fact that I can have a BufTracker(1024) as a type amazes me.

1569016450
companion_cube
welcome to dependent types

1569016466
stratact
Ah I see

1569016516
josuah
the benefits of templates without the pain

