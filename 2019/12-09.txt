1575849746
andrewrk
daurnimator, debug build of llvm is the sledgehammer fallback plan for debugging that

1575849772
daurnimator
erk

1575849775
andrewrk
but if you're lucky, you passed nullptr to something in codegen.cpp:4031

1575849843
andrewrk
IMO if you're working on stage1, bite the bullet and have a debug llvm build available

1575849859
daurnimator
I'm not though :P

1575849867
andrewrk
is that an american idiom?

1575849879
daurnimator
?

1575849888
andrewrk
"bite the bullet"

1575849894
daurnimator
Oh not sure; but I know that

1575849904
daurnimator
I was just saying I wasn't working on stage1

1575849918
daurnimator
--> It happened when I tried to use @asyncCall

1575849937
andrewrk
it means zig messed up something with the llvm types

1575849944
andrewrk
or passed null for something

1575849968
andrewrk
99% chance that hits a helpful assertion in llvm debug build

1575850053
andrewrk
WendigoJaeger, I think your project would be well-received if you posted a link on hacker news, /r/programming, or lobste.rs

1575850101
stratact
<andrewrk> var args's days is numbered ... `KV{ .key = reached unreachable code` ðŸ˜¢

1575850102
WendigoJaeger
andrewrk: I'll wait to have a more elaborated demo that 3 pixels

1575850150
andrewrk
WendigoJaeger, up to you :) people love to see something approachable though. the "hello world" in the title makes it sound like they would be able to understand the code

1575850426
emekankurumeh[m]
WendigoJaeger: nice! I tried to get that to work for the longest time!

1575850432
leeward
I just got an error on this expression: `@intCast(u16, val & 0xffffff)` (semantic analysis, can't be coerced into u16) but I believe that (val & 0xffffff) will always fit in 16 bits and I want to assert that (val & 0xff0000) is always zero. Is this a bug in the semantic analysis, or should I just put my assertion on its own line?

1575850485
WendigoJaeger
leeward: your litteral is a u24, not u16

1575850498
WendigoJaeger
emekankurumeh[m]: Did you publish any WIP somewhere ?

1575850531
leeward
WendigoJaeger: I noticed.

1575850545
leeward
Never mind though, it turns out my source type was actually a u16.

1575850552
leeward
It works as I expect when it's wider.

1575850610
dbandstra
andrewrk: do you use any tricks or special tools for editing long source files in vim?

1575850641
andrewrk
leeward, it's planned for this to work, I can't remember the issue number

1575850647
andrewrk
"Runtime Hint System"

1575850704
andrewrk
dbandstra, multiple buffers open to the same file, search (the `/` key), ctrl+o / ctrl+i

1575850748
andrewrk
sometimes I will have as many as 3 different vim tabs all looking at ir.cpp, each one with multiple split views...

1575850786
adamkowalski
andrewrk: is there any documentation about runtime polymorphism in Zig?

1575850813
adamkowalski
It sounds like there are two options, but I wanted to see if i'm missing any. union(enum) for when you have a closed set

1575850826
stratact
Alright, time I started to clean/finish up my terminfo.zig module and throw in a PR today to show I wasn't slacking. No sense in fighting Zig's print formatting for checking correct data in the StringHashMap entries.

1575850832
andrewrk
adamkowalski, there are no language features for runtime polymorphism. the main issue for that is

1575850834
adamkowalski
and a struct with function pointers (a la allocators)

1575850878
adamkowalski
Well maybe I don't even need it. But here is the problem I'm encountering. I'm building up a computation graph. There can be constants, variables, placeholders or operations

1575850882
andrewrk
adamkowalski, this topic is not considered to be stable yet, it's acknowledged that there is an issue here, especially as frmdstryr has been examining the performance of buffered input/output streams

1575850899
adamkowalski
the constants can be ndarrays but the element types can vary

1575850906
andrewrk
but yeah why don't you explain your use case and maybe #zig can give advice

1575850914
Snektron
andrewrk, i think theres a regression

1575850922
Snektron


1575850924
adamkowalski
the operations must be open to extension because people can add new operations that I didn't think about

1575850928
Snektron
All examples fail due to a missing @call

1575850938
dbandstra
somehow, i didn't realize you could hit Ctrl+O more than once (started using vim earlier this year). thanks for the tips :)

1575850941
Snektron
i suppose that's work-in-progress

1575850954
adamkowalski
but it's all the standard linear algebra operations like matrix multiplication, add, subtract, div, convolution, etc

1575850980
adamkowalski
So I was thinking about having 4 arrays, one for constants, one for variables, etc...

1575851007
adamkowalski
Then things like operations would have pointers to a enum(union) of constant, variable, operation, placeholder

1575851021
adamkowalski
An an operation would be an "interface" like allocators

1575851039
adamkowalski
does that all sound reasonable, or is that just me bringing an object oriented mindset

1575851268
Snektron
wait, how does this work

1575851279
WendigoJaeger
andrewrk: Hacker News

1575851460
Snektron
O

1575851634
Snektron
I see my problem, called wrong Zig executable

1575851657
Snektron
still doesn't explain the problems on the documentation

1575852899
emekankurumeh[m]
WendigoJaeger:

1575852904
emekankurumeh[m]
sadly no

1575853544
andrewrk
Snektron, can you point out one problem in particular?

1575854561
adamkowalski
andrewrk: can you take a look at this? I feel like my test "add" at the very bottom should pass:

1575854577
adamkowalski
The tests fail when I run both of them, but if I run just one then it passes

1575854607
adamkowalski
The pointer values magically change if both tests run haha?

1575854632
adamkowalski
The failing test is:     std.testing.expectEqual(x.constant, z.operation.left.constant);

1575854653
adamkowalski
Or:     std.testing.expectEqual(y.constant, z.operation.right.constant);

1575854670
adamkowalski
individually they pass but if you uncomment both they fail

1575855683
Snektron
andrewrk, i think the master documentation is from a commit with wrong code from a few days back

1575855719
Snektron
I myself had a similar problem, because i was accidently using the system Zig compiler instead of the freshly compiled one

1575855736
Snektron
Which was from that same time

1575857631
daurnimator


1575857745
daurnimator
also interesting HN thread:

1575858256
dbandstra
adamkowalski: did you figure out the problem with the code you posted an hour ago?

1575858612
daurnimator
A thought once we get "bounded" integers: `open()` would in theory be a `[:0] @boundedInt(1,255)`: though the sentinel is not a member of the type..... I wonder if there's something we can do there.

1575858939
andrewrk
sentinel termination is for in-bound values. you'd use a `?` for an out of bound sentinel

1575858965
daurnimator
a `?`?

1575859103
andrewrk
I see what you're saying

1575859772
fengb
I found an off by one error by rewriting these wasm tests -_-

1575859888
adamkowalski
dbandstra: not yet. Do you have any thoughts?

1575859953
daurnimator
andrewrk: I've been wondering if its worth setting up a weekly "zig update" meeting to engage the community. It's something the k8s world does a lot.

1575860027
dbandstra
adamkowalski: the tests run fine for me, but i might be just lucky. it looks like you're returning pointers to stack locals

1575860035
andrewrk
I could see this happening

1575860055
dbandstra
adamkowalski: return `Tensor(T){ .operation = &o };` where o is a local

1575860104
adamkowalski
Well I don't them to be stack locals. I want to allocate the memory in the ArrayList that the graph owns and return a pointer to that

1575860144
dbandstra
i think you could use array list's `addOne` function

1575860148
adamkowalski
But I don't want the API to be based around pointers, I want you to believe you're dealing with a Tensor, even though it's really just a handle to memory that the graph one

1575860163
dbandstra
however i'm not familiar with zig array lists and i'm not sure if those pointers will stay valid

1575860271
dbandstra
maybe you could call `count()` before appending to get the index of the new element, and store that

1575860320
adamkowalski
Your add one idea was spot on! Thanks

1575860354
adamkowalski
It gives me back a pointer to the newly allocated operation and then I just mutate it in place.

1575860391
dbandstra
yes, i'm just worried that when the arraylist reallocs itself to expand, the pointer could be no longer valid (hence why storing an index might be a better idea)

1575860512
adamkowalski
Hmm, so you're saying do away with the pointers alltogether? Just have a union(enum) which tells you which array to look into, and then deal only in indices?

1575860515
adamkowalski
I'll try that

1575860964
stratact
is there a way to do comptime imports?

1575860985
daurnimator
aren't all imports comptime?

1575861057
stratact
I want to block the `net` variable for FreeBSD as a temporary hack.

1575861074
stratact
in the std lib

1575861187
stratact
otherwise `zig build test-std` is big ouch for me

1575861335
daurnimator
stratact: use --test-filter?

1575861402
adamkowalski
dbandstra: I got the tests to pass with the index based approach, I like it but it's a bit more verbose. Is there anything you or anybody else can recommend that I can do to make my code more idiomatic Zig?

1575861781
stratact
daurnimator: -Dtest-filter is not working for me

1575861791
stratact
it's only blocking every test

1575861825
daurnimator
stratact: what are you trying to test?

1575861927
dbandstra
adamkowalski: the code you posted looks pretty good to me. i believe the idioms are still evolving. i personally can't give much advice on the std lib because most of it i haven't used or touched

1575862032
stratact
daurnimator: sorry nevermind, I figured it out what you meant earlier. I must of forgot there was a `zig test` command

1575862300
dbandstra
i'm no clearer than i was 1  year ago or 10 years ago how to approach polymorphism... currently wrangling with it again in a new project

1575862506
daurnimator
dbandstra: comptime time polymorphism or runtime?

1575862544
daurnimator
for comptime you can use mixins. for runtime you need @fieldParentPtr or a vtable.

1575862616
adamkowalski
daurnimator can you elaborate on those? I think the standard library uses just the vtable approach right? They just have a struct with function pointers that you have to fill in

1575862648
adamkowalski
For comptime what i've been doing so far is accepting a parameter by var and then checking if it matches the interface I need

1575862656
daurnimator
adamkowalski: no. the standard library uses @fieldParentPtr. I don't think anyone has done a vtable in zig yet

1575862658
dbandstra
daurnimator: even which of those to choose has to be considered

1575862683
andrewrk
hejsil and tgschultz both experimented with vtables and found llvm to optimize them better than @fieldParentPtr

1575862745
andrewrk
which makes sense since this is what c++ and other languages emits. according to my understanding it is arbitrary and not fundamental, the reason llvm does not optimize the @fieldParentPtr pattern, even though this would benefit other codebases, such as the linux kernel

1575862814
adamkowalski
andrewrk: if we don't have any docs for this, could we get some people together to get something started?

1575862830
andrewrk
docs for the interface pattern?

1575862832
adamkowalski
I can volunteer to get the ball rolling. If you can point me to where I can read about this more, or example projects that leverage

1575862850
adamkowalski
I can try to write about what the different methods are, example implmementations, pros and cons

1575862868
adamkowalski
Maybe you can look at them and yell and say they are terrible. Then we do a second draft

1575862874
adamkowalski
and eventually they will be fine

1575862892
dbandstra
there's definitely some prior work buried or linked to in some old zig issues

1575862916
adamkowalski
Well phase one can be just building a document with link to all prior work

1575862929
dbandstra
that would be good

1575862983
adamkowalski
And we can talk about when you can leverage compile time polymorphism, and the tradeoffs between specialization and icache bloat

1575863002
adamkowalski
And then runtime polymorphism, when is it necessary, what are the alternatives, and so on

1575863084
tgschultz
MY current thinking on interfaces is that "mixins" with a built in function to abstract to a runtime-unknown version of the interface are probably the best available generalized mehtod. Though there's still some things to be worked out with errorsets there.

1575863089
stratact
Finally, I got a PR up, time to celebrate with food.

1575863114
tgschultz
I can't seem to type "My" these days without capitalizing the Y as well. I did not intend any emphasis on the word.

1575863123
andrewrk
congrats stratact

1575863174
tgschultz
Though I personally don't want to encourage the "mixin" pattern, it is convenient for this usecase.

1575863237
adamkowalski
What do you all think about the dyno library from C++? It is designed to handle runtime polymorphism without inheritence

1575863277
adamkowalski


1575863278
daurnimator
tgschultz: you saw

1575863296
adamkowalski
It's by Louis Dionne who is a really interesting speaker

1575863313
adamkowalski
And there is also sean parents talk:

1575863332
adamkowalski
He tries to keep polymorphic types as value types rather then reference types

1575863352
tgschultz
daurnimator yeah that's basically what I'm talking about.

1575863358
tgschultz
I hadn't seen that comment though

1575863365
daurnimator
tgschultz: whats the error set issue you allude to?

1575863408
daurnimator
tgschultz: FWIW I was trying to make the error set creation automatic, but ran into

1575863429
daurnimator
for now with e.g. InStream, I just make part of the mixin expectations that you have `Self.ReadError`

1575863477
tgschultz
streams are complicated to use because of the errorsets, and trying to make them work with the interface pattern tends to run you into a lot of bugs and shortcomings with inference. That's all fixable though.

1575863603
tgschultz
A PR to switch over all the interfaces is std wouldn't be as much work now as it was when I was experimenting (we still had that sync-requires-an-allcoator thing going on. Oy).

1575863895
andrewrk
I have poured gasoline all over var args:

1575864811
stratact
andrewrk: thank you, granted my work could use some supervision. I took a lot of liberty to do things my style, to overcome the harder challenge.

1575864891
stratact
What matters to me is I show the forethought

1575866200
emekankurumeh[m]
please drop the match

1575866373
daurnimator
tgschultz:

1575867230
daurnimator
andrewrk: `std.debug.warn("foo", .{})` is pretty awkward.

1575867252
emekankurumeh[m]
default function arguments?

1575867476
dbandstra
or maybe "warn" and "warnf" functions

1575867521
mikdusan
formatting without any format placements is rare

1575867534
andrewrk
write() is the one without any format args

1575868221
daurnimator
andrewrk: can I still call a C vararg function?

1575868665
andrewrk
yes that's unrelated

1575868902
daurnimator
missing: the ability to write a C vararg function

1575868956
andrewrk


1575873746
stratact
daurnimator: thanks for the reviews. I'll wrap up the rest tomorrow. Have a look at the reply I made for one regarding name tokens. I spent so much energy on out of memory errors for allocators that I didn't realize I was being too conservative. :P

1575873750
stratact
Good night o/

1575879427
merlyndmg
hey. I'm working on trying to further flesh out translate-c-2. I have implemented binary mul, div, and rem without any problems.

1575879464
merlyndmg
However, I tried enabling the test case for them, and the functions won't print out because they have parameters, and function signatures don't seem to print out if you have those. I have spent some time trying to get that working, but I think I'm getting stuck on this: do I have to output tokens in order?

1575879529
merlyndmg
Trying to figure out if I need to output the tokens in the middle of what is currently finishTransFnProto

1575880392
merlyndmg
I tried outputting them after that function, and I get a segfault later. I think when rendering them

1575883916
mq32
hey

1575883933
mq32
anyone in for a "zig run -" and read the code from stdin? :D

1575883945
mq32
this would allow using zig as a shell script language

1575893749
bgiannan
reading the doc, i'm not sure what happens when a programs hits an unreachable of release fast mode?

1575893760
bgiannan
on*

1575893856
mq32
bgiannan: It's undefined behaviour

1575893868
mq32
so: nobody can tell you

1575893933
bgiannan
Right but if you have say: { ... unreachable; std.debug.warn("hello"); } Either the program stops at the unreachable statement or it doesn't.

1575894030
daurnimator
bgiannan: its more complex than that: if you reach the unreachable. things may go wrong

1575894107
daurnimator
like, you might fall into some other code that assumes that flags are set a certain way, and they get interpreted incorrectly and ends up `rm -rf`-ing your hard drive

1575894128
mq32
simple example:

1575894145
mq32
fn a() void { unreachable; } fn b() void { std.debug.warn("hello!"); }

1575894165
mq32
if you now call a(), it is possible (and allowed by the definition of UB) that b is called

1575894178
bgiannan
wow i see

1575894181
mq32
in terms of "a gets called and then the code of b gets executed"

1575894229
daurnimator
bgiannan: --release-fast is "go fast at any cost". if you're doubtful of any of the code you use.... use release-safe instead

1575894233
bgiannan
so how is std.debug.assert safe to use then?

1575894265
bgiannan
daurnimator, yes i'm considering it since i have no performance issues right now

1575894270
mq32
assert is safe as in "you assert (guarantee) that the argument is always true"

1575894297
bgiannan
right

1575894305
mq32
it's not a safety net to make sure "program stops when this condition is false", but "if this condition is not true, the program is not correctly programmed"

1575894318
daurnimator
bgiannan: unreachable is funny in that the compiler "works backwards" from it. => `if (x == false) unreachable` => in release-fast that means, "the code

1575894355
daurnimator
if it turns out x

1575894359
mq32


1575894365
mq32
this is a neat example on "what happens"

1575894384
mq32
you can see in assembler that both a and b are literally the same function as they point to the same memory address

1575894387
bgiannan
mq32, i think something like `if (builtin.mode == .Debug) { assert(...) }` is something i would be more comfortable with then

1575894433
daurnimator
bgiannan: assert actually becomes magic "go faster" source: because you get to tell the compiler all the corner-conditions that it neednt worry about

1575894444
daurnimator
s/source/sauce/

1575894485
bgiannan
i always thought of assert being something `compiled out` of the production binary

1575894549
daurnimator
bgiannan: right: its compiled out; because the compiler would hit unreachable if it

1575894559
daurnimator
and because unreachable isn't allowed to be reached. it

1575894608
mq32
nice example for "it gets compiled out":

1575894632
bgiannan
right but it does affect the resulting program

1575894636
daurnimator
bgiannan:

1575894639
mq32
yes

1575894649
mq32
that's the whole idea behind "unreachable"

1575894658
bgiannan
of unreachable yes

1575894659
mq32
otherwise you can just do "if(!true) exit(1)"

1575894669
bgiannan
but not of assert like i think about it

1575894699
mq32
it's usual in C/C++ to define assert in release modes to something like __expected which does the same as unreachable

1575894886
bgiannan
daurnimator,

1575894940
daurnimator
stratact: you may want this :)

1575894980
frmdstryr
daurnimator: How far did you get with the HTTP parser?

1575895075
daurnimator
frmdstryr: pretty far. hit a zig segfault trying to benchmark it and now I need to recompile llvm in debug mode :(

1575895126
frmdstryr
What segfault? Was it trying to use async?

1575895264
daurnimator
yep

1575895624
frmdstryr
Is it in the h1 branch?

1575895674
frmdstryr
I had a bunch of issues when using async only to find out I wasn't saving the frames somewhere

1575896174
daurnimator
frmdstryr: "it"?

1575896186
daurnimator
I have a few updates to the h1 branch + I didn't put in the example program

1575896202
daurnimator
but really the general strategy is the same as the h1 branch

1575896220
frmdstryr
"it" as in the code where the error is occuring

1575896268
daurnimator
frmdstryr:

1575896657
frmdstryr
Why's the loop beginOneEvent commented out?

1575896711
daurnimator
because it didn't seem to help or hinder

1575896725
daurnimator
and I was sort of throwing shit at the wall to see what compiles in the end

1575896738
daurnimator
I couldn't get async working :(

1575896931
frmdstryr
is the error somewhere?

1575896940
frmdstryr
or just wont build?

1575896955
daurnimator
won't build

1575896960
frmdstryr
did it work just using `async handleConnection`?

1575896974
daurnimator
well yeah.... but that doesn't save the stack frame anywhere

1575897016
frmdstryr
instead of @asyncCall use frame.* = async handleConnection(...)

1575898050
daurnimator
http_test.zig:34:14: error: attempt to dereference non-pointer type '[]align(16) u8'

1575898052
daurnimator
frame.* = async handleConnection(allocator, conn);

1575898057
daurnimator
frmdstryr: ^ how?

1575898114
frmdstryr
const frame = try allocator.create(@Frame(handleConnection));

1575898117
daurnimator
oh right its a slice not a pointer

1575900223
stratact
daurnimator: ah interesting, fixup without the git rebase tui. I suppose this means I need to squash my commit pile to make it easier to follow changes.

1575900288
daurnimator
frmdstryr:

1575900292
daurnimator
stratact: yep :)

1575900300
daurnimator
stratact: I use `git fixup`

1575900309
frmdstryr
nice :)

1575900334
frmdstryr
can you bench it with wrk?

1575900374
daurnimator
apparently not. segfault :(

1575901373
daurnimator
damn it. my logic in 94485b2a58f8efbfb61e46d2efa257420f12a22d was buggy

1575901535
daurnimator
frmdstryr: with wrk I hit my old friend `FileDescriptorAlreadyPresentInSet`

1575901568
frmdstryr
Yeah I think the event loop needs some fixes

1575901925
stratact
daurnimator: I'm amazed. Your reviews in my PR are not only exposing me to more Zig features but it shows your well thoughtout forethought... it's godly

1575901967
stratact
I'm implementing the tagged union idea right now

1575901986
daurnimator
stratact: forethought? I make 50% of this shit up as I go along :P

1575902806
daurnimator
frmdstryr: andrewrk:

1575903250
stratact
daurnimator: I'm beginning to see that now, but still, the ideas are cool ;) ... Sadly Zig won't allow enum literals to have field access to internal enums

1575903286
daurnimator
stratact: could you rephrase that?

1575903291
daurnimator
or give an example?

1575903363
stratact
error: type '(enum literal)' does not support field access

1575903364
stratact
.{ .short = "bw", .long = .boolean.auto_left_margin },

1575903468
daurnimator
`.long = Booleans.auto_left_margin`?

1575903487
stratact
worth a shot, will do

1575903538
stratact
error: expected type '@TagType(Terms)', found 'Boolean'

1575903540
stratact
.{ .short = "bw", .long = Boolean.auto_left_margin },

1575903579
daurnimator
stratact: I'll need to see more context than that

1575903631
stratact


1575903709
daurnimator
stratact: show me the whole code....

1575903741
daurnimator
in particular the definition of Terms...

1575903775
stratact
I'll push what I have to the PR for easier view

1575903795
daurnimator
stratact: oh doh. it will be `.long = .{ yourTermsfieldName = .auto_left_margin }`

1575903824
stratact
Oh I see, I'll give that a whirl :)

1575903981
stratact
Got it working now.

1575904144
daurnimator
frmdstryr: I'm thinking that event.net is just broken

1575904159
daurnimator
is it

1575904184
dimenus
is zig's stdlib supposed to provide '__gxx_personality_v0'?

1575904237
daurnimator
dimenus: no. isn't that symbol a C++ thing?

1575904254
dimenus
i'm linking with a base c++ library that provides a c api

1575904265
dimenus
libgcc and libstdc++ are both statically linked into the so

1575904293
andrewrk
it looks like that symbol is supposed to be provided by libstdc++

1575904298
daurnimator
dimenus: that symbol should be provided by libstdc++?

1575904327
andrewrk
you might try -fno-exceptions for your C++ code

1575904479
dimenus
it's referenced by libunwind

1575904484
dimenus
andrewrk: tried that, no dice

1575904657
andrewrk
you verified that libstdc++ is on the linker line?

1575904796
dimenus
yep, and it's not referenced in ldd

1575904813
dimenus
it's definitely this lib causing it though, no issue if i remove it from the build

1575904917
dimenus
andrewrk: wait, on the zig linker line or my gcc call?

1575904962
andrewrk
it sounds like the lib depends on this symbol, which means when it ultimately gets linked into a dynamic library or executable, libstdc++ needs to be on the linker line

1575904985
andrewrk
so, the zig linker line, if you're linking with zig

1575905044
andrewrk
it might be nice for zig build system to have a function to link against system libstdc++. here is where we do it for self-hosted:

1575905079
dimenus
hmm, that's strange to me. clang claims it doesn't need libstdc++ when linking

1575905094
dimenus
buut adding 'stdc++' to my build.zig totally fixed it on the zig side

1575905268
fengb


1575905294
fengb
Why does the build sit on a user prompt?

1575905343
andrewrk
no idea

1575905363
andrewrk
for WasmPageAllocator I doubt there is a windows-specific problemh

1575905396
andrewrk
you ready for a merge btw?

1575905415
fengb
Yeah, things look pretty good

1575905435
fengb
I end up mapping ~270 MB of ram, which is pretty slow in Rust wasm

1575905446
fengb
But everything else seems to be working fine

1575905509
andrewrk
sweet. I'll try to merge that today

1575905530
fengb
Cool

1575906727
andrewrk
alright, new non-var-args formatting API is in master. apologies for the code churn

1575906761
mq32
andrewrk: does the new syntax only support tuples or also anonymous structs?

1575906768
mq32
so: with field names

1575906790
andrewrk
it's planned to support that, but I did not add such functionality to the formatting implementation

1575906825
mq32
okay :)

1575906832
mq32
because this will be one heck of a cool feature

1575906848
mq32
same level of improvement as soon as you discover that regex supports named captures :D

1575906915
Pistahh
andrewrk: from now on do we need to add an extra ',.{}' to e.g. std.debug.warn even if we want to print a static string only?

1575906925
andrewrk
yes

1575906956
andrewrk
because var args is getting deleted from the language

1575906967
mq32
do i remember right that your plan is to remove the T { â€¦ } syntax for struct initialization?

1575906995
andrewrk
possibly. `T { }` syntax is equivalent to `@as(T, { })`

1575907035
andrewrk
`var x: T = .{ ... };` is equivalent to `var x = T{ ... };`

1575907113
mq32
hmm

1575907122
mq32
don't know if i like that, but i can understand why it's appealing

1575907160
andrewrk
Pistahh, if you have a stream, you can use `write` instead of `print` to avoid that extra parameter

1575907193
frmdstryr
With the var args pr just merged how is someone supposed to distinish between a tuple `.{}` and a struct `.{}`

1575907254
mq32
frmdstryr: it's the same thing

1575907263
mq32
tuples are just structs with auto-named fields

1575907327
andrewrk
there's no difference between a tuple with zero fields and a struct with zero fields

1575907358
andrewrk
yeah also what mq32 is correct; tuples are structs

1575907432
mq32
andrewrk: btw, on the topic of {} syntax: is it possible in userland to somehow utilize the "block type" passed to @cImport?

1575907457
andrewrk
it's not possible

1575907466
andrewrk
@cImport is doing special case analysis

1575907495
Pistahh
andrewrk: mostly I want to print something. I am a nobody here so I don't think my opinion matters (that much), so feel free to ignore me - but I have the feeling that too many things get oversimplified just for the sake of language simplification, and the "user experience" is secondary. (I'm not arguing, it is your language, you are the boss, your decisions. These just make me like zig less :(

1575907579
andrewrk
you're not wrong. but that's always been one of the explicit design principles- favoring language simplification over convenience for the typist

1575907656
mq32
Pistahh: how i stopped worrying and learned to love the typing:

1575907663
mq32
i have noticed something very special when coding zig

1575907694
mq32
i feel more powerful when coding with it, because you have to use less brain to actually produce zig code and thus can use more capacity to actually solve problems

1575907730
mq32
even though zig is sometimes overly verbose, if you are a good typer (and every programmer should become one eventually), it doesn't matter if you write & or 'addressOf

1575907767
mq32
but it's an experienced thing (at least by me) that i have solved some problems much more elegent and simple than before

1575907773
mq32
less code, less complex

1575907797
mq32
so: thumbs up to andrewrk for actually getting to where he wants to go with zig: "big brain time" :D

1575907887
companion_cube
good tooling can also help with that (like a good LSP implem)

1575907911
companion_cube
I know that it takes me less brain to program with such tools, cause I know if I do something wrong I'll get a red squiggle

1575907953
fengb
I'm not the biggest fan of letting IDE solve language problems. That leads to Java :/

1575907962
mq32
companion_cube: that's actually a false friend

1575907985
mq32
the point is: you don't want the red squiggle when you type your thought, but afterwards

1575908002
mq32
because as soon as that red line pops up, your train of thought is stopped and runs against a red squiggle

1575908013
mq32
then you fix a trivial syntax error, and start thinking again

1575908028
mq32
i reduced all the code helpers to a bare mininum

1575908038
mq32
manual compiling, then red squiggles

1575908044
mq32
manual code completion trigger, not automatic

1575908055
andrewrk
fengb, have you tried coding Java with a good IDE (such as eclipse) and practice using all the keyboard shortcuts and refactoring tools? it's incredible

1575908062
mq32
also disabled all template stuff, because i have to remember them

1575908077
andrewrk
it's some next-level productivity

1575908101
andrewrk
I'm talking keyboard shortcuts to auto- extract snippets into functions, and vice versa

1575908115
mq32
andrewrk: yeah that's true

1575908120
andrewrk
keyboard shortcuts that is scope-aware

1575908122
mq32
refactoring tools are awesome, also in VS+C#

1575908124
andrewrk
and type-aware

1575908124
companion_cube
mq32: yeah I'm used to triggering completions, but it's very nice because I know I don't have to remember exact names (nor to type them)

1575908132
companion_cube
just complete stuff, if it completes it'll work

1575908154
mq32
companion_cube: yeah, that's the point. auto-completion helps, but as soon as it tries to think for you, it actually hinders you

1575908165
mq32
because then you start coding against your IDE

1575908169
andrewrk
IDE support is no joke, one of java's biggest accomplishments. the main thing they solved is they have no conditional compilation

1575908171
companion_cube
yeah I removed `coc` from my vim config

1575908185
andrewrk
if zig can solve this with multibuilds, then we'll really be on to something

1575908186
companion_cube
but I still love to be able to complete with tab

1575908217
mq32
what is pretty nice in C#/.NET (and i assume java ides have this as well): "new Foo { X = 10, Y = 20 }", "Ctrl+." => "Create class in new file", "Enter"

1575908233
mq32
and you have a new file with the correct imports, class and property declarations

1575908254
andrewrk
if you get an error like "that function does not exist" you can hit a keyboard shortcut to create it for you, with the correct parameter types and return type

1575908316
fengb
andrewrk: yes it's great, but it also makes the IDE mandatory. And there's still mountains of boilerplate to wade through

1575908364
fengb
I love IDEs, but there's no reason for the underlying language to be crappy. C# is a lot more reasonable

1575908373
andrewrk
fair

1575908376
fengb
Or Kotlin

1575908478
companion_cube
well yeah, you want a good language with a good IDE

1575908487
fengb
There has to be a balance between Coffeescript's looseness and Java's straightjacket :)

1575908507
mq32
Yeah, Java without IDE isn't much fun

1575908515
mq32
C# is quite reasonable, if you remember a lot of class names

1575908576
mq32
also it's a dream to work with the commandline compiler

1575908579
mq32
"it just works"

1575908594
mq32
well, at least for .NET/Mono, i have bad experience with dotnet core

1575909609
daurnimator
fengb: agreed. java is a language that you can't write

1575909650
scientes
also needs lots of java to write java

1575909662
scientes
0xcoffeebabe

1575909677
scientes
0xc0ffeebabe

1575911629
dingenskirchen
with varargs being phased out in favor of 'tuples'/structs, would something like `std.debug.warn("value: {ident}", .{ident = my_variable});` be possible?

1575911890
andrewrk
dingenskirchen, yes

1575911893
andrewrk
not implemented yet

1575911909
andrewrk
someone should probably make note of this on

1575911980
dingenskirchen
amazing, I like to imagine that'd be a little more robust than index-based formatting strings ^^

1575914131
dimenus
andrewrk: did anyone do analysis to determine how bloat is affected by the std.fmt.format change?

1575914735
ovalseven8
Is Zig a suitable programming language for a next-gen operating system?

1575914973
andrewrk
dimenus, nope

1575915004
scientes
ovalseven8, why you want to create your own operating system?

1575915206
andrewrk
what do you mean by next-gen?

1575915384
ovalseven8
andrewrk, Almost every OS is C-based and at least a few decades old in its origins. With next-gen I mean a new one, with the lessons learned and without ballast

1575915464
scientes
ovalseven8, or C++

1575915504
scientes
something more realistic would be to write  a driver in zig

1575915534
ovalseven8
scientes, Is Zig not low-level enough?

1575915552
scientes
ovalseven8, zig is great, but writing a kernel is a huge project

1575915556
scientes
if you want it to be useful

1575915570
scientes
I mean if you want something really simple, sure

1575915576
scientes
people are using zig for bare-metal

1575915607
andrewrk
ovalseven8, here is a related comment I made on reddit recently:

1575915617
ovalseven8
As far as I read the website, Zig could provide some more compile-time guarantees compared to C, what would be good for kernels.

1575915639
andrewrk
summary: zig is even better than C for kernels, except for maturity. which is kind of a big deal

1575915666
andrewrk
but if you're willing to accept the caveat of immaturity, then zig is ideal for kernels, IMO

1575915693
scientes
also kernels require lots of obscure features

1575915705
scientes
like 8086 assembly

1575915732
ovalseven8
Yeah, for serious stuff Zig has to be stable before

1575915793
scientes
also you don't realize how good at C the linux devs are

1575915850
andrewrk
what does being good at C mean? abusing macros?

1575915855
ovalseven8
Had a (short) look at Rust and while I like its safety features a lot (!) it's not a programming language for hobby programmers, it's just to complex with so much features.

1575915862
andrewrk
I thought being good at C and being good at Zig was mostly the same thing

1575915885
andrewrk
ovalseven8, you might find this interesting:

1575915889
scientes
well, mostly it is knowing the tricky parts of C

1575915897
scientes
and not macros

1575915905
andrewrk
zig supports a way for hobby OS developers to provide an OS package so that application developers can use the zig std lib to target your hobby OS

1575915913
fengb
Many of us are here because we failed at learning Rust :P

1575915922
andrewrk
including me

1575915973
andrewrk
pixelherodev is taking advantage of this OS package feature, would probably be an interesting person here to chat with

1575916060
ovalseven8
Well, most of you are outstandingly intelligent, so I am sure you could learn Rust if you want. ;) I only deal on a hobby-level with a little bit programming and what I, as example, like about Golang is that it's just super readable even for inexperienced devs. :)

1575916119
scientes
ovalseven8, we would rather focus on the program than our knowledge of the language

1575916128
stratact
ovalseven8: they are amazingly intelligent. I learn a lot just from being here reading the chat ;)

1575916169
andrewrk
I like that about go as well

1575916202
scientes
that was part of the design of go

1575916205
scientes
and they did succeed

1575916262
ovalseven8
Go is criticized a lot about missing features. I like there is at least one programming language you don't have to keep track on the language changes.

1575916329
ovalseven8
I just wonder if Zig could guarantee memory-safety like Rust? Or is something like that only possible if you bloat the language with a lot of features.

1575916366
stratact
ovalseven8: no, and it shouldn't. The ownership model overcomplicates things and makes it less flexible to implement design

1575916401
scientes
ovalseven8, you cant guarantee things in languages without adding a escape value, that then gets overused

1575916405
stratact
I'm sick of wrapping my brain around strict compiler rules only to be filled with stress and fear.

1575916479
andrewrk
ovalseven8, safety is an ongoing project:

1575916492
andrewrk
there are 4 build modes. 2 of them are the "safe" modes

1575916503
andrewrk
but much of the safety is runtime checks

1575916510
ovalseven8
It's always a trade-off. In general I'd like to have a modern C alternative (small language, stable, simple), so perhaps Zig will be one in case it does not add more features.

1575916530
andrewrk
runtime checks means that the rules are simple, but you find out at runtime if you broke them

1575916545
andrewrk
vs rust has complicated rules but you find out at compile-time if you broke them

1575916559
scientes
ovalseven8, the interpreter feature means that zig is far more complicated than say, c89, but no-one wants a non-optimizing compiler so that argument is kinda out the window

1575916617
andrewrk
I do think that it's going to be possible to detect most use-after-free and bad ptr casts, but such safety does not exist in status quo zig

1575916620
ovalseven8
Is andrewrk the only main developer?

1575916655
andrewrk
you can get an idea of the last month of activity here:

1575916669
andrewrk
I'm the only full time developer

1575916686
ovalseven8
andrewrk, I'm blown away due to your productivity :)

1575916754
andrewrk
this is what it looks like to focus on the application rather than try to learn how use c++ features ;)

1575916777
gonz_
I'm very happy with investing in andrewrk so far.

1575916800
gonz_
I think he's turned out to be a good captain of the ship.

1575916819
stratact
andrewrk is worth my $15 patreon-a-month

1575916827
andrewrk
yarr harr fiddle-dee dee

1575916968
andrewrk
hmm looks like I need to refresh the macos CI llvm tarball

1575917145
andrewrk
hmm my macos wants to upgrade to catalina

1575917227
stratact
ovalseven8: Doing PRs for Zig is also a real treat. All peer reviews have been positive, helpful, and mind-stretching.

1575917428
dimenus
i want to contribute on the compiler side but haven't had the opportunity recently :(

1575917439
dimenus
also, ir.cpp scares me

1575917442
dimenus
:D

1575917461
dimenus
and agreed wholeheartedly on andrewrk's stewardship

1575920002
Snektron
hey andrewrk, i'm wondering why @typeOf to @TypeOf needs to still be accepted for another release cycle but other breaking features (the later proposed @bitReverse, or the removing of var args just now) don't have that?

1575920242
andrewrk
Snektron, mainly because it's such low effort to make this breaking change auto-fix itself

1575920253
Snektron
Fair enough

1575920497
Snektron
anyway, i've noticed that zig fmt on the std lib root doesn't actually handle all files

1575920560
Snektron
and there is also a small typo at reset_event.zig:115

1575921385
Snektron
ah

1575921414
Snektron
andrewrk, whats the point of the `seen` map in stage1.zig:Fmt?

1575921442
Snektron
Because the way i see it, recursively iterating over a directory tree shouldn't process the same file twice

1575921449
Snektron
unless symlinks are followed

1575921484
Snektron
anyway, it looks like the currently processed file is added to the hash map, but it is also free'd

1575921491
andrewrk
yes it's to avoid problems with symlinks

1575921512
Snektron
So the hash map is full of pointers to undefined memory

1575921513
andrewrk
good point, that looks broken

1575921528
Snektron
ill change it since im working on it anyway

1575921542
andrewrk
thanks

1575921557
andrewrk
valgrind should catch this error

1575921601
Snektron
yeah

1575921712
andrewrk
also GeneralPurposeDebugAllocator + #63 would catch this error

1575921751
Snektron
I had expected a StringHashMap to own its internal data

1575921772
andrewrk
there's BufMap for that. naming could probably be improved

1575921867
dimenus
HashMap doesn't make value copies?

1575921884
dimenus
then I also have bugs to fix... lol

1575921885
Snektron
yes, shallow copies

1575921900
dimenus
wait nvm, ignore me

1575921968
andrewrk
I wonder how expensive it will be to make every if into a switch 0 => ... 1 => ... else => @panic("branch on undef")

1575921993
Snektron
syntax wise?

1575921997
andrewrk
code generation wise

1575922003
andrewrk
that's what #63 means doing

1575922091
Snektron
Hmm

1575922122
Snektron
I think that basically means silently translating every type initialized to `undefined` into either a special type or a special value

1575922162
andrewrk
in safe build modes, zig already writes 0xaa when you assign undef

1575922167
Snektron
i don't see type inference handling the former, and the latter would produce problems with types that span their entire container (any 64 bit type for example)

1575922181
Snektron
Yeah but what if i have an i64 that i initialize to 0xaa...?

1575922214
andrewrk
some types can't be distinguished between an undefined state or valid state

1575922234
Snektron
but not all

1575922245
andrewrk
most can

1575922277
Snektron
but you still need something for the others, so i guess that basically means augmenting the type

1575922291
Snektron
(i mean making everything silently a kind of optional)

1575922316
Snektron
but that probably creates a few problems. I'm mainly thinking along the lines of arrays or i64 for example

1575922321
Snektron
of*

1575922400
Snektron
A friend of mine did his bachelor's thesis on some kind of runtime safety implemented in clang

1575922503
leeward
Woot, executed a program that used malloc in my emulator.

1575922560
leeward
Now let's find out if it produces reasonable results.

1575923203
stratact
leeward: what kind of emulator is this?

1575923285
andrewrk
I am pleased to announce that zig programming language no longer has var args. It is a compile error in master branch if you try to use them

1575923301
andrewrk
this is not related to C functions. C functions still work the same

1575923336
stratact
andrewrk: congrats on the change, I'm happy you are happy.

1575923355
emekankurumeh[m]
nice!

1575923447
andrewrk
time to go on a bug closing spree

1575923471
andrewrk
var args never worked at compile time or with zero bit types. tuples do not have either problem

1575923503
Snektron
hm

1575923512
Snektron
@typeOf(i32) produces very weird errors

1575923538
Snektron
oh wait, thats legal of course

1575923552
Snektron
(i had accidently forgot to make a better test case)

1575923558
leeward
stratact: AVR

1575923594
mq32
leeward: you write an AVR emulator?

1575923602
leeward
Yeah, it's something to do.

1575923609
stratact
leeward: no kidding? The 32-bit kind?

1575923610
mq32
could you

1575923622
leeward
8-bit

1575923634
stratact
ah gotcha, keep it simple of course

1575923642
leeward
atmega328p

1575923652
mq32
for what purpose?

1575923667
mq32
"for fun" or do you want to do something with the emulator afterwards?

1575923688
leeward
I'd like to get arduino-like stuff working in Zig, and I need to be able to debug it.

1575923719
leeward
I could use a real AVR emulator that already works, but this way I get to learn Zig and get more familiar with the platform.

1575923735
leeward
Number of bugs found in AVR instruction set documentation: more than 2

1575923746
mq32
haha

1575923753
mq32
they are probably already documented in an errate

1575923760
leeward
Odds are good.

1575923767
mq32
also, you are doing a useful project for the zig community :D

1575923780
mq32
because we could incorporate behaviour tests for the AVR8 platform :D

1575923790
leeward
Ooh, that could be useful.

1575923791
mq32
using your emulator for CI

1575923799
Snektron
Whats `align(x:y:z)` syntax?

1575923808
leeward
Though it would probably be better to use the emulator from Atmel for that.

1575923818
mq32
heh

1575923876
stratact
(phew, eating that sandwich from grubhub was worth it (it was late). Now to rebase my PR from upstream master and reflect any possible varargs-to-tuples changes Andrew made)

1575923946
mq32
oh yeah, that will break a lot of stuff in the ZGS project as well

1575924087
andrewrk
I paid my penance in

1575924193
leeward
stratact: Grubhub late? Gasp. That means it arrived!

1575924233
fengb
The title change means we're gonna start calling it tuples? :P

1575924305
stratact
leeward: I know, I'm entitled. But it was painful from fasting all morning ;)

1575924338
andrewrk
fengb, yeah it's tuples

1575924383
emekankurumeh[m]
so can we return tuples from functions? access individual elements?

1575924388
andrewrk
a tuple is a struct and has all the semantics of a struct, with the additional property that it can be coerced to arrays, and the `len` property works, and element syntax works

1575924438
andrewrk
yeah you can return a tuple from a function. what use case are you thinking of?

1575924488
andrewrk
if it's the division() use case, proper type for that would be `struct { quotient: T, remainder: T}` because the order of those return values is not significant

1575924533
leeward
stratact: I'm just commenting on their reliability. I think the last time we ordered grubhub it arrived several hours late. Doordash manages to be worse, but only just.

1575924636
leeward
andrewrk: Are tuples required to have only one type of element?

1575924667
emekankurumeh[m]
no, they can be heterogeneous like a struct or union

1575924677
emekankurumeh[m]
i was thinking something similar to tuples in Haskell

1575924707
leeward
emekankurumeh[m]: How can they be coerced to arrays then?

1575924741
emekankurumeh[m]
if they all have the same type

1575924778
emekankurumeh[m]
so .{0, 0, 0} is the same as [3]comptime_int {0, 0, 0}

1575924801
jonathon
If you deinit() an ArrayList, should it automatically free any items which had been appended to the ArrayList? I'm trying to narrow down an issue with continually increasing memory allocation and

1575925004
emekankurumeh[m]
leeward:

1575925315
Snektron
Alright that should do it

1575925541
andrewrk
they don't necessarily even have to all be the same type, just all have to be able to coerce to the array elem type

1575925629
andrewrk
jonathon, continually increasing memory - are you aware of how ArenaAllocator works?

1575925639
andrewrk
it frees nothing until everything at once

1575925693
Snektron
perhaps there should be an allocator that specializes on growing elements

1575926001
andrewrk
ArrayList is pretty good at that

1575926032
andrewrk
a good backing allocator for an ArrayList would be a general purpose allocator

1575926208
leeward
Is linking to the C standard library and using malloc still the easiest way to get a general purpose allocator?

1575926217
Snektron
pretty much

1575926394
mikdusan
jonathon: the code you posted does not leak on my system (simple test, just ran loop without time delay)

1575926411
jonathon
andrewrk: I was going by the "how to choose an allocator" section, it should be deinit() at the end of the main program loop

1575926455
jonathon
so (theoretically) periodically freeing

1575926565
emekankurumeh[m]
is it better zig style to return anon structs or struct literals?

1575926630
andrewrk
emekankurumeh[m], since we don't have inferred return types, wouldn't that be determined by your return type?

1575926691
emekankurumeh[m]
i mean in a constructor is it better style to do `return @This() { ... };` or `return .{ ... };`

1575926692
jonathon
mikdusan: Hmm. That might mean it's leaking somewhere else and I did actually get the Zig memory allocation correct... :| I wonder if it's the C library rather than my code (though libmosquitto should be pretty well tested by now).

1575926750
andrewrk
emekankurumeh[m], I would prefer the latter, since the former is equivalent to @as( @This(), .{ ... } ), which is just unnecessary

1575926824
mikdusan
also `fn append` works with

1575926834
mikdusan
^ jonathon

1575927562
andrewrk
all these issues with var args are now solved:

1575927630
emekankurumeh[m]
nice

1575927630
mikdusan
+1

1575928047
frmdstryr
How was the event loop code tested?

1575928097
frmdstryr
I can now get 40k req/s but it drops as I add more concurrency

1575928114
andrewrk
frmdstryr, it hasn't been tested more than a proof-of-concept

1575928149
andrewrk
that's the level of quality we're currently at here

1575928164
andrewrk
which is disappointing if you were thinking you wanted to rely on it, but exciting if you wanted to work on it

1575928217
andrewrk
there's also the problem to be aware of that std.os.write() is not integrated with the event loop yet

1575928238
andrewrk
so, if you increase concurrency, you'll have stalls that aren't supposed to be possible

1575928262
andrewrk
I'm working towards getting std.os.write() integrated. believe it or not, killing var args was part of the progress

1575928284
andrewrk
because the next step is going to be turning std.fmt.format into an iterator pattern, so that it does not use a callback

1575928316
fengb


1575928320
andrewrk
and then the next step will be std.os.write

1575928487
frmdstryr
sounds good. Was there any thought about using fmt as a "templating engine"?

1575928500
andrewrk
is that not what it is?

1575928501
frmdstryr
Since it pretty much is already

1575928539
frmdstryr
Haven't explored it much more than simple debug statements

1575928983
dingenskirchen
there was someone talking about using @embedfile as format string, for a text adventure I think?

1575929068
mq32
dingenskirchen: wtf, nice idea!

1575929084
dingenskirchen
heh, don't congratulate me :V

1575929100
mq32
yeah, but thanks for sharing :)

1575929158
dingenskirchen
it was pixelherodev! context here:

1575929206
jonathon
(OK, so I don't see a leak when I exe.linkSystemLibrary against the C library, but I do see the leak if I use Zig to compile the library from source with exe.addCSourceFile. At least it's not because of my Zig code and I can stop pulling my hair out trying to work out what I was doing wrong.)

1575930521
fengb


1575930532
fengb
Speaking of format bloat...

1575930902
Snektron
what the fuck

1575930937
Snektron
i wanted to see how mad it was with Zig

1575930943
Snektron


1575930971
Snektron
(its the same with release-small)

1575931054
andrewrk
Snektron,

1575931059
frmdstryr
Is there a way to chain a callback after an async frame completes?

1575931103
frmdstryr
like defer frame.deinit(some_cb)

1575931142
emekankurumeh[m]
that should work

1575931173
Snektron
thats not when a frame completes

1575931192
emekankurumeh[m]
oh that's when it returns

1575931206
Snektron
you could write a wrapper async function i suppose

1575931217
andrewrk
frmdstryr, this is the same question as "Is there a way to chain a callback after a function call returns?"

1575931422
andrewrk
Snektron, if you add --strip (to get rid of debug info) and change f64 to u64 then the object file comes out to 2.1K

1575931482
andrewrk
tiehuis breaks down the binary size improvements of Ryu on the issue I linked

1575931485
Snektron
andrewrk, thats still really large

1575931499
Snektron
oh, ill go take a look

1575931513
Snektron
I think theres something more at play though'

1575931574
andrewrk
how big would you expect that object file to be?

1575931609
Snektron
Well considering the compiler is still spewing out a lot of simd code for a simple int to string, a lot less

1575931645
andrewrk
I don't see any simd code

1575931683
Snektron


1575931711
andrewrk
yeah ok I see 4 simd instructions

1575931755
Snektron
looks like its also copying a whole lot of data from the stack

1575931806
andrewrk
it goes down to 968 bytes if you use only unsigned ints

1575932016
daurnimator
frmdstryr: did you figure out the EEXIST error I was getting?

1575932051
frmdstryr
Not yet, still playing with improving memory allocation

1575932139
frmdstryr
But I didn't hit that error at all

1575932168
mq32
oh wow, that bufPrint doesn't look very nice

1575932186
mq32
(in terms of instructions-per-actual-ops)

1575934085
shakesoda
mq32: what do you think about making sdl_image optional in sdl.zig

1575935352
merlyndmg
I ran valgrind on the download page zig build. I'm getting errors galore. Thousands of them. On my local release build I'm getting almost no errors. Is that to be expected andrewrk ?

1575935381
merlyndmg
I've basically never used valgrind before, so I don't really know what things to filter out mentally :)

1575935694
daurnimator
merlyndmg: doing what operation?

1575935710
daurnimator
I don't think I get any warnings under valgrind unless my code is wrong

1575935739
merlyndmg
This is regarding bug 3838, regarding the translate-c that's spitting out nan's

1575935782
merlyndmg
lots of errors e.g. "Conditional jump or move depends on uninitialised value" on the download build, no errors on a local build with the same translate-c command on the same input.h file

1575935889
merlyndmg
I guess I can comment on the bug page instead. Just thought it might be faster to chat here. Since I'm not really conversant with this type of investigation maybe it's best to pass the ball to whomever can pick it up later

