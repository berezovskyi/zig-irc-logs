1566198131
bgiannan
Hi there. If I wanted to use SDL with zig, would you recommend cImport or bindings or something I don't know about?

1566198913
daurnimator
bgiannan: perhaps start with

1566199016
bgiannan
well "I'm still experimenting. Don't try to use it yet."

1566199354
daurnimator
bgiannan: you could also look at

1566199460
bgiannan
i know sdl and what i can do with it, glfw not so much

1566199504
bgiannan
and i would already have to learn zig itself so adding a new lib to learn on top of that would makes things unfun

1566199586
gonz_
bgiannan: Maybe work with zig-sdl as a base? It should be convenient to have some of the work already done and you could still change things + add more to it.

1566199672
gonz_
Be careful to not learn Zig through the lens of compatibility types, though; it seems to be very common.

1566199731
bgiannan
my idea was to abstract away most of the sdl stuff and forget about it

1566200269
gonz_
I'm sure you'll be fine either way and I'm not sure which of these would provide less friction but I'd guess it'd be the "build on zig-sdl" way.

1566200393
bgiannan
yeah i'll give it a go

1566204033
samtebbs
bgiannan: I've been working with SDL2 lately, and I find that cImport'ing the header works well. zig-sdl didn't for some reason

1566204242
bgiannan
samtebbs, do you have a gist or something?

1566204344
samtebbs
This will serve as some inspiration :)

1566204406
bgiannan
nice

1566204409
bgiannan
seems easy enough

1566204453
FireFox317
Yeah I think you really don't need the zig-sdl repo, because that is for building SDL from source and you probably already have the libraries for SDL installed on your pc.

1566204475
FireFox317
And should be able to link against them, and CImport the header files

1566204496
samtebbs
bgiannan: Yeah it's pretty easy. Check out the build.zig to see how to link with it

1566204549
samtebbs
`linkSystemLibrary("SDL2")` and `linkSystemLibrary("c")` will do it

1566204586
bgiannan
great! i'll see if i can get a minimal program running

1566207860
bgiannan
When installing zig with homebrew, it asks for Xcode 11 even after i installed it

1566208146
gonz_
I would've thought the binaries on the home page would've sufficed like for the other platforms

1566208295
gonz_
Curiously the instructions don't even mention Xcode, though...?

1566208681
samtebbs
bgiannan, gonz_: Perhaps it's asking for Xcode as that's the normal way to get a C/C++ toolchain on a mac

1566208690
samtebbs
Installing gcc/clang separately may help

1566208709
bgiannan
i don't mind it using xcode toolchain

1566208719
bgiannan
just wondering why it asks for xcode 11 when it's there

1566208736
daurnimator
bgiannan: what exactly is asking for xcode?

1566208760
bgiannan
homebrew is

1566208768
bgiannan
when upgrading from 0.3.0 to 0.4.0

1566208799
gonz_
I think it's unwise to be on 0.4.0 at the moment

1566208806
gonz_
You should probably be on master

1566208846
samtebbs
Agreed, for the syntactical and semantic changes, as well as bug fixes

1566208863
bgiannan
`xcode-select --install` did the trick

1566208866
bgiannan
ah

1566208872
bgiannan
so i should build zig myself

1566208887
gonz_
No, you can download the master binaries from ziglang.org

1566208902
bgiannan
ah yes just saw that

1566208971
daurnimator
bgiannan: depends on if you expect to end up contributing to zig itself. If you can imagine yourself helping with the standard library then it's worth building things yourself

1566209104
gonz_
Setting it up is useful, but running only self-built isn't necessary even if you do end up contributing, it seems to me. I have several downloaded versions + self-built.

1566211583
samtebbs
bgiannan: I would only build if you (as daurnimator said) want to contribute to zig or want to pull down certain changes and build immediately rather than wait for the nightly builds.

1566212910
bgiannan
alright managed to run a minimal example

1566212916
bgiannan
should be easy enough from there

1566217451
bgiannan
what's the best practice to serialize and save data to a file?

1566218144
samtebbs
bgiannan: What type/s do you want to serialise?

1566218299
bgiannan
structs? i'd like to avoid having to writing serializing functions for all my data types if  possible

1566218792
samtebbs
Well a naive way would be to convert your struct instance to a pointer and write that to a file as a buffer :p

1566218804
samtebbs
That falls down if you use pointers ofc

1566218849
bgiannan
hum

1566218862
bgiannan
what happens when a struct field is another struct ?

1566218912
samtebbs
That should be fine as the field is embedded inside the parent struct

1566218945
bgiannan
alright

1566219622
daurnimator
bgiannan: a different answer is: time to write a CBOR library or to at least "automaticify" the JSON library

1566219643
bgiannan
the file would be huge for the amount of data i want to save

1566219657
bgiannan
as binary it was already around 4Mo

1566219680
bgiannan
as json i mean

1566219703
Tetralux
Maybe I should write a MsgPack lib for Zig...

1566219727
daurnimator
Tetralux: why? CBOR is better is all respects...

1566219742
Tetralux
Never heard of that.

1566219792
daurnimator
Tetralux: it's a proper stand created after the shortcomings of msgpack were figured out.

1566219797
daurnimator
*standard

1566219841
Tetralux
God I hate reading RFCs xD

1566219849
Tetralux
As much as I like the idea of them.

1566219865
daurnimator
then don't? play around at

1566219958
samtebbs
daurnimator: Regarding the hardware that you have access to from worksonarm, what can you do on it? Do you essentially have access (sudo?) over ssh?

1566219977
daurnimator
samtebbs: its a dedicated hardware box. I can do anything I want with it

1566219996
daurnimator
rules are essentially "don't abuse things" "only use it for open source projects"

1566220012
Tetralux
Thanks, daurnimator.

1566220018
samtebbs
Ok, so theoretically if we can just get it connected to the CI then it's a great option

1566220026
daurnimator
samtebbs: yup

1566220057
samtebbs
That may require using a different CI solution though as from what I know, azure devops doesn't allow you to add arbitrary machines as build agents

1566220061
samtebbs
Whereas TeamCity does

1566220068
daurnimator
samtebbs: just give me something I can feel confidentish can't be exploited by arbitrary PRs (or at least can be reset afterwards)

1566220084
daurnimator
samtebbs: gitlab CI does... but their arm64 runner has a bug when used in "docker" mode :(

1566220107
bgiannan
how do i express errors in zig? from the doc it seems you define an error type as a return type for your function, but what if the function returns a valid value? can i do `fn afunction() SomeError, AValidType {...}` ?

1566220109
daurnimator
bgiannan: you return an error by doing `return error.AnyErrorYouWant`

1566220113
samtebbs
daurnimator: And that bug doesn't seem to be close to merging given how long it's been there for so far

1566220134
daurnimator
bgiannan: your return type will need to include your error set. just prefix with ! for automatic error set inference

1566220138
samtebbs
benaiah: `YourError!YourReturnType`

1566220139
daurnimator
samtebbs: indeed :(

1566220157
samtebbs
oops wrong tag, bgiannan

1566220175
fengb
Gitlab doesn’t seem to resolve open source bugs :/

1566220184
samtebbs
so `fn afunction() SomeError!AValidType {}`

1566220201
Tetralux
(Or `fn aFunction() !AValidType {}`)

1566220212
daurnimator
bgiannan: myerrorset = error.foo || error.bar; error_or_bool = myerrorset!bool;     fn fun() error_or_bool { ....... }

1566220225
daurnimator
bgiannan: ^ that substitute in directly as may want.

1566220235
daurnimator
though in 95% of cases you just end up using inferred error sets

1566220237
samtebbs
daurnimator, fengb: :/ I vote for migrating to TeamCity if that is at all reasonable. I've used it at work to verify my own patches and I've made it run on arm hardware

1566220255
daurnimator
samtebbs: its not so much a migration we need as something additional

1566220266
daurnimator
samtebbs: I'm not familar with team city. got a tl;dr?

1566220296
fengb
I haven’t heard of TeamCity for over 10 years. I didn’t know they’re still a thing

1566220339
samtebbs
daurnimator: It's from JetBrains (peeps behind IntelliJ, Kotlin, CLion etc.) and is more "low level" CI software. You create scripts that happen on some event and it propogates them to your build agents

1566220389
daurnimator
samtebbs: looks like it's not a service but a run-it-yourself?

1566220399
samtebbs
That event can anythting from Git, GitHub PRs, webhooks...

1566220403
daurnimator
samtebbs: if we're doing that we might as well use more traditional stuff like jenkins... or drone

1566220409
samtebbs
daurnimator: Indeed

1566220431
bgiannan
what's the best practice to handle c functions that may return NULL?

1566220444
bgiannan
just test for it ? or will it raise an error?

1566220446
daurnimator
bgiannan: ? makes a type optional in zig

1566220456
bgiannan
ah there's optional types great

1566220460
samtebbs
That "indeed" was regarding it being run-it-yourself. I've not looked into jenkins or drone really

1566220523
daurnimator
samtebbs: I'm happy to manage a job-runner myself; but I'm too busy to maintain an actual drone/jenkins server myself. are you volunteering? :)

1566220538
samtebbs
It being run-it-yourself would mean we'd need harware to run the server on but we could do that on the worksonarm hardware as it's free(?)

1566220564
bgiannan
daurnimator, so something like `var sprite: ?[*c]SDL_Surface = ...`

1566220574
Tetralux
bgiannan: The equivalent of T* from C cannot be null in Zig, so a pointer that might not point to a valid memory address is ?*T.

1566220598
samtebbs
daurnimator: I reckon I am volunteering :D If I don't have to pay for it... (being a broke student and all)

1566220615
bgiannan
`?*` or `?[c*]` ?

1566220619
Tetralux
First one.

1566220625
Tetralux
The second should never be used in code you write.

1566220633
bgiannan
alright

1566220672
daurnimator
bgiannan: [c*] is a "C pointer" => a pointer that is automatically generated from C headers that is undocumented for if it is one item or many items./

1566220720
daurnimator
bgiannan: you should convert your C pointers to single item pointers (*), slices ([]) or multi-item pointers ([*]) as soon as possible

1566220806
daurnimator
samtebbs: a CI server wants a bit more than that... e.g. you'll need to manage user data, backups, etc....

1566220935
samtebbs
daurnimator: what user data?

1566220961
Tetralux
Does the stdlib have a way to discover how much physical memory is free?

1566220965
daurnimator
samtebbs: well usually e.g. the author of a PR can kick it off again

1566220980
daurnimator
Tetralux: you should pretty much never be doing that

1566220989
daurnimator
unless you're on a freestanding microcontroller

1566221040
Tetralux
If you don't know if you are or not... for one.

1566221048
daurnimator
what??

1566221072
Tetralux
Otherwise, it can help to make a choice between a slow, resource-easy way, and a fast, but resource-heavy way.

1566221092
Tetralux
Because you don't know if you fail until you are already part way through a process.

1566221116
daurnimator
Tetralux: physical memory on a system should almost be always used. however much of it is used for speculative prefetches and the kernel will drop things as memory demand increases

1566221148
daurnimator
i.e. memory free is not a good indicator of if memory is available

1566221176
Tetralux
I meant that you'd be asking the kernel how much is free, if you have a kernel.

1566221191
daurnimator
that's not useful info

1566221282
Tetralux
What would you suggest then?

1566221306
bgiannan
am i responsible to test that an optional is not null?

1566221311
Tetralux
Yes.

1566221312
daurnimator
bgiannan: yes.

1566221319
Tetralux
There are several ways.

1566221329
Tetralux
If you know it isn't: optional.?

1566221331
Tetralux
If not

1566221332
daurnimator
Tetralux: ask the kernel for lots of memory. if you get it, do the lots-of-memory path. otherwise ask for less memory; and do the small-memory path

1566221339
Tetralux
if (optional) |value| { ... }

1566221341
Tetralux
Or

1566221355
Tetralux
var value = optional orelse @panic("there wasn't a value")

1566221362
Tetralux
You can also:

1566221370
Tetralux
var value = optional orelse { ... };

1566221371
daurnimator
bgiannan:

1566221379
Tetralux
The orelse can return instead of providing a value.

1566221389
Tetralux
var value = optional orelse return -1;

1566221410
daurnimator
bgiannan: the most common style IME is `if (optional_foo) |foo| { doSomethingWithFoo(foo); }`

1566221419
bgiannan
perfect

1566221466
Tetralux
If you're style is more early-out-returning, then the orelse is more common.

1566221481
Tetralux
IMO, it can be much more readable.

1566221629
bgiannan
can i do something like `if ((myvar = maybenull())) |foo| { ... }` ?

1566221647
Tetralux
In daurnimators example, myvar is the |foo| part.

1566221658
daurnimator
bgiannan: no... but why would you need have `myvar` there? you have `foo` inside the conditional

1566221755
bgiannan
or maybe: `var something: *Something = maybenull() orelse { return AnErrorType; }` ? or will it just put `AnErrorType` in `something`?

1566221774
Tetralux
No, that's fine.

1566221775
fengb
Return always returns from the function

1566221777
daurnimator
bgiannan: the `return` will immediately return from the current function

1566221784
bgiannan
alright perfect

1566221804
daurnimator
bgiannan: also you (probably) don't need to specify the `*Something` there, it's inferred. and the braces are not required.

1566221812
fengb
Is there a built-in to lookup the field declaration by name?

1566221818
Tetralux
You can return from a block, but you don't use the 'return' keyword. You label the block with `label: {...}` and then `break blk: value;`

1566221829
daurnimator
fengb: std.meta has something for it

1566221865
fengb
Ah I see, thanks

1566221870
bgiannan
daurnimator, yes those braces led me to believe that block was a closure or some sort

1566221879
bgiannan
of*

1566221915
daurnimator
bgiannan: a block mainly introduces a new scope

1566221957
daurnimator
bgiannan: though it also can be `break`-d from.

1566222205
samtebbs
daurnimator: Oh I see, so you'd want an author to be able to kick off another build in case of infrastructure issues? Any changes made to a PR would be picked up and built automatically.

1566222254
samtebbs
TeamCity does have a registration and log in system so contributors could possibly be given accounts with limited privileges.

1566222275
samtebbs
And it may be possible for them to fire off builds from their own PRs, not sure though

1566222286
samtebbs
s/from/for

1566222290
daurnimator
samtebbs: so something I considered was just running gitlab in shell mode; but only for master branch. that way a driveby PR can't break things

1566222315
fengb
Is it just the runner that's broken? We could maintain a forked copy

1566222326
samtebbs
daurnimator: Like nightly builds

1566222341
daurnimator
samtebbs: well per-master-commit CI rather than per-PR

1566222357
daurnimator
fengb: so that's where I'm waiting to hear back from someone: they are apparently maintaining a working fork

1566222384
fengb
Ah okay

1566222393
samtebbs
daurnimator: Ah makes sense. At least that would give andrewrk a chance to review them first. But it is valuable for contributors to have their changes validated before merging

1566222414
daurnimator
samtebbs: would be better than the status quo of nothing

1566222415
fengb
I've been waiting for a working changeset get merged into Gitlab proper for over a year now so I'm kinda bummed at their process

1566222536
samtebbs
daurnimator: It's certainly an option for the short-term.

1566222537
Tetralux
You can return from a block, but you don't use the 'return' keyword. You label the block with `label: {...}` and then `break blk: value;`

1566222547
Tetralux
Whoops - wrong window xD

1566222561
samtebbs
fengb: I'm surprised since surely they have people paid to review external changes...

1566222606
samtebbs
daurnimator: Can contributors currently fire off builds of their PR without making any changes?

1566222613
fengb


1566222617
fengb
wtf they just closed it

1566222834
samtebbs
10/10 would contribute again

1566222891
fengb
Literally been working with tests for 10 months :(

1566222975
daurnimator
fengb: huh? where do you see they just closed which MR?

1566223012
fengb


1566223020
fengb
Less bad but still pretty bad

1566223166
bgiannan
can function parameters have default vaules?

1566223168
bgiannan
values*

1566223184
fengb
nope

1566223193
samtebbs
bgiannan: Nope, not sure if it's been proposed either

1566223256
daurnimator
huh. that would be an interesting alternative to overloading...

1566223333
fengb


1566223353
Tetralux
I've wanted default parameters since I started using Zig.

1566223366
Tetralux
I use those things pretty frequently in languages that have them.

1566223372
fengb
Closest we have atm is a struct with default values

1566223404
Tetralux
Though if you have we, PLEASE FOR THE LOVE OF SOMETHING BEAUTIFUL, have them so that you have to specify them by name=value ALONG WITH the positional arguments.

1566223412
Tetralux
The second part is more important than the first.

1566223444
daurnimator
Tetralux: that makes them

1566223453
daurnimator
Tetralux: because then you can just pass a single struct

1566223468
daurnimator
I think struct type inference is an open proposal (maybe even accepted?)

1566223473
fengb
At this point, I just want inferred struct builders

1566223479
fengb
Ha

1566223483
Tetralux
So for `fn f(x: i32, y: i32 = 47)`, you can do `f(42, y=7)`, `f(32)`

1566223500
daurnimator
I think it would be: `foo(.{.bar="foo"})`

1566223520
daurnimator
though there's the "tuple" issue around as well

1566223548
Tetralux
Personally, I think that making someone have to write a struct,

1566223573
Tetralux
I'd rather it was done more ergonomically than that.

1566223585
daurnimator
Tetralux: structs can be anonymous...

1566223614
fengb
Overloading trashes a lot of internals, like C++ mangled symbols

1566223633
daurnimator
which means you could declare like: `fn foo(kwargs: struct{bar: i32, qux: u32 = 42}) void { .... `

1566223645
Tetralux
Indeed, `fn f(x: i32, opts: ?struct{ y: i32 = 47 })` is...... well no that's kinda terrible now that I look at it.

1566223661
Tetralux
(Note the ?)

1566223675
samtebbs
+1 for default values as an alternative to overloading

1566223695
samtebbs
Codegen for it should be simple enough too

1566223700
fengb
But default values is just another name for overloading. Unless there's something super magical you can do with function pointers to make it sane

1566223706
daurnimator
hell I even overload in C with some regularity....

1566223716
samtebbs
daurnimator: u wot

1566223729
Tetralux
I use fn overloading often in any language that has it.

1566223746
daurnimator
samtebbs: the C preprocessor is..... "fun"

1566223761
mq32
hmm

1566223774
mq32
i don't think default values will fit the zen of zig, sadly :(

1566223780
Tetralux


1566223790
samtebbs
daurnimator: Oh I remember seeing a stackoverflow answer about macros with variable number of parameters :D

1566223795
samtebbs
Looked ery "fun" indeed

1566223812
Tetralux
Sometimes I feel like I should be a dentist.

1566223812
samtebbs
mq32: How come?

1566223823
Tetralux
"I feel like I'm pulling teeth, so often."

1566223830
mq32
when having a struct with default values is available, we already have a way (although not obvious)

1566223904
fengb
default value structs also sidesteps the function pointer problem

1566223906
daurnimator
samtebbs: essentially: `#define NARG_(_15, _14, _13, _12, _11, _10, _9, _8, _7, _6, _5, _4, _3, _2, _1, N, ...) N` `#define NARG(...) NARG_(__VA_ARGS__, 15, 14, 13, 12, 11, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1, 0)` `#define PASTE(a, b) a ## b` `#define XPASTE(a, b) PASTE(a, b)` `#define my_func(...) XPASTE(my_func, NARG(__VA_ARGS__))(__VA_ARGS__)`

1566223918
mq32
fengb, yeah

1566223939
mq32
brainfart: @callWithArgs(function, MyArgStruct { .x = 10, .y = 20 });

1566223949
Tetralux
ó.ó

1566223964
mq32
with anonymous structs this would allow "named args" and it would be useful for other stuff, too (storing arg lists and such)

1566223993
daurnimator
samtebbs: i.e. the macro dispatches to the function for the relevant number of arguments: `myfunc(x)` is forwarded to `myfunc1(x)`; `myfunc(x,y)` is forwarded to `myfunc2(x,y)`; etc.

1566224015
fengb
daurnimator: you can do that type of overloading with comptime too :P

1566224036
samtebbs
mq32: But using anonymouse structs feels like it's too obfuscated to be in the same category as parameter default values

1566224051
daurnimator
fengb: indeed. you can currently do overloading in zig with varargs. but "they'll be removed soon"

1566224061
fengb
Oh right

1566224067
fengb
So tuples

1566224079
daurnimator
except that tuples don't exist yet

1566224093
mq32
samtebbs: i don't like anoynmous structs anyways. but i try to work my way with stuff that already exists or is accepted (and i think they are accepted already)

1566224094
daurnimator
so.... we're just left waiting to see what we get :p

1566224105
fengb
samtebbs: we're trying to avoid polluting Zig semantics. Default values have a lot of technical challenges that you need to work around at a low level

1566224203
fengb
That may be solvable with closures / fat function pointers... but then I'm not sure how it'd interop with C

1566224238
daurnimator
fengb: so here might be a good example:

1566224249
samtebbs
fengb: I could be understating it but surely if you have `foo(x); ... ; fn foo(x, y=2){}` then the codegen would just be (subject to abi) `push x; push 2; call foo`

1566224268
samtebbs
I don't see where the technical challenge comes from

1566224269
fengb
Yes, but if you want to pass it in as a function pointer, what would happen?

1566224278
fengb
Would it be fn(x, y)? fn(x)? Are they the same pointer?

1566224282
samtebbs
Ah, damn function pointers

1566224290
fengb
C++ solves it by mangling the names

1566224293
fengb
Which is hideous

1566224321
fengb
If it's a comptime structure, that'd be fine, but we still need to codify the semantics

1566224351
samtebbs
Make a pointer to a function with default values illegal?

1566224378
samtebbs
BEcause it's impossible to know what the default value will be

1566224464
samtebbs
Or if you can specify the default value in the type... `fn foo(x, y=2){}; ... ; func_pointer: fn(u32, u32=2) = ...`

1566224474
samtebbs
No that doesn't work

1566224490
samtebbs
Ignore that :p Only works with comptime known values

1566224532
samtebbs
Making it illegal seems sensible and would still allow default values everywhere else

1566224871
Tetralux
I don't see how passing as a fn ptr changes anything.

1566224886
Tetralux
Statically, the fn always has all it's arguments.

1566224930
Tetralux
The compiler knows that some have defaults, and so allows you to omit them at the callsite.

1566225006
daurnimator
the default values would need to be part of the function type

1566225032
daurnimator
as samtebbs sayss above

1566225045
daurnimator
samtebbs: why did you say that wouldn't work?

1566225080
daurnimator
are you suggesting you'd have non-comptime-known default values? I don't think we'd need that

1566225122
daurnimator
what I'm more curious about would be if we could cast from `fn(u32, u32=2)` to `fn(u32)`. And I think not,

1566225212
andersfr
what editors/IDEs are popular among Zig users?

1566225241
Tetralux
I'd say that you could cast it, just that the Zig compiler would need to understand that a default does need to passed, even if you don't provide on.

1566225243
Tetralux
one*

1566225256
samtebbs
daurnimator: Well my first interpretation of default values was that the caller would push them onto the arguments list, in which case it has to know what the default arguments are and therefore needs to know what function is being called (whereas function pointers are used when you don't know what the function is)

1566225268
Tetralux
You could however implicitly cast fn(i32, i32=4) to fn(i32, i32).

1566225303
samtebbs
However, if the callee puts them on the arguments list/loads them into its registers itself, then the caller doesn't need to know what function is being called and so function pointers with default values could work

1566225324
Tetralux
Seems a promising line of enquiry.

1566225351
andersfr
why don't you just create a struct and use it for arguments? They can have default arguments and everything is nicely named

1566225372
Tetralux
Because you have to pass the struct.

1566225374
Tetralux
For oe.

1566225377
Tetralux
one*

1566225387
samtebbs
andersfr: That sounds inefficient to me

1566225398
Tetralux
And that's another :p

1566225414
samtebbs
You'd have to rely on optimisation to figure out that the whole struct creation process is unnecessary

1566225421
samtebbs
Since it can be expensive

1566225422
andersfr
default values are also passed to the function

1566225424
daurnimator
I don't even mind inefficiencies here

1566225434
mq32
@callWithArgs and @ArgStruct(fnType) { } :P

1566225434
andersfr
doesn't matter if you overwrite the defaults

1566225434
samtebbs
And it's bad on the eye :p

1566225442
daurnimator
the big thing about optional function arguments for me is that APIs evolve over time

1566225457
daurnimator
you'll eventually want to add some extra 'canFoo' argument

1566225474
Tetralux
By that logic though, you'd

1566225487
daurnimator
and you don't want to make a new function fooButWithCanFooArg()

1566225500
Tetralux
Why not just make default args

1566225521
Tetralux
alloc(u8, 32, zeroed=true)

1566225541
Tetralux
fn alloc(comptime T: type, n: usize, zeroed: bool = false) {}

1566225546
samtebbs
Tetralux, daurnimator: Agreed

1566225582
Tetralux
How would the callee know that values were given for one or more of the default args?

1566225593
Tetralux
And so doesn't need to provide its own defaults for them.

1566225601
Tetralux
I guess statically?

1566225632
andersfr
The callee needs to inspect the function definition site to know

1566225643
andersfr
that is why many people dislike the concept

1566225646
samtebbs
Tetralux: Ah, it wouldn't if the callee is expected to set the argument values itself (needed for func pointers) and it wouldn't have to if the caller does it (means func pointers won't work)

1566225728
Tetralux
I'm not sure I quite understand

1566225756
Tetralux
The callee is expected to set them to the defaults (for fn ptrs), but would not have to if the caller provided them.

1566225791
Tetralux
That seems like a contradiction to me.

1566225796
andersfr
The callee cannot set any of its arguments to anything

1566225804
andersfr
it needs all of them provided

1566225827
andersfr
default values are just syntactic sugar for the compiler filling in the arguments that weren't provided

1566225840
samtebbs
andersfr: True, obviously it can't set its own as it would always end up overwriting what was passed

1566225863
samtebbs
andersfr: That didn't cross my mind

1566225923
Tetralux
You could just disallow defaults for fn ptrs.

1566225937
Tetralux
.. but

1566225948
Tetralux
.. still allow people to provide positional, non-default args by name.

1566225978
Tetralux
`fn f(x: i32, y: i32 = 4)` => f(y=9, x=4)

1566225983
Tetralux
And that way

1566225983
samtebbs
Absolutely

1566226004
samtebbs
Better than my suggestion of making them illegal alltogether

1566226015
Tetralux
You can provide a fn(i32, i32=4) to fn(i32, i32) and still provide the default arg by name.

1566226029
Tetralux
can cast*

1566226038
Tetralux
.. in spite of the fn ptr.

1566226057
samtebbs
So only fn(i32, i32=2) => fn(i32, i32) and not fn(i32, i32=2) => fn(i32)

1566226068
Tetralux
That's how Jai does it.

1566226080
Tetralux
IIRC.

1566226097
Tetralux
(In that you can named-arg any argument.)

1566226116
Tetralux
samtebbs: Maybe.

1566226130
samtebbs
+1

1566226146
Tetralux
I'd be nice to be able to cast away the default, but I'm not sure how you'd do it as yet.

1566226173
andersfr
what would you actually use these default args for? particularly for function ptr I cannot come up with a good use case

1566226181
samtebbs
I think it's impossible

1566226199
Tetralux
I showed you one earlier with alloc.

1566226211
Tetralux
alloc(u8, 32, zero=true)

1566226223
samtebbs
Well I find that the need for this kind of thing emerges as you write software, or maybe I'm bad at thinking of examples

1566226239
Tetralux
create(u32) // fn create(comptime T: type, count: usize = 1)

1566226271
Tetralux
Well, the second one you wouldn't have because of alloc(T, n)

1566226275
Tetralux
But you get the drift.

1566226311
andersfr
for alloc and create the memory is actually set to 0xaa and not zero due to runtime safety of undefined values

1566226348
Tetralux
Simply put, it's an easy, ergonomic way of providing extra functionality to your procedure when adding some complicated struct instance that you have to pass instead, would not make sense.

1566226384
Tetralux
andersfr: .. which is something that's bitten me before.

1566226388
samtebbs
Actually the other day I was writing some C++ that would search a list and optionally filter based on a boolean argument. In most cases that boolean agument was false since that was the logical default

1566226400
Tetralux
andersfr: The default arg would document it.

1566226419
Tetralux
Also note that...

1566226429
Tetralux
I hate passing bools to fns like

1566226441
Tetralux
DoAThing(list, stuff, true, true, true)

1566226465
andersfr
bools as arguments is horrible. Always make a meaningful enum

1566226468
Tetralux
I'd rather DoAThing(list, stuff, sort=true, zero=true, rollbackOnFail=true)

1566226513
daurnimator
Tetralux: that's terrible too

1566226516
daurnimator
Tetralux: use enums

1566226527
Tetralux
It's an educational example.

1566226531
andersfr
DoAThing(list, stuff, .Sorted, .Zeroed, .RollBackOnFail)

1566226541
daurnimator
^

1566226550
mq32
DoAThing(list, stuff, .Nah, .Nah, .Nah)

1566226551
mq32
nice :D

1566226551
Tetralux
Part of the reason, is that if you're changing code rapidly, and don't yet know it's final form, I am not gonna want to rewrite enums several times.

1566226559
samtebbs
That's the same though :p

1566226568
samtebbs
enums and bools are the same thing in this issue

1566226568
Tetralux
I'd rather just pass 5 thousand defaulted-bools and then refactor out later.

1566226585
mq32
Tetralux, just introduce implicit conversions! :D

1566226590
mq32
#badDesign

1566226600
Tetralux
And yes, they are something of the same thing.

1566226606
Tetralux
At least here.

1566226668
Tetralux
DoAThing(list, stuff, .Sorted | .Zeroed | .RollbackOnFail) isn't bad... for a final API.

1566226714
fengb
"I'd rather just pass 5 thousand defaulted-bools and then refactor out later."

1566226716
fengb
Famous last words

1566226716
Tetralux
I'd argue however that DoAThing(list, stuff, sort=true, zero=true, rollback=true) is easier to type, just as easy to understand, better at documenting at a glance what the options are, and easier to change rapidly.

1566226746
Tetralux
especially if default values MUST be named-args.

1566226751
Tetralux
(at the callsite)

1566226779
gonz_
Those options could all just be u1s in an option struct, though.

1566226801
Tetralux
And all parses could be streaming parsers.

1566226813
Tetralux
parsers*

1566226842
Tetralux
In this case, a struct would not add anything of value to this.

1566226871
Tetralux
Except maybe memory footprint.

1566226892
Tetralux
But it matters, even for just ONE bool.

1566226908
Tetralux
f(stuff, true) is not as clear as f(stuff, doExtraThing=true)

1566226923
Tetralux
Even that, is a good illustration of the problem.

1566226938
Tetralux
If enums were as easy to infer as errors, then I'd use them instead.

1566226940
Tetralux
But they aren't.

1566226948
andersfr
DoAThing(list, stuff, sort=true, zero=true, rollback=true) would have a higher footprint than DoAThing(list, stuff, struct{ bool, bool, bool })

1566226952
fengb
structs don't add memory footprint. It'd just as efficient as passing multiple args in Zig

1566226994
Tetralux
Great, maybe the compiler could optimize to pass the defaults as one struct then xD

1566227031
andersfr
that would contradict the calling convention

1566227031
Tetralux
Also, would you provide none of them as f(stuff, .{}) ?

1566227043
Tetralux
andersfr: In what way?

1566227065
andersfr
the optimization lies in the fact that the struct is packed into a single register

1566227088
andersfr
multiple arguments cannot be packed without changing the function signature

1566227127
Tetralux
Devil's advocate: They

1566227148
Tetralux
Is it

1566227153
Tetralux
Personally, I wouldn't bother.

1566227169
Tetralux
Just pass them as bytes to the fn - problem solved.

1566227182
andersfr
passing them differently means instantiating multiple versions of the same function

1566227182
Tetralux
Yes, it takes three more bytes of memory.

1566227219
Tetralux
andersfr: No, no. There'd be one. The one with the struct. And when you passed the defaults, they'd be put into the struct on the stack and passed.

1566227228
Tetralux
Either way though.

1566227241
andersfr
parameters on common architectures are passed as full registers or as word-sized stack allocations

1566227289
fengb
I don't think Zig defines an ABI

1566227298
fengb
structs are packed however Zig wants to atm

1566227307
Tetralux
I'm not sure how much speed you would lose for having four bools as bytes versus a struct of them.

1566227317
fengb
Of course, I'm excluding "extern"

1566227322
Tetralux
But my instinct is that mine is actually faster.

1566227325
Tetralux
Because usize.

1566227336
andersfr
transforming the function signature is possible if and only if you have internal linkage and thus fastcall convention

1566227355
andersfr
I don't think however anybody has written a pass for doing that

1566227457
Tetralux
At any rate, I'd call it some unfortunate friction to have to change every usage of the fn to pass the anon struct, if I now suddenly decide to experiment with passing an extra default.

1566227473
Tetralux
Like - I'm just gonna want to make a struct for every fn from the start.

1566227483
Tetralux
Even if it contains no options.

1566227495
Tetralux


1566227505
Tetralux
Only to then maybe change my mind ten minutes later.

1566227515
Tetralux
That friction is not worth it.

1566227571
Tetralux
I didn't mention before of course, but the defaults can be integers etc.

1566227578
Tetralux
So an enum would be enough.

1566227582
Tetralux
would not be*

1566227636
andersfr
using a struct for options is an efficient solution

1566227680
samtebbs
If a struct can be passed as one register, then why can't booleans

1566227684
Tetralux
.. which is anti-exploration.

1566227692
andersfr
booleans can indeed

1566227702
andersfr
they just take up an entire register for 1 bit of use

1566227714
samtebbs
Not if you pack them

1566227718
andersfr
structs can have multiple fields within the register width

1566227731
andersfr
packing bools means putting them in a struct

1566227753
Tetralux
This just sounds like an optimization.

1566227753
andersfr
afk

1566227753
samtebbs
Well internally yeah ;p That's not what the programmer sees though

1566227769
Tetralux
Surely Zig could pass all default values as one struct.

1566227776
Tetralux
In exactly the way you are describing.

1566227790
fengb
So default values are a sugar for struct?

1566227794
companion_cube
sounds like enums are better for readability?

1566227823
Tetralux
They are not sugar.

1566227833
Tetralux
It is an implentation detail and an optimization.

1566227842
Tetralux
But one that Zig could reliably do.

1566227875
samtebbs
companion_cube: Possibly, that would be up to the API implementer. They can choose to use default values or not

1566227900
Tetralux
But not doing so would make it harder to explore with what the best API is.

1566227919
Tetralux
Because you'd have to change the usage of it if you went back and forth it needing/wanting options.

1566227927
Tetralux
With default args, that would not be the case.

1566227937
Tetralux
AND

1566227944
Tetralux
If they get optimized to a struct...

1566227959
Tetralux
Then you get the same thing, but without breaking and with easier exploration.

1566227990
Tetralux
I value my time writing code - I do not want it wasted too much by things like this. xD

1566227998
Tetralux
(As I'm sure you all do too.)

1566228016
andersfr
I do understand your motivation

1566228019
samtebbs
(thumbs up in agreeance)

1566228025
samtebbs
agreement*

1566228028
companion_cube
what I'm curious about, personnally, is the interaction of generics and lack of RAII

1566228031
Tetralux
Yes, Zig values reading over writing - but I'd humbly suggest that we don't be hardlined about it.

1566228053
Tetralux
.. and a few other things too, at that.

1566228072
andersfr
currently I'm working on the LSP project which fixes a lot that friction

1566228073
Tetralux
And in this case especially, I'd argue that it doesn't even hurt reading code that much, if at all.

1566228080
Tetralux
Oh?

1566228082
Tetralux
Whatcha got?

1566228084
companion_cube
andersfr: ♥ that sounds amazing

1566228090
andersfr
it will provide introspection and auto completion

1566228096
andersfr
and refactoring arguments for you

1566228110
companion_cube
you have opportunities to do unusual things too, with Zig, andersfr

1566228117
companion_cube
like, possibly, show comptime values on hover

1566228129
Tetralux
So long as it's fast and doesn't stutter ;3

1566228138
andersfr


1566228141
Tetralux
The very idea of using a socket rather than shared memory scares me.

1566228169
andersfr
it is still in early stages

1566228171
Tetralux
Just the sheer amount of speed you'd lose.

1566228173
companion_cube
sockets are pretty fast these days

1566228196
gonz_
18:19:51 <Tetralux> I value my time writing code - I do not want it wasted too much by things like this. xD

1566228201
gonz_
I don't value your time writing code :D

1566228222
Tetralux
gonz_: You don't value your time exploring the best way to write your code?

1566228227
Tetralux
Because I do ;)

1566228241
gonz_
Jokes aside, though, I don't really care about people's unwillingness to write code when there are clear ways to write it with already existing facilities.

1566228269
Tetralux
Calling it "unwillingness" is misleading.

1566228271
samtebbs
gonz_: With that attitude we'd still be writing assembly 24/7 ;)

1566228277
Tetralux
+1

1566228282
gonz_
If an issue amounts to "I don't want to write 10 lines instead of these 2 with a new construct" I think it should generally be tossed

1566228284
andersfr
I think a lot of the issues arises from lack of tooling

1566228311
Tetralux
If friction is built into a language, I'd consider it ripe for looking it.

1566228317
Tetralux
This is my argument with C++.

1566228324
Tetralux
.. along with a few other things.

1566228330
gonz_
C++ has tons of niceties to turn 10 lines into 2

1566228333
companion_cube
and with C ;)

1566228342
Tetralux
You know the headaches of header files and having to update the signature in both places.

1566228366
Tetralux
I would not call them niceities, personally xD

1566228410
Tetralux
andersfr: Feature request: An easy way to type `while (cond) : (expr) {}` without having to type all the brackets.

1566228428
Tetralux
.. in a way where I don't have to press tab every time.

1566228442
andersfr
that is more of a snippet issue with your editor of choice

1566228454
Tetralux
I thought you might say that.

1566228465
andersfr
but it can actually be done with LSP

1566228467
Tetralux
Snippets do not seems good enough for that.

1566228479
Tetralux
I'd rather something better at the job.

1566228482
gonz_
This is pretty much the exact use-case for snippets

1566228506
Tetralux
It's also a good usecase for not having to put parens around everything. ;)

1566228537
andersfr
the parens are actually very necessary to not make the parser impossible to implement

1566228537
Tetralux
I use Sublime Text because it doesn't try to be that smart.

1566228546
companion_cube
meh, what's the cost of writing a bit more {} if it saves you from ambiguity…

1566228547
Tetralux
But typing the parens interrupts my flow of typing quite badly.

1566228567
fengb
#define begin (

1566228591
Tetralux
andersfr: Not true. Jai and Odin both omit them.

1566228604
Tetralux
"Impossible" is a strong word.

1566228608
Tetralux
Don't use it liberally ;)

1566228630
samtebbs
A lion does not concern itself with the opinion of sheep

1566228643
samtebbs
(the sheep being Jai/Odin)

1566228644
gonz_
Maybe this highlights the core of what we talked about before. Small conveniences aren't worth certain changes.

1566228665
andersfr
if you knew the amounts of hacks were required to make zig parseable with current syntax you would understand the use of strong words

1566228668
gonz_
And maybe convenience should not be the overriding value  at all.

1566228686
Tetralux
samtebbs: My reaction to statements like that is, without exception, one of automatic caution.

1566228697
Tetralux
Much like "impossible", funnily enough.

1566228710
companion_cube
jsut use rust-like syntax already… :-°

1566228714
gonz_
I've said it before and it bears repeating: It would be very good to have an actual outright statement of Zig's values, preferably ranked from most important to least.

1566228715
samtebbs
I just wanted to use the quote

1566228730
companion_cube
isn't there a zig zen already?

1566228732
Tetralux
samtebbs:

1566228744
Tetralux
samtebbs: A noble goal.

1566228766
gonz_
companion_cube: There is and it has good points, but if nothing else it should be more front and center.

1566228799
Tetralux
andersfr: Does that not imply that there might be an easier way to parse it?

1566228821
andersfr
if you are willing to sacrifice speed and memory there is

1566228838
samtebbs
In the end, conveniences and nice things like default values make Zig more attractive to the modern programmer, and our goal should be to dominate the world

1566228841
gonz_
An actual statement that "Your convenience does not matter as much as the convenience of readers of code" would do wonders to dispel a lot of enthusiasm for over-engineered feature requests meant to only save people lines of code.

1566228851
Tetralux
I'd like to point out, Jai parses 125,000 LOC in <20 ms.

1566228872
fengb
Zig is not Jai

1566228872
gonz_
Jai doesn't exist outside of 4 people's computers

1566228882
andersfr
the language spec as written implies is only parseable with a PEG engine (which zig is not actually)

1566228900
fengb
I thought Zig had a PEG

1566228914
Tetralux
fengb, gonz_: Both well-intentioned responses. But, with respect, slightly narrow minded to reality IMHO.

1566228943
andersfr
the actual compiler is not implemented as a proper PEG

1566228958
Tetralux
At minimum, there's much more nuance to it than that.

1566228961
fengb
Oh

1566228969
gonz_
Tetralux: As in too aligned with  reality? Jai has an install base of 4 people.

1566229005
Tetralux
gonz_: Not related to parsing speed though, eh?

1566229027
fengb
We don't know what Jai is doing so saying it's faster doesn't really help

1566229029
gonz_
There are research paper programs that have run on several times the amount of computers as Jai.

1566229070
Tetralux
fengb: It's a basic, entire-source-in-memory, parser.

1566229076
Tetralux
It's not streaming.

1566229080
Tetralux
It's just scanning.

1566229091
Tetralux
It tokenizes and then it parses the token sequence.

1566229103
Tetralux
I know because I've watched many of the streams where he's worked on it.

1566229127
Tetralux
I don't know what the best word for it would be.

1566229127
gonz_
Until there is actual code to look at it just doesn't matter at all.

1566229130
fengb
Then feel free to recreate it and submit the PR

1566229131
Tetralux
Maybe recursive?

1566229157
Tetralux
If I was familiar with how the structures are assembled by the parser, I might :p

1566229161
fengb
I'm sure there's a lot of good going into Jai. But we can't borrow much based on vague video-based semantics

1566229185
Tetralux
gonz_: I respect why you feel like that. I disagree.

1566229201
samtebbs
It's not related to Zig but does anyone know why he hasn't open sourced it?

1566229206
companion_cube
jai is just in the middle of the {zig…V} spectrum :p

1566229215
samtebbs
^

1566229231
gonz_
companion_cube: It's much more like V than that; you're being a bit too nice.

1566229235
fengb
My guess is that Jon Blow is a game dev and does game dev based stuff

1566229245
Tetralux
samtebbs: He doesn't want to be bogged down by other people's suggestions. As much as he'd appreciate them.

1566229250
fengb
Like not releasing stuff until "it's done"

1566229251
companion_cube
well, I trust Blow more for writing good actual code, than the V guy

1566229254
Tetralux
It's important to him that his vision for the language stays true.

1566229269
Tetralux
He also doesn't want people to start trying it and having to contend with compiler bugs.

1566229283
Tetralux
Because that makes people just say "Oh I'll come back later when its ready"

1566229283
companion_cube
I follow something called Lean (a proof assistant) and its 4th iteration is a bit like that: they develop it internally to not have to argue about every single little detail

1566229286
THFKA4
i don't think the syntax is even set in stone

1566229291
companion_cube
and it's developped by extremely good people

1566229292
Tetralux
He wants people to be able to rely on it like C, from the start.

1566229299
samtebbs
I see. I disagree but understand

1566229300
fengb
Blow has some really good ideas

1566229308
fengb
I just wish he was more open about it

1566229333
samtebbs
Tbf Ritchie must not have realsed C or Unix before it was "done"

1566229337
gonz_
companion_cube: I do too, but it's safe to say he didn't know what he was getting himself in to from the beginning. You can plainly hear it in the first videos, he had no clue.

1566229340
fengb
It's funny how some parts of Zig and Jai actually converged despite the original design differences

1566229343
Tetralux
fengb: He is a game dev yeah.

1566229379
fengb
Which I kinda feel like wasted work... and I really wish we could collaborate on these topics

1566229410
Tetralux
fengb: He answered a chat question about this once by saying that serious programmers do not have the time to be bothered with languages that aren't finished yet. And he wants the language to have a good shot.

1566229425
fengb
That doesn't make sense

1566229431
fengb
Serious programmers tinker in random crap all the tmie

1566229446
companion_cube
it's very hard to develop a useful language, and I'm super impressed by andrewrk on the process for Zig

1566229448
Tetralux
In the games industry, you release a game and if people lose interest, that's it.

1566229449
companion_cube
it's the high road

1566229454
Tetralux
So you have one shot.

1566229458
Tetralux
Better make it good.

1566229463
fengb
Yeah I agree with "game dev"

1566229498
kristoff_it
Jonathan Blow has his own way of approaching this stuff, he's keeping it closed mainly because of that. I think it's reasonable to trust Jai more than V, that said, I've been watching a few recent streams and it seems a bit behind Zig in some aspects.

1566229511
kristoff_it
The last stream on macros was very interesting

1566229522
samtebbs
How long has it been in dev for?

1566229530
gonz_
Tetralux: Many times you have a lot more shots than one, even to ridiculous degrees. The entire history of Crytek is a testament to that.

1566229534
samtebbs
Zig has for AFAIK 3 years now

1566229534
companion_cube
I mean, you can't trust V at all

1566229545
fengb
Jai's been in the works for 5? years

1566229561
Tetralux
I should note that another motivation for him is that he doesn't want it to fall victim to embrace-extend-extinguish.

1566229583
halosghost
fengb: maybe

1566229589
halosghost
fengb: there's no public release of it at all

1566229601
halosghost
afaiac, until something is actually released, it's purely vaporware

1566229601
fengb
Blow's original video is 5 years old. I dunno when he actually started real work

1566229604
fengb
rant video*

1566229605
Tetralux
Which is one of the ways he's answered the question of "are you gonna open source it?" -> "Yes, but maybe not immediately upon public release."

1566229622
halosghost
yeah

1566229630
halosghost
like I said, till it's released, I'll consider it not-a-thing

1566229637
Tetralux
I should also note

1566229648
Tetralux
It took his company 5 years or more to make the Witness.

1566229655
Tetralux
Slow is his way of doing things.

1566229660
halosghost
that doesn't bother me

1566229665
Tetralux
And he doesn't exactly type quickly.

1566229668
kristoff_it
halosghost: that's a safe way of looking at the issue. not always right though.

1566229685
Tetralux
kristoff_it: +2.

1566229696
halosghost
kristoff_it: there were rumors of an Old Navy coming to my hometown since I was born

1566229697
companion_cube
typing quickly is overrated :D

1566229700
gonz_
kristoff_it: For practical purposes it's exactly right. For speculative purposes it's not.

1566229703
kristoff_it
I think the chance of Jai being a new V is very, very low

1566229705
halosghost
it finally happened when I was 18

1566229709
halosghost
I'll believe it when it happens

1566229752
halosghost
I can't code against it; I cannot prototype with it; I cannot see what it's like to use for anything significant, or even trivial for that matter

1566229757
halosghost
till I can, it's not a thing

1566229770
Tetralux
gonz_: > many times you have more shots; Your actions will color you. So which ones you make are important. Especially the first one. Though, I do take your point.

1566229778
fengb
I'm always impressed to hear Andrew type. He sounds like he's going 400 wpm

1566229842
gonz_
Tetralux: The fact that Crytek is still in business is empirical proof that making garbage several times over doesn't stop you at all. It's a nice thought that "your actions will color you" but it just doesn't match reality a lot of the time.

1566229875
Tetralux
gonz_: I mean it'll color people's perception of you. Like RAD game tools.

1566229880
gonz_
And that's just one of the examples of game studios that would love the mythology that if you're still here, you're a success. The truth is that the games business isn't at all as hard as they'd have you believe.

1566229883
Tetralux
Everyone knows RAD does quality stuff.

1566229886
companion_cube
I'd also point out that several good indie games have used the open alpha model with success

1566229899
fengb
No Man's Sky? :P

1566229902
companion_cube
Rimworld, nuclear throne, prison architect, at least (citing those I know of)

1566229960
samtebbs
Minecraft

1566229962
mq32
companion_cube: Minecraft, Factorio are probably also good examples

1566229969
samtebbs
^

1566229977
mq32
and Wube/Factorio may be the best Example on

1566229984
kristoff_it
I think this whole discussion is missing the point that jblow seems to be a person that has strong opinions over stuff and that doesn't like interacting with other developers as other more agreeable/extroverted people would.

1566229997
gonz_
Tetralux: And yet people bought CryEngine for a long time and probably still do. The positive case ("These people do quality stuff, we like them") is probably true, but the negative case isn't as big a thing as people think.

1566229998
Tetralux
Likewise ;)

1566230025
gonz_
You can be a total loser in game development and still make it big and you can continue to be a loser and still have your studio survive.

1566230045
kristoff_it
When you opensource something you get a ton of attention and people start opening issues etc. And then you have to reply with care. I think it's understandable, given what I can tell from his public content, that he doesn't want to go public too early, regardless of what the best strategy would be.

1566230050
companion_cube
ah yes, factorio!!

1566230065
Tetralux
gonz_: Indeed. I take your point. But Blow thinks the software industry is atrocious and believes he knows the many ways it can be better - so maybe it's partly a "be an example" thing - albeit by accident or not.

1566230071
halosghost
kristoff_it: that's fine

1566230086
halosghost
kristoff_it: but till he does, what he develops with it matters very little to my life in development

1566230094
companion_cube
iirc he also really dislikes anything academic, right?

1566230096
Tetralux
gonz_: I belive he wants it to be known because it was great from the start. Not because it's good _now_.

1566230121
halosghost
since, again, there's no part of it I can leverage (unless I intend to make my own language, which I do want to do; and in that case, the production value is actually in his videos for thoughts on implementation, not any language he makes)

1566230132
gonz_
Tetralux: Probably. I just wanted to temper the idea that game development is this harsh business that only the good/strong survive.

1566230156
gonz_
I used to think it was the case and then I worked at Crytek

1566230168
Tetralux
I suspect, in part, more by luck than judgment - though there is definitely some judgment you can leverage there.

1566230181
Tetralux
How much is hard to judge.

1566230226
fengb
I love all of Blow's ideas, but I feel like the closedness has hurt some parts of the design

1566230281
mq32
fengb: it's nice to see that open business strategies (like open source, using common/open protocols, ...) doesn't hurt business structures

1566230288
mq32
would love to see that more

1566230322
mq32
software companies do it more nowadays, but hardware companies are like "i would prevent that you even know what this single pin on this chip does"

1566230359
fengb
e.g. he went down ctors/dtors for a rather extended time before removing it. It's understandable, but also feels like the time could have been better spent

1566230386
kristoff_it
fengb: I think so too, but the human factor is real, it could end up way worse the other way.

1566230425
Tetralux
He's trying to determine how to do things based on trying what he can think of, finding its shortcomings, and changing it to be better.

1566230437
Tetralux
"Distilling the good parts", as it were.

1566230450
fengb
I'm not doubting he's doing his best, but it also means treading down the beaten path

1566230458
fengb
Maybe he can solve it in a better way

1566230460
Tetralux
This is part of why it's so important to me that exploratative programming should be pretty easy.

1566230489
Tetralux
fengb: Maybe you should join one of his streams and suggest your better idea then :3

1566230513
Tetralux
If he sees what you address to him, and it's a good thought, he will take it seriously.

1566230523
Tetralux
Someone did that just the other day with his macros demo.

1566230599
fengb
Not talking about me

1566230649
fengb
It also doesn't help that he kinda went into a hole for about a year so I have no idea what's going on anymore

1566232654
Tetralux
He's been doing bug fixes and cleanups for a year

1566232667
Tetralux
Now he's back to adding the last two compiler features.

1566232677
Tetralux
(One of which was macros, the other is modules-proper.)

1566232687
Tetralux
Then presumably optimization.

1566232900
Tetralux
Is it possible to declare the type of a struct field by switching on another field's value?

1566232924
Tetralux
It says the field is not declared.

1566233159
bgiannan


1566233169
bgiannan
^ why is it complaining that install doesn't exist ?

1566233263
THFKA4
old compiler?

1566233309
bgiannan
ah right 0.4.0 on this machine

1566237785
Tetralux
Are you meant to be able to declare a variable `comptime T: ?type = null` ?

1566239658
Tetralux
How do you check if a `x: var` is a slice?

1566240252
Sahnvour
std.meta.trait.isSlice(@typeOf(x)) ?

1566240295
Tetralux
I also need to know if it's []const u8, or []u8 though.

1566240708
Sahnvour
there may be a trait to check the constness of the child type

1566241354
andrewrk
vim is slow after suspending and resuming my laptop, and it's driving me nuts. no idea what's causing it

1566241495
FireFox317
only vim or your whole system andrewrk?

1566241632
andrewrk
the only time I notice it is when I use vim to open a large file and scroll around

1566241636
andrewrk
everything else seems fine

1566241735
lunamn
is there any news regarding zig and glibc 2.90?

1566241786
andrewrk
lunamn, you mean 2.30?

1566241818
FireFox317
You could try this out, maybe it is a plugin in Vim that is causing the slow down.

1566241833
lunamn
andrewrk, yeah, typo'd there

1566241949
andrewrk
FireFox317, the culprit is <SNR>33_Highlight_Matching_Pair()

1566242049
FireFox317
Disabling that plugin and the issue is gone? Then you are sure that that is the plugin that is causing the slow down.

1566242088
andrewrk
I think that's just syntax highlighting

1566242110
andrewrk
but yes I can confirm that `:setf text` is fixing it

1566242119
andrewrk
well that does narrow down the problem. I'll take this to #vim. thanks

1566242189
FireFox317
Maybe something in the config of the zig syntax highlighting is causing it, but i'm sure they can help you better in #zig

1566242199
andrewrk
this is c++ syntax highligthing

1566242222
FireFox317
oh ^^

1566242275
andrewrk
I'll just turn it off. I'd rather type fast and scroll around fast than see color

1566242285
FireFox317
#vim i mean ofcourse

1566242415
bgiannan
is there any reason i don't see anything i'm printing on stdout or stderr?

1566242438
andrewrk
ok I figured it out. it's the new regex engine in the new version of vim. :set re=1 fixes it for me.

1566242904
FireFox317
Pretty weird that it only happens after the suspend tho

1566243064
andrewrk
lunamn,

1566243068
andrewrk
I'll do this before 0.5.0 is released

1566243152
lunamn
thank you!

1566243200
FireFox317
bgiannan, are you using `std.debug.warn("foo")` ?

1566243218
bgiannan
yes

1566243231
bgiannan
and tried

1566243325
FireFox317
What OS are you using?

1566243370
bgiannan
linux

1566243489
andrewrk
what happens when you run it with strace

1566243514
FireFox317
I can't think of another issue than that something is wrong with the terminal

1566243649
bgiannan
i'll tell you once i got it compiling again

1566243858
andrewrk
hello world isn't compiling?

1566243882
bgiannan
no it's not the hello world

1566243894
bgiannan
i only meant i was using the same functions described in it to print on stdout

1566244084
andrewrk
strace will probably have a story to tell

1566244350
gonz_
bgiannan: Do you have a stray `@breakpoint()` anywhere?

1566244526
FireFox317
You could show us the code through something like pastebin

1566244581
gonz_
I ask mostly because zig builds with breakpoints just fine and the program will just seemingly not do anything at all when you run it.

1566244637
gonz_
Luckily  `zig build run` fails in the same scenario, but unfortunately not with any kind of indication of what's wrong.

1566244765
andrewrk
the information is available. that message could be improved

1566245000
gonz_
Obviously I'm suggesting this as a possible culprit for "I get no output and I'm super confused" because of previous experience, by the way. :D

1566245006
gonz_
Sometimes it's the small things.

1566248596
dingenskirchen
Hey. I've only (very, very) recently started looking at zig, so I have next to no clue what I'm doing.

1566248596
dingenskirchen
With that in mind, I wanted to test the C interop using libcurl:

1566248596
dingenskirchen
It works perfectly fine, but in l.11 I needed an IMO rather ugly call to @intToEnum, because just using c.CURLOPT_URL resulted in a type mismatch compile error.

1566248596
dingenskirchen
Is that intentional or am I doing it wrong?

1566249779
andrewrk
dingenskirchen, zig's rules about enum types are slightly stricter, not letting one implicitly cast an integer to an enum value. it makes me wonder, though, why didn't they make CURLOPT_URL an enum type in their API?

1566249809
andrewrk
I think there is an optional warning that some compilers have that this is equivalent to.

1566251026
dingenskirchen
m( I attempted to use CURLOPT_URL as a constant instead of the enum member CURLoption.CURLOPT_URL

1566251040
dingenskirchen
using the latter works without any casts

1566251125
andrewrk
I believe you would also be able to pass `.CURLOPT_URL` (an enum literal)

1566251197
dingenskirchen
that works too, great ^^

1566254719
ntgg
zig fmt is saying that the 1:1 in my file is an invaild byte

1566254723
ntgg
why would this be

1566255254
mikdusan
ntgg: BOM on file?

1566256099
ntgg
mikdusan: I don't believe so

1566256270
ntgg
mikdusan: zig build seems to ignore whatever is causing the problem

1566256923
mikdusan
shrugs. hexdump the first 8 bytes

1566257975
daurnimator
ntgg: shebang?

