1572912187
data-man
andrewrk Now I am testing Zig grammar.y, it is slightly incorrect. PR is welcomed? :)

1572912249
andrewrk
data-man, yes

1572912441
data-man
Just an idea: online check sources via PEGJS. What you think?

1572912820
andrewrk
I think I will be ok to let things break occasionally until the language has stabilized

1572914181
data-man
Why is there no loop with post-condition in Zig? Something like repeat/until (e.g. Lua, Pascal) or do/while (e.g. C, D). It's very useful in many cases.

1572914222
scientes
data-man, that was rejected

1572914232
scientes
its easy to implement to

1572914256
scientes
the only thing that really ticks people is that you have to declare your loop index in the outside scope

1572914263
data-man
Please revote for this! :)

1572914271
scientes
meh, its not a big deal

1572914280
scientes
the loop index is the only thing that is kinda annoying

1572914351
data-man
Is there no special optimization for do/while in LLVM?

1572914364
andrewrk
correct, there is none

1572914395
scientes
and hardware loops are generated by an optimization pass

1572914419
scientes
data-man, so there is, the PPC pass, that has been generalized into the PPC+ARM-M hardware loop pass

1572914441
Snektron
scientes: you have to declare that outside the loop anyway in zig

1572914472
scientes
data-man, this talk, the video should be up soonish

1572914485
scientes
but llvm-9 has the codegen

1572914650
data-man
Yet another proposal: LLVM has builtin llvm.readcyclecounter. Would be nice to have it in Zig, especially for benchmarking. I tried to implement this but still not well studied the source code of the compiler.

1572914746
data-man
scientes thanks!

1572914757
andrewrk
data-man, this is a good proposal - can you open an issue with this?

1572914774
data-man
Sure.

1572914885
scientes
there is also talk about coverting all recursive calls in llvm to loops

1572914942
scientes
*most

1572914973
andrewrk
it will still look close enough to recursion though

1572914994
scientes
yeah but it generalizes the optimzations

1572914997
andrewrk
have a look at this fun thing:

1572915003
scientes
and compilers are all about normalization

1572915025
andrewrk
specifically fact-await.zig - there is an example of recursion that will always be allowed

1572915065
scientes
this was brought up at the dev mtg in a round-table, and basically someone knows all the issues, but doesn't have time to implement it

1572915113
andrewrk
what are you talking about scientes? recursion?

1572915121
scientes
yes

1572915125
scientes
lowering recursion into loops

1572915159
andrewrk
ah. unfortunately zig will not be able to take advantage of any such feature

1572915162
data-man
Also would be nice to have builtin prefetch. I'm not sure about the proposed syntax yet. :)

1572915226
scientes
just means you write an alloca() in your loop, which is generally frowned upon :)

1572915265
andrewrk
scientes, well if you can tail recurse, zig will allow this

1572915268
scientes
anyways, i should read the proposal

1572915278
andrewrk
otherwise you need a heap allocation to avoid unbounded stack growth

1572915847
data-man


1572915857
andrewrk
thank you data-man

1572915974
frmdstryr
@andrewrk is the code from your chat demo in a repo somewhere?

1572915993
andrewrk
dimenus, extern struct will be a good workaround for you until #3133 is done. the memory layout of extern structs is well defined, and it's the same as C ABI

1572916084
andrewrk
frmdstryr, I'll make a gist for you. here:

1572916099
frmdstryr
Thanks!

1572916354
andrewrk
scientes, after a discussion in #llvm I'm convinced that we should move forward, for now, with my strategy of vector array element pointers. the one that has metadata in the type, and does not assume any memory layout of vectors

1572916376
andrewrk
I'm pretty sure this is compatible with all your test cases anyway

1572916570
scientes
not adding 1

1572916575
scientes
doing pointer arithmatic

1572916587
scientes
I had a talk with jdoeffert in #llvm about this

1572916593
scientes
and he said use GEP

1572916695
andrewrk
tomorrow, end of day, #3580 will be closed and #3575 will be closed, and dimenus's examples will work (except for vector literals which is not happening, see #208)

1572916737
andrewrk
and we can move on with the rest of simd

1572916741
scientes
yeah I don't really care about vector literals

1572916761
scientes
it was just brought up in a bug and I didn't care

1572916993
scientes
ok my patch no longer allows vector literals

1572916996
scientes
*PR

1572917466
dimenus
yeah i didn't need literals, i just did it on accident

1572917468
dimenus
and noticed it segfaulted

1572917632
dimenus
andrewrk & scientes: was there a final decision on indexing vectors then?

1572917713
scientes
if I had some good example code on using ResultLoc I could finish a patch on the way I want to do it, and demonstrate that it works

1572917790
dimenus
i can't grok it yet, need to spend more time digging in the compiler

1572917960
scientes
ahhh crlf is causing me grief

1572917972
scientes
as the softfloat library has crlf, and now git is trying to be too smart

1572918123
andrewrk
dimenus, yes, it generally works just fine, but the pointer type is not simple. have a look at the test cases in my PR

1572918234
andrewrk
dimenus, your second test case does not yet pass in my PR, but I will make it work

1572918360
dimenus
that one at least makes intuitive sense to me, it would be consistent with `var foo: @Vector(4, f32) = [_]f32 { 1, 2, 3, 4 }`

1572918399
andrewrk
yes it is supposed to work

1572918592
scientes
oh, so you DO want vector literals?

1572918594
scientes
I am confused

1572918797
dimenus
scientes: no i think he's referring to the second test i posted on your PR (which is the same one you posted on his PR)

1572918808
scientes
except that i tested the value

1572918812
scientes
i got your version working

1572918816
scientes
it just isn't setting anything

1572918835
scientes
cause it needs a ResultLoc to know what to set

1572922887
data-man
scientes

1572922936
scientes
prefetch is rarely useful

1572922942
scientes
on modern processors

1572922947
scientes
I don't really see the point

1572923004
scientes
basically, it is useless on OOO processors

1572923011
scientes
it is only useful on in-order processors

1572923107
data-man


1572923321
scientes
is there a blog post?

1572923488
scientes
data-man, you did see my @expect PR right?

1572923650
data-man
Sure I saw.

1572923706
data-man


1572923940
scientes
wow, considerable difference

1572923945
scientes
even on an OOO processor

1572923983
data-man
Yet another example

1572924064
scientes
a write prefetch is bizaare

1572924137
pixelherodev
That -

1572924140
pixelherodev
What does that even mean?

1572924144
pixelherodev
What's a write prefetch?

1572924160
scientes


1572924166
scientes
>  rw is the specifier determining if the fetch should be for a read (0) or write (1)

1572924173
pixelherodev
...okay but

1572924177
pixelherodev


1572924178
scientes
you tell the CPU where you are writing

1572924187
pixelherodev
How can it prefetch that though?

1572924190
pixelherodev
That makes no sense

1572924203
scientes


1572924227
pixelherodev
Wait, so it fetches the data that will be written?

1572924243
scientes
well, that is what it does on intel

1572924289
pixelherodev
... okay that actually makes some sense but for one point

1572924291
pixelherodev
Why is it needed?

1572924303
pixelherodev
Isn't that semantically identical to a read prefetch of that data?

1572924312
pixelherodev
Why add a second opcode when one would suffice

1572924313
pixelherodev
?

1572924332
scientes
that is done all the time

1572924341
scientes
to encode additional meaning

1572924355
scientes
for forwards compatibility

1572924359
pixelherodev
Just seems wasteful to me

1572924388
pixelherodev
Then again, I like tinkering with 8-bit CPUs, so I definitely have a skewed perspective :P

1572924393
scientes
pixelherodev, i think you are a waste of a ipv4 address /sarcasm

1572924479
pixelherodev
My pedantic side feels like pointing out that I'm not an ipv4 address ;)

1572924510
scientes
yeah but you are connected to freenode via one

1572924558
pixelherodev
Yes, but

1572924564
pixelherodev
Maybe the waste of a TCP connection

1572924577
pixelherodev
Or, rather, my connection would be a waste

1572924618
scientes
yeah but its znc

1572924632
scientes
and you rent that service that uses the ipv4 address

1572924639
scientes
so if you were kicked off the net you wouldn't use it

1572924644
scientes
anyways.....

1572924674
scientes
its like saying someone isn't worth the bullet it would be required to shoot them

1572924718
pixelherodev
That reminds me of the thieves who shot $50 of ammo into the ceiling to intimidate the cashier when there was only $20 in the register :)

1572924719
pixelherodev
On a more Zig-related topic: how difficult would a Zig to C translation layer be?

1572924766
pixelherodev
A lot of things map 1:1, but advanced stuff like async/await could theoretically map to e.g. pthreads

1572924769
scientes
pixelherodev, we already have that

1572924771
scientes
zig translate-c

1572924779
pixelherodev
... that's C->Zig

1572924780
scientes
ooooh

1572924782
pixelherodev
I'm talking the opposite

1572924788
scientes
pixelherodev, there is a llvm-to-c translator

1572924792
scientes
so there is no motivation

1572924794
pixelherodev
Also, isn't translate-c header-only?

1572924797
pixelherodev
scientes, no there isn't.

1572924799
pixelherodev
It's defunct.

1572924820
pixelherodev
And the modern "upgraded" version apparently outputs awful code from what I've heard

1572924823
scientes
well, I don't see the reason

1572924833
scientes
llvm is quite portable

1572924842
pixelherodev
Yes, but C is even more so

1572924848
scientes
yeah but its lower quality

1572924849
pixelherodev
e.g. SDCC can produce code for a bunch of small targets

1572924859
pixelherodev
Sure, but as effectively a compiler backend it doesn't matter

1572924866
pixelherodev
It's basically an intermediate format like LLVM IR normally is

1572924866
scientes
yeah but if you are transpiling you are going to get bloated code

1572924870
scientes
that won't run on such targets

1572924892
pixelherodev
I don't think it would have to be

1572924901
pixelherodev
Not if it was Zig->C with no intermediate layer like LLVM

1572924906
scientes
and people don't really write c89 these days anyways

1572924916
pixelherodev
I know, I typically use C99

1572924922
scientes
so again, its just not worth the effort

1572924931
scientes
the path of least resistance is to port llvm

1572924939
pixelherodev
I might look into making a transpiler of a small subset of Zig then

1572924943
pixelherodev
If I'm the only who uses it, that's fine :)

1572924959
scientes
I'd rather see more zig targets

1572924968
pixelherodev
Yes, but I don't have the knowhow for that

1572924971
pixelherodev
I've read the LLVM docs

1572924974
scientes
what is the target?

1572924975
pixelherodev
The abyss stared back.

1572924982
pixelherodev
XTensa

1572925032
scientes
hmm, there were other DSP vectors at the llvm conference

1572925135
torque
espressif might actually finish their llvm xtensa backend in the next decade

1572925143
torque
patience solves all problems

1572925183
pixelherodev
Yeah, but I'm not going to need it after ~four months from now probably

1572925199
pixelherodev
So there's no point in waiting

1572925212
pixelherodev
If I got a minimal subset working in a week, that'd at least be mildly usable

1572925226
scientes
yeah, but then why not just write in C?

1572925243
pixelherodev
Because I am and I miss Zig!

1572925248
pixelherodev
:(

1572925302
pixelherodev
Seriously though, I knew C had problems (even if it was the least bad option for many of my projects), but Zig is freaking *amazing*. I honestly haven't had any problems with the language.

1572925309
pixelherodev
Any problems I've had are compiler bugs, and those are transient

1572925404
data-man
pixelherodev: because "add a builtin function for every llvm C library intrinsic and bit manipulation instrinsics #767"  :-D

1572926418
pixelherodev
?

1572926421
pixelherodev
What's that in response to?

1572926433
pixelherodev
The prefetch thing?

1572926974
data-man
pixelherodev: yes

1572927609
scientes
i've added bazillions

1572927614
scientes
have have some WIP patches for a few more

1572927726
scientes
was just thinking of llround

1572927740
scientes
and that it probably should return a smaller integer

1572927746
scientes
and a biger one for f128

1572927774
scientes
declare i64 @llvm.lround.i64.f128(double %Val)

1572927800
scientes
but the significand is 112 vits

1572927802
scientes
*bits

1572927808
scientes
so it should return a i112

1572932859
daurnimator
andrewrk: how long until/what triggers docs to be uploaded to

1572933127
daurnimator
companion_cube: I found doing bit operations on huge (fixed width) integers nicer than doing in on what would otherwise be e.g. a [64]u8

1572934504
pixelherodev
There a plan for 0.5.1 release soon?

1572934519
daurnimator
pixelherodev: not unless there's a huge breakage

1572934538
daurnimator
pixelherodev: for some reason andrew doesn't do point releases.... releases are 6-monthly

1572934579
pixelherodev
On a different note, anyone know who maintains the Alpine package?

1572934665
daurnimator
mps apparently. why?

1572934743
pixelherodev
Was going to ask what the zig-dev package is

1572934755
pixelherodev
"... development files"

1572935008
daurnimator
Yeah that's weird+wrong.... they seem to have split off all the shipped libcs into a separate package

1572935016
daurnimator
You can probably bring it up in the alpine channel

1572935053
pixelherodev
Added to my todo list

1572935066
pixelherodev
Don't want to have to deal with followup right now; I'll probably bring it up tomorrow

1572935068
pixelherodev
Or better yet, send a patch myself :)

1572935098
pixelherodev
But yeah, I got curious about versions because apparently 0.5 is before `-I` was added to zig

1572935126
pixelherodev
So my `rsync /path/to/backup/ /home/ -av` wasn't enough to get it working after I set up my PC a few days ago :(

1572935136
pixelherodev
Guess I'll have to build Zig from scratch

1572935141
pixelherodev
Again.

1572935149
pixelherodev
Maybe I can copy my ccached files over :P

1572935197
pixelherodev
Oh wait - they'd be included in that backup, and so should a working build :D

1572936187
pixelherodev
Until I felt the need to `git pull` it and now I have to re-make it. Because of course I did.

1572937715
pixelherodev
Yay, everything's working again :D

1572938357
pixelherodev
Is a build targeting x86_64-linux-musl static? Or is there a separate target for static builds?

1572938607
pixelherodev
Never mind, tested and it's static. That's awesome!

1572939437
mq32
hey pixelherodev

1572939519
mq32
and now: i may present the first x86 fake assembler written in zig that runs on freestanding:

1572939552
mq32


1572939587
reductum
Could anyone point me in the direction of something in the stdlib that will let me run a separate program? Should I just build on top of std.os.linux.execve?

1572939953
pixelherodev
mq32, nice :)

1572939967
pixelherodev
I just got a working static build of my project for Github's Game Off jam :D

1572940012
mq32
nice

1572940057
pixelherodev
Not quite 45 bytes small (apparently the smallest quasi-legal ELF file you can make for x86 :P), but pretty good

1572941122
mq32
pixelherodev: Game Off Jam would be a funny idea

1572941140
mq32
"yeah, my entry is a pretty small game written for a virtual console i have written during the jam time" :D

1572941654
pixelherodev
?

1572941662
pixelherodev
Ah

1572941696
pixelherodev
Yeah, mine builds both as a static linux build (which is still freaking awesome) and with the LIMNOS kernel (the x86 project I've been working on) as a backbone

1572941714
pixelherodev
Which is a good thing, because it means I can provide a build most people can actually

1572941721
pixelherodev
I mean, if they're willing to open a terminal ;)

1572941753
pixelherodev
Should probably figure out how to do that for Windows too, but I don't think there's a termios equivalent, which i need to put the input in the expected format

1572945218
muffindrake
What is a comptime_int, more precisely?

1572945628
mq32
muffindrake: it's an arbitrarily sized integer type that can only be used at comptime

1572945667
mq32
it casts implicitly in all integer types that can capture the value the comptime_int has

1572945708
muffindrake
That's helpful to know, thanks!

1572945837
mq32
i just noticed how much difference it is between "debug" and "release-fast" mode

1572945845
pixelherodev
Anyone know a way to do the equivalent of `stty -echo -icanon` on Windows?

1572945949
mq32
pixelherodev: you should read the docs on how the windows "terminal" works

1572945964
pixelherodev
Probably, but they scare me

1572945970
mq32
a tl;dr is probably just "it's actually just a character buffer"

1572945975
mq32
not a terminal emulator

1572945985
mq32
so everything "terminal like" you see is user space

1572945988
mq32
at least to my understanding

1572946015
pixelherodev
Alright thanks

1572946018
pixelherodev
Anyway, night

1572946028
mq32
<pixelherodev> Anyway, night

1572946038
mq32
it always confuses me that we all have different time zones here

1572946044
mq32
i'm on my way to work right now

1572946045
mq32
:D

1572962249
Cadey
andrewrk: i just submitted a tag proposal for the zig tag on lobste.rs

1572965340
leeward
Are there examples out there of libraries written in C that have been partially converted to Zig? I'd like to look at how the build system and environment are set up.

1572966574
dimenus
leeward: check out 'Zig in the Wild'

1572966584
dimenus
some of those projects might contain some c code still

1572966601
dimenus
or this:

1572967034
mq32
dimenus: oh wow that zig looks so unusual :D

1572967043
mq32
it's zig 0.3 or before, right?

1572967076
dimenus
mq32: I would imagine so. blog post is 2017

1572967081
dimenus
that was before the great desigiling :D

1572967204
mq32
hehe

1572967218
mq32
i hope the syntax won't change much from now, it's already quite comfortable

1572967245
dimenus
i agree, i was 'meh' on it in 2017, but I've come around big time

1572967274
emekankurumeh[m]
how would one go about adding a new abi to zig?

1572967297
dimenus
andrewrk: do you know if anyone has proposed a '@extern' or something similar to specify a symbol name just for linking purposes?

1572967334
dimenus
or would the recommended zig way to do things just be to const realFnName = _linkFnName;

1572967341
emekankurumeh[m]
that's @export

1572967361
dimenus
i'm not exporting a symbol here, i want to link with one in a different o file

1572967364
emekankurumeh[m]


1572967417
dimenus
emekankurumeh[m]: i don't think that's correct, in this case the symbol originates from non-zig code

1572967433
dimenus
i want to call the fucnction by another name (not it's link name) within the zig code base

1572967551
mq32
dimenus:

1572967585
mq32
usingnamespace struct { extern fn myExternFunctionWithStupidName() void; pub const myFunkyName = myExternFunctionWithStupidName; };

1572967735
dimenus
ah yeah, so it's basically what i thought. No builtin needed. thanks :)

1572967772
mq32
probably even better would be

1572967786
mq32
const myFunkyName = struct {  extern fn myExternFunctionWithStupidName() void; }.myExternFunctionWithStupidName;

1572969123
bentxt
hello, dear zigs

1572969247
bentxt
I don't have a lot of experience with c. Do you consider c a requirement for zig, or does zig makes it easier for beginners to work with manual memory management?/

1572969406
andrewrk
bentxt, C knowledge would help you, but you can learn Zig without knowing C

1572969453
andrewrk
zig is immature and there are compiler bugs, this is a downside. but on the upside, you get nice things like stack traces for segfaults

1572969600
leeward
dimenus: thanks

1572969664
dimenus
it also provides a lot of useful collections and a ton of examples between the tests and standalone exes

1572969863
leeward
Also keep in mind that the language isn't done. So in addition to compiler bugs, there's an extra maintenance burden on any code you write to port to newer versions of the language.

1572970720
andrewrk
bentxt, I would be curious to hear what your thoughts are as a beginner after reading

1572971166
FireFox317
andrewrk: What raspberry pi will you be giving the demo on? I saw you asked for usb keyboard support, I would like to try to figure that out

1572971477
andrewrk
FireFox317, rpi 3 B+

1572971512
andrewrk
my fallback demo is a bouncing dvd logo

1572971517
andrewrk
will it hit the corner??

1572971594
edr
lol

1572971702
scientes
you should make it not do a 1x1 diagonal move

1572971709
scientes
so it always hits the corners

1572972515
mq32
implement a corner prevention algorithm that applies a force to the logo if it comes near a corner

1572972634
scientes
why is that a problem?

1572972654
scientes
or maybe its to prevent people from getting satisfaction?

1572972686
mq32
i remember some demo program that did exactly this

1572972702
mq32
bouncing dvd logo but had like ... 10 different versions on preventing the logo from ever entering a corner

1572972719
scientes
but i proposed a version where it ALWAYS hits the corners

1572972736
scientes
even taking non-straight paths

1572972742
mq32
logo splits and hits

1572978197
FireFox317
andrewrk: did you test the latest clashos on hardware?

1572978301
andrewrk
FireFox317, no. I haven't tested on real hardware since before merging markfirmware's patches

1572978317
andrewrk
was planning on doing that this week

1572978333
FireFox317
Okay, because I got it working before with markfirmware's patches, but can't get it working now

1572978383
FireFox317
One thing I remember when it worked on real hardware, was that the bootloader did not work anymore

1572978427
mq32
andrewrk, FireFox317: is the code for stack traces in ClashOS working with master?

1572978450
mq32
i'm on "low internet connection" and i don'T want to load any more web pages than necessary

1572978473
andrewrk
mq32, no, that regressed with markfirmware's patches. I'm planning on reverting them all and redoing the work myself

1572978495
mq32
hm, okay. sad :D

1572978868
mq32
am i seeing this right that zig assumes '\n' is a "line break"?

1572978895
mq32
(instead of a line feed)

1572979071
dantix
hi, is there a way to attach additional data to an error?

1572979173
dantix
`FileNotFound` is cool and everything, but it would be more useful to know file path. or json parsing failed, which line and character was at fault.

1572979205
mq32
you can always inspect the state of your system, even after an error was returned

1572979239
mq32
but no, it's not possible to attach additional information to an error

1572979321
dantix
hm, how I can inspect state? if I to use `errdefer` or `defer` state is gone at that point

1572979414
andrewrk
alright scientes, vector element access is in master. bring on the next SIMD PR.

1572979472
companion_cube
the chat server stream is pretty cool

1572979484
companion_cube
but I'm quite frightened by async/await and how implicit it is :s

1572979564
andrewrk
I think you're confusing async/await with the std lib event loop + std.io.mode

1572979610
companion_cube
right, right, but still, whether stuff blocks or not is super implicit

1572979988
mq32
huh. i found two compiler bugs with one line of code :D

1572980005
mq32
have to prepare a stripped down version of this, but shouldn't be that hard...

1572980959
andrewrk
companion_cube, isn't that how it always works? in hosted code, the kernel can preempt at any time

1572981081
Kappa322
Using zig to build C, is there a way to add include directories as -I<directory> other than manually with addBuildOption?

1572981119
Kappa322
There's only addIncludeDir as far as I can see but that does it with -isystem

1572981189
andrewrk
Kappa322, you're using build.zig?

1572981195
Kappa322
Yep

1572981262
andrewrk
addCSourceFile takes a parameter which is a list of c flags. but addIncludeDir is the preferred way. is -isystem problematic for some reason?

1572981356
Kappa322
My project has a common library which is part of the project and I want it in the include path; using -isystem warnings and such would be ignored for those header files iirc

1572981360
andrewrk
Kappa322, also, I'm running tests locally for a patch that makes addIncludeDir use -I instead of -isystem, and addSystemIncludeDir is newly available

1572981386
andrewrk
will push that to master in a few minutes

1572981528
Kappa322
Awesome, thanks

1572981541
companion_cube
andrewrk: preemption with other processes is quite different than preemption within a sequential looking function

1572981544
Kappa322
Loving the motivation behind zig and the path you're taking it so far btw, keep it up!

1572981584
andrewrk
companion_cube, I'm probably going to agree with you, but humor me and let's go through the reasoning

1572981671
companion_cube
well, preemption from the kernel is generally transparent (with the terrible exception of signals 😱); in a process it means any shared state could change anywhere

1572981710
companion_cube
maybe I didn't understand your comment in the stream about blocking calls meaning that the caller might resume in a different thread though

1572981717
andrewrk
in a multi-threaded process any shared state can change anywhere

1572981744
companion_cube
well here the thing is, everything is shared as soon as you call an async function :s

1572981750
andrewrk
not quite

1572981752
companion_cube
(in rust, it's quite clear what's shared or not)

1572981754
companion_cube
ah?

1572981786
andrewrk
when you create an API one of the decisions you make is whether or not it is thread safe

1572981805
andrewrk
e.g. std.HashMap

1572981828
companion_cube
right, but can you control whether a complicated piece of code always runs on a single thread?

1572981936
andrewrk
well, for one you could choose to initialize the event loop with a single thread. but let's say that you're a library, not in control of the i/o mode

1572981975
andrewrk
your library defines an API that is or is not thread safe. If it's not thread safe, that's perfectly fine, it's the caller's responsibility to lock/data protect

1572981997
andrewrk
internally, now, you're going to call functions that might be async functions

1572982028
andrewrk
let's say that you never use `async`. in this case all accesses to your data will be always from one concurrent thread. not necessarily the same one the whole time, but only 1 at a time

1572982043
andrewrk
sort of like how the kernel can pre-empt and then resume in another cpu core

1572982044
companion_cube
ah, I think I see

1572982061
companion_cube
in this way `async` is a bit like `go` in go

1572982067
companion_cube
or spawn, or whatever

1572982068
andrewrk
yes it is

1572982080
companion_cube
alright, that makes more sense, thank you.

1572982082
andrewrk
if you use `async`, then you've now invited the possibility of > 1 concurrent thing

1572982098
companion_cube
in the scope of the async, yes

1572982106
companion_cube
(I mean, for values shared with teh async expr)

1572982111
companion_cube
that's reasonable indeed.

1572982113
andrewrk
however, the application may choose blocking I/O, in which case your `async` calls are actually just blocking, and await is noop

1572982147
companion_cube
shouldn't you still have a trhead pool or something?

1572982155
andrewrk
the std lib event loop has a thread pool

1572982160
companion_cube
this seems like it'd invite deadlocks, if you rely on the `async` running in parallel

1572982173
companion_cube
I mean when it's blocking IO

1572982195
andrewrk
it's correct that it's possible to write code that depends on non-blocking I/O. the chat server demo in the live stream is an example of this

1572982226
andrewrk
it's also possible to comptime assert that the io mode is non-blocking, so you can prevent a runtime deadlock of this nature

1572982231
emekankurumeh[m]
have we tested zig on more exotic llvm targets? like nvptx or amdggpu?

1572982252
companion_cube
right, comptime assert, gotcha

1572982257
andrewrk
but, importantly, for some libraries, there is no reason for them to have to choose; the logic is perfectly fine for both non-blocking and blocking

1572982287
andrewrk
emekankurumeh[m], not in any meaningful way

1572982357
companion_cube
it seems pretty hard to write something optimal in both cases, though

1572982391
companion_cube
(like, if you use async to run a few queries in parallel and use the first one that completes; in sync mode it's just a waste)

1572982434
andrewrk
companion_cube, check this out!

1572982462
andrewrk
don't get distracted by perf comparison, the point is the fact-await.zig example

1572982478
andrewrk
and the explanation of that example at the bottom

1572982818
companion_cube
(I'd be curious to know how it compares with crystal)

1572983147
andrewrk
Kappa322, tests passed. pushing to master. addIncludeDir will now do -I instead of -isystem

1572983423
mq32
my promised two bug reports had a child and got three!

1572983618
Kappa322
andrewrk, cheers! Rebuilding now to try it out

1572984580
mq32
+1 bug

1572984784
dimenus
andrewrk: thanks for the vector-element-access merge!

1572985784
andrewrk
dimenus, np, thanks for being a guinea pig on this simd stuff

1572985925
andrewrk
dimenus, what's the next simd blocker issue?

1572986137
dimenus
on my side? hmm gather/scatter or bitcasting probably

1572986183
andrewrk
yeah on your side. thanks good to know

1572988354
leeward
Is there a way to create an array of known size that aliases part of another fixed-size array?

1572988448
mq32
leeward, do you have a reason not to use a slice?

1572988556
leeward
mq32: Maybe not. Assuming slices can use their comptime-known lengths to minimize overhead at runtime.

1572988607
mq32
what are you coding that unrolling a loop is necessary?

1572988609
mq32
D:

1572988619
mq32
because otherwise slices aren't slower than arrays

1572988632
leeward
Who's unrolling loops?

1572988648
mq32
a slice is just "pointer+length"

1572988664
leeward
Right, I'm not concerned about speed; I'm concerned about space.

1572988674
leeward
1K of RAM makes one stingy.

1572988701
mq32
as long as you only use slices on the stack, it should be fine

1572988750
mq32
otherwise, if you really care for size, you could probably just pointer-cast stuff

1572988755
leeward
These are global.

1572988818
mq32
so where's the problem? you can iterate with an offset then

1572988859
leeward
I have a bunch of memory, which is a big array, but also want smaller arrays that point into it.

1572988871
leeward
No loops involved, at least not yet.

1572988874
mq32
huh

1572988879
mq32
can you tell me what you want to build?

1572988887
mq32
it's better to reason about stuff if you have context

1572988951
leeward
It's an emulator. The goal is to ultimately run it on a similar-but-different piece of hardware.

1572989013
leeward
The global memory space is an array, and there are some memory-mapped registers in it.

1572989062
leeward
So addrSpace[32..96] is a set of registers.

1572989107
mq32
are the registers "smart" or "dumb"?

1572989144
mq32
because if you're writing an emulator, you should probably use setMem and getMem functions then (to implement memory mapped i/o)

1572989147
leeward
It varies. Some are just plain general purpose registers. Others trigger things happening when written to, but can be read.

1572989195
mq32
yeah then i recommend setMem/getMem

1572989202
mq32
but: i have to get some sleep, i'm getting grumpy

1572989207
leeward
Yeah, that's probably the easiest way to do it.

1572989269
leeward
Enjoy.

1572991721
FireFox317
andrewrk: With the new boot files I'm pretty sure it is necesarry to name the binary kernel8.img instead of kernel7.img

