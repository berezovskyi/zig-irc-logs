1567900810
Tetralux
You mean toDigit?

1567900857
Yardanico
I mean that std formatFloat calls "try parseRepr"

1567901014
Tetralux
Not sure

1567901021
Tetralux
It only does that once per call.

1567901026
Tetralux
But it is a big function

1567901028
Tetralux
So maybe.

1567901052
Tetralux
But that's not why the non-std parseFloat is slow.

1567902020
Tetralux


1567902843
mikdusan
heh.

1567902932
mikdusan
isn't 15ns too fast for string -> f64?

1567902958
Tetralux
Nothing is ever too fast ;)

1567902964
Tetralux
Also it was actually 12.5 xD

1567902965
mikdusan
i'm thinking llvm has totally elided the parseFloat just trying to confirm.

1567902984
scientes
mikdusan, it seems reasonable if you had a FPGA implementation

1567902993
scientes
but otherwise, yes seems too fast

1567903006
mikdusan
ok but parseFloat into a local var never used...

1567903006
Tetralux
Would LLVM

1567903008
scientes
especially as you need to use hardware divide

1567903030
scientes
well, i think those divides can be switched into multiply actually

1567903049
scientes
but not if safety checks are on

1567903065
scientes
because you can only do that because of the modulo behavior of divide

1567903102
Tetralux
I'll look at the IR.

1567903179
Tetralux
Here's the relevant LLVM IR from main.

1567903191
Tetralux
Or so I presume.

1567903195
Tetralux
If not I can post all of main.

1567903276
Tetralux
I'll note that this was compiled with --release-fast

1567903286
Tetralux
But for some reason there's still debug stuff?

1567903450
Tetralux
Oh yeah

1567903452
Tetralux
Forgot to mention

1567903465
Tetralux
That IR is when you say `parseFloat(...) catch unreachable`

1567903472
Tetralux
The call to parseFloat

1567903489
Tetralux
But it prints out that it took 11.8 ns.

1567903591
Tetralux
Also the body of parseFloat in the IR is non-trivial.

1567903611
Tetralux
All this leads me to conclude that computers are faster than you think they are

1567903768
scientes
Tetralux, well in this case the branch predictor would probably do its job very well

1567903772
scientes
which makes a big difference

1567903781
scientes
also the cache would be very effective

1567903796
Tetralux
That's exactly what I was going for so good - I'm glad xD

1567903839
scientes
and that speed is the throughput

1567903840
scientes
not latency

1567903858
scientes
but pipelines are not THAT long

1567903886
Tetralux
> throughput not latency -- What exactly do you mean? x)

1567903906
scientes
well I don't think it actually matters

1567903917
scientes
but if you had a 20 stage pipelines

1567903934
scientes
then the "speed" of addition would be 1/20 of a cycle

1567903943
scientes
oh wait, 1 cycle

1567903950
scientes
ughhhh

1567903967
scientes
if you had 20 pipelinable instruction, then you would do all twenty in one cycle

1567903971
Tetralux
I wish I knew my CPU internals architectures better now... xD

1567903972
scientes
there we go

1567903980
Tetralux
Yeah

1567903982
scientes
Tetralux,

1567903992
scientes
the craziest thing is out-of-order

1567904016
scientes
that is very energy costly however, so most phones have in-order cpus in addition to possibly having out-of-order cpus

1567904017
Tetralux
You mean like how you can essentially cook-off a bunch of different adds and they can be executing at the same time

1567904018
Tetralux
?

1567904040
scientes
^^^^video

1567904048
scientes
there are so many optimizations its crazy

1567904093
Tetralux
Hey - most programmers don't even know what a cache IS, or that the CPU even has a branch predictor, OR that either of those are important for speed, so. xD

1567904127
scientes
there are also MANY types of branch prediction

1567904152
Tetralux
If you also have a talk on that

1567904156
Tetralux
I'll queue that one up too

1567904157
Tetralux
xD

1567904170
scientes
that talk talks about that

1567904178
Tetralux
Oh marvellous.

1567904178
scientes
and that is just the public stuff

1567904191
scientes
Intel and AMD keep this stuff really secret

1567904619
daurnimator
Tetralux: I think you're confused on 3158

1567904637
daurnimator
Tetralux: the popOrNull returns a ?T. so in your case a ??u64

1567904651
Tetralux
That is what I was expecting it to return.

1567904657
daurnimator
Tetralux: `orelse` will unwrap one layer, giving you a `?u64`

1567904675
Tetralux
Which in my example was null.

1567904700
daurnimator
yes.... because you pushed `null`

1567904704
Tetralux
Indeed.

1567904710
daurnimator
so whats the problem

1567904729
Tetralux
Because I was expecting the `orelse unreachable` in the example to

1567904744
Tetralux
I was expecting that to only be checking for whether it managed to pop an element or not.

1567904756
daurnimator
I don't think it does

1567904759
daurnimator
It does.

1567904762
daurnimator
/should

1567904779
daurnimator
At least when I tried the example I tripped a compiler bug :P:

1567904803
Tetralux
My point was that it was running the orelse statement, even though it found an element, but the fact that the element was

1567904815
Tetralux
Suffice it to say, I did not expect that.

1567904842
daurnimator
What made you think it was running the orelse statement?

1567904861
Tetralux
Because it hits unreachable.

1567904869
Tetralux
And points to that.

1567904887
daurnimator
I don't get that. (I get the compiler bug)

1567904892
Tetralux
In my own code where I discovered this, I wasn't unreachable.

1567904896
Tetralux
it wasnt*

1567904902
Tetralux
I never actually ran the example in the issue.

1567904918
daurnimator
...

1567904927
daurnimator


1567904952
Tetralux
In my real code, it was `orelse return error.Blah`

1567905047
daurnimator
if I change the unreachable to that an error I get the same compiler issue

1567905049
Tetralux
I do NOT get a compiler bug with that example.

1567905056
Tetralux
I get this:

1567905109
Tetralux


1567905209
Tetralux
If I return an error instead of unreachable, it returns the error instead, just fine.

1567905228
daurnimator
Tetralux: running my exact code? I've just tried 4 different similar things and they all hit the same compiler bug

1567905235
Tetralux
Yep

1567905240
Tetralux
Straight cutnpaste.

1567905275
Tetralux
I'm on latest master.

1567905279
daurnimator
so am I

1567905281
Tetralux
NyatzAxfLNHHkgaz3fLyOMF-x7n2mWbC8ImSoaVAij6lz9lW0YV1TdFOkkD35DCC

1567905284
Tetralux
(zig id)

1567905308
daurnimator
I'm on IPfzZcvAwpHbi7_u7GmYelMlPukqcgichRJzJCn32UopgQpGji1fR21Ka3siDnSH. But I think you're on windows vs I'm on linux

1567905316
daurnimator
So the zig ids are expected to mismatch

1567905316
Tetralux
This is true.

1567905320
Tetralux
I am on Win

1567905326
Tetralux
I have a linux box.

1567905330
Tetralux
One mo.

1567905539
Tetralux
Nope.

1567905547
Tetralux
Also fine.

1567905563
Tetralux
Ubuntu 18.04.1

1567905667
Tetralux
zig id = NyatzAxfLNHHkgaz3fLyOMF-x7n2mWbC8ImSoaVAij6lz9lW0YV1TdFOkkD35DCC

1567905669
daurnimator
okay. using the official binaries I hit the unreachable

1567905692
Tetralux
Maybe time to remake your build directory :p

1567905819
Tetralux
Also

1567905823
Tetralux
My pastebuffer screwed up

1567905830
Tetralux
The second zig id I meant to paste was this one:

1567905831
Tetralux
IlodXIZPaAgWA-9f_TUco_EeoXCzn0m2_8BRAF99lS9SR5iubRH3HDDROT_8YcaF

1567905836
Tetralux
That's my Ubuntu id.

1567905896
daurnimator
Tetralux: the ids aren't super useful i think

1567905906
Tetralux
Yeah I'm getting that impression too xD

1567906083
daurnimator
I get the hunch that my broken LLVM module error might track down your issue

1567906107
Tetralux
Oh?

1567906123
daurnimator
Tetralux: inlining things to `const maybe_value = ((??u64)(if (list.len == 0) null else list.pop())) orelse return error.Foo;` doesn't exhibit the issue any more

1567906161
daurnimator
so I think there's something going wrong with the LLVM IR genereated for the actual function popOrNull: locally I hit that broken module assertion; while you might be falling through to another case.

1567906216
Tetralux
My instinct was that something's probably not checking for if the element is null or not and is just unwrapping all the optionals instead of just the top one.

1567906233
Tetralux
But yes

1567906244
Tetralux
That's very possible.

1567907217
Tetralux
That sounded more dismissive than I intended it xD

1567907260
Tetralux
You're thought is probably more likely - it strikes me as kinda hard to accidentally unwrap multiple times - but maybe LLVM's doing it.

1567907268
Tetralux
Your*

1567908137
mikdusan
fyi i always got that llvm error when first seeing 3158

1567908173
mikdusan
and the error speaks pretty loud. there's a mismatch between 2 types: *?u64 and *??u64 .

1567908281
Tetralux
That's true.

1567908545
daurnimator
interesting; inlining .pop into .popOrNull fixes the issue.

1567908555
daurnimator
So it's maybe something to do with tail calls?

1567909434
andrewrk
`zig id` is for the caching system. it includes e.g. the system's libc. `zig version` is what you want to compare versions with other people

1567909470
stratact
andrewrk: I'm interested in getting the "get all the tests passing for freebsd" task completed. How do I activate the tests in my zig git clone?

1567909511
andrewrk
stratact,

1567909549
stratact
Gotcha thanks

1567909581
andrewrk
I recommend to start with behavior tests only. then std lib tests. then the whole test suite with -Dskip-release. Then run without -Dskip-release overnight

1567909613
stratact
I'll keep note of that

1567910820
andrewrk
mikdusan, it makes sense right? if you put `catch unreachable` at the callsite, you're asserting that there will not be an error. So the optimizer is then free to delete all the code that handles possible errors

1567910843
andrewrk
this is why it's a very bad idea to `catch unreachable` in non-safe build modes unless it's actually impossible for an error to occur

1567910958
Tetralux
How can you check if a error union is a non-error without try or catch?

1567910964
Tetralux
Or can you not?

1567910980
curtisf
I'm actually curious about the above too, I'm trying to work around

1567910990
Tetralux
Like, var maybe = f(); if (maybe) |value| { do something with non-error }

1567911005
Tetralux
Then you presumably have an else there too.

1567911017
andrewrk
Tetralux,

1567911049
Tetralux
Huh... I thought I'd tried that ages ago and it not work.

1567911064
Tetralux
I don't remember if it prompted me to put an else there or not.

1567911068
Tetralux
I'm gonna guess not

1567911073
andrewrk
the examples in the lang ref are tested with the main test suite of zig

1567911077
Tetralux
In which case, no wonder I didn't think of putting one there.

1567911084
Tetralux
andrewrk: Ah.

1567911087
Tetralux
Makes sense.

1567911323
daurnimator
Hopefully the extra sample I added to 3158 helps

1567911638
stratact
"Created /usr/home/stratact/Projects/Zig/zig/zig-cache/o/FuM4J9ikyu4oowxPyNH-fxxl2x1MOjmWAopJNS5dff6OIxksqFcdvVWyaQXN5lXh/test but skipping execution because it is non-native." ... 😑

1567911767
andrewrk
is this unexpected?

1567911825
stratact
Well I got this type of message 15+ more times, without any clues what how the test failed. So it sounds like I need to work on the systems headers task.

1567911850
Tetralux
I got those messages quite a lot when running stdlib tests.

1567911852
Tetralux
Believe me

1567911862
Tetralux
It's better than when it prints "No tests to run" 15 times.

1567911901
Tetralux
I had some problems using filters to only run the tests I was trying to audit as well - never figured out what that was.

1567911957
Tetralux
But yes - it'll mention non-native tests a bunch before it gets to actually running interesting things.

1567911964
Tetralux
It didn't seem to stop me then.

1567911970
andrewrk
stratact, if you run `zig build test` then these messages are expected

1567911993
andrewrk
this is the current list of targets that are tested:

1567912012
andrewrk
once freebsd is passing all tests, it should be added to this list

1567912034
andrewrk
which means even running `zig build test` on e.g. windows, will at least build the tests for freebsd

1567912043
andrewrk
even though it cannot run them

1567912140
stratact
Gotcha. Thank you guys. I guess I'm learning the ropes to how things are done in Zig and what to expect

1567912512
Tetralux
o7

1567915292
stratact
Oh yay, I fixed a test

1567916119
shritesh
Is Zig complete as a programming language?

1567916317
daurnimator
andrewrk: I'm looking at some mild refactoring of the build system.... but encountering some design questions. you available to answer some questions?

1567916739
daurnimator
shritesh: well first off, a comptime_int doesn't have a defined memory layout; so the exact example as given doesn't make sense.

1567917028
shritesh
So not yet a complete programming language :D

1567917029
shritesh
(Sorry I was just curious if we had something like that)

1567917084
daurnimator
actually I guess we do defined bit operators on comptime ints..... so maybe it does make sense as a question

1567917107
stratact
Tetralux: could you help me out? I'm trying to translate this C function parameter into Zig: void *(*start_routine)(void *)

1567917134
stratact
Is it a function pointer?

1567917641
daurnimator
stratact: yes. that's a function pointer to a function that takes a pointer and returns a pointer

1567917660
daurnimator
hrm. size of packed structs still has issues :(

1567917818
stratact
*fn(*c_void) *c_void ?

1567917882
daurnimator
stratact: I think so

1567917921
daurnimator
stratact: though you don't really have the `*` at the front in zig IIRC

1567917953
daurnimator
stratact: so: `const start_routine = fn(*c_void) *c_void;`

1567918020
stratact
I see, thank you :)

1567925312
shachaf
Hmm, is the plan to depend on LLVM forever or to have an alternative backend at one point?

1567929818
gonz_
shachaf: I think at some point the idea of having another backend (gcc, I guess?) became a thing. I don't know that there's an actual plan set up for it, though.

1567930880
Yardanico
Yeah, if there are plans to add another backend, I hope it will be C since that will help with portability of Zig programs to less known OSes and architectures

1567931029
shachaf
What about a native code generator?

1567931061
Yardanico
I think that's quite hard and it doesn't have a lot of benefits

1567931092
Yardanico
But I think Zig should first become fully self-hosted, only then we should think about other backends :)

1567931200
Yardanico
And for a language with multiple backends you can look at Nim. It has C/C++/Obj C/JS backends (although the C one is the default), and there's a LLVM backend developed by a single guy (it's not official and not everything works though)

1567931412
Yardanico
But Nim stdlib is highly dependent on the C library, buy that's not the case with Zig

1567931611
Sahnvour
the motivation for other backends is mainly to have one for debug builds that is seriously faster than LLVM, for now

1567931626
Sahnvour
but afaik nothing's really planned yet

1567934897
Snektron
Its really hard to make a compiler backend, what with the optimization and all

1567935038
Snektron
Even if every developer who ever did something related to Zig worked together, i'd seriously doubt they would be able to produce anything thats better in terms of code generation

1567935082
shachaf
Better in what way?

1567935106
Snektron
That would be able to produce a more efficient binary

1567935112
shachaf
I'm sure you could make something that runs more quickly than LLVM, or that gives you more control over things like memory layout.

1567935138
shachaf
It probably wouldn't easily be better at compiling the ridiculous code that C++ templates generate, but that's also not nearly as relevant.

1567935156
Snektron
Thats compiler frontend

1567935160
mikdusan
Snektron: the debug "faster" backend meaning it compiles faster, not produces more optimized code

1567935171
shachaf
Stack layout?

1567935176
Snektron
Templates are all instantiated before they are passed to LLVM

1567935198
Snektron
mikdusan: yes for debug builds its a different story of course

1567935206
shachaf
Yes, and they generate terrible code that you need a fancy optimizer to have a hope of turning into efficient code.

1567935247
Snektron
You need that fancy optimizer anyway

1567935299
Snektron
Templates only generate terrible code when you use them terribly

1567935340
Snektron
Its just AST level substitution so it would make no difference if you made the same template instantiation by copy pasting

1567935360
mikdusan
except copy-pasting is a million times more readable

1567935393
shachaf
"X is only bad when you use it terribly" isn't an excuse when most people "use it terribly".

1567935399
Snektron
If you write templates in GNU-style yes

1567935425
Snektron
Or if you let me write templates, then you also can't read them

1567935454
Snektron
shacaf: isn't that basiacally the anthem of c++?

1567935456
mikdusan
how many years did it take compiler vendors to

1567935535
Snektron
I woulnd't know, i avoid old c++ compilers

1567935538
shachaf
I'm not sure what you're getting at now.

1567935578
Snektron
I don't think c++ templates are terrible or unreadablr

1567935635
shachaf
OK.

1567935737
gonz_
I love compile time code generation and I can't deny that there's something I love about templates, but empirically they seem to cause problems in practice.

1567935772
gonz_
I think comptime interface structs in Zig (sort of like first class modules in something like OCaml) are probably better in practice.

1567935818
gonz_
They compile down to fast calls, make it obvious what's being passed in, the code is explicit at every step about what it's dealing with.

1567936003
Snektron
Thats what attracted me to Zig in the first place

1567937854
Sahnvour
Snektron: yes, by "faster debug builds" I meant faster compiling, as for now even with an unoptimized zig compiler, LLVM backedn is taking most of the time

1567938475
stratact
This docgen test is driving me nuts. I wonder if it's a bug with the linker?

1567938668
daurnimator
I believe the idea is that zig should be able to use any backend that is sensible. e.g. generate SPIR-V; also generating GIMPLE (gcc)

1567938706
daurnimator
You have projects like the linux kernel that are very hesitant to become dependent on LLVM as a project

1567938738
daurnimator
From my talks with kernel devs; lack of GCC support is one of the largest blockers to actually having kernel code in zig (aside from stability of the language)

1567938741
Sahnvour
with good reasons

1567938794
Sahnvour
zig also would be safer if not tied to a single backend

1567938813
daurnimator
yes. but also would mean that its slower to add any given Zig feature

1567938839
daurnimator
but long term (say 2 years); I would totally expect some zig community member to start upstreaming a GCC frontend

1567938894
daurnimator
Yardanico: in terms of priorities.... andrew's concentration is the main thing to ration IMO. If we have some experienced GCC developer turn up, I would be encouraging them to work on a GCC frontend/zig backend

1567939136
Yardanico
daurnimator: yeah, I know that andrew is working hard on Zig :)

1567939816
gonz_
tgschultz or anyone else: What's the current comptime interface suggestion(s)? Is anyone looking like they're considering that actual comptime interface structs with function pointers is a perfectly good solution that we already have right now? All I see is what amounts to overengineering.

1567939872
gonz_
Surely the null hypothesis here should be "You don't need to do anything but mark an interface struct parameter as comptime and refer to the functions/contents inside of it and it'll be sorted".

1567939926
daurnimator
gonz_: you might want to look at some of bgiannan's examples: they show the need for some sort of comptime interfaces

1567939995
gonz_
My point is we already

1567940022
daurnimator
gonz_: I don't suppose you have history of the channel to find bgiannan's links?

1567940044
gonz_
And sure, I'll be happy to change my mind but given how first class modules and functors work in OCaml I'm inclined to not really believe it's needed.

1567940074
gonz_
We can take comptime structs with function pointers as arguments, we can return them from functions. That serves all the comptime interface needs I'll have.

1567940103
Yardanico
daurnimator: I use quassel so I have logs since sept. 4

1567940109
gonz_
Making these implicit serves no real purpose other than saving on typing and making it less clear what's being passed in.

1567940124
gonz_
And in most languages with this functionality it also makes compile times much slower.

1567940142
daurnimator
Yardanico: there's also the log link in the /title

1567940148
gonz_
Haskell has very ergonomic support for type constraints like these and has to search the entire function space to find interface candidates.

1567940156
gonz_
It's super slow. Rust is the same.

1567940181
gonz_
(Slow at compile-time, that is)

1567940241
gonz_
Moreover it just doesn't really provide an upside other than "Yeah, I don't have to type as much". Arguably, though, it's clearer to have the interface explicitly passed in. You can save the interface in a value and just refer to it when you pass it in.

1567940329
daurnimator
gonz_: uh, grabbing a seemingly relayed bgiann link:

1567940357
gonz_
This isn't really what I'm talking about

1567940391
gonz_
Hang on, I'll push some code I have to test this out

1567940581
gonz_


1567940718
gonz_


1567940720
daurnimator
gonz_:

1567940727
daurnimator
uh; shit same link

1567940756
daurnimator


1567940775
daurnimator
gonz_: reading his examples I learnt about the deficiency in zig as I ran out of options

1567940817
gonz_
I don't think these accomplish the same thing, though. He's trying to solve something like inheritance, or trying to model subtyping, no...?'

1567940828
gonz_
I'm trying to solve "Which functions should this thing run?"

1567940847
daurnimator
gonz_: how is subtyping difference to inheritence?

1567940850
gonz_
It's a much less complicated question and what we have right now solves it completely

1567940866
gonz_
I just said they were basically the same thing

1567940882
gonz_
And also explicitly that that's

1567940908
daurnimator
Isn't it the same question of "comptime interfaces" though?

1567940944
gonz_
What I was questioning before was that it seems "comptime interfaces" to people means more, when it ought not to.

1567940976
gonz_
People are involving new keywords, complicated casting machinery, etc., when we basically already have OCaml's facilities and those are provably good.

1567941008
gonz_
It's a clear, well performing, readable, maintainable pattern and somehow we "need" more?

1567941067
gonz_
You can also remove the comptime keyword on it and determine the interface at runtime

1567941590
gonz_
And yes, like OCaml functors you can generate these interfaces as well, which, like when passed in are specialized and correct by construction.

1567941633
gonz_
The one caveat being error sets have to be explicit

1567941709
mq32
gonz_: i don' think explicit error sets are a problem

1567941877
daurnimator
mq32: they are for e.g. InStream.

1567941898
daurnimator
mq32: there is an open "interface" problem is that InStream has to be parametized by error set

1567941937
mq32
hm

1567941942
mq32
i'm trying something right now

1567941969
mq32
can i have "pointer to unknown" in zig?

1567942131
daurnimator
mq32: *c_void ?

1567947610
Snektron
can i pass commands to my program via zig build run with exe.run()

1567947628
Snektron
like how i can do `cargo run -- my-argument`

1567948336
gonz_
mq32: I don't think it's a particularly big problem either, but it's there.

1567948344
Yardanico
SimonNa: zig build run --argument ?

1567948400
Yardanico
ah nvm, you're right, that doesn't really work :D

1567948446
mq32
gonz_: i don't know if i fully got you, but your argument was "zig doesn't need builtin interface stuff", right?

1567948551
gonz_
mq32: Passing explicit interfaces should be enough, yes, is my point.

1567948573
gonz_
I don't see a good argument against it, given that it doesn't need any new constructs, no one needs to learn more than what's already there and it's obvious what's going on.

1567948588
gonz_
It compiles down to good code, is hard to misuse, etc.

1567948629
mq32
hm

1567948638
mq32
so i write my vtables by hand now :P

1567948677
gonz_
You take in functions that need to be known at compile-time and use them in the most obvious way.

1567948708
gonz_
It also degrades into a runtime requirement pretty gracefully, I'd suspect

1567948750
gonz_
But yes, what something like Haskell does automatically for you, you do yourself.

1567948781
mq32
hm. i'm still a huge fan of #2938

1567948796
mq32
it's still explicit, but it reduced the amount of code i have to repeat

1567948818
gonz_
It compiles fast since everything is known at compile-time and since this gels so well with what's already there in zig, specialization of the functions, for speed, is already done because of the fact that you're being explicit. In Haskell, the compiler passes a vtable, literally, at compile time, which is then inlined.

1567948852
gonz_
It spends time finding the actual implementation (because it searches globally) and then time trying to actually make it good.

1567948853
mq32
i'm with you that implicit interfaces aren't the way to go for fast comptile times (and i don't like them that much anyways)

1567948971
gonz_
It wouldn't be the worst thing in the world to have some kind of interface idea, but I think people are making the null hypothesis more complicated that it ought to be.

1567948997
gonz_
When it really is just a struct of functions passed explicitly to a call that's interested in having a certain interface to use.

1567949041
mq32
what is good about making some explicit interface declarations in a struct:

1567949050
mq32
you SEE what interfaces the struct implements

1567949064
mq32
you don't have to do the search-thing by hand (which is way slower than with a compiler :P)

1567949081
gonz_
I love Haskell and I wouldn't really change type classes in any way, *in Haskell*. But OCaml has the right idea about explicitness and fast compile times. They've also been flailing around trying to implement "modular implicits", which is a roundabout way of getting a more convenient way of doing the same thing.

1567949096
gonz_
When the real value is in having it be obvious which implementation is going to be used at the callsite.

1567949224
gonz_
I'm open to the idea that this will all turn out super well with explicit support for some kind of interface concept, but I wouldn't  be disappointed if zig just settled on exactly these explicit interfaces being passed.

1567949240
mq32
do you have me a pointer where i can lookup ocaml interface examples?

1567949252
Yardanico


1567949295
mq32
that looks useful!

1567949316
Yardanico
also it gets comments for stdlib functions, but most of them don't have these, so it's almost empty

1567949350
Yardanico
example of generated html -

1567949355
gonz_
mq32: I guess the most obvious place to point to is Real World OCaml, but I'm not enthused about the examples used there:

1567949414
gonz_
A functor can be regarded as a function that takes a module and returns a module, so we could have the same thing in zig, just returning a set of functions from a struct of interfaces.

1567949500
gonz_
We use functors in a couple of projects at work to ensure that something supplies all functions to fulfill some kind of interface, and then we generate a set of functions from that, that they can use.

1567949554
mq32
hm

1567949558
mq32
i have never seen any ocaml code

1567949569
mq32
is module similar to module in other languages?

1567949586
gonz_
As an example we have a `CompanyNameApp` functor that requires that your module has a `phoenix_handlers` value in it that describes how your app deals with incoming messages, etc.

1567949605
gonz_
A module in OCaml is a first class value, so we would have it be a struct in zig

1567949638
mq32
what function has a "module" in ocaml? storage? execution? object? class? value? :D

1567949640
gonz_
The module can be inspected, the components of it can be used piecemeal and you can pattern match on modules as well as pass them inline.

1567949652
gonz_
Collection of types and functions

1567949685
mq32
hm

1567949692
mq32
i don't understand a single piece of code on that page :D

1567949711
gonz_
Did you see my example before with the clustering interface?

1567949736
mq32
probably not

1567949777
gonz_


1567949803
mq32
ah that

1567949806
mq32
yeah i've seen that

1567949808
gonz_
First link points to the specification of the interface. In the type signature of `kmeans` you can see that it takes one of these interfaces and has to know everything at compile time.

1567949825
gonz_
Imagine now that you take a function that takes the interface, but also spits out a set of functions.

1567949828
gonz_
That's a functor.

1567949857
gonz_
You can then bind the result of calling that to a value, access the things it generated or pass to functions, etc.

1567949884
gonz_
Effectively, you've generated what can be compared to a "module", a set of values and functions.

1567949924
mq32
ah

1567949927
gonz_
For most intents and purposes these are the same and practically speaking we've used this exact pattern in TypeScript to generate type safe specialized functions based on interfaces passed in.

1567949952
gonz_
We pass an object with function implementations in and we get an object out with some functions, specialized to the interface we passed in.

1567949988
mq32
so you propose instead of  kmeans.ClusteringInterface(Point2){ … } just call a MakeClustingerInterface(Point2) ?

1567950001
mq32
and that returns the struct prefilled?

1567950005
gonz_
Yes, that could be one way to design it and we use that in our TS code.

1567950046
gonz_
Idiomatically in OCaml you'd have a `Make` function (functor) in the `ClusteringInterface` module that created a ready-made set of functions for you to use.

1567950060
mq32
i think we had a smaller wording conflict right now :D

1567950060
mq32


1567950101
gonz_
Yeah, functor has its roots in mathematics and well, it's persistent...

1567950116
mq32
in my world functor is the "function object used to pass function pointers along with its state

1567950116
mq32
"

1567950128
gonz_
I don't particularly mind this kind of language, but for practical purposes when describing the concept I prefer to state it in terms that we already have at hand.

1567950175
mq32
but if i pack the Make function into ClusteringInterface, the module probably has to know

1567950191
gonz_
What do you mean?

1567950199
mq32
ClusteringInterface.Make(Point2)

1567950211
mq32
i understood that it would be similar to this ^

1567950213
gonz_
You would pass a set of functions to `Make` to get a set of functions out.

1567950222
mq32
ah, hm

1567950223
gonz_
Module in, module out.

1567950233
gonz_
The module you get out is specialized to `Point2`

1567950275
gonz_
So imagine you have a `Map`. You pass a set of functions for everything that's needed for a `Map` type into `Map.Make` and get ready-made specialized functions for interacting with a map conforming to the interface you passed in.

1567950299
mq32
so just usual generics :P

1567950300
gonz_
So you would have a function to hash the thing in the interface, perhaps.

1567950340
gonz_
I think the point here isn't really any one example of thins

1567950353
gonz_
but rather that it's a very useful pattern and I think the null hypothesis should be exactly that

1567950367
mq32
but if i understood you correctly, we do that all the time already in zig

1567950373
mq32
ArrayList for example

1567950443
gonz_
`ArrayList` takes only a type, as far as I know. But you are right in that it's the same level of obviousness; types and values in, create a ready-made thing from those.

1567950472
gonz_
It seems to me that people have blinders on for the natural extension of that simplicity, so they invent new keywords and obfuscations around it.

1567950598
gonz_
`HashMap` is a better example where instead of a struct it's just taking everything parameter by parameter.

1567950611
gonz_
But yes, it's an illustration of it, as far as I can see.

1567950633
mq32
yeah, but imho it's not the use case we need interfaces for in zig

1567950651
mq32
because this method won't work as soon as i want to store a list of interfaces

1567950658
mq32
like "everything printable into this list"

1567950674
mq32
because then i need at least two pointers

1567950681
mq32
one for the function and one for the object itself

1567950857
gonz_
I see what you're saying, but I'm not sure it makes sense to me in practise

1567950926
gonz_
My main worry is that something more is added and it sucks but everyone is using it and I'll just have to ban it in my stuff and avoid using everyone elses stuff.

1567950990
gonz_
And suddenly it's just like  Haskell, C++, et al where every dependency should have a "cost" entry in  a database for runtime & compiletime.

1567950996
gonz_
Or maybe more topical; Rust.

1567951063
mq32
gonz_, simple example is games:

1567951079
mq32
imagine some kind of interface "Actor" that has an inventory

1567951092
mq32
or better, just make the interface Inventory

1567951101
mq32
now you want to display inventory UI

1567951123
mq32
you can now use your approach which means we get one inventory implementation per inventory type we have in the game

1567951135
mq32
</>

1567951138
mq32
forget that

1567951147
mq32
i'm thinking of a better example, my head is too full right now :D

1567951152
mq32
brb

1567951799
Tetralux
By making the interface struct comptime, does calling the fns in the struct become static calls at runtime?

1567951818
Tetralux
gonz_

1567951983
gonz_
Tetralux: Yes

1567951987
gonz_
Same as calling any other function

1567951990
gonz_
I checked the assembly

1567952006
Tetralux
Sigh. I still haven't quite figured out the intutition for that it seems.

1567952031
gonz_
Specifically `e8 ...`

1567952036
gonz_
call near, relative

1567952045
Tetralux
My usecase is that I'd be storing the interface as a struct field

1567952053
Tetralux
And using it to repeatedly call one of it's fns.

1567952056
gonz_
Relaxing the requirement for comptime does change the assembly as well

1567952077
Tetralux
If the interface struct is comptime, then field must also be comptime

1567952080
Tetralux
I presume

1567952081
gonz_
To `ff ...`

1567952098
gonz_
I assume so, yes

1567952103
Tetralux
But then I thought I can't call it from non-comptime member functions.

1567952472
gonz_
I heartily recommend this pattern as a baseline for "How do I use something with many different things". I have to confess to not seeing why I'd want a heterogenous list of things and not instead a list of the things those things have in common, though.

1567952490
gonz_
It's possible that I've just dodged what people are trying to solve.

1567952576
gonz_
When things are somewhat heterogenous I'll just push them into a sum type. That's how we handle messages of different types in our apps, for example.

1567952697
gonz_
But yeah, if people come up with some obvious, fast and generally good solution, that'll be great.

1567952705
mq32
gonz_, u have my example:

1567952747
mq32
gonz_, your approach with sum types only works for applications, not generic purpose library code

1567952771
mq32
i'd have to change your library in order to append custom messages to your message list

1567952780
Tetralux
I'll also note that mq32's example requires the library author to apply the interface.

1567952801
gonz_
mq32: We have general tools that do exactly that, though. We have functors that require you to have a `message` type. What that message type actually contains is up to you, but it's needed for certain interface functions.

1567952818
gonz_
So no, you don't have to change the library code.

1567952869
gonz_
We have 3 different apps conforming to our `CompanyNameApp` and they all have different message types. We require in the `CompanyNameApp.Make` functor that you have a message type and that it's used in certain other parts of the interface so we can guarantee a well working ready-made module for you.

1567952874
Snektron
i cant read a slice into an array? lame

1567952891
Tetralux
Snektron: Slice the array and use mem.copy.

1567952962
Tetralux
gonz_: The usecase I had was a simple one. I have a struct that takes a Reader and stores it into a field for later use. A Reader is just a read([]u8) !void; and readByte() !u8;

1567952967
gonz_
This extends also to the state of our apps; we require that you have a `state` type, but we don't mandate what's inside of it, since app state is different from app to app. We then require that you have functions that take the app state, a message type and give a new app state, etc.

1567952994
Tetralux
I wanted to allow a user of my library to pass an ArrayList, a slice, or something already with read/readByte.

1567953032
Tetralux
But found it very awkward to map the Reader's read call to the array.

1567953041
gonz_
Tetralux: In that case the interface can say "I need these functions with these type signatures and I need to know the type" and if there are ready made functions those are the implementations passed in the cases of those types.

1567953085
gonz_
As far as I understand, at least

1567953086
mq32
gonz_, same question: how does your approach handle "store references to different stuff with a similarity into a list" without known all "different stuff"?

1567953092
Tetralux
I didn't want the user to have to specify anything,  so I had a user-facing function that took `reader: var`, and then used typeInfo to see if it had read/readByte etc or not.

1567953137
Tetralux
But I found myself running into `fn([]u8) !void` does not match `bound fn ...`

1567953152
gonz_
mq32: If something is "like a list", does that mean it can be turned into a list? In that case, the interface function can trivially be `turnIntoList(value: T) List`

1567953167
gonz_
Though you may have misgivings about the performance implications of that.

1567953196
mq32
gonz_, i meant something like

1567953205
mq32
List.append<T>(T{});

1567953212
mq32
not List<T>.append(T{})

1567953222
mq32
so "turnIntolist" is wrong, but "addToList" would be right

1567953234
mq32
and i want to access functionality of the stuff stored in my List

1567953242
Tetralux
mq32: You mean a list where each node can store a different type?

1567953255
gonz_
Like I said before, I don't know why I'd be storing heterogenous things in lists. It's something I've dodged since forever, so I can't relate.

1567953266
mq32
UI

1567953277
mq32
you want a list of childs per widget and each child is a different widget type

1567953280
gonz_
`toUiElement(thing: T) UiElement`

1567953285
gonz_
Now they're the same

1567953291
gonz_
homogenous list

1567953291
mq32
and UiElement is a pointer?

1567953301
mq32
because i want to implement custom widgets as a user

1567953321
Tetralux
You could do the old trick of taking a *BaseWidget and having an array of *BaseWidget

1567953333
mq32
yeah

1567953343
Tetralux
And having the first field of each widget type be a BaseWidget, etc etc.

1567953348
mq32
but that's just inheritance

1567953354
mq32
(also similar to interfaces)

1567953359
Tetralux
More or less yeah :p

1567953388
gonz_
And your widgets could be turned into a `UiElement`. Maybe the interface specifies `onClick` as a way to customize how your widget behaves, etc. When I was doing DOM manipulation in PureScript I made a `IsNode` type class where you specified a way to turn whatever thing it was into a HTML Node

1567953401
gonz_
Which then makes it so that you can have different things but turn them into `Node` when you need to

1567953417
mq32
but what does UiElement store?

1567953422
gonz_
But yeah, I think modeling inheritance and OOP when you don't have them can turn awkward, no question about it.

1567953426
mq32
this type is already defined and i cannot change it

1567953427
gonz_
I also don't think it's needed

1567953440
Tetralux
gonz_: You mean that each Widget type would have a asBaseType() BaseType?

1567953447
mq32
i'm still thinking about writing a UI lib in zig

1567953453
Tetralux
And each sub Widget knows how to construct a basetype instance to rep it?

1567953460
mq32
but i'm not sure if i want to because of missing inheritance

1567953468
gonz_
Tetralux: In the interface struct in that case, yeah, for certain functions, or perhaps as a standalone comptime function pointer.

1567953474
gonz_
It depends on the interface of the library.

1567953513
gonz_
Like I said, I haven't lived in a certain world where you learn to think in inheritance, so take it with a grain of salt.

1567953525
gonz_
I just don't see the point. To be fair, I never did while writing C++ either.

1567953537
Tetralux
mq32: You can always use the longer-way around perhaps and have a list of union(enum).

1567953555
Tetralux
But then you can't add new widget types without changing the union definition.

1567953564
mq32
Tetralux, also only works if all widget types are known at declaration time

1567953575
gonz_
Your union can be parameterized on the type.

1567953593
mq32
you mean on a full list of types

1567953597
mq32
like

1567953604
mq32
CustomWidget1, CustomWidget2, CustomWidget3

1567953610
gonz_
`pub fn Widget(T) type { ... }`

1567953611
mq32
that's not possible right now

1567953618
Tetralux
I think that the interface way is the simplest way to go then.

1567953628
Tetralux
Store a list of interface ptrs.

1567953644
Tetralux
And allocate the widgets seperately.

1567953654
gonz_
`union(enum) { CustomWidget: T }`

1567953655
mq32
yeah that would be my way now as well

1567953656
Tetralux
Each widget knows how to construct an interface instance for itself.

1567953717
Tetralux
gonz_: Only works at decltime and have to change the definition of the union to add more - but the one adding more might be a library user.

1567953741
gonz_
Tetralux: They can add things to `T` without changing anything.

1567953753
mq32
gonz_, expanding the enum probably won't work except for some comptime loop stuff

1567953764
Tetralux
gonz_: How?

1567953766
gonz_
The union doesn't need to change at all for them to add things to `T`

1567953783
Tetralux
Is T a struct that they provide?

1567953787
gonz_
Yes

1567953796
Tetralux
How does it get into the union?

1567953799
gonz_
Or well, anything

1567953806
Tetralux
Is the union returned from a fn or something?

1567953810
gonz_
Yes.

1567953814
gonz_
Like any generic

1567953815
mq32
hm

1567953824
mq32
i don't like the union way at all for extensibility

1567953834
Tetralux
Yeah - I've had trouble with that too.

1567953837
mq32
it will make a horrible, unmaintainable mess of code

1567953842
gonz_
So you can have library offered things in that enum, but also `CustomWidget` that contains whatever type you want to extend with.

1567953847
Tetralux
But more from just a awkwardness perspectively.

1567953867
mq32
and CustomWidget is just a dispatcher to widgets from, like, 10 different widget libraries

1567953872
mq32
and one of my own extensions :D

1567953887
Tetralux
It's like the extension type in MsgPack.

1567953903
gonz_
The apps that I have that are based on sum & product types + basic interface shuffling are more maintainable than anything else I've seen.

1567953903
Tetralux
You have several primitive types - anything else? Put it as an extension type.

1567953929
Tetralux
I didn't do CS so I don't know what any of that means xD

1567953933
gonz_
Like I said, I don't think in inheritance and things, so I think it's a matter of perspective.

1567953951
gonz_
Tetralux: Sum types = tagged unions, product types = records/structs

1567953956
mq32
gonz_, inheritance is quite comfortable for a lot of stuff that

1567953972
mq32
UI Widgets are probably the perfect example

1567953982
gonz_
Yeah, that's what they usually say.

1567953984
mq32
as some widgets are really similar to each other, but extend only a portion of the code

1567954001
gonz_
I just have been convinced over time that there isn't really anything that needs inheritance or is better served by it.

1567954022
fengb
Are we discussing theoreticals?

1567954039
gonz_
I used to think there was, while still not really getting it. I went full OOP in C++ way back and then just fizzled out because I was just flailing around.

1567954043
Tetralux
I think the problem has - and always will be - that talking about these things doesn't actually help - you have to see a working system that makes good use of it.

1567954057
mq32
no, fundamentals! religious beliefs! this is the holy war!

1567954078
gonz_
I'm not trying to be dogmatic about it. I genuinely don't think it's useful.

1567954083
fengb
Apple Cocoa has limited inheritance but the userland should almost never use it

1567954099
fengb
It has other (arguably better) ways of extending functionality

1567954106
gonz_
And let's not frame this as the tyranny of non-OOP; it's the most popular paradigm by far. OOP is doing well, let's not baby it.

1567954124
Tetralux
> let's not baby it +1

1567954142
fengb
React also is starting to ignore inheritance. I find the two to be much easier to understand than inheritance based widget kits

1567954197
Tetralux
Does that have anything to do with multiple inheritance or multiple layers of inheritance?

1567954218
Tetralux
Because if you're doing inheritance

1567954224
Tetralux
I think single-layer is where its at.

1567954230
mq32
mixins! :D

1567954235
mq32


1567954239
gonz_
Single-layer doesn't work for UI, though...?

1567954248
gonz_
You kind of have to go full OO, no?

1567954272
Tetralux
I might try to compose before going multilayer.

1567954278
mq32
single layer

1567954288
mq32
but all widgets share at least some properties

1567954294
mq32
(position, style, ...)

1567954294
Tetralux
But then my version of ideal inheritance is basically just composition, so.

1567954308
Tetralux
That stuff is what'd go in the bottom layer.

1567954317
Tetralux
Then all widgets just compose that.

1567954325
fengb
Non inheritance you'd have a separate field for that data

1567954343
gonz_
I dunno, this seems like something I'll happily try out but then I'd be afraid if I don't like it it's still there any everyone is using it and I'm becoming a code-hermit prematurely.

1567954347
fengb
And interface it to something like "getPosition, getStyle"

1567954357
Tetralux
fengb: That's my default-preferred way to inherit.

1567954365
fengb
That's not inheritance though :P

1567954378
Tetralux
It is.... if you can mark the fields as such.

1567954383
gonz_
Tetralux: But then the interface functions are just `getThis`, `getThat`, etc., which works beautifully with the comptime interface struct style.

1567954383
Tetralux
This is reality in Jai and Odin.

1567954396
mq32
i still like the proposal of mikdusan on that

1567954404
mq32
(

1567954406
mq32
#2938)

1567954414
mq32
it's conventient embedding and fieldParentPtr

1567954429
fengb
Ah so something like Go embedded structs

1567954437
Tetralux
fengb: .. means you can mark the 'supertype' field `using f: BaseType` and then you can use the fields of 'f' as if they were fields of the enclosing struct.

1567954440
mq32


1567954456
fengb
supertype... sounds like prototype inheritance now

1567954467
Tetralux
I'm only calling it supertype for clarity's sake.

1567954473
gonz_
But we can already just pass an interface struct that gets these fields :D

1567954477
Tetralux
It's literally just an embedded struct.

1567954480
gonz_
You already have this :D

1567954487
gonz_
You can just sit down and use it, now :D

1567954501
Tetralux
gonz_: The one thing you cannot do currently is

1567954533
Snektron
I don't think its wise to implement go-style inheritance in Zig

1567954537
Snektron
or any really

1567954579
Tetralux


1567954642
Tetralux
(Adds something else to that paste)

1567954678
gonz_
Tetralux: I know this example is intentionally minimal, but what's so wrong about having to specify a way to get that thing out of the struct beforehand or having to dot a bit further down into it?

1567954705
Tetralux
In that particular case, what you're suggesting would simple be "takesBase(s.base)"

1567954721
Tetralux
The issue is, you want to write the function to be maximally reusable.

1567954737
Tetralux
The implicitness of the casting makes that ergonomic.

1567954744
fengb
[implicitness]

1567954748
gonz_
It takes a base. It's reusable. Give it a base.

1567954793
gonz_
If it needs more, give it a comptime struct of functions to work with `Sub` and one of them is a function to get the `Base`.

1567954798
Tetralux
It's fragile to breakage though.

1567954800
Tetralux
s.x += 1

1567954805
Tetralux
s.base.x += 1

1567954819
Tetralux
What if you want to rename the field, as the standard example.

1567954827
gonz_
Which field?

1567954835
Tetralux
base.

1567954848
gonz_
Then your function will not compile because the interface isn't compiling.

1567954860
gonz_
It'll tell you `Sub` doesn't have a `base` field.

1567954864
Tetralux
Which is unnecessary in most cases, nmo?

1567954883
Tetralux
You're only using base at all because you have to provide it.

1567954884
gonz_
Why? It's the best kind of error: "Your assumption is wrong"

1567954888
Tetralux
It's busy work.

1567954909
Tetralux
If it was implicit, this isn't even a problem you have to think about at all.

1567954924
gonz_
`<leader>en` takes you to the error, you change it to the new field name, bam.

1567954925
fengb
Or... get an IDE to refactor that

1567954928
gonz_
These are not hard issues.

1567954955
Tetralux
fengb: IDEs are overrated.

1567954974
Tetralux
gonz_: I value my time. :)

1567954982
fengb
Well it solves this problem much more elegantly than polluting the language

1567954987
Tetralux
There's literally no need to have to do this.

1567955026
Tetralux
Yes, you could just pass base, and mention my_custom_widget.base.x everywhere if you wanted to.

1567955031
gonz_
Tetralux: I think this is just a fundamental difference in outlook. We just have spent time in very different areas of programming and I can't really relate to this particular thing in the end.

1567955064
gonz_
This interface could be created in one place and referred to trivially where it's used, which would give you one compile error to care about, that you fix in a second or two.

1567955081
gonz_
Above all, it's a compile time error which is the holiest of errors.

1567955114
Tetralux
Simply put - you agree this is a good interface - why not make it more ergonomic?

1567955135
Tetralux
That's essentially the root of my point.

1567955146
fengb
No, having a consistent interface is good. Implicit coercing into other types is not

1567955150
Tetralux
You may think it's already fine, and I see your point.

1567955158
Tetralux
I just think it could be better.

1567955172
Snektron
Tetralux:

1567955177
gonz_
I think passing functions to other functions is good and that's probably what I'll do until the end of time. Sometimes the functions are in structs and sometimes I explicitly generate function pointer structs from other function pointer structs.

1567955178
Tetralux
fengb: It only happens when passing to a fn that takes the base type.

1567955262
Snektron
oh, it fixes itself after i write the parenthesis

1567955323
Tetralux
Snektron: ;)

1567955333
Tetralux
Snektron: Also pushed a fix for it anyway.

1567955386
Snektron
ah, great

1567955387
Snektron
thank you

1567955408
Tetralux
o7

1567955471
Tetralux
The only issue with this kind of inheritance is that you cannot go from Base to Sub.

1567955486
Tetralux
So if you need to look at the information from Sub, you need to pass a Sub.

1567955505
Tetralux
Unless fieldParentPtr could help.

1567955850
gonz_
Tetralux: Can I interest you in an interface function called `fromBase(b: Base) T`? :D

1567955875
gonz_
Passed at the call site, for your (in)convenience

1567955926
gonz_
Jokes aside, could you not just pass the actual thing as a parameter to whichever function needs the subtype as well?

1567955965
Tetralux
;D

1567955984
Tetralux
I'm struggling to think of counterexamples right now.

1567955986
mq32
gonz_, your proposed solutions of "specialize everything" has one problem we haven't talked about yet :P

1567955992
mq32
code size

1567955996
Tetralux
But the way I'd handle it normally is with fn overloading.

1567956015
Tetralux
One that takes Base, and another for any other type that actually does need to do something special.

1567956019
fengb
Code size would be bloated regardless

1567956021
Tetralux
In Zig, I obv can't do that.

1567956021
gonz_
mq32: The interface can be marked non-runtime, which should be able to solve it...? I've yet to confirm that.

1567956033
gonz_
non-compiletime*

1567956042
mq32
if it would be runtime, it would decrease code size

1567956051
fengb
Oh that's what you meant. Ignore me!

1567956078
mq32
but even so, if i have a function instance for every T i call, it will increase linearily with every T

1567956083
gonz_
mq32: Right. So if you had a function that checked the type to see which interface to return, could this not be dynamic and not bloat code size?

1567956093
mq32
nope

1567956098
fengb
andrewrk mentioned he wants an interface pattern that could seamlessly transition between comptime and runtime

1567956150
mq32
gonz_, you wouldn't require a function then

1567956151
gonz_
mq32: For that I'd concede that some kind of runtime polymorphism solution is warranted, I suppose.

1567956154
mq32
because it doesn't specialize anything

1567956218
mq32
in C you just pass an interface to such functions

1567956230
gonz_
Just to refresh my memory, because I never really use it, if I have `var` is that forced to be known at compiletime or I can check it at runtime?

1567956239
mq32
(struct with function pointers + void* params)

1567956262
mq32
gonz_, everything regarding types is enforced comptime

1567956264
fengb
But we can already emulate that with fieldParentPtr

1567956272
mq32
yeah

1567956287
gonz_
Whichever way you can do runtime checking you could have an interface generated that does exactly that.

1567956291
gonz_
No?

1567956308
mq32
we cannot do runtime type checking

1567956321
mq32
we don't have RTTI, only TI

1567956331
mq32
(run-time type information vs type information)

1567956335
mq32
zig only has static reflection

1567956370
gonz_
Right, so this is not really an issue with passed interfaces so much as an issue with checking at runtime

1567956390
gonz_
Because if there was a "check at runtime" interface passed, it'd do just that.

1567956400
mq32
dunno. reducing code size would work by predeclaring all interfaces as const objects

1567956416
mq32
instead of emitting functions that create this interface

1567956538
gonz_
I'm not sure I follow 100%. The interfaces themselves don't actually take up any size or whatever.

1567956552
gonz_
It's the functions that they refer to that actually exist.

1567956590
gonz_
Reducing code size would be a question of removing the need for different functions being referred to, so checking at runtime in the one function they all use.

1567956656
gonz_
'cause we're talking the tradeoff that Rust highlighted a few weeks back, right? People overuse static polymorphism and code size rockets up.

1567956685
gonz_
The passed interfaces don't actually really exist AFAIK, they don't show up when debugging, for example.

1567956736
gonz_
They do point to the very specific, specialized functions that you put in them, though, so there's no question that each thing has its own, but whichever way you'd then have runtime polymorphism, an interface could also specify those functions.

1567956740
mq32
gonz_: your example code you posted earlier (kmeans)

1567956745
mq32
creates one implementation per type used

1567956751
gonz_
Yes.

1567956757
mq32
so if you use it with Point2, it has size N*1

1567956764
mq32
if you now use it also with Point3, you have N*2

1567956765
mq32
…

1567956767
mq32
and so on

1567956780
gonz_
Yes. So we are on the same page.

1567956784
mq32
to reduce code size it would require to not be specialized on a type

1567956786
mq32
okay, good :)

1567956793
gonz_
It's the existence of the specialized functions that is the thing that bloats the code size.

1567956809
gonz_
And yes, runtime checking is the solution to bloated code size.

1567956816
gonz_
So it's not inherently any issue with passed interfaces.

1567956875
gonz_
I'm not saying you wouldn't need some modification, though;  I probably would have a function that required a comptime interface and possibly one that didn't.

1567956917
mq32
to reduce code size bloat you'd have to remove any type dependencies

1567956943
gonz_
But this is the same issue you'd have if you just had a bunch of code. If I wanted to implement K-means clustering for 10 types without passed interfaces I'd have the same amount of code as I do with passed interfaces.

1567956951
mq32
so kmeans would be called with "this start pointer, this stride, this function takes two untyped pointers and returns distance"

1567956976
mq32
no, you can do that without any interfaces

1567956983
mq32
C syntax would be something like

1567957008
gonz_
If you had 10 specialized kmeans clustering functions you'd end up with the same amount of code

1567957012
mq32
void kmeans(void * elements, size_t elementStride, size_t elementCount, float (*distanceBetween2)(void * a, void * b));

1567957022
gonz_
`kmeans_point{2,3,4 ...}`

1567957031
mq32
now you can pass in any type, without increasing code size

1567957137
gonz_
Right, sure.

1567957163
gonz_
Specializing increases code size, which I'm fine with. Having alternatives to specializing isn't something I'm against.

1567957294
fengb
Embedded UI?

1567957317
mq32
ah.... yes

1567957338
mq32
at work we have a UI system that has separated widgets

1567957348
gonz_
Though I'd like to work with embedded stuff, but that's mostly so that I'll be forced not to over-abstract.

1567957351
mq32
each widget consists of a .data and a .rodata part

1567957363
mq32
so we don't use too much RAM

1567957386
mq32
(position, size, callbacks, ...) is .rodata (flash memory) and stuff like (isChecked, text) is .data (RAM)

1567957403
gonz_
I know no one in embedded work and I make a killing in backend work so I haven't been sufficiently motivated to get to looking for work in lower level stuff as much.

1567957436
gonz_
My last work offer was for Haskell on the backend and I work with Elixir now, so I'm about as far away from embedded as you can get in some sense.

1567957558
mq32
hah

1567957567
mq32
i'm planning some crazy project right now

1567957578
mq32
still not sure if i go with zig, c++ or C

1567957607
mq32
but my experiments the last days show that i would probably work around a lot of zig compiler bugs and be blocked in actually getting something done

1567957632
andrewrk
nontrivial projects in zig will require participating in the development process to some degree

1567957644
mq32
yeah

1567957804
gonz_
Do it in C++ and rewrite it in zig :D

1567957826
gonz_
Write a blog post on HN about how you've seen the light

1567957842
mq32
haha

1567957870
mq32
first i have to figure out my requirements on the project

1567957900
mq32
will be some kind of "new" UI system with some aspects of Web Development and some aspects of, well, other stuff :D

1567957993
gonz_
Who was it that had the setup with ALE for `zig build`, by the way?

1567958010
gonz_
I need to get me some of that

1567958106
gonz_
Don't hoard these sick scripts, whoever it was

1567958632
Snektron
"Cannot store runtime value in type 'comptime_int'"?

1567958669
Snektron
this is on a if (a) 1 else 0 type construction

1567958696
fengb
Peer type problem. You need to manually cast one of the literal

1567958705
Snektron
i see, thanks

1567958911
Tetralux
mq32: Please make it trivial to lay things out.

1567958934
Tetralux
I still use .Net whenever I want to make a program with UI

1567958946
Tetralux
And that's in no small part because of .Anchor.

1567958982
Tetralux


1567959007
Tetralux
(It keeps certain edges of a Widget equidistance from that sides' edge.

1567959036
Tetralux
s/from that sides' edge/from that sides' window edge.

1567959069
Tetralux
If I have to make 20,000 layers widgets just to lay out the window in a sane way... :)

1567959079
Tetralux
layered*

1567959108
Tetralux
Well - it's mostly cuz graphical UI for laying out the UI - but still.

1567960258
gonz_
Do we have a `.seen` command on a bot?

1567960281
gonz_
As in you can query a bot about when someone was last seen in the channel.

1567960521
gonz_
It was fubd who had the ALE linter, it turns out. :/

1567960522
Snektron
I feel like there should be a way to cast a pointer to a slice without a lot of builtin functions

1567960739
nrdmn
sync your portage trees

1567960840
Snektron
I doubt that will help

1567960905
nrdmn
it's generally a good idea

1567961741
Yardanico
925593

1567961745
Yardanico
sorry wrong window

1567961781
gonz_
Time in seconds spent compiling GHC

1567961807
Yardanico
gonz_: it's actually a GitHub 2FA sms code :D (don't worry, I already used it)

1567963012
stratact
andrewrk: yesterday I managed to fix one test, but I've been having bad luck trying to figure out this one, since it deals with the linker:

1567963050
stratact
I think I got most of the tests to past except for docgen

1567965646
andrewrk
stratact, the zig std lib assumes pthread_attr_setstack is available in libc, but it appears to not be available in FreeBSD. That is surprising, I would like to ask devs about it

1567965679
andrewrk
also pthread_create? maybe zig simply needs to add -lpthread to the linker line for FreeBSD

1567965717
andrewrk
that's in src/link.cpp

1567969336
Snektron
can i be generic about const in Zig?

1567969373
Snektron
its annoying to write a get() and getConst()

1567969471
Yardanico
are you using it for []const u8?

1567969483
Snektron
member function in this case

1567969649
Snektron
for example i have this struct which fetches a pointer to another thing

1567969661
andrewrk
Snektron, that's an unsolved problem at the moment

1567969665
Snektron
if the struct is declared as const the pointer return should be const of course

1567969697
Snektron
andrewrk: i see. I heard about a programming language which allowed to be generic about that, and about errors in a certain way, but i forgot which one it was

1567970446
stratact
andrewrk: by linker line, you mean the LinkJob object?

1567970559
andrewrk
stratact, yes, look at construct_linker_job_elf for example

1567970603
stratact
gotcha, thank you

1567970653
andrewrk
stratact, per issue

1567970656
fubd
gonz_ here's what i've got for an ALE zig linter

1567970676
fubd
it finds build.zig and calls "zig build" but a more general solution would probably not be far from that

1567970705
andrewrk
stratact, I believe on freebsd it's going here:

1567970731
andrewrk
stratact, and you can add specific detection for freebsd (g->zig_target->os == OsFreeBSD) and mess with the linker line there, such as by adding -lpthread

1567970820
stratact
Understood, I'll use the FreeBSD detection conditional for the -lpthread append and play around

1567971020
scientes
is there a function to check if two types are compatible?

1567971023
scientes
or functions

1567971040
scientes
oh nvm

1567971187
stratact
andrewrk: omg, yay, it worked! :D

1567971235
stratact
It feels so good

1567971365
gonz_
Ahhh, realtime syntax and type checking for zig

1567971371
gonz_
(in vim)

1567971373
gonz_
Living the dream

1567971448
stratact
Once docgen test is completed, I'll do a full test with -Dskip-release and another without it and if all good, I'll make a PR 😌

1567972605
scientes
gonz_, really?

1567972619
scientes
that requires running zig

1567972645
gonz_
Indeed it does. It's actually annoying to have it on text change

1567972648
gonz_
so I switched to only save

1567972667
scientes
for stage2 we will work on zig's compile performance

1567972728
gonz_
You can also set a text change delay for it with debounce, AFAIK, so with just some tuning of that, if zig can actually give you realtime results in the future in a reasonably sized project, that'll be pretty sweet.

1567972863
gonz_
Though, to be honest, I don't expect this. There are only two languages that do a decent job of this that I've tried and they are OCaml & TypeScript

1567972878
scientes
gonz_, well since zig is limited to one thread it isn't annoying if you have bazillions of ram and 2+ cores

1567972899
scientes
gonz_, just another side effect of comptime

1567974587
Yardanico
gonz_: there's also zig-lsp although atm it mostly has syntax checker (braces, invalid ;, etc)

1567974617
Yardanico
imagine coding in zig with real-time autocompletion 😍

1567974666
scientes
and real autocompletion

1567974674
scientes
instead of that shit that mode editors produce

1567974681
scientes
*most

1567974702
Yardanico
well, I previously used nim, it has an autocompletion tool (nimsuggest), and there's a vscode plugin for it, so it's a real real-time autocompletion

1567974721
Yardanico
although it doesn't use language server protocol

1567974783
gonz_
Currently I run a program called TabNine the checks for patterns in your source code and auto completes them when it sees you typing them.

1567974795
gonz_
s/the/that

1567974811
Yardanico
wow, that exists? I though there were no alternatives to Kite which wasn't actually working

1567974856
Yardanico
gonz_: thanks for suggestion, I'll try it rn

1567974886
gonz_
It exists, yeah, and works pretty well. Since it doesn't really rely on any language specific things it can actually pick up patterns for any language, even if you have maybe some dependency in C that you use in zig.

1567974929
gonz_
I wouldn't say it's perfect, though.

1567974949
gonz_
I'm using it with zig only because there's nothing else.

1567974958
Yardanico
well of course, but it's good enough if there's nothing else I guess

1567974975
Yardanico
I think TabNine + zig-lsp + vscode right now is the most you can get for Zig

1567974979
gonz_
What could be interesting and that I haven't actually explored is to let it loose on big code bases in a language to soak up all the idioms and then you use it for yourself.

1567974999
gonz_
And you'll be getting suggestions for common ways to express stuff (maybe).

1567975009
gonz_
Like I said, I haven't really checked how well that'd work.

1567975023
Yardanico
gonz_: I'll try it right now

1567975033
gonz_
I did open up a few Haskell open source projects up at some point and then coded myself and it did have some impact.

1567975069
gonz_
But the biggest impact I saw at the time was when I was writing boilerplate DB migration scripts in Elixir and it actually autocompleted entire sections for me.

1567975075
Yardanico
damn TabNine deep learning model is 684mb

1567975110
gonz_
It could usually guess at what the next thing I was going to write. So it's pretty good for boilerplate stuff.

1567975113
Yardanico
and you can actually enable sending your code to their servers for GPU-powered completion (although it's off by default which is nice)

1567975126
Yardanico
well, they say they remove it after the query, but who knows :D

1567975135
gonz_
Yeah, nah :D

1567975304
Yardanico
hm, their binaries actually use musl which is nice

1567975503
gonz_
It's a pretty neat project and I hope they do well. I ended up not using it after a while when I first tried it because it clobbered all other auto-completion, but I figured now that with zig I really only have some basic editor word completion anyway.

1567975633
Yardanico
I think that if they get enough money they can train their model on the entire GitHub database

1567975648
Yardanico
since it already exists in google BigQuery

1567976072
Yardanico
LOL "In recognition of the fact that TabNine could not exist without the Rust ecosystem, TabNine's paid features are always enabled when completing Rust code."

1567976176
Sahnvour
you-complete-me + language-specific tools also does a great job

1567976926
Snektron
is it me or does setOutputDir not work anymore?

1567977171
Tetralux
I just discovered what I think was the commit that broke the fast parseFloat code I wrote: 42cc4a406bd4d037f4203fa2ebca2853db33c780

1567977198
Tetralux
On this commit, 11ns. Next commit forwards: 144ns.

1567977329
Tetralux


1567977504
scientes
ughhh, changes like renaming bigint_as_unsigned to bigint_as_u64 are really annoying for maintainers of PRs

1567977531
scientes
it means i have to build every patch when i rebase

1567977582
Tetralux
At least you're doing it on Linux where building takes 30 seconds.

1567977591
Tetralux
On Windows it can take upwards of 2 minutes.

1567977767
scientes
well I just rebuild zig0

1567977773
scientes
user-mode takes too long

1567977968
Yardanico
what is the current state of networking and threading/concurrency in zig?

1567978076
scientes
Yardanico, needs to be implemented

1567978095
Yardanico
scientes: so no http requests in pure zig (without C libs) for now?

1567978106
scientes
I'm pretty sure coroutines got merged

1567978119
scientes
so it can now be implemented correctly (and not the lame C way)

1567978209
fengb
Yeah async is in, andrewrk is still working on bugs and primitives like event loos, channnels, etc.

1567978701
Tetralux
So...................

1567978703
Tetralux
Fun story.

1567978800
Tetralux
If you comment out std/mem.zig:342, my code runs 13.5 times faster.

1567979013
scientes
Tetralux, well yeah, that really should use @memcmp

1567979025
scientes
or whatever we call the llvm intrinsic

1567979057
scientes
or actually, @bcmp

1567979128
Tetralux
This is insanity. Checking if two pointers are equal vs that much speed degredation!

1567979139
Tetralux
That doesn't seem right at all.

1567979150
scientes
Tetralux, it makes prefect sense

1567979167
scientes
thats what happens if the branch predictor doesn't work

1567979238
Sahnvour
why would it not work when comparing the pointers, but work when comparing the data ?

1567979259
scientes
it doesn't work either times

1567979266
Sahnvour
Tetralux: did you identify what slice comparison takes longer in your code ?

1567979270
scientes
but failing twice is much worse than failing once

1567979278
scientes
also if you sort the data the branch predictor can work better

1567979283
scientes
in many cases

1567979285
Tetralux
There's only two mem.eqls in the code.

1567979290
Tetralux
Both are at the top

1567979297
Tetralux
They check for "inf" and "nan"

1567979312
scientes
Tetralux, you can't check for nan with mem.eql

1567979339
Tetralux
scientes: We're parsing strings; if the strings compare to "inf" or "nan" then it returns the appropriate floating point value.

1567979345
scientes
ohhhhhh

1567979346
Tetralux
Otherwise it actually parses the string.

1567979376
Sahnvour
well obviously in that case, checking for pointer equality is not going to help

1567979377
Tetralux
Basically, the ptrs will not ever be equal, because we're comparing a string literal with the given slice.

1567979389
scientes
Tetralux, it would be faster if you just checked if the first character is a number

1567979405
Sahnvour
but still, I'm a bit puzzled by such a degradation

1567979413
Sahnvour
you should compare the generated code

1567979447
Tetralux
scientes: Maybe, but it evidentally didn't matter before.

1567979454
Tetralux
Sahnvour: Also yes.

1567979471
Tetralux
Like - this is the worse kind of footgun, at the very least.

1567979485
Tetralux
Futher, I checked godbolt. I cannot find any obvious difference.

1567979493
Tetralux
But I suck at using godbolt for diffing machine code.

1567979507
Tetralux
They seem to have removed the ability to even bring up the diff.

1567979517
Snektron
> That doesn't seem right at all.

1567979517
Snektron
Without context because im lazy, this screams `noalias`

1567979567
Tetralux
Snektron: Can't use noalias on mem.eql unfortunately, since they could

1567979598
Sahnvour
besides, your code seems to be parsing the same float again and again, so I would expect the branch predictor to be just fine in learning that

1567979629
scientes
there is no need for noalias on memcmp anyways

1567979645
scientes
cause it doesn't change anything

1567979733
Sahnvour
how up to date is godbolt with trunk zig ?

1567979775
scientes
Sahnvour, it builds it often enough

1567979794
Sahnvour
cool

1567979798
scientes
oh rather

1567979804
scientes
it downloads it from ziglang.org/downloads

1567979813
Sahnvour
that's automated ?

1567979816
scientes
yeah

1567979821
scientes
ziglang builds every commit

1567979827
scientes
its part of the CI

1567979834
scientes
CI uploads to ziglang.org

1567979853
Tetralux
I just realised that I wasn't actually doing it right when I checked on godbolt before.

1567979862
Tetralux
I can't even run my example code in 0.4 because it uses std.time.

1567979872
Tetralux
So I can't use godbolt to diff it anyway.

1567979924
Tetralux
Also, Zig does not seem to have @memcmp.

1567980034
scientes
I had a patch, but I never polished it

1567980041
scientes
to do stuff related to that

1567980043
Snektron
Tetralux: just copy memcpy

1567980055
Snektron
actually, maybe there should a non-overlapping version of memcpy

1567980060
Tetralux
know where it is?

1567980066
scientes
Snektron, that is called memmove

1567980069
Snektron
i mean it should be added

1567980078
Snektron
sorry, i meant memcmp

1567980134
Sahnvour
Tetralux: first things first, you should benchmark on strings that are not easily known to the compiler, in your example it's able to unroll `parseFloat` based on 4.77777777

1567980188
scientes
cool, SIMD PR updated

1567980202
scientes
with a new feature

1567980203
andrewrk
thanks scientes. I will definitely make an attempt to get that merged before the release

1567980348
Tetralux
Sahnvour: I'm pretty sure that's not it.

1567980360
Tetralux
But just to be sure I generated a random string of digits.

1567980381
Tetralux
If I remove the line, it takes 10ns.

1567980414
Sahnvour
it is, take a look at

1567980525
Sahnvour
it's basically iterating over your number string (`__unnamed_3`)

1567980548
Sahnvour
incrementing the offset with a couple instructions each time

1567980563
Tetralux
Yeah - seems unrolled to me.

1567980571
Tetralux
But even if I make it use random numbers

1567980575
Tetralux
It still only takes 12 ns.

1567980648
Sahnvour
can you try with the additional pointer comparison, but calling mem.eql as @inlineCall ?

1567980678
Tetralux
Hmmm.

1567980695
Tetralux
I think using random numbers means you have that pointer comparison and it doesn't slow it down.

1567980716
Tetralux
Here's how I'm doing it

1567980716
Tetralux


1567980728
Tetralux
(Bad indentatio)

1567980732
Tetralux
indentation*

1567980816
Sahnvour
I'd init the prng with current time, to be really sure the optimizer can't see the digits it will generate

1567980887
Tetralux
Firstly

1567980896
Tetralux
Just tried with time.timestamp as the seed

1567980904
Sahnvour
I'm out of time now, but it would be interesting if you can get an assembly comparison with the smallest possible repro

1567980907
Tetralux
Still 12ns without the check, and >100 with it.

1567980931
Tetralux
I'm gonna try what you suggested with inlining it.

1567980971
Sahnvour
also maybe it chooses to unroll it by seeing it's fixed length, and the actual content of the string doesn't matter that much as long as it's short enough to be worth unrolling

1567981029
Tetralux
OOooo

1567981031
Tetralux
So

1567981036
Tetralux
I realised that I was checking the wrong example

1567981039
Tetralux
But

1567981043
Tetralux
If I have the check

1567981046
Tetralux
And don't use string literals

1567981049
Tetralux
(randomly generate)

1567981051
Tetralux
Then it's fast.

1567981089
Tetralux
But if I do use literals, then it's slow with the mem.eql ptr check.

1567981217
Tetralux
Inlining the call to mem.eql does NOT make it any faster.

1567981550
gonz_
Ah, this chat log is fantastic

1567981565
Tetralux


1567981585
Yardanico
how do I actually LINK a .a library? trying to do "const lib = b.addStaticLibrary("libui", null);" and then "exe.linkLibrary(lib);" fails with "libui: linker needs 1 or more objects to link"

1567981620
Tetralux
Does it work if you just .addObject("libui.a") ?

1567981639
Tetralux
I've never used any of that, but I seem to recall this question coming up before.

1567981667
Tetralux
gonz_: XD

1567981671
Yardanico
Tetralux: "reached unreachable code"

1567981681
Yardanico
"/usr/lib/zig/std/build.zig:1606:15: 0x246729 in std.build.LibExeObjStep.addObject (build)"

1567981732
gonz_
Isn't `addStaticLibrary` for creating one in your project, from your source?

1567981791
Yardanico
gonz_: then what's the one for linking with .a library? :D

1567981816
gonz_
I'm looking through `std.build` to see

1567981818
Tetralux
Maybe .addObjectFile ?

1567981833
Tetralux
(passing the path to the .a)

1567981861
Tetralux
There's also .addLibPath too if that doesn't work :D

1567981925
Yardanico
Tetralux: addObjectFile seems to be it

1567981931
Tetralux
Okay good

1567982316
Tetralux
We really should put all these details somewhere so we don't have to search for it every time.

1567982318
Tetralux
Or better yet

1567982323
Tetralux
Make it blatantly obvious.

1567983434
Yardanico
damn, I managed to run libui controlgallery example from Zig

1567983480
Yardanico
although the raw C syntax for using it is far far far from perfect -

1567983494
Yardanico
but zig translate-c is very useful anyway

1567983741
gonz_
If nothing else it can provide a way to build better ways to interact with a lib

1567983757
Yardanico
well yeah

1567983759
scientes
does anyone have cannonlake hardware I can test on?

1567984176
Yardanico
also, on a good note - zig in release-fast mode is only 16kb (168 vs 152kb) bigger than original controlgallery built in release mode (well they dynamically use GTK libs anyway)

1567984223
Yardanico
ah nvm lol, after stripping both binaries zig binary is actually smaller by 4kb

1567984463
Snektron
why is @byteOffsetOf giving me invalid values

1567984593
Snektron
ah

1567984603
Snektron
packed structs don't work with @byteOffsetOf

1567984617
Snektron
sometimes

1567984710
Snektron
oh boy

1567984713
Snektron
this is a fun one

1567984778
Snektron


1567986415
Snektron
this is really annoying

