1568595715
Tetralux
fengb: ?

1568595762
fengb
It’s hard to accidentally pass in the wrong value

1568595783
Tetralux
If that really is the reason, that should definitely be commented.

1568595796
Tetralux
And indeed, I'm amazed it's not if that is the case.

1568595799
Tetralux
But also

1568595802
fengb
I’m just guessing >_>

1568595814
Tetralux
That smells like a missing feature.

1568597018
Tetralux
Also, considering the rename for the function in #3037; I'm trying to decide on what the name should be for an iterator that is able to remove elements from the container, versus the one that cannot.

1568597047
Tetralux
Assuming that .iterator should not be able to remove, which I'm not really sold on, but, there's been some resistance.

1568597061
Tetralux
I also thought a little about this when I first made the PR a month ago

1568597073
Tetralux
Short version: iteratorMut.

1568597094
Tetralux
I think it's also pretty important for the name to be pretty close to the normal one: iterator.

1568597173
Tetralux
Personally, I think the assertion of "I specifically do not want to be able to remove anything from this" is better than "I specifically want to [...]"

1568597241
Tetralux
However regardless, if it is necessary to change it in order to get it into 0.5 in it's otherwise current form, anyone have any suggestions for names?

1568603359
mikdusan
Tetralux: u29 i think because llvm docs `1 << 29` is the max alignment

1568603856
bgiannan
Tetralux, i just found myself needing that iterator this week-end

1568603922
Tetralux
bgiannan: A handy tool, ain't it? :p

1568604243
bgiannan
Tetralux, was used to how `pairs` works in Lua

1568604272
bgiannan
Tetralux, would be useful for HashMap too

1568604289
bgiannan
which actually was the use case i had

1568604339
Tetralux
Removing from a map while iterating?

1568604342
bgiannan
yes

1568604367
Tetralux
Interesting.

1568604412
bgiannan
what you would get i guess is a KV with a value potentially null

1568604438
Tetralux
Why's that?

1568604444
bgiannan
so you iterate over the set of keys as they were at the start

1568604465
bgiannan
say you remove a key you haven't reached yet

1568604483
bgiannan
when you get to it you just get a null value which tells you that key doesn't map anything now

1568604493
Tetralux
Ah, I gotcha

1568604494
Tetralux
Hmm.

1568604513
Tetralux
You wouldnt be able to tell between a null value in the map though.

1568604520
bgiannan
yeah

1568604526
bgiannan
and thinking about it you don't need that

1568604538
bgiannan
you just need to skip the dead keys

1568604557
Tetralux
Simplest would prob be just to make it remove independant of the iterator.

1568604567
Tetralux
Just like  #3037.

1568617030
telemach
Hey folks, found some time to play with Zig again. Doing basic exercises and hit unexpected (for me) thing. I do fn LinkedList(comptime T: type) type { const Self = struct { ... }; return Self; }

1568617063
telemach
so far so good, but when I try to reference Self in its methods zig complains

1568617079
telemach
though similar toplevel declaration works

1568617177
telemach
is it expected? any workarounds besides using LinkedList(T)?

1568619479
stratact
telemach: may we see a pastebin of the errors?

1568619862
telemach


1568620551
stratact
telemach: I left a comment in your gist

1568620606
telemach
thanks for the comment, TIL @This()

1568621082
stratact
Ah, I thought recognize your avatar from somewhere. You're one of the lead plugin designers for Kakoune?

1568624045
tencho
Hi, I've started learning zig yesterday. I cannot figure out why the following does not compile:

1568624050
tencho
1 const std = @import("std");

1568624051
tencho
4 pub fn main() void {

1568624051
tencho
7     return;

1568626466
euantor
tencho: Can you post your full code on gist.github.com or pastebin.com or something? It seems to be cut off

1568626698
tencho


1568626799
tencho
ops.. the compiler version in the above link is wrong, but if you change it to 0.4, it will give another error

1568626862
tencho
the actual error that I don't understand

1568642317
fengb
Use the nightly build. 0.4.0 is really outdated now

1568642341
fengb
And it'll give you a better error

1568642397
fengb
`cannot store runtime value in type 'builtin.Declaration'` type info is a purely comptime construct and this is trying to store it as runtime

1568643685
tencho
I still don't get it. Isn't every type a "comptime construct" ?

1568643783
fengb
I mean it doesn't exist at runtime

1568643792
fengb
There's no memory definition for types

1568643821
fengb
So you can't just store it into a 'var'. If you want the data, you'll have to manually pull out the fields into a separate struct

1568643926
fengb
There's a different way to build a comptime array of decls. Lemme see if I can find it

1568643951
Tetralux
By 'types', fengb means TypeInfo in general; for the record, I consider this a bit of a mistake on Zig's part, that TypeInfo is only available at compile time.

1568643974
Tetralux
It's in the name of simplicity.

1568643986
Tetralux
But yes, that is how it works right now.

1568644035
Tetralux
Basically, the problem is `g_d`.

1568644055
Tetralux
You cannot store TypeInfo of any kind, Declaration or otherwise, directly in a runtime-known value.

1568644095
fgenesis
what about const Type = comptime Maketype(...) or something like that

1568644113
Tetralux
Depends on what Maketype does.

1568644117
mq32
fgenesis: types are always comptime values

1568644123
mq32
you cannot have runtime type information

1568644127
Tetralux
.. and that's why ^ :p

1568644133
fgenesis
ah, then i misunderstood the question

1568644164
fgenesis
was still looking at

1568644172
tencho
It works for some of the fields , but it won't work for unions ?!?

1568644236
fengb
Const is fine. The compiler would convert const into comptime known. It's the var that's a big problem

1568644299
Tetralux
fengb: Which const?

1568644305
Tetralux
Only L7 changes.

1568644322
fengb
const foo = anytype

1568644351
Tetralux
Sure, but I'm not sure how that applies to the example xD

1568644353
fengb
You can't `var foo = anytype` because vars are runtime

1568644380
Tetralux
Oh - Sorry - I thought you meant that something changed to being a const in the second example.

1568644386
Tetralux
You were being more general than that.

1568644435
Tetralux
This compiles though

1568644445
Tetralux
And it's not entirely clear to me why.

1568644458
Tetralux
When this does not: g_d[idx]= decl;

1568644464
fengb
Because the names are just strings and extractable

1568644496
Tetralux
Yeah, but you're assigning a comptime-known field.

1568644504
Tetralux
.. in a var

1568644511
Tetralux
.. that has a type only known at comptime.

1568644516
Tetralux
Why are you allowed to reassign it?

1568644518
fengb
That's not the problem

1568644538
fengb
You can't make a copy of TypeInfo because it doesn't exist in the runtime definition

1568644553
fengb
Whereas strings are fine because they're just strings

1568644580
Tetralux
Let me put this a different way.

1568644580
fengb
So it's just an array of strings, and we just made a few literal copies

1568644594
Tetralux
What's the type of g_d at runtime?

1568644642
fengb
It's a compile error

1568644647
fengb
It can't exist

1568644648
Tetralux
It is not.

1568644651
Tetralux
See the example I posted.

1568644653
Tetralux
It compiles.

1568644684
fengb
Oh...

1568644742
tencho
trying to make a better example:

1568644756
fengb
So my guess is... the struct is defined, but any actual info is inaccessible

1568644772
fengb
.name = .name works because it's a comptime string and inlined

1568644809
Tetralux
If I try to print out g_d[0].name, it works, and prints 'mem', incidentally.

1568644819
fengb
So on compile, it becomes `.name = "Dwarf"` etc

1568644819
Tetralux
But trying to print out the actual struct value does not, requiring comptime.

1568644830
Tetralux
fengb: Indeed.

1568644831
Tetralux
However

1568644835
fengb
Yeah the struct data is inaccessible

1568644846
fengb
And the compile doesn't know how to inline it

1568644849
Tetralux
You're assigning that string literal into a struct value that is comptime only.

1568644852
Tetralux
.. but is in a var.

1568644858
Tetralux
This makes absolutely no sense.

1568644863
Tetralux
Absent of magic.

1568644866
Tetralux
Which Zig hates :)

1568644885
fengb
My guess is the struct definition is fine

1568644898
Tetralux
But the struct definition is TypeInfo.

1568644905
Tetralux
.. which is only allowed at comptime.

1568644906
fengb
But the actual type data can't be accessed at runtime, and also cannot be inlined

1568644930
fengb
Retracting my previous statement, I'm saying the definition just exists, not just at comptime

1568644939
fengb
But the data is only available at comptime

1568644960
fengb
So when trying to assign the struct, it'll bomb because the data is neither accessible nor inlineable

1568644980
fengb
But you can manually wire in the fields

1568645000
Tetralux
None of this makes any sense to me at all.

1568645015
Tetralux
Either you should have full access to all type info in both contexts.

1568645017
Tetralux
Or none at all.

1568645029
Tetralux
(.. in which case you have to copy it into a runtime stored variable.)

1568645030
fengb
The struct is avaialbe in both contexts

1568645036
fengb
But the data is only comptime

1568645059
Tetralux
Meaning that you

1568645060
fengb
So you can define a struct, but you can't use the data, unless you finangle the data to be runtime knowable

1568645068
fengb
Yeah looks like

1568645074
Tetralux
That makes even less sense.

1568645077
fengb
I'm just piecing this together too :P

1568645095
Tetralux
"You can declare a variable of type TypeInfo, but access it's fields"

1568645101
Tetralux
.. is what I hear when you say that xD

1568645112
Tetralux
And yeah, I appreciate that ;p

1568645143
fengb
You can't copy the struct at runtime

1568645156
fengb
But you can introspect all the data, so you can access its fields just fine

1568645182
fengb
So arguably the fix is allow for inlining at runtime

1568645220
fengb
Because I think that's the blocker that's preventing the assign

1568645222
Tetralux
I am thinking more and more that you should just be able to access all of TypeInfo at runtime and be done with it.

1568645228
Tetralux
This is way too difficult to understand.

1568645255
fgenesis
yes

1568645286
fgenesis
i mean if it's not done and the data are unreferenced it'll be optimized away anyway

1568645387
Tetralux
Probably not in most cases though, because you'd probably use it.

1568645400
Tetralux
I can think of a good example of the top of my head.

1568645424
tencho
I think the problem is because of fields of type 'type'

1568645432
Tetralux
For weeks I've been banging my head against a wall trying to figure out how to arcitect the decoding/encoding of CBOR. It would be solved in minutes with RTTI.

1568645458
Tetralux
tencho: Maybe.

1568645461
fgenesis
just thinking, assuming you'd write a sorta universal serializer for a struct that generates the right thing at compime --> in that situation you wouldn't need any rumtime stuff, imo?

1568645468
mq32
Tetralux, what's your problem with CTTI?

1568645478
mq32
(why do you need RTTI?)

1568645553
Tetralux
mq32: Essentially, I want a heterogenous list of stuff.

1568645569
Tetralux
And what type each thing is, has it's own behaviour.

1568645608
mq32
const CBORValue = uniom(enum) { integer : i64, string : []u8, … };

1568645610
mq32
?

1568645618
Tetralux
Already have that.

1568645620
mq32
for deserialization

1568645625
mq32
for serialization you can introspect the serialized object

1568645654
Tetralux
The problem is, you may not have enough bytes to completely read an object.

1568645694
Tetralux
I haven't worked on it for over a week because it was getting me down, so I may not completely remember.

1568645716
Tetralux
But, I know how I'd do it if I had RTTI.

1568645726
Tetralux
I do not see a neat solution without it.

1568645765
mq32
huh

1568645840
fengb
Oh hey,

1568645963
fengb
I think we need more subtle blog posts like this :)

1568646208
mq32
a bit offtopic: has someone here experience with both WASM and WebSockets?

1568646232
fengb
Uh... I've done both separately :P

1568646322
mq32
i want to do some stuff with both technologies

1568646351
mq32
i read some stuff about WASMer.io and it looks like it's a cool replacement for Lua (for scripting in games or similar)

1568646488
mq32
and now i wonder if i could "port" my UI system with emscripten to wasm+websockets instead of normal UDP sockets

1568646496
fengb
I don't know much about wasmer... but it looks like a runtime for wasm only. WebSockets is a browser technology and isn't a part of the spec

1568646504
mq32
yeah, i know

1568646518
mq32
but i need to glue websockets somehow into wasm (or access them from there)

1568646526
fengb
Oh

1568646531
mq32
would like to have as little JS as possible :D

1568646542
fengb
I'd expect emscripten to have glue to make it easier

1568646659
mq32
mhm

1568646664
mq32
have to look that up some time

1568646680
mq32
sadly i couldn't find a single easy websocket library

1568646688
mq32
that has the same "easyness" as the JS api

1568646696
Tetralux
Wait

1568646701
Tetralux
You use UDP sockets for a UI?

1568646712
mq32
Tetralux, not yet, but i will :D

1568646737
mq32
well, UDP is just a layer between, but just replace UDP by "realiable datagram transport layer"

1568646740
Tetralux
I'm immediately suspicious as to why a message bus is not faster.

1568646770
Tetralux
Or a msg bus over UDP if you wanted it to be remotely viewed for that matter.

1568646779
mq32
because a message bus is hard to implement remotely

1568646784
fengb


1568646796
Tetralux
Can you elaborate a little on that?

1568646855
mq32
the UI uses a really non-standard way of doing things

1568646874
mq32
it's more similar to HTML/CSS than to Qt or Windows Forms

1568646893
mq32
but also more similar to WPF than HTML

1568646905
Tetralux
Sounds like the problem is more arctitectural than technical?

1568646927
mq32
the UI system needs a reliable datagram transport layer to be used

1568646951
mq32
because it is message based API, not function based API

1568646975
Tetralux
Message-based API

1568646978
Tetralux
You mean like...

1568646985
Tetralux
shared memory or a channel? xD

1568646998
mq32
channel

1568647009
mq32
SHM would not work over network/serial line/... :D

1568647028
gonz_
It is indeed hard to share memory over a network

1568647034
Tetralux
A message bus would though ;)

1568647085
mq32
what is a "message bus" for you?

1568647108
Tetralux
Conceptually, it's a pipe you pop off messages and handle them if there is any.

1568647119
fgenesis
something on four wheels that delivers mail and packages

1568647132
Tetralux
It can in practice, be a stack/array, channel.

1568647142
Tetralux
Or on top of a socket.

1568647147
Tetralux
Or file, for that matter.

1568647152
mq32
yeah, that's probably the right wording then

1568647160
Tetralux
Usually, shared memory or array though.

1568647164
Tetralux
(for speed.)

1568647170
fgenesis
what about reliability

1568647178
Tetralux
Reliability?

1568647186
Tetralux
Of an array? :thinking:

1568647218
mq32
Rowhammer says your array content is not reliable!

1568647240
Tetralux
Better be! Literally nothing would work without it XD

1568647259
kristoff_it
fengb: :D I think once Andrew gets enough budget for a marketing team I'll have a good argument for getting hired haha

1568647272
mq32
Tetralux, lookup rowhammer attack :D

1568647316
mq32
kristoff_it, nice article again :)

1568647317
fgenesis
let's not assume cosmic rays ok

1568647337
gonz_
Tetralux: "Usually" shared memory seems misleading.

1568647349
gonz_
Shared memory message passing is in itself pretty superfluous

1568647362
mq32
but Tetralux: i wanted to implement the UI transport layer agnostic, but right now i don't care :D

1568647362
gonz_
Nothing really is improved by sharing memory but passing messages

1568647369
fgenesis
whatever sort of 100% reliable channel you have doesn't matter if your hardware is still prone to derp every now and then, even if it's rare

1568647371
gonz_
You pass messages because you have a distributed system

1568647381
mq32
three step program: 1) make it work, 2) make it right, 3) make it good

1568647401
fgenesis
4) rewrite it because verything sucks and software was a mistake

1568647404
mq32
:D

1568647419
mq32
fgenesis, want the challenge to implement a system client for AVR if i'm far enough with the API?

1568647422
mq32


1568647460
fgenesis
looks like i won't get very far with this anytime soon because of life and everything, you know

1568647465
Tetralux
gonz_: I'm not sure I entirely get your point :p

1568647469
fgenesis
but yes it would be nice to learn zig with this eventually

1568647484
Tetralux
mq32: I'd consider a message queue / bus.

1568647492
fgenesis
mq32: on my list of things to do once this phd-mess is over ;_;

1568647499
Tetralux
And then just make the messages POD so that you can easily serialize them over a stream.

1568647518
fgenesis
make messages xml

1568647523
Tetralux
NOPE.

1568647530
fgenesis
nothing can go wrong with plaintext!

1568647543
fgenesis
(except EBCDIC)

1568647545
Tetralux
Never mention XML in my presence again

1568647551
Tetralux
(unless riffing on it.) :)

1568647575
gonz_
My point is that there's no real upside to pretending to have a message protocol between systems if you're sharing memory.

1568647581
mq32
Tetralux, nah, POD is too large :D

1568647584
Tetralux
Honestly, YAML is better if you're editing it manually, in my experience.

1568647593
fgenesis
ASN-1

1568647598
Tetralux
Damn-sight easier to read.

1568647602
fgenesis
send as teletext-string

1568647624
Tetralux
gonz_: I mean, "message bus" can take many forms.

1568647630
mq32
i'm using some encoding similar to the one used in protobuf (so smaller integers take less space)

1568647642
Tetralux
If you used shared memory, you could have an atomic or whatever to indicate if a message was ready, etc.

1568647645
Tetralux
instead of having an array.

1568647647
mq32
also most data transferred is var-sized, so POD types would make parsing actually harder

1568647650
fgenesis
mq32: using zigs variable bit-integers? :D

1568647661
mq32
fgenesis, no, it's written in C++

1568647681
Tetralux
mq32: I don't really see why.

1568647711
mq32
Tetralux, designing a system to take as less space as possible to make it suitable for µC

1568647735
mq32
target space would be to probably require 32k HEAP and some extra RAM except for the heap

1568647751
fgenesis
should be doable in 2k

1568647759
Tetralux
If a message is variable length, you have a tag to say what kind of message it is; for variable length fields, encode the length as an int that preceedes the bytes of the field value?

1568647772
mq32
but even my ints are variable-length ;)

1568647787
Tetralux
WHY WOULD YOU DO THAT TO YOURSELF

1568647792
mq32
because space matters!

1568647805
fgenesis
or include a special kind of message that carries the bit-widths of types used later in the message, so you can change them at any time when convenient

1568647809
Tetralux
Surely for transferring over the wire, it's okay?

1568647821
mq32
yes, for storage of serialized data in RAM as well

1568647842
Tetralux
You only are storing the latest message in memory in encoded form though?

1568647859
mq32
nope, i have to store the current UI layout, all resources and data required by the UI in RAM

1568647864
Tetralux
The first thing you do is encode it into the struct you originally had.

1568647868
Tetralux
Then you store that.

1568647871
Tetralux
( the struct )

1568647871
mq32
resources is stuff like "UI layout", "images", ...

1568647893
Tetralux
You don't have enough bytes to store one encoded message? :)

1568647907
fgenesis
send the entire UI as a compressed, pre-rendered image

1568647918
mq32
not enough space for a fullscreen image

1568647927
kristoff_it
mq32: thanks! :)

1568647934
fgenesis
use my special coded that doesn't need memory

1568647936
Tetralux
mq32: Could send it in parts ;p

1568647937
mq32
right now, my UI layout for a calculator UI takes about 100 bytes

1568647942
Tetralux
Quadrants :)

1568647953
Tetralux
How much RAM you got?

1568647961
mq32
32k HEAP, 32k static RAM

1568647982
mq32
(well, remove everything from static ram that is required for heap management)

1568647986
Tetralux
If you use more than that, I'd be staring at all your XML you have to store.

1568648001
mq32
what XML?

1568648017
Tetralux
That's the correct response ;p

1568648033
mq32
but i have a custom binary representation for GUI layouts :D

1568648036
mq32
similar to ...

1568648046
mq32
well, UI trees

1568648048
Tetralux
ó.ó

1568648074
mq32
imagine simplified, binary encoded HTML :D

1568648087
fgenesis
wrapped in xml for convenience

1568648094
Tetralux
This is unimaginable.

1568648098
Tetralux
I totally understand.

1568648112
mq32
for each UI widget, i need at least 3 bytes :D

1568648115
Tetralux
I feel like you don't entirely need that.

1568648124
Tetralux
3B seems reasonable.

1568648127
mq32
1 byte type information, 1 byte property count, 1 byte child count

1568648134
mq32
well

1568648144
Tetralux
How many UI elements you got?

1568648154
Tetralux
I swear to god if you say > 1000.

1568648158
mq32
you mean widget types?

1568648169
Tetralux
Instances*, but yes.

1568648181
fgenesis
over 9000 buttons on a 320x200 touchscreen probably

1568648184
Tetralux
.. instance

1568648185
mq32
instances? dunno, the system supports over 9000 :D

1568648190
fgenesis
the way i know mq32 :D

1568648214
mq32
my format supports all that can fit into target system RAM :D

1568648236
Tetralux
If I walk up to this display, and try to do something reasonable

1568648241
Tetralux
How many UI elements will I see.

1568648259
Tetralux
And how many of them do I only need if I want to do something rare and specific?

1568648284
mq32
depends on the kind of application

1568648295
Tetralux
Oh, we're talking general-case?

1568648297
fgenesis
can we agree that mq32 is totally not over-optimizing

1568648298
mq32
yeah, sure

1568648305
fgenesis
maybe we need to do this first

1568648312
Tetralux
fgensis: Waaaay ahead of you ;)

1568648319
mq32
fgenesis, there isn't much to optimize in the format anymore :D

1568648324
mq32
seriously .D

1568648327
fgenesis
could be done in 7 bits tho

1568648340
mq32
it actually does and uses the 7th bit for different information

1568648347
mq32
so, at least for property information

1568648350
Tetralux
mq32: How about, if you only load into RAM like two "pages" (windows on Windows) and then query the network for other windows you want to display?

1568648359
Tetralux
Or get it off SD card or whatever/

1568648375
mq32
target platform has no SD card and a

1568648388
fgenesis
mq32: still your heater control or something else this time?

1568648390
Tetralux
Ah - so remoting into this thing is worthless to begin with? xD

1568648391
mq32
yeah :D

1568648403
mq32
but the idea is to have the UI system be

1568648411
mq32
develop desktop apps and embedded apps with the same UI system

1568648419
mq32
and allow remote use

1568648429
fgenesis
just use Xlib then

1568648438
mq32
so have an embedded IoT device connect to your smartphone and provide a UI you can control the device with

1568648448
Tetralux
Well - on desktop, message bus is fine.

1568648455
mq32
for desktop→desktop, yes

1568648456
Tetralux
On embedded, I'd say it still is.

1568648472
mq32
the UI system is just a smaller part of a larger project

1568648473
Tetralux
But you obviously need to be a lot smarter about it.

1568648484
mq32
and i couldn't find a single ui system doing the stuff i need

1568648493
mq32
(or networking library, lol)

1568648498
fgenesis
somehow it's always like that, is it not

1568648504
mq32
well

1568648518
mq32
how much distributed, ad-hoc network stuff do you know that actually is simple and works? :D

1568648536
Tetralux
Just how slow is this IO you speak of?

1568648538
mq32
and UI that can work with ad-hoc displays that

1568648540
Tetralux
115200 baud? :)

1568648554
mq32
actually, it's 230400!

1568648561
Tetralux
Oh excellent!

1568648564
mq32
but polling-based :D

1568648579
Tetralux
I don't know what that means but it probably bad.

1568648587
mq32
so, it's a real bus with multiple participants and only a single host that has to poll clients for messages

1568648601
mq32
similar to RS485 networks

1568648609
Tetralux
The host has the display?

1568648618
Tetralux
Or the clients?

1568648631
mq32
it depends™

1568648673
Tetralux
I think message bus is still the simplest solution.

1568648706
mq32
can you send me "more information" on "your" message bus?

1568648714
mq32
i cannot find anything on google except for overkill enterprise solutions

1568648759
fgenesis
mqtt?

1568648769
fgenesis
even starts with mq

1568648780
fgenesis
so it is literally perfect right there

1568648792
companion_cube
redis? :p

1568648792
mq32
does mqtt requires a connection? :D

1568648800
fgenesis
no

1568648807
Tetralux
So, it depends really - when I say "message bus" - the idea is that the approach is the valuable part rather than the implemenation, since that gets adapted to the use case of it.

1568648809
Tetralux
However

1568648810
fgenesis
you just barf things into the network

1568648820
Tetralux
One example of it is the WinAPI PeekMessage interface.

1568648829
mq32
ah

1568648830
fgenesis
aaaaahh you said WinAPI

1568648842
mq32
hey, the winapi is actually quite sane (crossref #demo.ger)

1568648853
mq32
Tetralux, yeah that's probably the thing i will do

1568648884
mq32
i think we talked of the same thing with different names then

1568648907
Tetralux
I figured we might have been :p

1568648930
Tetralux
But yes - the essence is - you have a way to push new messages, and pop off messages in order.

1568648942
mq32
yeah

1568648949
mq32
will have to write something for that too :D

1568648949
Tetralux
Be it a stack implemented as an array, shared memory, stream etc.

1568648963
mq32
fgenesis, mqtt won't cut it, it requires a central instance

1568649026
fgenesis
fair point

1568649032
mq32
as the UI should be generic purpose, i would just make some interface { fn poll() ?[]u8; fn send(data : []u8) void; }

1568649041
fgenesis
saves you from using mgmt ram in the dumb, attached devices tho, which is nice

1568649065
Tetralux
mq32: What's that the interface to exactly? The socket?

1568649071
Tetralux
Or the message bus? :p

1568649086
mq32
the message bus :D

1568649105
mq32
UI encoded data and tells some broker: "put that away!"

1568649113
mq32
and the broker say: "yeah i've received that blob for you"

1568649235
Tetralux
I might expect messages to be structs.

1568649246
Tetralux
But otherwise, pretty much, yes.

1568649280
mq32
yeah the problem is that all my messages are variable length

1568649455
Tetralux
The first field of each message struct is a u16 that represents it's type.

1568649485
companion_cube
so, you mean a tagged union, right? :p

1568649495
Tetralux
Ehhhh

1568649503
Tetralux
More that you read a fixed size integer first

1568649514
companion_cube
isn't that what the tagged union is about? :)

1568649518
Tetralux
That tells you how to read that kind of message.

1568649529
Tetralux
In that it tells you the structure.

1568649530
companion_cube
tbh sounds like a serialization format would be cleaner

1568649538
Tetralux
That

1568649547
Tetralux
Quite literallly

1568649555
Tetralux
Except that the type part is encoded into the struct.

1568649570
mq32
for me, structs have always fixed size

1568649586
mq32
even if distinguished by a type ID

1568649630
mq32
something like { type: u32 = 1, length : u32, payload : [length]u8 } would not be a struct in my world :D

1568649753
Tetralux
Indeed - the struct would be `payload: []u8`

1568649771
Tetralux
But you serialize by writing a u32 length or whatever followed by that number of bytes.

1568649784
Tetralux
And that's how you deserialize at the other end.

1568649792
Tetralux
Read the length, read that many bytes.

1568649815
mq32
yeah that part is clear

1568649822
mq32
that's how most of my serialization works already

1568649823
Tetralux
Similarly for the message itself, the fields, and what type they are depends on the type of message, which is just a u16 or whatever that you always read first.

1568649868
fgenesis
mq32: just leaving this here,

1568649991
Tetralux
mq32: That's good then :)

1568650047
mq32
my code right now:

1568650133
mq32
uses big-endian encoding, that's why the encoder is not as readable as the decoder :D

1568650235
Tetralux
Seems reasonable at first glance :p

1568650294
Tetralux
A faster option might be to just store numbers the same as the payload

1568650345
Tetralux
Yeah, but varints will not.

1568650347
mq32
so i have that VLI encoding for the length (1 to 5 bytes) and then the binary data

1568650363
Tetralux
Yeah, something like that.

1568650367
mq32
and i don't think that message decoding speed is slow :D

1568650373
mq32
*the slow part of the whole system

1568650383
Tetralux
The first byte tells you how many bytes the length is :p

1568650397
Tetralux
And yeah, if it's fast and works. A comment is good enough I guess.

1568650402
mq32
yep

1568650415
mq32
i have to document all formats anyways some time

1568650424
fgenesis
SOON(tm)

1568650428
Tetralux
I might frown at you for using something that isn't very obvious what it does without a comment but >.<

1568650432
mq32
i'm happy that for most of the data i can actually omit an length specifiers :D

1568650442
Tetralux
Yeah, CBOR has that too.

1568650457
Tetralux
For numbers <=22, it takes one byte.

1568650471
mq32
encoding is []{ type : u8, data : DependsOn(type) } where the array ends with a type=0

1568650471
Tetralux
Kinda like the small-string optimization.

1568650501
mq32
btw, to have something visual we talk about:

1568650512
mq32
that's the current state of the (visual) part

1568650556
Tetralux
Seems alright.

1568650565
daurnimator
Tetralux: you might want to do your CBOR stuff like

1568650566
fgenesis
not enough bling and smoothscroll

1568650575
Tetralux
It's hard to tell how much latency there is from that, but yes.

1568650643
mq32
there is no networking involved yet

1568650657
mq32
also stuff like that will work with zero-frame latency, even with network

1568650665
desperek
how do i get commandline arguments? argc and argv as arguments to main?

1568650688
Tetralux
std.process.args IIRC.

1568650714
Tetralux
Or .argsAlloc if you want a slice of them in memory all at once.

1568650717
desperek
oh, thanks. do i have to read source to do anything btw?

1568650728
Tetralux
Basically yeah.

1568650735
Tetralux
It's easier than it sounds though.

1568650740
Tetralux
CTRL+F is your friend :)

1568650759
desperek
Tetralux, ctrl+f where exactly?

1568650766
desperek
in a spec. file/

1568650767
desperek
?

1568650768
Tetralux
Github.com mainly.

1568650779
Tetralux
Or the search thingy.

1568650809
fgenesis
Tetralux: you know, your answer still isn't very specific

1568650834
Tetralux


1568650872
desperek
We could not perform this search haha

1568650873
Aransentin
Is ?[*c]u8 supposed to be 16 bytes wide? This bit me when porting a C struct to Zig.

1568650906
Tetralux
desperek: You're meant to type something into the box XD

1568650924
Tetralux
But that will search all of zig.

1568650929
Tetralux
Filter for Zig code of course.

1568650929
desperek
theres no box tho

1568650932
Tetralux
Top left.

1568650938
Tetralux
"Search or jump to"

1568650943
tdeo
Aransentin: is it in an extern struct?

1568650953
Aransentin
Yes

1568650957
desperek
aa this one

1568650973
desperek
thanks

1568650976
Tetralux
o7

1568650983
Aransentin
Also doing stuff with it causes the compiler to start dumping it's internal memory to the console:

1568650994
desperek
it is hard though Tetralux

1568651005
fgenesis
Aransentin: awesome!

1568651009
Aransentin
:)

1568651012
Tetralux
duarnimator: Yeah, I considered that. First glance made me think it was a little overly complicated, but I did only glance.

1568651040
Tetralux
desperek: Yeah, if you don't know what something's called, you can only guess the file it's in.

1568651074
Tetralux
I have

1568651084
desperek
:/

1568651095
desperek
why is it so hard

1568651103
mq32
desperek, there was/is a project out there that parses a zig directory and creates a content listing

1568651110
mq32
maybe this is what you search?

1568651137
desperek
mq32, well, i just want to know what function does what really, not specifically searching for things

1568651146
desperek
but i guess thats not yet here .w.

1568651159
Tetralux
Yeah - doc comments are annoying sparse.

1568651162
fengb
Aransentin: pointers should be usize

1568651166
Tetralux
Oh yeah - sidenote:

1568651170
euantor
desperek: I believe you're trying to parse command line args? if so, check this:

1568651172
Tetralux
Made this yesterday.

1568651307
desperek
thanks

1568662052
kuon
Hello. I have an old lightweight UI engine I wrote a few years back for a game project. I am now working on a project of a medical device, and I need a UI/layout engine for it. I looked into what exists (nuklear, imgui...) and I realize my old engine was quite decent and I'd like to revive it. It is now written in C but as it will be used in a medical device, I'd like to rewrite it in a safer language.

1568662072
kuon
I looked in rust, but I have a feeling of "complexity" I cannot pinpoint.

1568662127
halosghost
hot-take: Zig is not ready for high-reliability-required, production-grade applications like medical devices

1568662128
kuon
I know this might seem quite subjective, but I am wondering how stable zig is. Especially it's future. I cannot use a language that will be gone in a few years.

1568662172
halosghost
having said that, I think Zig's future is bright and I look forward to the time I would feel comfortable with Zig being used in applications like that

1568662183
halosghost
(also, I'm not heavily involved with Zig's development)

1568662218
kuon
So you think it is too early? The device would ship around 2021 so there is time for improvement.

1568662280
halosghost
my personal take is that any language created in the last decade is likely too young for the level of reliability I would like to be used for medical devices

1568662289
companion_cube
kuon: if it's in a medical device, have you considered Ada?

1568662294
halosghost
if that's helpful calibration

1568662299
companion_cube
it's been designed for high reliability systems…

1568662324
andrewrk
medical devices is certainly in scope of zig, however it would be irresponsible to use zig for this use case pre-1.0

1568662344
companion_cube
even LLVM would have to be vetted, I think

1568662375
halosghost
and LLVM's not exactly a simple piece of software

1568662396
companion_cube
ahahah wait for Zig to have a compcert backend 🙃

1568662409
kuon
zig uses lvvm? I didn't check that already.

1568662484
halosghost
yes

1568662506
kuon
I guess that's to be expected, because it supporrted a lot of targets very quickly.

1568662539
companion_cube
LLVM is the reason why there's so many new compiled languages

1568662539
kuon
This is not a high availability medical device, that's why I can experiment a bit.

1568662545
halosghost
for a language that has some similarish goals to zig, but doesn't rely on LLVM, take a look at myrddin; note also that myr is even younger than Zig

1568662563
kuon
It's a secondary monitoring solution that will only display some data.

1568662607
halosghost
also, it's possible that myr is dead

1568662611
halosghost
minor detail :P

1568662645
ky0ko
kuon, i'm also working on medical devices, and we generally stick with c/c++ with qt. i don't think zig is mature enough for this even with it only being a secondary thing.

1568662677
ky0ko
not necessarily for reliability reasons, but reproducability reasons - it's important to make sure that in 7 years after release someone can still build the whole software image for your device

1568662698
ky0ko
zig is still actively changing, and you can't make the guarantee that it will be buildable ~10 years from now without changes

1568662705
fengb
Man, in 7 years, I'd have upgraded 3 JS frameworks :P

1568662706
kuon
ky0ko: yeah, the maintainability thing is my main concern.

1568662811
kuon
I've been writing C for 25 years, I want out:P

1568662830
ky0ko
kuon, definitely should be. i'd stick with something that you're sure is still going to be more or less the same in a decade

1568662839
kuon
Been fixing the same kind of bugs for all those years.

1568662865
andrewrk
rust will be ready for medical devices before zig will. they've already started those efforts

1568662868
ky0ko
kuon, i'd be able to recommend rust for this use case despite not generally liking working with it myself. it is

1568662893
kuon
Rust is promising, but after a week trying it, I have some weird feeling it's "too high level".

1568662912
ky0ko
it is definitely more analogous to c++ than to c.

1568663137
kuon
Yeah, that's my feeling.

1568663177
kuon
To be honnest, I was "successful" with rust, I could write what I wanted. But I don't enjoy using it.

1568663252
ky0ko
kuon, yeah, i'm with you there. it is not an appropriate replacement in my opinion and experience

1568663263
ky0ko
kuon, are you running on bare metal, or with an os underneath?

1568663389
kuon
Both. The UI uses a toradex module with linux. And the data module is bare metal.

1568663508
kuon
But the data module is avr based, I don't think I'll be able to use anything else that C on it.

1568663666
ky0ko
i meant on the ui side - i figured the data module would be bare metal. so yeah, you've got some potential options then

1568663779
ky0ko
if you're not afraid of extremely functional languages you might give erlang a shot, it's pretty well tested in the embedded realm (and was designed for it originally)

1568663803
ky0ko
it comes with a wxwidgets ui, and there's some packages written for it for both retained and immediate mode graphics

1568663824
ky0ko
(well really they're written for elixir, but are compatible with erlang as well since they run on the same abstract machine)

1568663877
ky0ko
it's wildly different than c-like languages though

1568663892
kuon
I do use elixir for web apps.

1568663918
kuon
I write them more as a hobby. I didn't think of elixir/erlang for UI apps.

1568663943
kuon
I stumbled on it when I wanted to write a small web based game, I used phoenix.

1568664077
ky0ko
well then if you think that'd work for you i'd say to give it a shot! erlang/elixir is, imo, a fantastic option for embedded stuff. the underlying platform has been around long enough that i don't think you have to worry about future maintainability much

1568664089
ky0ko
the elixir bits are a little different, since that's much newer

1568664099
ky0ko
but it seems to be stable enough

1568664103
kuon
Yeah. I give it a shot.

1568664108
kuon
Thanks for your feedback.

1568664120
FireFox317
Aransentin: regarding your comment on your issue, a null terminated string which can also be null should be described by an optional unknown length pointer: ?[*]u8 or maybe even ?[*]const u8

1568664133
Aransentin
Hmm

1568664151
Aransentin
So what's the point of [*c], then? :)

1568664203
Aransentin
I imagined it was something like if you pass a plain "string" to a [*c] argument the compiler would warn you

1568664235
fengb
[*c] just means it's translated from C source

1568664238
FireFox317
When using zig translate, zig doesn't know whether a pointer points to one thing or multiple things.

1568664260
FireFox317
I think if you read the complete section of the C Pointers on the ziglang docs, you will understand it

1568664303
fengb
null terminated strings/slices/pointers are on the horizon but they don't exist in the language yet

1568664385
Aransentin
Aha. Right.

1568664440
Aransentin
[*c] is optional by default so doing ?[*c] just adds another optional on top, that's why it's 16 bytes

1568664479
Aransentin
(It still shouldn't crash, but now I know why it looked so strange at least...)

1568666207
josuah
zig sound exciting...  but I need to sleep!

1568666244
josuah
sounds*.  I have no choice but to write something in it now...

1568666639
Sahnvour
aren't export variables supposed to work ?

1568667957
nrdmn
I did some pointer arithmetic.

1568668007
nrdmn
Apparently comptime vars of type type aren't actually variable inside while loops

1568669001
andrewrk
Sahnvour, they are but it's not implemented for every type

1568669005
andrewrk
sorry

1568669275
Sahnvour
andrewrk: ha, where is it implemented ? am I right that every exported variable should be visible from the generated C header ?

1568669378
andrewrk
Sahnvour, yes you are right. see ir_analyze_instruction_export for @export. `export` keyword for vars is handled in resolve_decl_var. the fact that they are not unified might be part of the issue

1568669421
andrewrk
I'm also now seeing that the lazy values interacting with variables might incorrectly prevent exporting, if you look at resolve_top_level_decl

1568669428
Sahnvour
thanks, I'll have a look if I find some time

1568669451
Sahnvour
I wanted to do a test with exported variables of extern structs

1568669467
andrewrk
I'd like to do a comprehensive test of export and @export with every supported type

1568669477
andrewrk
that currently does not exist

1568669865
Sahnvour
that would be great

1568669971
Sahnvour
I'm having `@typeInfo(@import("root")).Struct.decls[n].data.Var` reported as a runtime value, looks like a bug ?

1568670487
andrewrk
Sahnvour, yes that is a bug, `type` cannot be runtime

1568670625
Sahnvour
right, thanks

1568670635
Sahnvour
i'll make issues for these

1568670989
nrdmn
andrewrk: does it make sense to have a type "*type" if there are no runtime types?

1568671013
andrewrk
yes

1568671026
andrewrk
it works in comptime code

1568671138
nrdmn
I was wondering if it should

1568671715
andrewrk
nrdmn, why not? it would be more complicated to prevent it from working

1568671919
stratact
andrewrk: I wanted to share an epiphany I had about issue #2885. I haven't done it yet since I  want wait for your mentorship. An idea I had was to instead of passing an []u8, that I could pass an ArrayList(u8) to both deleteTree() and Dir.open() in std.fs. It technically removes inserting the allocator into the API call and allows the buffer to grow when expeniencing "EINVAL" as a Dir error. However this approach doesn't completely remove

1568671920
stratact
allocation, if that's the goal as well.

1568672031
scientes
stratact, you can't remove the allocator from the API call and have the buffer grow....

1568672035
nrdmn
andrewrk: see the link that I posted about an hour ago. I'm not sure if something like that should be possible :D

1568672038
scientes
you can't allocate memory without an allocator

1568672076
nrdmn
about the comptime vars in loops: it seems to be a bit more complicated. Some comptime vars of type type work just fine

1568672263
scientes
also, my PR fails on Freebsd, but freebsd isn't tier 1

1568672300
stratact
scientes: I gotcha. I guess that's why I thought just passing an ArrayList with the allocator inside ahead of time would allow me to remove the allocator parameter in those function/method calls from an API standpoint

1568672329
andrewrk
stratact, that's a good thing to realize - an ArrayList serves a similar purpose to an allocator

1568672349
scientes
oh, well I'm not familiar with ArrayList, it is possible to types to store their allocators

1568672362
andrewrk
but ultimately - to have a growable ArrayList available - you will need an allocator to initialize the ArrayList with

1568672391
andrewrk
stratact, the purpose of #2885 is to modify the current logic - which has O(N) memory requirements - to have O(1) memory requirements

1568672430
stratact
with a static sized buffer?

1568672431
andrewrk
I would suggest solving one OS at a time - whatever is your home OS - and carefully read the documentation for the relevant APIs to determine whether you can do a directory listing with a fixed amount of memory

1568672453
scientes
it does need an allocator is you want to provide a wrapper that iterates a directory in sorted order

1568672462
scientes
which is needed occasionally

1568672501
andrewrk
scientes, in this case it can be a separate API that takes an allocator

1568672509
andrewrk
there is value in not requiring one when it is not needed

1568672515
scientes
yes

1568672543
scientes
but it could just ignore the allocator?

1568672543
andrewrk
btw your SIMD patch set is next on my list - I'm doing a couple bug fixes first

1568672581
andrewrk
that would work fine, but a more readily understandable API will have the function prototype communicate what is and isn't needed

1568672602
andrewrk
readDirUnsorted() vs readDirSorted(allocator: *Allocator)

1568672625
andrewrk
even if the underlying implementation is the same function

1568672659
telemach
I see that sometimes allocator is passed as the first argument, sometimes as the last; is there any convention when which position to prefer?

1568672668
andrewrk
telemach, recently I've been preferring 1st

1568672820
telemach
thanks, and in the case like this:         pub fn destroyNode(self: *Self, node: *Node, allocator: *Allocator) void {

1568672825
telemach
should it go before node?

1568672899
scientes
telemach, yes

1568672917
scientes
*self is magic, and has to come first

1568673103
stratact
andrewrk: it sounds like I would need to read the API documentation and look for a readdir syscall if FreeBSD supports one to get an appropriate sized buffer for each entry and hopefully avoid allocation.

1568673120
stratact
at least for Dir.nextBsd()

1568673143
stratact
and maybe there might be a similar syscalls for Linux too

1568673147
andrewrk
telemach, I'd like to remove that function from std lib

1568673175
andrewrk
it's a "helper" that is trivially implemented anywhere else; I don't think it belongs there

1568673192
scientes
readdir() is part of POSIX

1568673210
stratact
Ah, nice

1568673233
scientes
but is implemented with getdents() which has differences

1568673268
andrewrk
getdents is the proper API for the std lib to use on linux

1568673292
stratact
I'll note that down

1568673315
andrewrk
it's already done, that's already how it works

1568673323
scientes
it still needs a static allocation

1568673342
scientes
as getdents() is batched

1568673401
andrewrk
stratact, which OS are you tackling first?

1568673453
stratact
I'll tackle my home OS, FreeBSD first, and try Linux there after

1568673562
scientes
d_name[] is limited to PATH_MAX + 1, so linux_direct64 would be limited to PATH+MAX+1 + 24

1568673577
scientes
but you will get better performance with a larger buffer

1568673623
scientes
but that is probably actually quite adaquate most of the time

1568673665
andrewrk
stratact, good choice. your next task is to read docs for getdirentries and come up with "proof" that can be cited that a certain size fixed buffer will be guaranteed to always return at least 1 entry. cite that reasoning/proof in comments for why the size is chosen. If there are reasons to pick a larger or smaller buffer as scientes hints, make that a comptime number that can be chosen. A nice default can be chosen for a higher level

1568673665
andrewrk
function, which calls the slightly lower level function with the comptime number

1568673687
stratact
scientes: I will play around those sizes

1568673709
andrewrk
but it should comptime assert that the number chosen is at least the minimum to get one dir entry

1568673728
scientes
i would suggest 8192

1568673735
scientes
which is quite big for a stack allocation

1568673844
stratact
roger that guys, I'll keep notes of this discussion, if you guys don't mind? :)

1568674042
andrewrk
_whitelogger has that done for you already :)

1568674063
stratact
Ah of course 😌

1568674150
stratact
andrewrk and scientes: thank you for the mentorship, I got something I can work on tonight (PDT). I need to wrap up some online course work first, but later I'll dive into this assignment.

