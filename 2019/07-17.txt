1563329228
andrewrk
Clang/LLVM 9 has emscripten as an OS target

1563330513
daurnimator
andrewrk: oh I meant to ask you: how do I target wasm with zig cc?

1563330586
andrewrk
don't use zig cc, use the higher level API

1563330589
daurnimator
e.g. I make wasm.c containing: `int foo() { return 42; }` -> how do I call that function in my browser?

1563330592
andrewrk
gotta go

1563330647
daurnimator
Trying to run `zig cc -target wasm32 wasm.c` results in: `wasm-ld: error: unknown file type: /lib/crt1.o` `wasm-ld: error: cannot open /usr/lib/clang/8.0.0/lib/libclang_rt.builtins-wasm32.a: No such file or directory`

1563331678
fengb
daurnimator: I think you're supposed to use something like `zig build-lib --library c --c-source wasm.c -target wasm32-freestanding`

1563331833
daurnimator
fengb: okay, that outputs a libwasm.a file.... what should I do with that?

1563331897
fengb
build-lib -target wasm32-freestanding should build a .wasm file...

1563332043
fengb
Do you have wabt? We can try inspecting lib file to see if it's correct

1563332052
daurnimator
fengb: it seems to have put a wasm file inside of a .a archive

1563332099
daurnimator
inside of the archive is a single file: `zig-cache/o/VQ1oIrWBLiUiB6v98Pd2ehg8lXnt6uXaJWr9h2XxP4n0Jhy03F36eN3ZucxgGiXm/wasm.o` which

1563332128
fengb
That's really weird

1563332134
fengb
Lemme pull latest

1563332179
fengb
I'm also distracted cause I finally got Mario working lol

1563332290
daurnimator
so trying to load that wasm.o file into node gives: LinkError: WebAssembly Instantiation: Import #0 module="env" function="__linear_memory" error: memory import must be a WebAssembly.Memory object

1563332303
fengb
Yeah that's just an object file. It's not fully linked

1563332385
fengb
Latest with build-lib gives me a "wasm.wasm" output file

1563332664
fengb
Hmm, how old is your zig? Maybe you still need build-exe ?

1563334412
ntgg
is there a way to call a shell command in zig and capture the output?

1563334581
lunamn
maybe with std.ChildProcess?

1563334748
ntgg
looks promising

1563335041
fengb
error: integer value 16384 cannot be implicitly casted to type 'u8' — u32(BANK_SIZE)

1563335045
fengb
Am I going crazy?

1563335083
fengb
Oh... the field type was accidentally u8

1563335346
darithorn
how do i pass a union(enum) as an argument to a function? I get "runtime cast to union 'Key' which has non-void fields"

1563335362
darithorn
the error isn't very helpful

1563335549
ntgg
like have a function that takes in a type that is union(enum)?

1563335599
ntgg
just the same as any other type i think

1563335609
darithorn
yeah, if const Key = union(enum){}; and fn foo(key: Key){}

1563335614
darithorn
that's what I thought but i'm getting an error

1563335735
darithorn
hm, it had something to do with the fact I didn't explicitly specify the type on my variable

1563335756
darithorn
I had var myKey = Key.None; I changed it to var myKey: Key = Key.None; and it fixed the error.

1563335837
darithorn
maybe someone who understands how the compiler infers types would know why

1563335899
ntgg
there are a fair amount of errors with tagged unions and type inference it seems.

1563338447
belgin
hello

1563338565
darithorn
hello belgin

1563338851
belgin
what's the deal with the line endings in zig?

1563339043
belgin
my baudot teletype expects a carriage return after a line feed

1563339158
belgin
or is it before?

1563339756
darithorn
windows uses \r\n

1563339773
hryx
belgin:

1563339794
hryx
tabs v. spaces related to newline issues

1563339811
hryx
oh crap, that FAQ needs to be updated. zig fmt automatically converts them for you now

1563340043
hryx
based on the dates listed here, I will assume I have been affectionately trolled:

1563340104
belgin
can't zig copy the source in to ram and then run fmt on that buffer?

1563340112
belgin
before starting to parse/compile etc

1563340148
belgin
on the other hand, i do appreciate the sentiment to have all zig code look the same

1563340216
belgin
but if fmt can fix the problems, just have fmt fix them?

1563340274
hryx
whitespace discussion is considered off-topic here; you should refer to the links in that FAQ. (sorry to have engaged earlier)

1563340428
darithorn
belgin if you have the zig vim plugin it runs zig fmt everytime you save

1563340594
darithorn
and i think the idea is to have zig fmt separate from the actual zig compiler because it's not really a pleasant idea to have the compiler itself mutating your source code

1563342470
emekankurumeh[m]


1563342867
emekankurumeh[m]
what about instead of `usingnamespace` we changed  it to `using`? using identifier length to enforce a style of code seems strange imo. that sort of thing belongs in the style guide.

1563343071
hryx
hey emekankurumeh[m], I was thinking of making a proposal to remove `usingnamespace` entirely, but I know that some consider it important and I want to make sure I consider real use cases. Would you mind explaining or linking me to the most compelling use case (in your opinion)?

1563343152
emekankurumeh[m]
basically it can be summed up as i really like this proposal:

1563343219
hryx
oh wow, I hadn't thought about that at all in relation to `usingnamespace`

1563343227
hryx
I think I understand the connection

1563343792
emekankurumeh[m]
wow, i guess i just assumed `use`/`usingnamespace` was the way that was going to be done. that's not even anywhere in the proposal

1563344184
emekankurumeh[m]
oh yeah, i got that idea from this pr:

1563350853
mikdusan
is usingnamespace documented anywhere?

1563352978
emekankurumeh[m]
is there something like regexes for zig constructs lying around anywhere by any chance?

1563353204
daurnimator
"zig constructs"?

1563353240
emekankurumeh[m]
what i mean is basically the syntax spec but basically in regex

1563353276
mq32
so you mean a tokenizer?

1563353289
Pwipwi
something like

1563353327
emekankurumeh[m]
mq32: basically, yeah

1563354301
fubd
are there known alignment/codegen segfaults? I'm seeing a weird one where if I add or remove a warn() call, my program is crashing, and the value of a field in my struct is getting zeroed out

1563354305
fubd


1563354357
fubd
^that's a narrowed down case

1563354508
mikdusan
fubd: which platform?

1563354588
fubd
mikdusan: this is `zig test segfault.zig` on windows, latest zig master

1563355179
mikdusan
trying to reproduce. in the meantime can you try this:

1563355660
fubd
mikdusan: still segfaults

1563355664
fubd
i updated the gist

1563355675
fubd
to include your changes

1563355699
mikdusan
i can see segfault on windows. fyi doesn't happen on macos or linux.

1563355699
Pwipwi
When I make a function that returns a new struct instance and assign it to some memory that was allocated, is a copy made or does the compiler "know" how to directly assign to it ?

1563355722
Pwipwi
fn mkstruct() { return Struct{ .myfield = 1; }

1563355729
Pwipwi
/ later

1563355751
Pwipwi
var mystruct = allocator.alloc(Struct, 1); mystruct[0] = mkstruct();

1563355757
Pwipwi
is there a copy step when I do that ?

1563355779
mq32
afaik there is right now, but there's been work put into copy elision

1563355992
fubd
mikdusan: hmm, strange. i wonder how else i can narrow this one...seems very dependent on alignment, because adding or removing certain statements makes it not happen

1563356003
fubd
or yeah like a codegen bug

1563356208
daurnimator
well that was fun...

1563356219
daurnimator
^ is that a llvm bug?

1563356429
mikdusan
Pwipwi: there is no copy made. mkstruct() will store "1" into field storage provided at callsite

1563356476
Pwipwi
I searched for copy elision and saw it was already partly implemented, this is great

1563356643
mikdusan
visualize `mkstruct()` as being passed a (hidden) pointer to mystruct[0]

1563356920
Pwipwi
yes, I was wondering if that was already built-in

1563357430
mikdusan
fubd: try this

1563357556
mikdusan
i fixed 1 of 3 locations where an array-on-stack escapes function. seems to solve segfault. other 2 locations should also be fixed.

1563358012
Pwipwi
are there helpers to display values as []u8 ? Like for instance an int

1563358031
Pwipwi
I remember in C we did unions with const char *

1563358078
Pwipwi
like the opposite of @bytesToSlice

1563358300
mikdusan
Pwipwi: take a peek at std.mem; maybe toSlice() is what you are looking for

1563358309
Pwipwi
cool, thank you

1563358380
Pwipwi
it seems to be related to C pointers, looking for a null terminated value it seems

1563358399
Pwipwi
well, I got it by creating a single item array and picking a slice over it

1563358532
mikdusan
ah you are right. i blame allergies wreaking havoc with my eyesight :)

1563358566
Pwipwi
you were right about std.mem though

1563358574
Pwipwi
lots of things there, might find what I'm looking for

1563359137
Pwipwi
well,  didn't :)

1563359632
mikdusan
Pwipwi: std.mem.asBytes() ? see

1563359668
Pwipwi
! glorious !

1563359700
mikdusan
std.mem is a tricky one. I go through it thinking nope doesn't help. then 9 out of 10 times find out later it has what I needed.

1563359863
Pwipwi
is there a std lib explorer somewhere ?

1563359870
mikdusan
not yet

1563359885
Pwipwi
there ought to be a temporary one that relies on regexp

1563359904
Pwipwi
... I might just make one

1563359914
Pwipwi
because I think the autodoc is at least one year away still

1563359935
Pwipwi
and a search function with somewhat formatted docs could go a long way in helping me :)

1563360168
mikdusan
'pub fn' and 'pub const.*=.*struct' for structs can help find the main players

1563360229
Pwipwi
doing that already

1563360389
omglasers2
has anybody built

1563360730
mikdusan
omglasers2: 3-4 weeks ago there were some posix/os API renames. `std.os.Thread` -> `std.Thread`

1563361008
omglasers2
thanks, had to change at l260 but now I have "src/main.zig:237:9: assertion failed. This is a bug in the Zig compiler."

1563361020
omglasers2
at l260 too*

1563361472
fubd
mikdusan: ah, I see. i was assuming that since the things they were pointing to were in the heap I was okay--I wonder if returning a slice of a stack object should be disallowed

1563361520
daurnimator
fubd: it should. but it's hard to do. currently an open issue I think

1563361552
mikdusan
fubd: i believe that is in the plan for compiler to do things like more thorough escape analysis

1563361704
scientes
when do ConstExprValue get populated?

1563361720
scientes
and what do i have to call to populate it

1563361784
scientes
// populated if special == ConstValSpecialStatic

1563361786
scientes
but it is

1563362034
scientes
figured it out

1563362671
scientes
if i use the child then i don't have a ConstExprValue, but if i use the non-child then i don't have a type.... :/

1563363493
mikdusan
is there something in .cpp source code (Visual Studio compiler) similar to @compileLog()? I'd just like to emit a sizeof(thing)

1563363502
scientes
printf

1563363508
scientes
or the debugger

1563363531
scientes
zig is generally developed on Linux

1563364158
mikdusan
yeah the issue is i can't get as far as passing asserts. no matter, i have a workaround.

1563364172
scientes
are you sure that code is being run?

1563364181
scientes
and are you compiling in debug mode?

1563364195
scientes
cause I'm working on ir.cpp right now

1563364262
mikdusan
it's a .cpp assert that fails comparing sizeof() on windows; zig_lang.cpp stuff. i suspect hardcoding some padding is not very robust and my compiler is producing something different

1563364390
scientes
oh then fix the bug

1563364405
scientes
that assert saved a much more difficult to fix bug

1563364491
mikdusan
i dunno, started off by asking something about .cpp compiler and how you got here is beyond my understanding.

1563364720
scientes
its not my problem. if you want answers you have to provide enough information

1563364943
mikdusan
@compileLog() in zig runs before runtime. the question was seeking an analogue for C++ if that even makes sense. printf/debugger/linux is not helpful. telling me to fix the bug is not helpful. i'm saying this with all due respect. and this is no longer productive, i have a workaround as stated.

1563365001
scientes
yeah you can step through in the debugger

1563365006
scientes
that is compile-time

1563365028
scientes
gdb or lldb

1563365035
scientes
or some windows thing perhaps

1563365055
scientes
oh i see

1563365066
scientes
yeah I don't think C has that

1563365069
scientes
I'm sorry

1563365080
scientes
the problem is I don't think C CAN have that, because of the preprocess

1563365090
scientes
you can look at the .i file from using --save-temps

1563365092
mikdusan
yeah i agree. it makes no sense. which is why the question probably threw u off.

1563365095
scientes
that is about all you can do

1563365110
scientes
that will tell you what the real type is

1563365125
mq32
<mikdusan> is there something in .cpp source code (Visual Studio compiler) similar to @compileLog()? I'd just like to emit a sizeof(thing)

1563365135
mq32
there's a pretty (and ugly) hack:

1563365147
mq32
template<size_t> struct deliver_me_a_value;

1563365160
mq32
deliver_me_a_value<sizeof(T)> val; // yields a compiler error with the number in it

1563365173
mq32
same thing goes for functions with no linkage  => linker yields the sizeof value

1563365215
scientes
error: incompatible types: 'u4' and 'i32'

1563365215
scientes
expect(u4(3) == a[2]);

1563365218
scientes
isn't that suppose to cast up?

1563365284
mikdusan
mq32: wow that works. thanks!

1563365314
mq32
mikdusan: this solution is so stupidly brilliant :D

1563365409
scientes
gd c++

1563365422
scientes
you could spend your whole life coding stuff in the STL

1563365496
scientes
the language where people brag that they can use the language

1563365517
nrdmn
seems like I can't build zig with gcc 9.1.0. Can anyone confirm?

1563365541
mikdusan
nrdmn: can confirm. does not build with 9.1.0 . some llvm error iirc

1563365635
nrdmn
does andrewrk already know?

1563365651
mikdusan
haven't heard anyone mention it before here

1563365659
scientes
just write a patch...

1563365663
scientes
its not that hard usually

1563365679
mikdusan
we don't currently patch llvm

1563365705
scientes
yeah you can probably just disable the warning

1563365721
mikdusan
yes that works

1563365758
scientes
then write the patch!

1563365828
scientes
src_assert(instruction->value.special != ConstValSpecialRuntime, instruction->source_node);

1563365834
scientes
why can't ir_llvm_value take Runtime values?

1563365853
scientes
oh nvm

1563366403
scientes
its not calling render....

1563366412
scientes
on my IrInstructionLoad

1563368419
mikdusan
emekankurumeh[m]: typo? should `WIN32` be `_WIN32` ?

1563369197
scientes
why isn't my ir_render being called on my IrInstruction before the instruction the references it is rendered?

1563369219
scientes
i would think it would walk it

1563369241
scientes
yeah that is what ir_render appears to do, but it isn't working....

1563369251
scientes
oh !ir_has_side_effects(instruction))

1563369303
scientes
wut

1563369308
scientes
the compiler has no sense of pure

1563369315
scientes
no side effects, but still generates a value

1563369472
fengb
Has anyone looked at

1563369549
Pwipwi
is it possible to use strings in enums ?

1563369566
Pwipwi
nvm

1563369567
scientes
not yet

1563369567
fengb
No, enums are ints

1563369570
Pwipwi
ok

1563369584
scientes
yeah but you could use the pointer value

1563369588
fengb
You can embed a lookup table if that's helpful

1563369590
scientes
if you used a usize enum

1563369619
Pwipwi
yeah but then I have to use builtins everywhere no ?

1563369622
Pwipwi
to get back the valeu

1563369623
Pwipwi
value

1563369639
scientes
well that's why i said not yet

1563369656
scientes
I want to do a perfect hash, but that is a sophisticated feature

1563369665
scientes
when D did it it did it the easy and slow way

1563369670
scientes
switches on strings

1563370036
mikdusan
Pwipwi: this is awkward but almost like ruby symbols:

1563370076
Pwipwi
awkward is an understatement lol

1563370099
scientes
you can do that with introspection features

1563370106
scientes
...probably

1563370113
Pwipwi
I'll wait for it to be implemented :)

1563370113
scientes
or should be able to

1563370177
scientes
hmm, yeah I can't figure out how to get ir_render_foo to run

1563370341
fengb
Pwipwi: you can also embed that as a method `fn stringify(self: &This()) []const u8`

1563370374
mikdusan
Pwipwi: "is it possible to use strings in enums" - just to confirm, you're not talking about union(enum) right?

1563370399
Pwipwi
enum ([]u8) {

1563370470
fengb
That's a slice. I wouldn't expect that to ever work

1563370495
Pwipwi
even with enum([]const u8) ?

1563370499
fengb
Maybe [*]u8 since that doesn't have an embedded length

1563370502
Pwipwi
since literals can auto cast in them

1563370520
mq32
Pwipwi, that doesn't really make sense

1563370522
fengb
[]const u8 maybe... it gets tricky because slices always have length

1563370523
mq32
what do you want to switch on?

1563370530
mq32
literals? runtime-values?

1563370596
mq32
but i think the real question should be: what do you want to achieve with that construct?

1563370624
fengb
Right now, enums are always exhaustive so none of that could be done. There's a proposal for non-exhaustive enums, which may be able to support pointers:

1563370651
fengb
But even then... I'm not sure I'd want an enum to operate on pointers, since there's no guarantee those are stable

1563370839
gonz_
Non-exhaustive enums

1563370842
gonz_
that seems super low value

1563370858
fengb
OS interop

1563370885
fengb
Rust and Swift both added it

1563370892
mq32
gonz_, that's relevat everywhere you cast integers into enumeration values where you don't know the whole enumeration set

1563370905
gonz_
fengb: I'm not sure that's a good argument for anything

1563370926
fgenesis
enums may be extended with lib/OS/... updates too so at least having an explicit fallback case is nice

1563370934
mq32
just imagine you interface

1563370935
halosghost
what is a non-exhuastive enum?

1563370941
fengb
It means it's clearly desired by similar languages. You can ignore all of their research if you want...

1563370943
halosghost
I don't believe I've heard that phrase before

1563370958
mq32
halosghost, enumeration that allows non-listed values as possible options

1563370963
halosghost
ah

1563370969
halosghost
à la C

1563370971
halosghost
meh

1563370971
fgenesis
halosghost: enums you know that won't be extended where you can guarantee at compile-time that all values are checked

1563370974
gonz_
fengb: zig

1563370989
fgenesis
= exhaustive

1563370993
halosghost
fgenesis: right

1563371006
halosghost
rust, zig, and swift all have quite different goals and needs, that's for sure

1563371024
halosghost
good to know about ideas from other languages, but “because they did” isn't a great reason to do something imo

1563371034
mq32
gonz_, doesn't mean we shouldn't consider features with practical use that may prevent either bugs or huge workarounds

1563371038
fengb
But dismissing it because "rust" is also not very helpful

1563371039
gonz_
A language that is trying to replace C++ is necessarily different than one that tries to be simple and have less extras

1563371065
fengb
I'm just saying there's a bunch of proposals about low level interop that's been done at a low level by other languages

1563371083
gonz_
Enough small things of practical use and you just end up with a language that has tons and tons of extras that can be added everywhere

1563371085
fengb
At least maybe read their reasoning before saying "no, rust"

1563371086
halosghost
I have a question

1563371101
halosghost
isn't @bitCast to an int already enough to solve this problem?

1563371110
gonz_
at that point the stated goal of debugging your own language knowledge not being a thing is definitely shot to hell

1563371147
mq32
halosghost, no, because if you want the enumeration values to be switched on you need @intToEnum

1563371162
mq32
and that panics/UBs when you pass non-valid values to it

1563371163
fengb
halosghost: but you can't actually use an enum to represent the "enumerated value" if it's not captured in the enum. You'll need to pass around `u8` or equivalent

1563371201
halosghost
mq32: but, if we're talking about values which have been added to the interface since you wrote your program, unless you have a default case, wouldn't that happen anyway?

1563371207
fengb
Distinct types are another solution, but it doesn't capture the known values very well

1563371224
gonz_
fengb: I think you're intentionally being dismissive as well, to be honest. I said citing rust as a reason for having it isn't really enough, not that zig shouldn't have it because rust does.

1563371224
fengb
halosghost: it's more about things you can't control, like OS status codes

1563371237
gonz_
fengb: Those two aren't the same

1563371268
fengb
e.g. Linux has a bunch of codes that are listed but extended at any point. We don't want Zig to just crash if the OS gets upgraded

1563371270
halosghost
fengb: I'm not sure I understand why that would matter; aren't OS status codes mostly documented and enumerable?

1563371272
gonz_
But in general, I stand by what I said; a language trying to replace C++ shouldn't end up looking like one that tries to replace C. One of them has gone badly wrong at that point.

1563371278
halosghost
mm

1563371280
halosghost
I see

1563371284
mq32
halosghost, but i cannot have a default case if i cover all

1563371298
halosghost
mq32: hmm

1563371301
fgenesis
semi-never

1563371310
mq32
i also have beautiful example for this

1563371313
mq32
wait a sec

1563371316
fengb
They're documented to be extended so it'd be nice if Zig could represent this case

1563371329
halosghost
mq32: wouldn't, then, the solution be to allow for default cases when switching on an enum even if all known cases have an explicit case?

1563371344
halosghost
because that is a change I would support

1563371350
halosghost
that seems very measured and reasonable

1563371356
fengb
halosghost: current enums cannot support unknown values

1563371358
fgenesis
+1

1563371365
mq32
halosghost, that's what we're talking about ;)

1563371366
fengb
It's undefined and panics in safe mode

1563371388
halosghost
heh

1563371420
mq32
quoting the LPC 178x manual:

1563371427
mq32
Interrupt identification. IER[3:1] identifies an interrupt corresponding to the UART1 Rx or TX FIFO. All other combinations of IER[3:1] not listed below are reserved (100,101,111).

1563371444
halosghost
I see

1563371459
mq32
if i now query the interrupt source and cast it to an enum (because we are semantic programmers, we do such things) and now my new

1563371462
mq32
i need a default case

1563371470
halosghost
right

1563371494
halosghost
been too long

1563371521
fengb
Also kinda helps with C enums since they're all non-exhaustive... but that's not necessarily a good motivator

1563371523
fgenesis
or like my new hardware suddenly returns a random number instead of -1

1563371595
halosghost
since zig enums cannot carry a payload, it would really need to be a different kind of enum

1563371609
halosghost
since, I assume, we aren't really thinking that it'd be a good idea to make all zig enums non-exhaustive

1563371620
fengb
Not a payload. We can do enum(u8)

1563371632
fengb
But yeah, definitely should be opt-in

1563371693
halosghost
wait

1563371702
halosghost
don't `extern enums` cover this case?

1563371717
halosghost
if you switch on an extern enum, does it still require exhaustiveness?

1563371818
mq32
yes

1563371822
halosghost
hmm

1563371826
halosghost
that seems odd

1563371826
mq32
(at least that's what my compiler tells me here)

1563371842
mq32


1563372531
gonz_
I wish there was a `language-feature-proposal` tag in the zig repo

1563372564
gonz_
proposals for fixes of current behavior are a different breed than language feature proposals, IMO

1563372860
fengb
What's the best way to represent C bit masked values? Struct bitfield?

1563373536
Pwipwi
can someone explain to me what's going on here ;

1563373544
Pwipwi
const l: usize = undefined;        try readExactly(mem.asBytes(&l));

1563373555
Pwipwi
expected type '[]u8', found '*align(8) const [8]u8'

1563373569
Pwipwi
where readExactly is just a thin wrapper on Instream.read

1563373590
Pwipwi
why do I have an align(8) on that variable ?

1563373598
Pwipwi
is it the compiler that decided to do so ?

1563373625
Pwipwi
NEVERMIND

1563373628
Pwipwi
sorry

1563373631
Pwipwi
const vs var

1563373646
Pwipwi
I got confused by the align, didn't see the const, move along.

1563373872
Pwipwi
man I'm having fun.

1563373895
fengb
Align = pointer alignment. When things aren't aligned to what the CPU wants, it works much slower (or often not at all)

1563373907
fengb
You don't need to know this to fix your current problem :P

1563373914
Pwipwi
indeed

1563374157
ntgg
in the std/json/test.zig file, why does `any` just call expect(true)? are they tests that arn't done yet? seems weird

1563375051
Pwipwi
how can I display a stack strace when I got an error ? debug.warn only displays the error

1563375144
scientes
Pwipwi, just throw the error

1563375155
scientes
and you will get a stack trace, and a debug trace

1563375162
Pwipwi
well that's no fun

1563375169
Pwipwi
but ok

1563375189
scientes
I think @panic() will do that to

1563375192
scientes
but not the debug trace

1563375199
Pwipwi
ok

1563375209
Pwipwi
another question, how do you deal with cannot resolved inferred error set ?

1563375225
Pwipwi
I'm doing recursion

1563375230
Pwipwi
errors get thrown

1563375242
Pwipwi
and !Type just doesn't cut it

1563375254
Pwipwi
the thing is I have errors thrown by std code and another by mine

1563375290
scientes
but zig gives you a trace

1563375294
scientes
so you know where the error came from

1563375314
mq32
Pwipwi, you have to manually define the error set

1563375321
Pwipwi
I was dreading that

1563375326
mq32
fn foo() MyErrorSet!void { }

1563375374
fengb
Or if you're super lazy, `anyerror!void`

1563375383
scientes
really?

1563375402
scientes
yeah that is lazy

1563375412
scientes
but its still correct error handling

1563375420
scientes
which C writers are usually too lazy to use

1563375426
fengb
I don't recommend it to be final, but while spiking it's handy

1563375453
mq32
oh yeah, anyerror is there as well

1563375491
Pwipwi
ok that works, but it's not very savory

1563375507
Pwipwi
how can I mention multiple error sets ?

1563375516
Pwipwi
instead of each individual errors

1563375526
mq32
a||b merges error sets

1563375551
fengb
You can define an errorset: `const MyErrors = error{A, B};`

1563375578
Pwipwi
I did

1563375599
Pwipwi
my function can return std.io.InStream.Error and my custom error set

1563375608
Pwipwi
I don't know how to specify that

1563375621
Pwipwi
also probably allocation errors

1563375659
mq32
fn foo() (std.io.InStream.Error || error { MyErr })!void { } should do that

1563375676
Pwipwi
ok, it's not in the docs is it ? I couldn't find it

1563375694
mq32


1563375709
Pwipwi
my bad

1563375795
Pwipwi
ok, I'm trying to get the error set from instream

1563375800
Pwipwi
this is the best I could get :

1563375801
Pwipwi
error: no member named 'Error' in struct 'std.io.InStream(error{OperationAborted,BrokenPipe,Unexpected,InputOutput,SystemResources,IsDir,})'    pub fn read(a_: A) (ValueError || in.Error)!Value {

1563375822
Pwipwi
I tried os.InStream.Error, but not much better

1563375964
Pwipwi
Ha, found it

1563375970
Pwipwi
sorry, asking too fast

1563376523
scientes
yeah I have difficulty with that too

1563376540
scientes
its hard to balance other people's time with estimating how long it will take to do it yourself

1563381939
andrewrk
scientes, do you have an aarch64 laptop?

1563381948
andrewrk
what is it?

1563382001
fgenesis
just for reference, rpi4 is aarch64 too, right? i mean once they update the OS to actually run 64 bits

1563382012
andrewrk
yes

1563382019
andrewrk
I'm looking to get a new main dev machine

1563382035
andrewrk
I'm tired of running out of disk space and ram

1563382043
mq32
hm.

1563382058
mq32
i have an olimex teres 1, but that's not a good "main dev" machine

1563382076
dimenus
andrewrk: I'm not having any issues linking glfw statically on Windows

1563382080
dimenus
with up to date master

1563382084
dimenus
there's something else going on here

1563382108
andrewrk
dimenus, thanks, that's good to know. I still think 95e04e3874d is a good idea, do you disagree?

1563382117
gonz_
Anything that allows 16GB+ DDR4, a nice quad core and 512GB+ SSD is a good dev box if it also comes with a nice-ish display, IMO

1563382128
dimenus
andrewrk: no, I would agree that msvc by default is probably good

1563382221
gonz_
But that's pretty much any laptop nowadays

1563382543
gonz_
I have a Dell Inspiron 15 7000 Gaming with 32GB RAM, 1TB SSD and otherwise the defaults. It's probably not very expensive now (if sold still) and does very well.

1563382601
gonz_
All in all it's been a very decent experience. I used to run arch on it without any major issues (beyond the usual "Shit, I don't remember what to do about nvidia drivers").

1563382619
gonz_
I run Windows now but that's because voice recognition and control still sucks on Linux.

1563382685
companion_cube
1TB SSD :o

1563382717
mq32
companion_cube, isn't that expensive anymore

1563382717
ibutra
andrewrk can you elaborate on #2883 what -target doesn't cover which would be covered by -mcpu?

1563382725
mq32
flash prices are all down right now

1563382752
companion_cube
damn, and I still only have 128GB

1563382786
gonz_
companion_cube: It was actually very obtainable, so I decided to buy a Samsung 860 EVO M.2. This was purely on the recommendation of the shop, though, because I'm not particularly "with it" when it comes to peripherals/accessories.

1563382793
mq32
i have a

1563382797
andrewrk
ibutra, I'll comment on the issue

1563382827
ibutra
I know currently the code just uses the native features in code (See linked pull request) but that could be adjusted to use the target doesn't it?

1563382831
ibutra
sure, thx

1563382981
andrewrk
ibutra, I also added " Add the list of possible options to zig targets so that they are discoverable" as a checkbox on that issue

1563383178
ibutra
andrewrk I am not sure about (all) the features for a cpu but things like fpu etc. are set by the tripple afaik.

1563383202
andrewrk
the fpu can be communicated by the C ABI, have a look at the list of `zig targets`

1563383694
ibutra
OK, I read in the documentation of clang, that even with -target it is often required to specify -mcpu, -mfpu, -mfloat-abi (and -mattr as well then I guess even though it isn't explicitly mentioned)

1563384447
andrewrk
as a first step, we need these options enumerated in target.hpp/target.cpp

1563384922
ibutra
sry, didn't mean to leave. You mean enumerate all possible options for -mcpu, -mfpu, -mfloat-abi and -mattr?

1563385017
andrewrk
yes

1563385025
andrewrk
this list must exist somewhere in llvm, and we need to expose it

1563385041
andrewrk
and bring it into become a zig concept rather than an llvm concept

1563385061
ibutra
as far as I know it only exists in source code and is dependent on compile options but I can try to look into that

1563385352
andrewrk
these will be exposed in @import("builtin") for comptime use in zig code

1563385359
scientes
andrewrk, i did, the pinebook, but now i'm waiting for the pinebook pro, which you can preorder in a week

1563385378
scientes
<andrewrk> I'm tired of running out of disk space and ram

1563385384
scientes
yeah not the machine for you then

1563385395
scientes
only 4GB of ram

1563385416
andrewrk
hmm this is still quite an interesting system for me though, it would be good to have an aarch64 computer

1563385437
scientes
yeah its great value for the money

1563385518
bheads


1563385526
bheads
they make good linux laptops

1563385537
scientes
for x86 I would get a thinkpad

1563385552
scientes
New York should have a great used thinkpad trade on craigslist

1563385560
scientes
SF certainly does

1563385663
andrewrk
ok definitely going to get one of these pinebook pros when it comes out

1563385693
andrewrk
gotta test that aarch64

1563385797
gonz_
Seems a bit underpowered for a main dev machine

1563385809
andrewrk
yeah that would not be a main dev machine

1563385822
scientes
its about the same as my current laptop

1563385832
scientes
4GB is fine, except that zig is a bit ram hungry

1563385866
gonz_
8 is bare minimum and I don't think I could reasonably go lower than 16 at the moment

1563385871
scientes
but yeah it isn't ok for LLVM

1563385879
scientes
meh 4gb is fine for LLVM, but you want more CPU

1563385918
gonz_
4 is definitely not fine for Haskell, 8 is mostly fine but would get cramped

1563386049
bheads
Actually the darter pro looks like a good dev laptop

1563386080
scientes
well not everyone can get by with 4GB like me

1563386093
scientes
i would like more cpu, but I can just do llvm stuff on a VPS

1563386218
andrewrk
I've had trouble with the system76 power cables before, the way they plug into the laptop

1563386242
scientes
I wouldn't get anything except a thinkpad

1563386246
scientes
that's just me

1563386246
gonz_
System76 always seemed a bit overpriced to me

1563386423
gonz_
Beyond that I've also noticed that what people recommended usually was worse than what they would actively suggest not to buy. My Dell laptop works great and I've upgraded it to the point where it's better than most people's desktops.

1563386464
gonz_
We've had two thinkpads that've had odd issues with their hard drives in Windows and shoddy hibernation support for Linux

1563386579
scientes
lots of ram is just an excuse for lazy programming

1563386592
scientes
like ubuntu starts up the thunderbolt daemon on computers without thunderbolt

1563386594
scientes
its just stupid

1563386598
gonz_
My HP ProBook that I bought for more portable stuff also works great

1563386633
companion_cube
sadly if you're in a position where you're expected to use slack… :s

1563386661
gonz_
I dunno, consumers having lots of RAM aren't exactly causing the issues themselves.

1563386680
andrewrk
zig stage1 is paying the cost of using more ram than strictly necessary so that we can iterate faster

1563386696
scientes
which is fine

1563386700
andrewrk
once the requirements stop changing so fast we can settle in and improve things

1563386793
gonz_
scientes: One of the reasons that I started looking around for a lower level language again a while ago was actually that I felt like we've lost sight of making software that isn't so resource hungry.

1563386821
gonz_
And sure, one justification that can be heard is that we have "so much RAM", but I think it's a bit deeper than that.

1563386828
companion_cube
what were you using then, gonz_?

1563386839
scientes
I agree, performance is part of correctness IMHO

1563386854
gonz_
Haskell, Elixir, PureScript, Racket, etc.

1563386854
scientes
at least once you have the requirements straight

1563386867
scientes
(premature optimization is still the root of all evil)

1563386878
gonz_
I used to do only C++ way back, but then I found python and since I was so tired of programming after 7 years of C++ I just fell in love with that stuff.

1563386893
companion_cube
feels like haskell wouldn't be that slow compared to python

1563386912
gonz_
And then I found functional programming with Racket and all the rest of the languages  in time.

1563386937
gonz_
Haskell is pretty fast and not super unreasonable to optimize, but I wanted something that made it easy to reason about lower-level ideas.

1563386969
scientes
well yeah, hardware is not functional

1563386971
gonz_
It's not that I dislike everything higher-level now but I'm looking to "build my mountain" (if anyone's seen Eskil Stenberg's C talk)

1563386974
scientes
its procedural

1563387004
gonz_
I want to build that mountain on something that I can talk to about lower level things and the spirit of zig makes that stuff fun (again).

1563387031
companion_cube
scientes: it's kind of neither, really, with modern cache consistency issues and whatnot

1563387040
companion_cube
gonz_: what about rust? too complicated?

1563387095
gonz_
I've learned some rust and I really like that they've cross-pollinated a lot, but I've just never had fun with it. Even the small things I've written in zig have been fun.

1563387103
gonz_
Also, rust is just trying to do a lot, I feel like

1563387169
gonz_
zig is one of those joyful languages that I just really like writing whenever I get the time

1563387195
Sahnvour
andrewrk: you showed builtin stack traces for zig1 before, is this intended to ship, or just for development ? Does/should the current release build have it ?

1563387226
dimenus
i didn't think this would work in Zig but I'm glad it does

1563387244
nrdmn
building zig with "make" (not: "make install") writes into the user's home directory (~/.local/share/zig/...), is this intended?

1563387378
andrewrk
Sahnvour, good question. it's just for development, probably should be disabled on the builds that we ship on the download page, since they don't have debug info

1563387440
andrewrk
nrdmn, yes there's a global cache for compiler_rt, builtin.zig, and zig's libc

1563387683
Sahnvour
does the windows package ship with the pdb then ? also, we should advise to build it locally in RelWithDbgInfo

1563387787
Sahnvour
I had some crashes caught by that mechanism but it was unable to load debug info, I didn't look at it yet but I suspect that's it

1563387827
andrewrk
I don't think we're going to ship with debug info on the download page, so for those builds it should be disabled. I agree for source builds we should recommend RelWithDebInfo

1563387948
Sahnvour
I'll do that one day or another and update the wiki

1563388082
andrewrk
dimenus, plz don't recommend to people to delete zig-cache

1563388157
andrewrk
unless there are any known bugs in it

1563388162
andrewrk
which is currently not true

1563388186
dimenus
apologies, i was just trying to recommend a clean slate for debugging the linking issue

1563388199
dimenus
but yeah, .def/.libs are generated in the base dir anyway

1563388204
dimenus
so it wouldn't be a cache problem

1563388211
dimenus
point taken

1563388245
andrewrk
yeah, it makes sense you're just trying to eliminate variables

1563388261
andrewrk
I'm just worried about people getting an incorrect understanding of how zig-cache works

1563388285
dimenus
agreed, you don't want word to spread

1563388295
dimenus
that deleting the cache is a recommended part of the process :P

1563388298
andrewrk
right

1563388313
dimenus
should I redact/edit that response?

1563388318
andrewrk
nah it's fine

1563388373
andrewrk
note that the first thing in all the cache-hashes is the zig compiler id (which you can see with `zig id`)

1563388418
andrewrk
so not only are all the input parameters in there, if you make any changes to the zig binary, or even any of its dynamic dependencies such as LLVM or even libc, it will produce a different hash value

1563388513
andrewrk
which means that the caching system works perfectly no matter how many versions of zig you're using simultaneously

1563388795
ltr-
can i rely on the json parser on the std not chaning much in the future?

1563389746
nrdmn
andrewrk: target zig_build_libuserland, which is a dependency of the default target, seems to install stuff to CMAKE_INSTALL_PREFIX. Is this intended?

1563390201
nrdmn
and while doing so, it doesn't prepend DESTDIR to CMAKE_INSTALL_PREFIX

1563390677
andrewrk
ltr-, I wouldn't consider anything in the std lib stable

1563390765
andrewrk
nrdmn, yes it's intended. what's the use case for DESTDIR when CMAKE_INSTALL_PREFIX specifies the install prefix?

1563390840
fengb
andrewrk: random question — is Zig as big of a project now as you had anticipated when you first started?

1563390900
andrewrk
it's been the plan to actually take over the space for real, not just a hobby project, since the beginning

1563390921
halosghost
:)

1563390936
andrewrk
in terms of scope? yeah I'd say that there were areas of the scope that I didn't anticipate

1563390953
andrewrk
for example, the idea that we'll probably need other backends besides LLVM

1563391023
omglasers2
are there other backends on the roadmap ?

1563391095
andrewrk
I don't think I expected to have to become an expert in so many different operating systems. I'm fine with it though

1563391116
andrewrk
omglasers2, not yet, it's a far-away goal that is not officially planned yet

1563391157
andrewrk
but it's becoming more and more apparent that this will be an ingredient to taking mind share, as well as accomplishing some of the technical goals, such as compilation speed for debug builds

1563391329
scientes
yeah a gcc backend is very sensible thing

1563391382
dimenus
scientes: transpiling?

1563391397
scientes
dimenus, no, an actual backend like gccgo

1563391436
scientes
but gcc doesn't have as good of a cross-compilation story

1563391451
scientes
(which is something gcc developers are very aware of)

1563391491
companion_cube
but it's still very fast in some situations

1563391505
scientes
gcc has really great optimizations that llvm doesn't have

1563391550
fengb
andrewrk: I'm glad you stuck through all of it. I feel like learning Zig has made me a better programmer

1563391651
andrewrk
fengb, I'm happy to hear that!

1563391661
andrewrk
btw can I demo FunDude on the stream tomorrow?

1563391666
fengb
Uhhh sure

1563391700
fengb
It's pretty raw still and I don't really like things half done... but I don't foresee it being as good as I want any time soon :P

1563391857
scientes
I've got a comptime int here, and yet data.x_bigint isn't populated

1563391860
scientes
what am i doing wrong

1563391867
scientes
neither in the child nor parent

1563391877
scientes
oh wait, the number is zero haha

1563391957
scientes
ahh I think i have to cast it to a type from comptime int

1563391963
scientes
before passing to llvm

1563392409
scientes
andrewrk, do you try to work 40 hours a week on zig?

1563392510
andrewrk
I think I average somewhere closer to 65

1563392541
scientes
I need a more ergonomic setup

1563392550
scientes
I just started swimming again, which is great

1563392556
scientes
but the posture of using a laptop is killing me

1563392589
andrewrk
how much I'm "trying" to work is a balance between my physical health, mental health, and relationships (friendships & significant other)

1563392681
andrewrk
I recommend a keyboard & monitor, it makes a huge difference

1563392743
andrewrk
a couple hundred dollars to significantly improve your physical health, easy decision

1563392753
scientes
i'm just traveling

1563392759
andrewrk
oh

1563392761
scientes
so i hate to have to give it away when i move

1563392780
scientes
but I can hang out in one place for a while

1563392858
very-mediocre
invest in a good chair imho, you spend at least 40% of your life in a chair or a bed

1563392878
andrewrk
if this project sounds fun to anyone, it would be beneficial to the wider open source community: work on emscripten's ability to self-host (build llvm)

1563392890
andrewrk


1563392919
andrewrk
once this works, it will be a small straightforward process to make a zig sandbox in the browser that works client-side

1563393060
andrewrk
hryx, I'm creating the llvm9 branch in zig right now and doing the "deal with breakage to zig_clang.cpp" process for the first time. I'll let you know how it goes if you're curious

1563393170
hryx
oh awesome, sounds good andrewrk

1563393792
mikdusan
hryx: have a moment?

1563393953
hryx
mikdusan: I'm at work but can read/respond here and there. what's up?

1563393983
mikdusan


1563394040
mikdusan
it's not activating for me because `WIN32` is not defined for me. I don't understand why it fails for me, but CI builds did not fail. changing it back to use `_WIN32` and stage1 builds for me again.

1563394084
andrewrk
I'm pretty sure it should be _WIN32

1563394116
andrewrk
emekankurumeh[m], was removing the underscore intentional there?

1563394124
hryx
interesting. yeah, looks like it was in my original commit:

1563394132
hryx
*was _WIN32

1563394135
andrewrk
in os.hpp we have _WIN32 as well

1563394141
mikdusan
i agree. have any idea why CI builds are NOT failing? i think they should have failed and caught that.

1563394152
andrewrk
no, it's strange

1563394164
andrewrk
I'll go ahead and make this change though

1563394190
mikdusan
andrewrk: there's one in src/util.hpp too

1563394204
andrewrk
oh, with no underscore

1563394228
emekankurumeh[m]
yeah that was a mistake

1563394249
andrewrk
no problem, incoming master branch commit

1563394266
emekankurumeh[m]
but i don't think we need the _WIN32 part because the size diff seems to be because of ABI

1563394276
mikdusan
small curiosity; any idea why CI builds didn't fail on static_assert fail that I was seeing?

1563394306
andrewrk
that remains an unsolved mystery

1563394309
emekankurumeh[m]
which static assert?

1563394311
mikdusan
ok. np.

1563394383
andrewrk
emekankurumeh[m], I haven't see the logic in clang headers but we should try to match that

1563394390
andrewrk
all we have to do is get the size correct

1563394437
emekankurumeh[m]
i mean it seems the size is different because of msvc so we should check for that alone

1563394448
andrewrk
ahh I see. that's reasonable

1563394453
mikdusan
this was the 1 of 2 failures:

1563394490
emekankurumeh[m]
are you on mingw(-w64)?

1563394505
mikdusan
windows10, visual studio 2019

1563394520
mikdusan
happens with 2017 for me as well

1563394646
emekankurumeh[m]
can you try changing `ZigClangAPValue`  to `char Data[68]`

1563394693
mikdusan
that's already confirmed to fix it. which led me to _WIN32 vs WIN32

1563394716
emekankurumeh[m]
oh okay

1563394837
gonz_
What's the story on comptime allocation?

1563394839
andrewrk
TIL gcc and clang have fixed point types

1563394850
gonz_
I thought I saw an issue on this before but maybe that was just an IRC question

1563394855
andrewrk
gonz_,

1563394875
gonz_
Ah

1563394877
gonz_
There it is

1563394909
gonz_
I didn't find it searching "comptime allocation" :|

1563395023
dimenus
why would making a packed struct make it larger? o.0

1563395054
fengb
There's a bug:

1563395082
mikdusan
thanks andrewrk;

1563395262
andrewrk
gonz_, feel free to add a comment something like "adding search keywords: comptime allocation"

1563397292
Sahnvour
andrewrk: is zig actively doing something wrt inlining of functions, excepted @[no]inlineCall ? It's been a few times I find it not inlining very much, so I'm wondering

1563397363
andrewrk
Sahnvour, zig adds the `alwaysinline` llvm attribute, and then adds an "always inline pass" when calling LLVM

1563397419
andrewrk
I thought you were asking about the inline keyword, but are you asking about release-fast builds, and inlining functions which do not have any annotations?

1563397437
Sahnvour
yeah

1563397461
Sahnvour
so every function is marked `alwaysinline` ?

1563397484
andrewrk
no, only `inline` functions are marked `alwaysinline`

1563397609
Sahnvour
ok, what about using `inlinehint` for functions that are neither `inline` nor `noinline`

1563397685
Sahnvour
I'm curious if it would help, and not increase codesize much, because as we know in c++, in the end the compiler does what it pleases

1563397888
mq32
i don't think its good to have an "maybe inline" flag. it just adds confusion about

1563397900
mq32
the @Cold and @Hot model is imho better to notify that something is timing critical

1563398112
Sahnvour
note I'm talking about the compiler's internal, not something visible from zig code

1563398136
Sahnvour
I don't really like inline hints either, but for now it looks like zig is under-inlining

1563398158
andrewrk
Sahnvour, if this is a problem with zig then it should be a problem with clang too

1563398163
andrewrk
what are we doing differently?

1563398187
emekankurumeh[m]
is there a way to test github linguist syntax locally?

1563398228
Sahnvour
andrewrk: actually looking at clang code to see how they use it

1563399425
Sahnvour
seems like they're using `inlinehint` only for functions that were hinted by the programmer

1563399611
andrewrk
that makes sense to me

1563399665
Sahnvour
yeah, so now I'm wondering if that's actually a good thing to not have inlining hints

1563399730
Sahnvour
in my case (hashing simple integers), forcing inlining causes the optimizer to see that since it knows the size of the object, the hash function can be simplified a lot

1563399764
Sahnvour
but I don't want to force this function to be inlined _everywhere_, for example when the size of the object (a slice) is not comptime known

1563399816
Sahnvour
I just wish the analysis would work across the function call, and inlining is kinf of a workaround

1563399858
andrewrk
yeah I've been thinking, there must be a better way to annotate the code other than "inline hint"

1563399874
andrewrk
what is the actual information that the optimizer is missing? maybe we can supply that

1563399941
Sahnvour
I

1563400111
andrewrk
hryx, the process was quite reasonable. here's the commit:

1563400114
Sahnvour
looks like constant propagation is stopping at the function call boundary, or something

1563400116
andrewrk
all translate-c tests passing in llvm9 branch

1563400184
andrewrk
Sahnvour, oh, one thing planned which should help is that we will pass slices as 2 parameters

1563400211
andrewrk


1563400231
Sahnvour
interesting

1563400324
Sahnvour
do you think that's a tough change ? I might be interested in doing that

1563400374
andrewrk
yes I think it will be challenging because it will cause breakage that won't be caught by compile errors

1563400383
andrewrk
not to discourage you though

1563400431
andrewrk
there are also some frequently used functions which will now have incorrect assumptions, e.g. handle_is_ptr for a slice currently returns true

1563400456
andrewrk
that should probably change to false but that will probably break other stuff

1563400585
Sahnvour
okay, well @inlineCall might do the trick in the mean time

1563400734
scientes


1563400746
scientes
^^great lwn article on optimizing compilers and undefined behavior

1563400829
andrewrk
these are all data races, every single example is invalid and should be using atomic operations

1563400852
andrewrk
(or mutexes)

1563400921
scientes
that is kinda the point

1563400936
scientes
but they are using volatile because they are in the past....

1563401320
emekankurumeh[m]
andrewrk: is `orelse` a keyword or operator?

1563401367
andrewrk
both

1563402637
ltr-
q: is the order of the evaluation of the conditions in the if statement guaranteed?

1563402740
scientes
with and and or, yes

1563402743
ltr-
and operator*

1563402744
scientes
otherwise, i don't know

1563402749
ltr-
ok

1563402753
ltr-
ty

1563402910
scientes
orelse too

1563402993
emekankurumeh[m]
re:

1563403038
scientes
2174 is a really difficult problem to solve opitmially

1563404793
scientes
i'm getting a run-time crash in a comptime block...............

1563404817
scientes
(in my added code)

1563405256
scientes
is there something special i have to do to write to the stack in comptime?

1563405852
dimenus
how do i do a raw memcpy in zig? @memcpy or is there something with even fewer rules?

1563405862
scientes
@memcpy

1563405866
Tetralux
Only that and std.mem.copy.

1563405870
Tetralux
So far as I know

1563405870
scientes
yeah the type safety of that really should be relaxed

1563405877
scientes
std.mem.copy is actually kinda broken

1563405885
scientes
because it curently guarantees forward copy

1563405891
scientes
so it might not be used correctly

1563405912
Tetralux
Maybe debug could detect that somehow.

1563405922
scientes
just add a panic test

1563405924
scientes
its quite simple

1563405935
Tetralux
Wait - it doesn't currently in debug?

1563405940
Tetralux
Even though it assumes that?

1563405943
Tetralux
That seems broken.

1563405951
Tetralux
Well - no - that's a bit far

1563405953
Tetralux
But still

1563405953
scientes
no it always does a forward copy

1563405966
scientes
but it shouldn't guarantee that

1563405977
scientes
there is also copyBackwards, which is woorse

1563405980
scientes
instead of a memmove

1563405984
dimenus
@memcpy(@ptrCast([*]u8, dest), @ptrCast([*]u8, &vertices[0]), size_of_vertices);

1563405991
dimenus
unnecessary casting :P

