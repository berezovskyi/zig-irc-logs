1564185706
daurnimator
Tetralux: `show(struct{})` or also `show(usize(1234))`: essentially being able to call it on anything.

1564187178
diltsman
Does Zig support Spir-V as a target?

1564188635
fengb
LLVM doesn't support it natively so Zig currently doesn't either

1564189068
emekankurumeh[m]
there is an open issue for spir-v as a target

1564189095
emekankurumeh[m]
there is also llvm-ir to spir-v transpiler

1564189381
diltsman
Ok.  I couldn't remember if that was resolved or not.

1564189748
emekankurumeh[m]
with the coroutine rewrite should we really rely on llvm specific features? would that make transitioning to other backends harder?

1564190144
fengb
Coroutine is no longer LLVM specific

1564191943
Tetralux
daurnimator: If 'type' is able to be a runtime value, isn't that just typeid/typeinfo?

1564191945
emekankurumeh[m]
I know, I mean the "prefix data" stuff

1564191983
Tetralux
daurnimator: i.e: `show(usize)` == `show(@typeInfo(usize))` or `show(@typeOf(usize))` ?

1564192000
daurnimator
Tetralux: wut?

1564192045
Tetralux
Unless I'm missing something obvious, doesn't what your suggesting amount to converting a `type` to a `typeid` or `TypeInfo` implicitly if you pass it at runtime?

1564192049
daurnimator
Tetralux: `show(usize(5))` ==> shows the number 5. `show(usize)` shows info about the type usize

1564192075
daurnimator
`@typeOf(usize) == type`

1564192127
Tetralux
I don't know how/if you can get/a typeid from a value.

1564192133
Tetralux
But I know you can get the info from one.

1564192141
Tetralux
But that's not the point

1564192161
Tetralux
Point is, `show(T: type)` -- What does it

1564192168
Tetralux
Surely typeid or typeinfo.

1564192221
daurnimator
Tetralux: it's `show(x: var)`

1564192285
Tetralux
Yeah - but `var` just means "specialize to whatever you pass` , right.

1564192315
Tetralux
So it'd get specialized to `show(anything: type)` if you passed a type.

1564192320
daurnimator
okay

1564192324
Tetralux
But we have typeid/typeinfo already.

1564192336
daurnimator
and then in such a function, it would be valid to do `@typeId(anything)`

1564192357
Tetralux
So

1564192359
Tetralux
To be clear

1564192371
Tetralux
I generally like the idea.

1564192417
Tetralux
But my inclination is that if you pass a 'type' to a fn at runtime, it would not be of type `type`.

1564192438
Tetralux
Because that's the type of a comptime version of a type.

1564192453
Tetralux
Like

1564192453
Tetralux
Okay

1564192458
Tetralux
I'm maybe not being clear.

1564192469
Tetralux
If 'type' can be runtime, what's the reason for having typeid/typeinfo.

1564192485
Tetralux
Does it make sense for there to be three such things?

1564192503
Tetralux
I'm not really seeing the advantage of having three over two.

1564192519
Tetralux
But perhaps it's just not clear to me.

1564192540
daurnimator
Tetralux: I don't understand the question

1564192559
daurnimator
Tetralux: the reason for @typeInfo is to get information about a type...

1564192569
Tetralux
Indeed.

1564192577
Tetralux
i.e: the runtime version of a 'type'.

1564192581
daurnimator
?

1564192594
daurnimator
a typeinfo is not runtime

1564192596
Tetralux
Or rather, the metadata about a type.

1564192614
Tetralux
(.. which is available at runtime.)

1564192628
daurnimator
@typeInfo is rarely valid in a runtime variable

1564192628
Tetralux
But typeid is also available at runtime.

1564192648
daurnimator
pieces of it are. but @typeInfo for most types contains comptime_ints, and child `type`s.

1564192679
Tetralux
.. Whereas typeid is basically just an integer that's unique to a particular type.

1564192726
daurnimator
no it's not... @typeId is the enum of type.... types.

1564192769
Tetralux
I'm not sure that makes sense to me xD

1564192832
nrdmn
is there any good way to completely disable stack probing in PE binaries?

1564192861
daurnimator
Tetralux: @typeId returns the type of a type => i.e. Bool vs Int vs Struct vs etc.

1564192880
daurnimator
`subtype` might be a better word

1564192897
Tetralux
Sounds like `typeOf` might be a better word xD

1564192929
daurnimator
??

1564192935
Tetralux
That sounds like it should be an enum field on TypeInfo.

1564192942
daurnimator
it is

1564192951
daurnimator
TypeInfo is a union over TypeId

1564192959
Tetralux
OH

1564192967
Tetralux
So TypeId is the tag type for TypeInfo?

1564192977
daurnimator
yes

1564192985
Tetralux
OKAY

1564192991
Tetralux
That makes a touch more sense.

1564192992
daurnimator
WHY ARE WE YELLING

1564192994
Tetralux
XDDD

1564192998
Tetralux
BECAUSE IM YELLING

1564193008
Tetralux
IM HAVING A REALISATION OVER HERE OKA\Y

1564193089
Tetralux
I'm not sure why you'd want to have `typeid` be a type, when you have builtin.TypeId.

1564193105
Tetralux
Since it's just the tag type.

1564193108
Tetralux
But still.

1564193110
daurnimator
what?>

1564193118
Tetralux
show(t: typeid)

1564193128
Tetralux
instead of just `show(t: builtin.TypeId)`

1564193129
daurnimator
did anyone propose that?

1564193140
Tetralux
I'm pretty sure I've seen code with that.

1564193159
Tetralux
Though, you're surprise makes me question myself a tad xD

1564193220
daurnimator
I don't see that used anywhere in the standard library

1564193228
Tetralux
Hmmm.

1564193230
Tetralux
Odd.

1564193246
Tetralux
/shrug

1564193254
Tetralux
XD

1564193287
Tetralux
But yes - if it's fair to say that both type and TypeInfo are compile time, then the difference between them is just that one is for typechecking, and the other is metadata?

1564193290
Tetralux
Is that a fair summation

1564195307
scientes
Tetralux, generally you are only going to pass around types

1564195313
scientes
or var

1564195355
scientes
everything is is just to manipulate the types

1564195360
scientes
*everything else

1564195371
Tetralux
Makes sense.

1564195429
scientes
I just ran into that today

1564195450
scientes
I will have to create a function that examines a var, and checks if the type is the type passed, or a vector with that as the scalar type

1564195464
scientes
and throws a @compileError() otherwise

1564195487
Tetralux
I might be a little spoiled from how Jai has you pass around typeinfos at runtime and only handles variables of type `type` at comptime. :D

1564195535
scientes
that sounds like dynamic typing

1564195604
scientes
we have had proposal for that, mainly stemming from wanting to return values attached to errors

1564195627
Tetralux
Nah - doing `show(usize)` in Jai would essentially the same as `show(@typeInfo(usize))` in Zig.

1564195637
Tetralux
IIUC.

1564195650
Tetralux
It's been a while since I saw him show that off.

1564195705
Tetralux
Except that TypeInfo in Jai, is not comptime.

1564195706
scientes
i really dislike dynamic typing

1564195714
scientes
because a bunch of errors get pushed to run-time

1564195720
scientes
that could be caught at compile-time

1564195742
scientes
maybe we should have sets of types

1564195753
scientes
instead of just "var"

1564195769
scientes
type theory is really complicated...

1564195776
Tetralux
Meh.

1564195802
Tetralux
I like var, because it means something specific: specialize to whatever type you pass.

1564195814
Tetralux
Though maybe that could be more explicit?

1564195846
scientes
well you end up writing your own type checking code

1564195864
scientes
I haven't worked with haskell much or really understoood it, but people that do say the type system is great

1564195868
Tetralux
I haven't needed to try yet

1564195883
Tetralux
But I'd start off trying to just assume I can do certain things with the type.

1564195885
fengb
The people who can understand the type system say it's great :P

1564195888
torque
is a union not a set of types

1564195893
Tetralux
(the var of the type passed)

1564195913
torque
I guess the issue is runtime specialization with unions

1564195927
Tetralux
In my limited experience, it's kinda wordy - like Java. But "worse.2

1564195931
Tetralux
"worse."

1564195932
scientes
torque, yes

1564195947
scientes
you need a way to tag the union with an enum

1564195966
scientes
and then the grainy issue of trying to provide type safety to that, and even compile out the enum at times

1564195979
scientes
cause dynamic types actually kinda suck

1564195990
fengb
You could use it as a pseudo functional type union but it's still statically defined

1564196018
scientes
yeah but you are checking the type id

1564196018
torque
dynamic types suck a lot which is why people have spent ridiculous amounts of effort shoehorning static typing into languages that are inherently dynamically typed (see typescript and python)

1564196027
fengb
So it's not as flexible as an ML-like union

1564196081
scientes
like full-blown dynamic typing really sucks, but having sets of types is quite reasonable at times

1564196099
torque
julia has the most understandable and expressive typing system I've run into (though there are probably other languages that are as good or better)

1564196171
fengb
Haskell is expressive :P

1564196177
fengb
Elm is understandable >_>

1564196212
scientes
zig's type system is already quite expressive

1564196222
scientes
**quite rich

1564196226
scientes
but not very expressive

1564196347
fengb
On principle, I kinda wish Zig has traits or interfaces or something of the sort... but I haven't encountered a strong need

1564196367
scientes
it has interfaces

1564196370
scientes
compile-time

1564196377
fengb
I mean runtime

1564196388
scientes
but why?

1564196390
fengb
Zig's generics is surprisingly good

1564196390
scientes
what does that give you

1564196398
scientes
fengb, beautiful

1564196407
scientes
i'm kinda a zero-cost abstraction person

1564196413
fengb
The allocator "interface" is pretty kludgy

1564196432
fengb
It works but it's via magic pointer offset voodoo that's easy to break

1564196442
scientes
its not voodoo

1564196453
scientes
@fieldParentPtr is better than Linux's container_of() macro

1564196464
scientes
and it is also zero-cost

1564196490
fengb
There's a ticket that explains the cost. It's hostile to LLVM optimizations

1564196500
scientes
but yes there is a good proposal to add type safety to @fieldParentPtr()

1564196516
fengb
I think it's pretty cool we have userland interfaces, but it also feels rather hacky

1564196537
scientes
@fieldParentPtr is something that go fundamentally can't do

1564196544
fengb
But again... I haven't encountered a strong reason in awhile. Just a principle thing that I want some sort of dynamic dispatch :P

1564196547
scientes
and they are tons of cludges in go to do half of what it does

1564196577
scientes
but yes that proposal is great

1564196580
Tetralux
I don't want dyn dispatch.

1564196586
Tetralux
I want that to be very obvious.

1564196590
Tetralux
And be discouraged.

1564196591
scientes
dynamic anything is risky

1564196602
Tetralux
Otherwise Rust traits happen everywhere xD

1564196632
Tetralux
Or well - not quite cuz those are more static.

1564196639
Tetralux
But dyn traits -- nope.

1564196726
fengb
I just want a little polymophism. I've gotten by with function pointers just fine, but that's because I have statically defined fields

1564196754
fengb
But again... it's a "want", not a need so far

1564196774
scientes
fengb, yeah it would be nice to have "safe" dynamic casts

1564196828
scientes
not only @fieldParentPtr, but also specialization

1564196833
scientes
like IrInstruction in stage1

1564196887
scientes
but  I guess that is union(enum)

1564196983
fengb
Union only works if you know all the types ahead of time. Although... most of the complex usecases I can remember about using polymorphism were all predefined

1564196997
scientes
wut?

1564197001
scientes
types are always comptime

1564197018
fengb
nvm

1564197074
scientes
uggh, its late i should go to sleep

1564197185
scientes
what about a ways to limit the amount of language features a program uses?

1564197198
scientes
nah

1564197206
scientes
that is only relevent if you want your langauge to be "safe"

1564204980
emekankurumeh[m]
Sobeston did you make any progress on that issue you were having earlier?

1564205780
emekankurumeh[m]
grr, i just figured out the error i was having

1564205806
emekankurumeh[m]
linking libc for mingw-w64 moves the section with the pdb info

1564208203
emekankurumeh[m]
i just realized lld can generate dwarf debug info for windows executables, so that raises the question when building zig executables on windows for mingw do we use pdb or dwarf?

1564208279
gonz_
I would assume tools will have pdb support

1564208304
gonz_
There are debuggers that will read pdb but not the way llvm creates them, as well, for example

1564208327
gonz_
so the most valuable option on Windows is to do it exactly the way `cl` would do it

1564208789
gonz_
The `RemedyBG` debugger doesn't work properly with zig, for example.

1564208809
gonz_
Happily windbg does

1564208819
emekankurumeh[m]
is the issue with lld's pdb's

1564208844
gonz_
As far as I can see on their issue tracker it's something like that, yes

1564208856
gonz_
They don't read the way lld/LLVM does it

1564208873
gonz_
Presumably this should be an easy add for them, but they're not prioritizing it

1564208970
gonz_
I think one ought to try everything and see what works best, obviously

1564213527
ArtlessMaladroit
Hello community, attempted convertee here. I'm trying to port some projects to Zig to get myself familiar with it and I've run into a road block with function pointers. I'm trying to do something like: "pub const FnAlias = ?extern fn([*]const u8, ...); pub var FnPtr: FnAlias = null;" which I then later assign to at runtime with "FnPtr = @ptrCast(Fn

1564213527
ArtlessMaladroit
Alias, addrOrigFn);" this is all fine but then when I later try to call it like: "FnPtr(args);" it reults in a compile error that the type isn't a function. What's the proper way to do this, or if not this, achieve the same effect of converting an address to a potentially null function pointer?

1564214056
gonz_
ArtlessMaladroit: Can you put a minimal example of what you want up on godbolt for people to see what you mean and play around with?

1564214077
gonz_
(

1564214470
gonz_
This seems like a minimal example of something like what you're talking about, correct?

1564214668
gonz_
Here's a modified version that unpacks the `?`:

1564214706
gonz_
Using `if (possibly_null) |unpacked_value| { doStuff(); }`

1564214807
gonz_
ArtlessMaladroit: Given the possible nullity of that variable, unpacking it explicitly is a very good way of handling it

1564214903
ArtlessMaladroit
Here's what I was originally trying to do:

1564214903
gonz_
Considering the type of `FnPtr`, it's certainly not actually a function. It's

1564215145
gonz_
I think the current situation at least points to it being just a type error because maybe null has to be checked

1564215147
ArtlessMaladroit
gonz_ Tried it out and it also gives me the TODO error. I guess it's just not implemented yet?

1564215183
gonz_
Can you paste the error if it's not too wordy?

1564215211
gonz_
Ah, the TODO with the issue

1564215212
ArtlessMaladroit
error: TODO: support C ABI for more targets.

1564215302
gonz_
Just to double check as well, is this on master?

1564215368
ArtlessMaladroit
I think I'm a bit behind: version 0.4.0+1547692d I'll go download master now and check though

1564215407
gonz_
I have no idea how much recent activity has been done on this, but you never know without talking to andrewrk

1564215576
ArtlessMaladroit
Yeah, the error persists on master as well. I'll follow the progress of the issue, just wanted to make sure I wasn't just doing something very wrong. Appreciate the feedback.

1564215762
gonz_
Is the use case trying to load one of the many different versions of DLLs depending on which is available, etc.?

1564215909
ArtlessMaladroit
Yep, getting the module of a loaded dll then calling GetProcAddress and attempting to assign that to a global variable to be called from elsewhere.

1564226124
Sahnvour
gonz_: interesting remedyBG doesn't work with zig executables, because LLVM tries to follow PDB format as closely as possible

1564226183
Sahnvour
and in fact does, because it can build complex C++ project and have native debugging working perfectly with windbg/visual studio

1564227253
gonz_
Reality is often disappointing.

1564227314
gonz_
The highest hit rate with regards to debugger friendliness will undoubtedly be "do it exactly how `cl` does it" regardless of whichever values one has.

1564231831
scientes
what about a bit pointer type

1564231891
scientes
(that can't be volatile)

1564232783
scientes
cause large bit manipulation is so painful

1564234525
scientes
Yeah a bit pointer type would make it much less painful

1564234878
gonz_
scientes: Did you just agree with yourself? :D

1564234901
scientes
well i'm doing it and its painful

1564234904
scientes
to bit pack

1564234915
scientes
what we could have would be "packed" pointers

1564234931
scientes
like var a: *packed u7 = undefined;

1564234939
scientes
which would underneath be a bit pointer

1564234957
scientes
and if you did pointer arithmatic it would move 7 bits at a time

1564235102
scientes
once you think about it this whole byte thing is the weird thing

1564235111
scientes
and 64-bit machines don't really need bytes

1564235117
scientes
because they have so much address space

1564237897
gonz_
scientes: I don't think I quite understand what it is you're doing. Is there some way you can illustrate what it is and what the purpose is?

1564237916
scientes
well I'm writing @bitCast to work with vectors

1564237925
scientes
and it means i have to serialize

1564237943
scientes
and it is just annoying that I manually have to deal with the fact that pointers only address bytes, and not bits

1564237975
scientes
the code would be WAY simpler if I could just have bit-granularity type sizes and pointer addressing

1564238030
scientes
it would also mean zig was more portable, if everything was just in bits

1564238057
scientes
a 8-bit byte pointer would just refuse to be taken out of alignment

1564238330
scientes
the language would be quite a bit simpler if the concept of bytes was completely eliminated, except in @alignOf()

1564238338
scientes
and @sizeOf()

1564238349
scientes
but @sizeOf() would require bits

1564238358
gonz_
Do you know of any examples of this being done previously on a big scale?

1564238373
scientes
no

1564238382
scientes
it could be done with proper types however

1564238386
scientes
all at compile-time

1564238403
scientes
generally you would still be using bytes under the hood, as that is how current hardware works

1564238412
scientes
but there really is no need to have that be part of the language

1564238453
scientes
i.e. most pointers would have align(3), i.e. byte aligned

1564238466
scientes
and that would be the default

1564238480
scientes
**that would be default due to the way @sizeOf works

1564238496
scientes
you would have to use "packed" to override that

1564238646
mikdusan
can you provide an example of a vector bitcast?

1564238675
scientes
var a: @Vector(4, u32); return @bitCast(u128, a);

1564238738
mikdusan
and anything under u8 is not applicable, correct?

1564238750
scientes
no i want to make those work too

1564238763
scientes
there is no reason to not support everything, even if it won't be as performant

1564238779
mikdusan
iirc you mentioned ppc did not pack vectors

1564238804
scientes
that is just the result of comparisons

1564238814
scientes
is a sext bool of the size of what was compared

1564238821
scientes
which means you can use bit-wise | and & on it

1564238842
scientes
that's kinda nice so I wanted to add a implicit cast from vectors of bools to that

1564238850
scientes
if the number of elements is the same

1564239724
companion_cube
weird question, but is there a way to index using isize and not usize? it's for a C pointer from weird code

1564239737
scientes
yeah Linux has that: ssize_t

1564239745
scientes
so does C++ with ptrdiff_t

1564239755
scientes
(ptrdiff_t BTW is an abomination)

1564239757
companion_cube
so should I cast my int to isize?

1564239775
scientes
companion_cube, use @intCast()

1564239784
scientes
which will panic (in debug mode) if the integer is negative

1564239787
companion_cube
but if I cast -1 into an usize?

1564239794
scientes
it will panic

1564239798
companion_cube
ah but that's the thing: this code uses actual negative indexing

1564239799
scientes
undefined

1564239809
scientes
oh, then use isize type

1564239809
companion_cube
(the pointer is in the middle of the array…)

1564239820
scientes
ahhh

1564239823
scientes
yeah that is a feature request

1564239837
companion_cube
:D ok

1564239839
scientes
to allow that for [*] arrays

1564239857
scientes
but you could do it with pointer arithmatic

1564239896
companion_cube
it's for [*c] here, as it's a lot of magic

1564239924
Tetralux
For clarity, `(ptr-1).* = ...` would modify the memory one memory address unit lower than the ptr value?

1564239932
Tetralux
Or "behind" the value, if you prefer.

1564239938
Tetralux
(Closer to NULL.)

1564239986
Tetralux
Well no - that's not it. You can do that already.

1564240120
Tetralux
Or am I wrong?

1564240131
Tetralux
I probably am lol

1564240160
scientes
Tetralux, you can by doing (ptr+offset).*

1564240185
scientes
but I don't think you can do ptr[offset] where offset is a signed number

1564240212
Tetralux
You can do ptr[offset] for [*]T ptrs in Zig

1564240213
Tetralux
?

1564240221
Tetralux
I don't think I've ever actually tried that.

1564240224
scientes
> where offset is a signed number

1564240243
Tetralux
To be clear, you

1564240248
scientes
yes

1564240250
Tetralux
Okay.

1564240267
Tetralux
Then yeah, that does sound somewhat reasonable to me.

1564240344
Tetralux
companion_cube: You probably did this already, but the workaround would be to @ptrToInt, subtract the amount, and then @intToPtr again.

1564240351
Tetralux
I believe that would work.

1564240365
scientes
also check if pointer arithmatic work

1564240367
scientes
i think it does

1564240383
scientes
(ptr+offset).*

1564240421
Tetralux
For -1, it'd be (ptr-1).* -- but yes. I believe that works on [*]Ts.

1564240427
companion_cube
no I didn't try, sounds like a good workaround

1564240433
scientes
Tetralux, you can add a negative number

1564240445
companion_cube
although it'd subtract in bytes, rigt

1564240448
companion_cube
right?

1564240455
scientes
no, add

1564240462
scientes
well yes

1564240466
scientes
i didn't read the whole sentence

1564240468
Tetralux
XD

1564240481
scientes
companion_cube, no bytes at all

1564240485
scientes
that concept doesn't apply

1564240497
scientes
it subtracts/adds in the ABI size of the type

1564240516
scientes
that's why I opened this

1564240516
scientes


1564240525
scientes
the concept of bytes is confusing and unnecessary

1564240580
Tetralux
I believe companion_cube is asking if for [*]T, (ptr+offset).* would be (ptr+(offset*@sizeOf(T))).*

1564240582
companion_cube
oh so the integer is really a multiple of the sizeof T, not a number of bytes

1564240601
companion_cube
yes tat's the question!

1564240627
Tetralux
I don't think I've needed to test that yet, but I'd be surprised if the offset was not in "number of Ts"

1564240637
scientes
thats why sizeof should just return bits

1564240653
Tetralux
(I would expect it to move my sizeOf(T) and not bytes.)

1564240657
Tetralux
my => by *

1564241032
Tetralux
I'm not entirely clear about why returning bits is more useful.

1564241067
scientes
Tetralux, because it eliminates "bytes" from the language

1564241075
scientes
it removed an entire concept

1564241080
scientes
*removes

1564241093
scientes
a concept which doesn't really help portability either

1564241107
Tetralux
I use bytes all the time, so I'm not sure what you're suggesting xD

1564241294
Akuli
the c standard defines byte as a thing that has n characters for some integer n >= 8

1564241317
Akuli
so you could have a system where c's char, a type whose size is one byte, is 32 bits

1564241337
scientes
Akuli, yeah its way too complicated and completely unnecessary

1564241350
Akuli
like someone on so said

1564241354
scientes
and the only place where it really matters, @ptrToInt, and @intToPtr, the C standard is silent

1564241359
Akuli
for any machine connected to internet, char is 8 bits

1564241371
scientes
yeah and Zig will continue to support that

1564241381
scientes
but with size "8", and not "1"

1564241395
Akuli
:)

1564241406
Akuli
so in zig we just call it u8 and that's it?

1564241417
scientes
no, there is also c_char

1564241423
Akuli
mmh lol

1564241437
scientes
or rather these

1564241437
companion_cube
well u8 is a char, right?

1564241440
scientes
guess there is not c_char

1564241447
scientes
companion_cube, no, on x86 it is i8

1564241450
scientes
but on arm it is u8

1564241459
companion_cube
well unsigned char

1564241463
Akuli
there are systems where c's char is u16 or u32

1564241475
scientes
yeah we should probably have c_char there too because of that

1564241478
companion_cube
anyway, the unit for utf8

1564241501
Tetralux
Personally, I'd find 'oct' (for octet) easier to type than u8 - not that I'm seriously suggesting that change.

1564241520
Akuli
put your index finger on u, middle finger goes to 8 automagically

1564241524
Akuli
u8

1564241525
companion_cube
u8 is very explicit ♥

1564241552
Akuli
(sorry i assumed that you are using a querty keyboard)

1564241581
Tetralux
Akuli: I just haven't needed to type u8

1564241593
Tetralux
I also do like both the consistency and simplictly of u8.

1564241596
Tetralux
I like u8.

1564241600
Tetralux
I just don't like typing u8 xD

1564241604
scientes
Tetralux, it isn't an octet, that would be u3

1564241616
Akuli
to type oct, i type o with my right hand middle finger, then i type both c and t with left hand index finger, moving it from c to t

1564241617
companion_cube
const myByte = u8; ?

1564241630
Akuli
hmm

1564241633
Akuli
const hex = u8;

1564241638
Tetralux
Akuli: I type 'o' with my right hand and the other two with my left. All index fingers.

1564241656
Tetralux
scientes: No, it is octet.

1564241671
Tetralux
That's a well established name for a byte AFAIK.

1564241678
Tetralux
(A byte that is 8 bits.)

1564241696
companion_cube
ugh, this C code does so many ugly things

1564241700
Tetralux
Perhaps I'm wrong but... :)

1564241728
Tetralux
Akuli: Well yeah, I could define const oct = u8, but then it doesn't light up in my highlighting and I feel sad xD

1564241741
Akuli
write a better highlighter :D

1564241761
Tetralux
No point - it's Sublime.

1564241788
Akuli
i think there should be a way to put common typedef names or similar in editorconfig

1564241801
Tetralux
I just don't wanna have to fiddle with it.

1564241808
Tetralux
I want to have an editor that just works (TM).

1564241820
Akuli
i wrote my own editor so :D

1564241827
Tetralux
Can I have it? xD

1564241836
Akuli


1564241848
Tetralux
I've considered 4Coder. It has some things I like, but...

1564241850
Tetralux
Not there y et.

1564241858
Akuli
tbh it just uses a library for highlighting

1564241861
Akuli
but that library is customizable

1564241879
Tetralux
Does it just have Py highlighting?

1564241893
Akuli
no it highlights pretty much anything

1564241896
Tetralux
Nope - just read that part in the readme xD

1564241902
Tetralux
Pygments is what Github uses no?

1564241914
Akuli
github used pygments before i think, they don't use it anymore

1564241937
Tetralux
Only, I program in Odin too and GH doesn't have highlighting for that.

1564241950
companion_cube
you like to live on the edge

1564241961
Tetralux
I like to use nice tools x)

1564241984
fengb
How about V then? :P

1564241997
Tetralux
I'm the guy that wants to buy a £15 mechanical pencil.

1564242005
Tetralux
But doesn't do that very often.

1564242016
Tetralux
I have... questions about... V. xD

1564242030
Tetralux
If I had the complete source code of it, then... /shrug.

1564242040
Tetralux
Depends how nice it is to use and debug stuff with.

1564242044
fengb
It’s been released

1564242046
companion_cube
there's 0.1% chance that V will yield anything useful ever

1564242077
Tetralux
One of my biggest complaints is that there isn't really a good debugger on Windows.

1564242091
Tetralux
VS is basically all you've got.

1564242122
Tetralux
GDB is damn near a hazard to install on windows.

1564242136
scientes
just debugg in wine

1564242139
Tetralux
And debug info is off in VS.

1564242151
Tetralux
(off meaning not entirely accurate)

1564242159
Tetralux
I could, but that's god-awful slow.

1564242172
Tetralux
Though it does help you debug bad winapi calls which is a godsend.

1564242175
Tetralux
I didn't know it did that.

1564242192
Tetralux
wine-dbg takes over five seconds to even begin running the program.

1564242227
Tetralux
I like having a simple lightweight interface where I can easily

1564242247
Tetralux
Like data breakpoints. I'd have to wade through text menus to figure out how to do that in gdb.

1564242262
Tetralux
VS isn't really much better. If at all.

1564242280
Tetralux
I don't wanna spend hours figuring out how to do the thing I want.

1564242287
Tetralux
I want to ask it and have it tell me.

1564242291
Akuli
look it up on google :)

1564242293
Tetralux
That's why I like the windows start search so much.

1564242302
Akuli
i know about 4 gdb commands and it's enough for my debugging needs

1564242330
scientes
eventually you will need reversable debugging

1564242338
scientes
and conditional breakpoints

1564242343
scientes
but yeah i was like you for a long time Akuli

1564242350
Akuli
don't tell me what i need, i survived for years with print

1564242358
Akuli
not in c though

1564242364
scientes
oh wow

1564242366
Akuli
but i still debug everything with print in other programming languages

1564242375
scientes
well of course

1564242376
Akuli
it's easy and it works

1564242379
scientes
but debuggers are nice

1564242392
Akuli
i think i have actually used the python debugger like once

1564242410
Tetralux
Personally,  I want to see someone write a debugger where you can just search for keywords about what you want to do, and it just tells you and lays out how to do it.

1564242410
companion_cube
print is nice for logic bugs, debugguers for index/memory errors, in my experience

1564242429
Akuli
i just valgrind to find memory issues :D

1564242431
Tetralux
print is terrible if you want to monitor multiple things at once and see if one changes as you step though.

1564242447
Akuli
so are my 4 debugger commands, why would i want to do that? lol

1564242456
Sahnvour
Tetralux: what do you mean debug info is off in VS ?

1564242485
Tetralux
In C/C++ it only shows you the line, not the stmt that's running, and in Odin/Zig it doesn't even correctly do that.

1564242516
Sahnvour
well that depends more on the debug info itself

1564242518
Tetralux
Sometimes you have to press step-forwards twice to go to the next line.

1564242528
Tetralux
This is rediculous man xD

1564242529
Akuli
if line only is a problem, you have too much stuff on your lines

1564242556
Tetralux
I tend to like to do things like `if (!x) return 0, false` etc.

1564242570
Tetralux
But still

1564242573
Tetralux
For instance

1564242575
Sahnvour
in zig it actually does highlight the expression being run, and there can be multiple ones on the same line

1564242585
Tetralux
Maybe you want `f(g(x))` to show you what g(x) gives back

1564242596
companion_cube
so when you write in a higher level language, most errors are logic errors so debugguers are less useful

1564242625
scientes
if your language is turing complete you will have to debug it at some point

1564242633
Tetralux
Like

1564242636
Tetralux
Don't get me wrong

1564242647
Tetralux
I think that Zig's stack traces for errors are very useful.

1564242653
Tetralux
The less time I spend in a debugger the better.

1564242657
Tetralux
But I still want to have a debugger.

1564242677
Tetralux
If I have a complex program, I probably need a debugger.

1564242685
Tetralux
Though, if any language has a chance of overcoming that

1564242688
Tetralux
I'd probably be Zig.

1564242703
Tetralux
JUST because of those traces, and segfault traces, and memory traces in general because of the debug allocator.

1564242729
scientes
yeah i kinda agree

1564242761
Sahnvour
all these things are nice to have, but nothing new and don't remove the need for a debugger ever, I think. In any sufficiently complex program you will end up having to inspect its state when the behaviour seems wrong.

1564242785
companion_cube
hmm, in vim I used to have error report on save, but not anymore — is it because the build requires --library c inthis case?

1564242786
Sahnvour
bugs are not just about crashes and memory leaks

1564242804
scientes
Sahnvour, it still saves you when you can't reproduce the problem

1564242812
scientes
so i think its a good idea

1564242843
Sahnvour
it's great indeed, just not solving every problem where a debugger is handy :)

1564242880
scientes
UML just introduced time travel

1564242893
scientes
so time jumps forward if there is nothing to do

1564242904
scientes
and you can even set it to make all cpu take zero time

1564243054
Tetralux
Akuli: Awwh dangit - the editor doesn't have DPI awareness?

1564243135
scientes
yeah, maybe i wont buy a 4K laptop

1564243960
Tetralux
Oh?

1564243973
Tetralux
I did. I'm spoilt for life now.

1564243982
Tetralux
Text is nice to read now xD

1564243984
gonz_
I think there are certain circumstances that make debuggers more or less useful. In Erlang I've literally never wanted a debugger because all the interesting bugs happen in code that does message passing.

1564244007
gonz_
Using stop-the-world debugging in a system like that will change the entire dynamic of the system and effectively make it behave abnormally.

1564246629
scientes
how do i test if the bits in one number are differn't from the bits in another number, i.e. 1010 | 0101 (differn't), vs 1010 | 1101 (some the same) ?

1564246664
scientes
oh, you have to do assert(a | b == a & b)

1564246665
fengb
Xor

1564246678
scientes
** assert(a | b == a ^ b)

1564247383
fengb
If there's *any same*, that'd be `a ^ b != 0`

1564247506
scientes
fengb, not true

1564247545
scientes
for intersection you need both or and xor

1564247573
fengb
Oops, that's any different. I got it mixed up

1564248851
scientes
which is actuall nor

1564248854
scientes
*nor

1564248923
scientes
and you can do everything in a computer with only nor and if

1564248950
scientes


1564249841
Akuli
Tetralux, what is dpi awareness :D

1564249859
Tetralux
I'm not entirely sure if you're serious or not xD

1564249863
Akuli
i am

1564249872
Akuli
i know about pixels and not much else

1564249884
Tetralux
To my knowledge, high DPI will not work on programs that do not declare themselves as "DPI aware"

1564249903
Tetralux
This means that on high-res screens (like 4k screens) the program with render things blurry.

1564249913
Akuli
pixely or blurry?

1564249917
Tetralux
Blurry.

1564249926
Tetralux
Because it's basically a bitmap scale.

1564249940
Akuli
how else would a display work than with a bitmap scale?

1564249967
Tetralux
But if they are DPI aware, then they automatically (I'm not sure if Windows does it or the program does it) render things at the larger size.

1564249993
Tetralux
So fonts that are drawn will be drawn at a larger point size.

1564249997
Tetralux
For example.

1564250010
fengb
On a Mac, they treat high DPI at a lower resolution: 2880x1800 is treated as 1440x900 in the math

1564250012
Akuli
does a font with size 12px render with more than 12px of precision?

1564250028
fengb
So if you're not high DPI aware, it'll render as upscaled 1440x900

1564250048
Tetralux
fengb: You mean they render at a large size and scale down if not DPI aware?

1564250088
fengb
No I mean they're rendered at "native" 1440x900 and then scaled up to 2880x1800 physical pixels

1564250123
Tetralux
Does "native" mean "the size of your primary screen" ?

1564250138
fengb
Dunno how it works on other OSs, but the Mac basically has "half pixels" on HDPI

1564250148
Tetralux
Akuli: If DPI aware, it'll essentially just increase the font size to be the appropriate amount, rather than bitmap upscaling it.

1564250178
Tetralux
I don't know how you actually make that work though. I

1564250182
Akuli
which operating system do you have?

1564250190
Tetralux
But I've never actually written a program that uses it so I don't actually know.

1564250194
Tetralux
Win 10 x64.

1564250214
Akuli
i only have windows 10 in a vm, and it eats up 4gb of ram every time i start it, lol

1564250221
Akuli
not exactly a thing i want to touch when not needed

1564250229
Akuli
if you can get it to work, please send a pull request :)

1564250243
fengb
Fonts are mostly vector based so I'd expect most fonts to behave correctly at HDPI, e.g. 12px might not be physical pixels

1564250271
Akuli
you can call winapi functions from python with ctypes, something like ctypes.winapi.SetProcessDpiAwareness(1)

1564250391
fengb
Tetralux: my terminology is confusing. Mac treats 2880x1800 physical pixels as 1440x900 software pixels. And each software pixels can be referenced via float half-pixel

1564250422
Tetralux
Akuli:

1564250448
fengb
So if the software is not HDPI aware, it works just fine but everything is blurry because they're 2x upscaled

1564250700
Akuli
hmm or maybe it's something like ctypes.CDLL(ctypes.util.find_msvcrt()).SetProcessDpiAwareness

1564250706
Akuli
it's been a while since i used ctypes

1564250835
Akuli
i found some code for you :D

1564251904
Tetralux
So I took a brief glance at the code

1564251914
Tetralux
But cannot figure out where the entry point is.

1564251916
Tetralux
xD

1564251931
Tetralux
If I could, I'd try putting a call to the winapi at the top of main

1564251949
Tetralux
ctypes.windll.LoadLibrary("shcore")

1564251949
Tetralux
; ctypes.windll.shcore.SetProcessDpiAwareness(2)

1564251954
Tetralux
Something like that.

1564252146
Akuli
for a quick and dirty hack, just put it to any of the porcupine/blah.py files :D

1564252181
Akuli
the more correct place for it is the main() function in porcupine/__main__.py

1564252279
Akuli
porcupine.init(blah blah) creates the window, so you need to put it before that

1564252832
Tetralux
Already tried putting it at the top of main. Even assert(False) didn't assert there.

1564253770
Akuli
how are you running porcupine?

1564253789
Akuli
you likely have two porcupines now, an installed porcupine and a porcupine from 'git clone'

1564253967
Akuli
i have multiple porcupines too, i use one for all real work, including developing the other one :D

1564255332
Tetralux
Where does it install it to?

1564255337
Tetralux
When you don't clone it.

1564255429
Akuli
i don't remember :D run py on cmd, then type 'import porcupine', then just 'porcupine'

1564255452
Akuli
if you have a cloned porcupine, cd to the directory where readme is and run 'py -m porcupine'

1564255593
Tetralux
Ta

1564255595
Tetralux
That worked

1564255614
Tetralux
So calling SetProcessDpiAwareness(2) before init makes it not blurred

1564255630
Tetralux
But it then it's small, because it's at native resolution.

1564255641
Akuli
mmh

1564255642
Akuli
awesome

1564255659
Tetralux
So now everything that's rendered has to have it's size scaled to the DPI of the screen you are on in order to be a good experience.

1564255675
Akuli
i think i know how to make the font sizes bigger

1564255678
Tetralux
The default is 96DPI. You get a message on the windows message loop when the DPI changes.

1564255695
Tetralux
You also have a winapi call that tells you the DPI you're actually dealing with.

1564255707
Akuli
there is this thing i found and i have no idea what it does

1564255744
Tetralux
I found this if it helps

1564255745
Tetralux


1564255753
Akuli
oh you found a tkinter question too

1564255757
Tetralux
;)

1564255857
Tetralux
Giving 1 to SetProcessDpiAwareness means that it only detects the DPI at startup (bad) - and 2 means it updates when the DPI changes (like if you drag it onto a different monitor) (good.)

1564255877
Tetralux
If it's 1, it takes the DPI of the monitor it first appears on, at first glance.

1564259344
scientes
wow, once you get use to zig's safety C is painful

1564259423
companion_cube
once you tried anything else…

1564259444
scientes
heh, I like C!

1564260059
scientes
…

1564260068
scientes
hmm compose plus TWO . is …

1564260072
scientes
should be three

1564260331
companion_cube
…

1564260345
companion_cube
‽¿¡

1564260367
companion_cube
damn I'm spoiled by languages with stdlib docs and LSP :s

1564260510
scientes
LSP?

1564260569
companion_cube
language server protocol

1564260572
companion_cube
I mean a semantic plugin

1564260580
scientes
well i don't have enough memory for that

1564260584
scientes
even for c/c++

1564260604
Akuli
some day i'll implement lsp support in my editor :D

1564260613
Akuli
for now, grep ftw

1564260683
companion_cube
well works for OCaml and rust :s (even though the rust plugin could be improved)

1564260702
companion_cube
jeez I dislike this block expression syntax so much

1564260776
hryx
companion_cube: what do you dislike about it?

1564260836
scientes
the blocks are so powerful

1564260843
scientes
and awesome, because you can comptime initialize things

1564260858
scientes
they are def. differn't, but once you start getting use to them

1564260917
companion_cube
hryx: it's verbose and there's a useless name

1564260924
companion_cube
I just want {foo; bar; x} -_-

1564260996
companion_cube
(so it's easy to turn `x` into `{ warn(whatev); x }` and conversely, for example)

1564261019
scientes
but that would break the arguments are const thing

1564261027
scientes
well i guess it wouldn't have to

1564261039
scientes
what is wrong with "return x"

1564261040
hryx
the label isn't useless when you have nested blocks, but a lot of people do wish for the ability to break without one

1564261051
hryx
there was discussion recently on GitHub if I recall

1564261061
scientes
explicit returns are ugly and a thing of dynamically typed languages

1564261079
scientes
not really a fan

1564261086
scientes
*implicit returns

1564261091
companion_cube
hryx: it should be optional ten

1564261092
companion_cube
then*

1564261109
Tetralux
"Only one way to do things."

1564261112
companion_cube
like, sure, if you have a weird case where you want to return from several nested blocks, name the outside one

1564261118
companion_cube
same as for loops

1564261124
companion_cube
would you want to name every single loop?

1564261125
scientes
Tetralux, optional names I don't think beaks that

1564261135
scientes
its still the same way

1564261149
Tetralux
I meant optional return to break with a value

1564261167
companion_cube
also `return` I find a bit ugly too, but well

1564261173
scientes
yeah I can see making the name optional

1564261179
scientes
but I like the "return"

1564261184
companion_cube
(again it's useful for early return, but shouldn't be required for one liners)

1564261188
scientes
it means that everthing is a statement

1564261192
Tetralux
While I've become a little more okay with naming every block I'm returning a value from than I was when I started, I still have the same idea of not wanting to

1564261197
companion_cube
everything should be an expression :/

1564261210
scientes
although I guess return is a little weird, because it comes from C where sizeof alignof offsetof and return are special things

1564261231
scientes
that are not functions

1564261232
Tetralux
Arguing that return is from C seems a little weird to me.

1564261235
companion_cube
just pick rust's syntax and remove the traits, borrow checker, and use simpler error handling :p

1564261245
Tetralux
And impl syntax.

1564261250
companion_cube
yeah sure

1564261250
Tetralux
And generic syntax.

1564261262
companion_cube
but the expression syntax is awesome, imho

1564261269
companion_cube
it's nonambiguous and clean

1564261288
Tetralux
That's in the form of:

1564261289
companion_cube
(again with the `while … { … }` and `if … { … }` without parenthesis but with mandatory braces)

1564261296
scientes
what's wrong with zig error handling companion_cube ?

1564261297
Tetralux
`let x = { code; return x; }

1564261297
hryx
sorry, I can't find the discussion about breaking to parent block without a label. I think the proposed word was `result`

1564261308
scientes
I have a few issues, but I think the idea is sound

1564261329
hryx
there may have also been a proposal for implicitly returning last expression but not sure

1564261334
scientes
hryx, yuck, just use "break"

1564261336
companion_cube
scientes: it's good!

1564261341
companion_cube
I mean, it's one of the differences with rust

1564261353
hryx
scientes: wasn't my proposal

1564261361
scientes
yes

1564261367
fengb
hryx: it ended up being rejected as being too foreign and named blocks are “good enough”

1564261368
companion_cube
but what I mean is that syntax is my least favorite part of zig

1564261378
companion_cube
well, it's good, but it could be closer to rust and gain from it imho

1564261414
Tetralux
Oh yeah - and that semicolon after the block name when you break?

1564261422
Tetralux
SOMETIMES YOU NEED TO PUT IT BEFORE THE NAME AND NOT AFTER

1564261422
scientes
fengb, but we already have implicit scope with while and for

1564261435
hryx
fengb: thanks, I forgot it was closed. here's the issue for anyone interested in the previous discussion:

1564261464
fengb
Yeah, the break emulates C / Java style where it’s loop based

1564261488
scientes
and if() is not a block

1564261495
scientes
for the implicit scope

1564261498
fengb
Block based return languages don’t have a good return keyword afaik

1564261501
scientes
we already have these rules for while and for

1564261525
scientes
so just expand it to include result blocks

1564261554
fengb
I think it’s not ideal... but it fits existing paradigms. I kinda wish there’s a breakloop keyword and break is just nearest block

1564261555
scientes
with break returning a value (and continue and next compile errors)

1564261575
companion_cube
I just wish it'd be as simple as rust -_-

1564261579
scientes
otherwise, you could have two differn't sets of implicit blocks, and return could be the keyword

1564261604
fengb
Or make loop breaking the weird case that needs a label

1564261609
scientes
because it does not make sense to return from a function in a initialization block

1564261621
scientes
but then what if you wanted to return an error?

1564261622
scientes
uggh

1564261631
scientes
so probably break

1564261700
scientes
yeah closures would make sense here as is mentioned

1564261718
scientes
and you could return an error by using try to run the closure

1564261765
fengb
I don't want a closure just to break. Reminds me of IIFE hacks in JS

1564261803
scientes
closures don't have to be ugly

1564261811
scientes
look at how go does them

1564261812
companion_cube
|x| { x+1 }

1564261834
companion_cube
or `fn(x) { x+1 }` maybe

1564261835
fengb
I also don't like the Go version. Specifically, immediate execution closure is basically a block

1564261864
hryx
yeah, in Go you commonly find IIFE too

1564261869
hryx
namely in defer

1564261882
fengb
Like... go func() {} is a programmer error but the compiler won't warn you

1564261915
fengb
Whereas a Zig-like block would be `go {}` and really hard to screw up

1564261927
scientes
but why can't blocks be closures

1564261948
scientes
you would just have to add a (); at the end

1564261989
scientes
ahh yeah that is a problem, you don't always want to have to add ();

1564261989
companion_cube
😱

1564261998
fengb
Because they aren't the same? I suppose you could make them the same but you need syntax to distinguish definition versus execution

1564262015
scientes
but they are if you immediately run them and they don't take arguments

1564262031
companion_cube
what's wrong with `fn (x) { … }` ?

1564262034
scientes
oh, binding variables

1564262035
scientes
i see

1564262049
fengb
Still different from defining and executing. Go style forces you to run it, which is easy to forget

1564262063
scientes
companion_cube, so fn (x) { … }(foo); ?

1564262091
companion_cube
uh, no, I meant for writing actual closures

1564262093
fengb
Oof, I forgot Go doesn't actually capture the variable in a sane way

1564262095
companion_cube
why would you do that?

1564262106
scientes
companion_cube, you wouldn't but you could

1564262115
companion_cube
yeah but there's no point

1564262121
hryx
Does anyone here have experience reading the output of --verbose-ir? I could use some tips on getting started

1564262136
fengb
Anyway, I think closures are out of scope here. We can use them to emulate blocks, but we don't have them and they open a can of worms on where to store the context

1564262137
scientes
companion_cube, more like fn (x: u32) { |x| … }

1564262142
Tetralux
fengb: Maybe.

1564262144
Tetralux
Whatcha got?

1564262166
scientes
ohhhh i see

1564262177
scientes
not annonymous functions, but closures

1564262180
scientes
differn't things

1564262184
scientes
I'm too use to C

1564262208
scientes
yeah, I would be happy with annonymous functions

1564262215
scientes
for now

1564262228
scientes
as fengb says, closures are a can of worms

1564262257
scientes
C's lack of annonymous functions is annoying

1564262258
hryx
"can of worms" was my experience when daydreaming about closures in zig

1564262272
fengb
There's a proposal and I think they're a good idea, but I'm not sure how cleanup would happen

1564262301
companion_cube
yeah memory management is messy

1564262302
scientes
fengb, but how about implementing annonymous functions now, and thinking about closures later

1564262308
companion_cube
and it's probably superseeded by coroutines anyway

1564262373
companion_cube
tbh I can't imagine anything simpler and cleaner than

1564262379
fengb
scientes: Yeah I'm a fan of that. We have quite a few `struct { fn foo() }.foo` hacks in std already

1564262397
scientes
fengb, and all over tests

1564262430
companion_cube
I think closures would be fine if they were always used comptime (and therefore specialized on)

1564262447
scientes
companion_cube, that would allow us to get the syntax down

1564262448
companion_cube
at least no need to worry about memory representation

1564262463
scientes
cause closures are a superset of annonymous functions (right?)

1564262465
fengb


1564262468
companion_cube
`foo.sort(|x,y| { x.a > y.a }`

1564262472
companion_cube
`foo.sort(|x,y| { x.a > y.a })` sorry

1564262498
fengb
That'd just be anonymous functions

1564262508
companion_cube
they could capture the scope though

1564262515
companion_cube
it'd be compiled as a function with additional arguments

1564262517
scientes
I like the variables in the {}

1564262526
scientes
`foo.sort({ |x, y| x.a > y.a })`

1564262552
scientes
but I think having it match function syntax is better

1564262557
fengb
Let's drop the parents too! `foo.sort { |x, y| x.a > yxa }` :P

1564262590
scientes
so like `foo.sort(fn(x: u32, y: u32) bool { return x.a > y.a; })`

1564262600
companion_cube
`var i = …; foo.sort(|x, y| { x.a + i < y.a + i });

1564262602
scientes
strongly typed too, as it should be

1564262685
scientes
so identical syntax, you just leave out the symbol name

1564262780
fengb
I think the biggest challenge with closures is how to deal with mutations, e.g. what happens when reassigning `i` in your example

1564262828
scientes
also that example is horrible, you have to have a way to specify that i is bound to the function

1564262836
fengb
Java resolved it by only allowing `final` variables to be closable

1564262865
scientes
fengb, well that is why you pass it like a function

1564262867
fengb
scientes: closures imply automatic binding, usually via lexical scoping

1564262868
scientes
but when you define it

1564262905
companion_cube
it really is a can of worms…

1564262906
scientes
fengb, ewww, I guess I haven't really used closures, but just using lexical scoping seems gross

1564262911
fengb
(Doesn't have to be lexical... but languages that do dynamic scoping are terrible)

1564262929
scientes
it should be passed, just before execution

1564262938
scientes
then you don't have the variable-ish problem

1564262943
fengb
It's the basis for most MLs and Lisps

1564262962
scientes
but anyways, I don't use closures, but I want annonymous functions

1564262974
scientes
I will eventually use them if they exist

1564262978
scientes
maybe...

1564262982
scientes
but it sure sounds horrible

1564262990
scientes
perhaps co-routines are better

1564262994
scientes
as those also keep state

1564263009
hryx
mikdusan: if you're around, any tips on getting started with zig IR / --verbose-ir? I have your "minimal boilerplate" gist, but don't know how to read the output

1564263010
companion_cube
closures are just one shot coroutines

1564263024
scientes
yeah, then why no leap-frog them and have coroutines

1564263039
scientes
(and also annonymous functions)

1564263043
fengb
companion_cube: not if you talk to a functional programmer :P

1564263045
companion_cube
you could have a short syntax for closures that just give you a coroutine 🤷

1564263095
companion_cube
fengb: why not? :)

1564263111
fengb
Because if you can't return a closure, it's not a "real" closure

1564263128
companion_cube
well you could, just malloc and copy the closure there, right?

1564263139
companion_cube
ah that's assuming capture by value though

1564263149
mq32
oh the closure topic. i'm in!

1564263151
fengb
You can't if your context references are mutable

1564263154
scientes
well I guess I just haven't used them

1564263162
scientes
so I don't know what they are useful for

1564263167
fengb
But... you can't mutate in functional programming so it works

1564263170
scientes
and haven't seen how to optimize them either

1564263179
mq32
scientes, most simple example is targetet callbacks

1564263184
companion_cube
I feel like a fanboy, but look at what rust does? :D

1564263192
mq32
imagine having a list of callback functions that all require some logic with context to execute

1564263192
companion_cube
(it's not simple though)

1564263202
fengb
Nothing in Rust is simple :P

1564263214
mq32
you can do the c-style-thing (functionptr + void*) or use a closure, where you capture the void* context in the closure itself

1564263223
companion_cube
fengb: the syntax is pretty simple

1564263242
mq32
companion_cube, i think syntax is not a problem at all ^^

1564263249
companion_cube
I think it's a big deal

1564263256
companion_cube
syntax makes some things easy and some things cumbersome

1564263260
fengb
Syntax is the least of my worries here. Storing variables sounds like a nightmare when dealing with manual memory

1564263266
mq32
what fengb says

1564263278
mq32
syntax is something to talk about when all other stuff is safely designed

1564263286
scientes
WTF< why is buf_write_value_bytes big-endian?

1564263298
scientes
ho wait it isn't

1564263307
scientes
its little, it just has weird padding

1564263317
companion_cube
but yeah, when talking about closures it's not the first priority, semantics is

1564263339
fengb
Some things have colliding syntax. I think whatever we agree on with closures will look pretty close to current functions and proposed anon functions

1564263370
fengb
I'm more scared of the ramifications of when variables go out of scope, how they get copied, how we can pass around closures, etc.

1564263422
mq32
i'll take a look at how Rust implements closures

1564263431
companion_cube
with traits

1564263443
companion_cube
but you have several flavors of closures, which is pretty neat

1564263446
mq32
so they actually go the same way as c++?

1564263450
companion_cube
(either by ref, or by move)

1564263482
companion_cube
I'm not sure about the details for C++, but in rust each closure is a nameless type which implements one of Fn, FnMut, FnOnce

1564263497
companion_cube
(depending on whether it captures by move (value), or by const/mutable ref)

1564263498
mq32
yeah

1564263501
Tetralux
I'm curious where the storage for captures vars goes.

1564263519
mq32
in C++ every closure is a class that implements a function call operator

1564263520
companion_cube
for moved closures, you have this nameless type which is basically a struct

1564263530
companion_cube
by-move closures*

1564263533
fengb
My brain hurts already. I'm gonna go back to coding :P

1564263546
companion_cube
so you can put that in a box (malloc) or just return it on the stack, or whatever

1564263564
companion_cube
for the by-ref closures, you have to respect scopes otherwise the borrow checker yells

1564263575
mq32
hm

1564263583
mq32
so they go full c++ with more hurdles :D

1564263609
Tetralux
I'm honestly not sure you need to have closures.

1564263623
mq32
it's useful some times

1564263637
fengb
Having the borrow checker yelling at you is a good thing. I hope we can't get to a point where we get an invalid stack reference because we used the closure wrong... eventually

1564263638
mq32
but: most closure tasks could be done with fnptr+context*

1564263671
companion_cube
less hurdles, more safety, mq32 :p

1564263672
Tetralux
mq32: Indeed. But where do you put the context?

1564263681
fengb
Hmm, I wonder if we can solve it with a coroutine. Stick the @Frame wherever you want and you get full control of the lifecycle

1564263692
Tetralux
You would statically allocate it as part of the function pointer.

1564263695
mq32
Tetralux: in most cases: on the stack

1564263712
companion_cube
in which case you have to respect the same constraints as rust's borrow checker imposes

1564263714
fengb
I really want to see the new coroutines in action. It feels like it can do so much :P

1564263722
Tetralux
Like a closure could be: struct { context: FnContext, proc: fn(FnContext, ...) }

1564264032
mq32
i just got an idea…

1564264038
mq32
where's my compiler explorer?

1564264770
scientes
uggh this padding in bigint.cpp is so weird

1564264788
scientes
its using big endian padding on little endian

1564264851
mq32
oh, found a compiler bug i think…

1564264861
scientes
welcome to the club :)

1564264878
mq32
yeah :D

1564264898
mq32
playing around and it seems like you can't capture @typeOf() through function layers

1564264902
mq32
although it should be possible

1564264944
mq32
oh

1564264946
mq32
even better

1564264947
mq32
unreachable: /deps/zig/src/codegen.cpp:gen_const_val_ptr:5956

1564264991
scientes
uggh, this padding is so fucked up

1564265008
scientes
mq32, look at the code, there are tons of FIXME all over stage1

1564265009
hryx
oh wow, github's "related issues" feature actually just prevented me from opening a dupe. nice work github

1564265016
scientes
its hard to "not" find acompiler bug

1564265023
scientes
hryx, yeah that is a great feature

1564265025
mq32
scientes, yeah i'm not surprised :D

1564265127
fengb
I'm surprised you haven't found one yet :P

1564265142
mq32
fun thing is i found it while working around another one :D

1564265160
mq32
but i have to admit, i'm more the theoretical zig programmer right now

1564265190
mq32
but, my example/thought is done:

1564265213
mq32
this is how closured

1564265220
scientes
its cool to see people in here using my SIMD work

1564265225
mq32
the function types would have to be somehow comptime generated

1564265282
companion_cube
like coroutines, right?

1564265363
mq32
i think my example could actually work without compiler support if @reify would be implemented and we could "enforce" an argument list like c++ variadic templates

1564265467
mq32
but my main idea is to have a "closure type" which is a struct that 1) provides a pointer to a function and a context, 2) stores all captured variables (by-ptr or by-val) and 3) implicitly casts to it's corresponding closure type

1564265493
mq32
3 could work by the "go style inheritance" proposal

1564265635
mq32
companion_cube, yes, i think so. maybe a whole lot of the coroutine stuff could be reused for closures

1564265648
mq32
hm

1564265661
mq32
yeah, a closure would be a endless-loop-coroutine then

1564265703
mq32
except for that a "resume" passes in new arguments to the coroutine

1564265958
companion_cube
ah, if you can call it several times, interesting

1564265976
mq32
closures are meant to be called several times, usually

1564265996
mq32
scientes, i got another nice example for you :)

1564266022
mq32
var i : i32 = 0; list.forEach(fn(x : i32) { i += x; });

1564266039
mq32
generic forEach that can accumulate or calculate arbitrary stuff

1564266073
Tetralux
Is that cleaner or clearer than just a for loop though?

1564266082
companion_cube
it can be

1564266097
Tetralux
I can't say I've seen a good example of that.

1564266108
Tetralux
Though as someone who's played around with linq in their time

1564266110
companion_cube
if it's something a lot more complicated to iterate on, than a list

1564266117
companion_cube
(eg a tree)

1564266136
Tetralux
If you foreach a tree, surely the for isn't THAT much worse.

1564266298
mq32
Tetralux, yeah for an array a simple loop would surely be better

1564266302
companion_cube
heh, what about code reuse?

1564266323
companion_cube
what if it's a HAMT/radix tree? the iteration logic becomes non trivila

1564266328
companion_cube
trivial

1564266330
mq32
but if the enumeration type is more complex (imagine a sparse array structure), it's better to reuse the iteration code than rewrite it every time

1564266346
companion_cube
ofc you could also have iterators.

1564266376
mq32
we would'nt neet one if we have closures :D

1564266398
mq32
var iterator = list.makeForwardIterator(); while(iterator()) | loopvar | { … }

1564266462
hryx
currently seen as `... while(iterator.next()) ...`

1564266474
mq32
yeah, that' true :D

1564266491
hryx
don't get me wrong mq32, I think closures are cool :>

1564266493
fengb
I mean, technically you wouldn't need anything else if you had closures :P

1564266531
mq32
hryx, wanted to say: for me closures aren't much more than neat syntax sugar that allows some code to be better to read because of less clutter

1564266548
companion_cube
but is it still C like then?

1564266564
mq32
closures

1564266567
mq32
but with manual work

1564266590
mq32
which is cumbersome and and error-prone

1564266642
hryx
mq32, agreed but there's actually one odd thing that closures would actually bring (albeit horribly roundabout way). In the `iterator.next()` approach, you can't make anything inside `iterator` private. see #2059

1564266709
mq32
my browser tells me i should stop reading so much issues on the zig language repo :D

1564266718
mq32
if i type "zi" my browser autocompletes to the issues tab

1564266804
hryx
your browser is encouraging you to read more of them!

1564266837
mq32
:)

1564266869
mq32
on the private/public stuff:

1564266889
mq32
i've stopped using "private" in my code unless you can

1564266904
mq32
in most of my structs all fields are public

1564266920
mq32
and i noticed that most of the code gets better in quality

1564266935
mq32
less code → less errors, better readability, less code to maintain, …

1564266944
hryx
interesting observation, very cool

1564266955
mq32
but there are reasons to hide state

1564266974
mq32
like safe memory handling (in C++ with alloc-on-ctor, free-on-dtor) and similar

1564266981
mq32
this stuff is mostly private

1564267011
hryx
I see. luckily not an issue in zigland

1564267101
hryx
my main concern is, does lack of `pub` mean a leakier or weaker API for the user?

1564267140
hryx
I honestly don't know but my guess would be seeing all the "private" fields adds noise for the consumer

1564267158
mq32
yeah, that's some stuff that annoys me in c++ from day 1

1564267166
Tetralux
Yeah - I like POD.

1564267175
Tetralux
So private isn't really in my vocab.

1564267180
Tetralux
Though private to file scope is.

1564267186
Tetralux
That seems useful.

1564267235
fengb
I believe that we need a "this is API stuff" and "thar be dragons". Accessibility isn't what I care about

1564267236
hryx
mq32 I'll keep in mind what you said about not having private leading to better quality code

1564267280
fengb
Although I do prefer nothing to be inaccessible cause then I can't work around poor assumptions/designs/bugs

1564267342
mq32
hryx: i have to code with c++builder @ work and it's sometimes horrible how bad your code

1564269877
scientes
uggh, the padding of bigint.cpp is big-endian on little-endian architectures

1564269885
scientes
and my code is going forward and backwards

1564269891
scientes
and had to pack bits

1564269902
scientes
this could be so much simpler with bit-granularity types

1564269908
scientes
and pointers

1564269970
scientes
and i cant used unsigned, because i have to support types large than 64-bits

1564269979
scientes
its madness

1564269996
scientes
i had something working, but then i ran into backwards padding

1564270004
scientes
and now its all to hell trying to support that

1564270082
scientes
maybe i should just us an array of bools

1564270095
scientes
that would make the logic much simpler

