1574126544
gruebite
hmm

1574126567
gruebite
i'm getting expected 'comptime_int' when using c.ENUM where it expects it

1574127052
gruebite
had to do `@intToEnum(c.some_c_enum, c.SOME_C_ENUM_A)` is this required?

1574127065
gruebite
C enums are not by default their enum type?

1574127554
andrewrk
gruebite, are you sure the .h file defines it as an enum?

1574127591
gruebite
header file:

1574127616
gruebite
typedef'd heh

1574128415
gruebite
not `struct foo` but `typedef struct {} foo`

1574128591
gruebite
the zig header also has extern enum def

1574128854
andrewrk
that should work fine in theory. looks like an improvement is needed to translate-c

1574128878
gruebite
works if i do it explicitely

1574129047
gruebite
i had to do: c.godot_method_rpc_mode.GODOT_METHOD_RPC_MODE_DISABLED

1574129068
gruebite
and it worked, otherwise c.GODOT_METHOD_RPC_MODE_DISABLED didn't work

1574129310
daurnimator
gruebite: FWIW you should just be able to write: `.GODOT_METHOD_RPC_MODE_DISABLED`

1574129500
gruebite
cool

1574129509
gruebite
c. no though

1574129522
gruebite
does does a self-hosted translate-c look like?

1574129569
andrewrk
gruebite, self-hosted translate-c is in progress. you can experiment with `zig translate-c-2` and see also this issue:

1574129602
daurnimator
andrewrk: are you back home from handmade now?

1574129604
andrewrk
once self-hosted catches up to the C++ version, we get to delete 4,000 lines of C++ and then start using the self-hosted translate-c for everything

1574129607
andrewrk
daurnimator, yep!

1574129722
daurnimator
sort of wish I'd paid more attention to it and tried to go... sounded like fun

1574129755
andrewrk
I think it was the best one yet

1574129791
gruebite
handmade?

1574129812
andrewrk
I went to this convention over the weekend:

1574129829
andrewrk
ran a zig booth. had some fun conversations

1574129831
gruebite
nice! i'm based out of seattle

1574129836
gruebite
i could've gone

1574129844
andrewrk
ah, you'll have to go next year

1574129849
gruebite
yeah

1574129870
andrewrk
one guy came up and said, alright, C replacement? What's one reason I should use Zig instead of C?

1574129883
andrewrk
I said "Hmm let me see... What do segfaults look like for you?"

1574129894
andrewrk
"Well, I try to make sure they don't happen. I have a lot of asserts."

1574129899
andrewrk
"OK, what do asserts look like for you?"

1574129920
andrewrk
"You know - function name, line number, message, abort()"

1574129934
andrewrk
"Yeah, yeah, OK, let me show you what an assert looks like in zig."

1574129949
gruebite
niiiice

1574129954
andrewrk
(invoke integer overflow or something in a short example, and the stack trace displays on the screen)

1574129962
andrewrk
"Oh, wow. Oh... that is nice"

1574129976
gruebite
haha

1574129992
gruebite
yeah, coming from c to zig is refreshing

1574130037
gruebite
currently writing bindings for godot's nativescript. there are cpp/rust/d bindings now

1574130070
andrewrk
yeah. ideally the @cImport would be enough, but as you've observed, translate-c is at proof-of-concept stage, not at completed-and-mature stage

1574130095
gruebite
right now i'm just running .patch at part of the build step, for now at least

1574130109
fengb


1574130122
andrewrk
fengb, I saw this PR but haven't dug into it yet

1574130130
andrewrk
this is one of those "hard" PRs

1574130175
andrewrk
and uh to be honest there are a dozen "hard" PRs in line before you

1574130206
fengb
I thought I had some simple results but the more I fiddle, the less confident I am with the numbers

1574130239
andrewrk
one thing to keep in mind is that std.sort.insertionSort is intended to be just that- exactly the insertion sort algorithm, nothing more, nothing less

1574130243
fengb
I can loop back once I actually finish implementing grailsort if that makes more sense than doing it incrementally

1574130278
andrewrk
we can have more sort algorithms but they need to have names that describe what they are, and then of course there will be a "default" sort which can do heuristics based stuff

1574130302
fengb
Okay, I'll convert this over to just an improvement of the bsearch instead

1574130313
andrewrk
I think that will be easier to merge

1574130342
fengb
Cool thanks

1574130538
gruebite
i've been struggling with opaque types

1574130549
daurnimator
andrewrk: FWIW I've got 2 PRs to send on top of #3644. One of which is the overhaul of "stream" :)

1574130558
gruebite
seems if a struct is defined after the opaque type is used in a function, it just treats it as an opaque type

1574130567
gruebite
function prototype*

1574130674
andrewrk
daurnimator, #3644 is definitely hard. but also important

1574130683
andrewrk
it's on my shortlist

1574130713
andrewrk
gruebite, have you discovered how to observe warnings from translate-c?

1574130722
daurnimator
andrewrk: oh? I thought it would be pretty easy (its the first follow up thats hard!). what makes it hard?

1574130739
gruebite
yeah, i'll see if there is a warning for the struct

1574130751
andrewrk
in the self-hosted version they conveniently show up as comments, but in the c++ version you need --verbose-cimport to see warnings

1574130797
gruebite
string not found

1574130801
andrewrk
daurnimator, sorry, I meant the thing that changes the streaming API & implementations. It does look like #3644 messes with std.io implementations a bit

1574130802
gruebite
when searching the struct

1574130816
andrewrk
daurnimator, that's the part that I want to look at carefully

1574130911
gruebite


1574130954
daurnimator
andrewrk: you mean you want to look at the std.io changes carefully? the changes are in PeekStream, BufferedInStreamCustom, BufferedOutStreamCustom: I pretty much just swapped out their buffer management to just use fifo methods instead.

1574131009
andrewrk
daurnimator, yes that's what I mean. It's probably fine, I just want to think it through so I can be on the same page with the next steps that you're taking

1574131015
daurnimator
k

1574131039
daurnimator
If I can figure out a way to do comptime callbacks in a nicer way, I will be able to get rid of those 3 classes entirely!

1574131044
andrewrk
I'm also asking myself the question "are all these abstraction layers necessary?"

1574131051
andrewrk
maybe the answer is "yes"

1574131074
andrewrk
but, yes, maybe the answer is to fix issues related to comptime callbacks

1574131137
andrewrk
sometimes code reviews are harder for me because I'm not just asking the question, "is this the correct code based on a language that already exists?" but "does this code demonstrate that the language or std lib is designed incorrectly?"

1574131157
daurnimator
andrewrk: the answer is "almost no". What those 3 do compared to a plain fifo, is "auto-fill" from another chained stream. I intend to add that facility to fifo via comptime callbacks: you'd create a Fifo instance that has a callback for "onEmpty" that would fetch from another backing stream.

1574131222
daurnimator
andrewrk: for callbacks; this is the only thing I have working:

1574131241
andrewrk
btw quetzalb, do you have a use case for windows on aarch64? I'm curious about the details

1574131458
fengb
andrewrk: is there a way to convince zig/llvm to use cmov? I found

1574131535
andrewrk
fengb, are you trying to do constant-time operations?

1574131544
andrewrk
can you elaborate on the use case?

1574131572
fengb
It's for binary search. I found an old resource that uses cmov for removing a conditional branch

1574131589
fengb
I wanted to test it out to see if it's helpful since bsearch is pretty bad for branch predictors

1574131590
fengb
\

1574131780
adamkowalski
andrewrk: i've been using zig for a couple days I wanted to say how fun it's been to use. The ability to have first class types rather then having a seperate language such as a template metaprogramming system makes everything feel much more unified and well thought out

1574131831
fengb
I guess I'll learn a little assembly while I'm at i :P

1574131845
adamkowalski
I also really enjoyed learning about the allocator model and it made me realize how much of what i've written had the potential to fail due to hidden allocations

1574131846
andrewrk
fengb, yeah I think this might be a "use-inline-assembly" use case

1574131870
andrewrk
that llvm code review thing you linked does a pretty good job explaining why the instruction selector chose branches rather than CMOVs

1574131889
andrewrk
adamkowalski, glad to hear it! looking forward to seeing what you create

1574131951
fengb
Yeah it makes sense in the general case

1574131974
fengb
But sometimes I want to tell the optimizer to stop helping >_>

1574133383
fengb
Ugh, I seemed to have killed my raspberry pi :(

1574134591
gruebite
i am doing `while (core) |ext| { core = ext.nest; }

1574134680
gruebite


1574134796
gruebite
i guess i have to cast it?

1574134816
gruebite
struct_some_c != some_c?

1574136151
fengb
zig test src/bench.zig --release-fast -target armv6-linux /// error: instruction requires: armv6k

1574136214
fengb
Ah, probably .arm, .aarch64 => asm volatile ("yield"),

1574137362
gruebite
I have to do `@as(*const c.godot_gdnative_api_struct, ext).next` which i hope doesn't crash

1574138405
gruebite
is `var i = 0; while (i < n) : (i += 1) { }` the correct way to do range loops?

1574138491
gruebite
also, it seems like every field i am encountering is opaque typed

1574138493
gruebite
:/

1574138501
gruebite
i do not want to cast everything everytime

1574140430
gruebite
just got this Assertion failed at /home/grue/packages/aur/zig-git/src/zig/src/list.hpp:31 in at. This is a bug in the Zig compiler.

1574140450
gruebite
how can I run it with a backtrace?

1574140535
daurnimator
gruebite: run the zig command under gdb?

1574141201
gruebite
had to rebuild with debug symbols

1574141207
gruebite
looks like master is broken right now though?

1574142329
quetzalb74
I tried to add "pub const io_mode = .evented" to my hello world zig file. But when I compile it using master, it get an llvm error. Is it a known issue? Any workaround or suggestion on how to debug?

1574142330
quetzalb74
C:\Users\qbradley\source\repos\events>..\zig\build\bin\zig.exe build-exe events.zigbroken LLVM module found: Instruction does not dominate all uses!  %743 = load %std.pdb.MsfStream**, %std.pdb.MsfStream*** %92, align 8, !dbg !7527  %501 = load %std.pdb.MsfStream*, %std.pdb.MsfStream** %743, align 8, !dbg !7549Instruction does not dominate all uses!

1574142331
quetzalb74
%743 = load %std.pdb.MsfStream**, %std.pdb.MsfStream*** %92, align 8, !dbg !7527  %512 = load %std.pdb.MsfStream*, %std.pdb.MsfStream** %743, align 8, !dbg !7555Unable to dump stack trace: debug info stripped

1574142710
quetzalb74
I downloaded zig-linux-x86_64-0.5.0+aa4e92f3b and tried on windows subsystem for linux and no repro.  However if I add "-target x86_64-windows-gnu" to cross compile for windows it repros on linux too

1574143505
daurnimator
quetzalb74: yeah it looks related to OutStreams and async

1574143527
daurnimator
quetzalb74: note that targets with a .exe/.pdb output use different code to elf targets

1574143544
daurnimator
so you'll be hitting the non-async-ness of the OutStream in std.pdb

1574143556
daurnimator
I have a PR coming up to refactor all that... but please do file an issue anyway

1574143557
quetzalb74
oic

1574143566
quetzalb74
Ok

1574143835
quetzalb74
filed

1574146309
dbandstra
code generation is so easy with zig's build system

1574146374
dbandstra
although i just copy pasted how to do it from somewhere... one line in my build.zig and i'm using a zig script to generate something which is then imported by my main program, and it all works and only rebuilds when the script changes

1574146451
dbandstra
i made a script to generate zig bindings from GLSL shader, so i just edit the shader, run zig build, and can start following the compile errors in my program where i need to update my calls

1574146563
dbandstra
i think i was conditioned to believe this should be hard because i grew up with MSVC

1574147206
traviss
dbandstra, do you have a link showing how you're doing code gen?

1574147494
dbandstra
traviss: the glsl thing is not online yet but i used it in another project for some webgl related stuff:

1574147637
traviss
thank you. i didn't know where to look when i considered trying something similar myself.

1574147744
dbandstra
i just stumbled across it when checking out one of andrewrk's repos, maybe clashos

1574148267
traviss
on another issue, is var args already gone from master?  and what is the new way to do var args?  something like `.{._0 = arg0, ._1 = arg1...}` and a function accepts an `args: var` param where you then get its values using `@field(args, "_0")`.

1574148332
traviss
i'm thinking it would be simpler to use a slice...

1574148530
dbandstra
var args is not gone from master yet

1574148675
dbandstra
i believe the plan is for the literal `.{ ... }` syntax to be an array if all the elements are of the same type

1574148728
dbandstra
i mean when passed as a `var` typed argument

1574148768
traviss
i'm thinking it would be simpler to use a slice...

1574148774
traviss
oops sorry

1574148856
dbandstra
it already works to call a function `fn func(params: var) void` like this `func(.{"one", "two", "three"})`

1574148892
dbandstra
but @typeOf(params) will be a struct, so it's a little awkward to iterate in the function

1574148904
traviss
ok thank. that looks good. was just a bit confused as anon arrays aren't in master yet along with anon structs.

1574148914
dbandstra
they are

1574148932
traviss
oh, so i am wrong again. i'll give it a try :)

1574148960
dbandstra
but it was merged recently and there are still some rough spots

1574149024
mq32
dbandstra, actually it's not that awkward ;)

1574149054
mq32
for(std.meta.fields(params)) |fld| { std.debug.warn("{} = {}\n", fld.name, @field(params, fld.name)); }

1574149112
dbandstra
yeah not bad, but someone could just pass any struct with named fields into that function. if you wanted an array you would have to check if a fieldname is "_0" or something and compile error if it's not

1574149128
traviss
yes, thats pretty much what i have now. +1

1574149172
dbandstra
or i guess the field is actually `@"0"`

1574149309
traviss
yeah i just noticed the same thing. thanks again.

1574149312
mq32
i still don't know if i really like this change

1574149319
mq32
but it allows for many interesting options

1574149352
mq32
std.debug.warn("{.x} = {.y} * {.z}", .{ .x=60, .y=20, .z=3 });

1574149441
dbandstra
it does seem a little sketchy the amount of things that `.{` can represent

1574149531
dbandstra
but i don't have any better ideas

1574153713
Snektron
Struct literals are basicslly initializer lists

1574154372
Snektron
Wait, .{} With all elements the same will be an array? That doesnt sound right

1574154428
Snektron
I'd rather see either a dedicated array literal or a std lib function to transform a struct literal into an array

1574154562
Snektron
Is .{a = 10, "b"} also valid?

1574154821
mq32
i don't see a reason why it should not be allowed

1574156453
mq32
andrewrk: i think i found some regression in the zig compiler, but i cannot really locate it

1574156487
mq32
but: with the current version, the TextEditor component in ZGS is broken and panics with a your-memory-contents-here "message"

1574156857
traviss
.{a = 10, "b"} gives compiler error: expected token '}', found 'StringLiteral'.  pointing at "b"

1574159187
muffindrake
How does one handle strings, particularly variably-sized ones returned from a function? Since there is no end-of-string character in Zig, I suspect there's little fun to be had.

1574159645
mq32
muffindrake: simple ;)

1574159654
mq32
use slices (pointer+length) and allocators for allocating them

1574159768
muffindrake
I don't consider 'use memory allocation' a satisfactory solution for this ...

1574159864
mq32
you can take a look at

1574159880
mq32
bufPrint(sliceInput, …) → sliceOutput

1574159901
mq32
the function returns a part of the input slice as an output, containing the formatted string

1574160029
mq32
or maybe i didn't understand your question in the first place ^^

1574160722
muffindrake
I'll be fine with slices as per your suggestion, but I still feel like there could be better handling for strings. C makes it a bit easier since you can arbitrarily end one with a \x00 character

1574160830
mq32
i don't think nullterminated strings are easier to handle

1574160841
mq32
slices have the nice option that strings

1574160845
mq32
and that comes handy some times

1574161010
mq32
also slices are much faster than zero-terminated strings, as "strlen" will be O(1) instead of O(N)

1574166318
Snektron
muffindrake: even in C that string has to be allocated somewhere

1574166350
Snektron
If its a string literal it will be allocated in a data segment in the executable

1574166385
Snektron
In Zig its similar

1574166435
Snektron
Except its a slice or array instead of a pointer

1574173494
kenaryn
Hello computer guys. Does the word `undefined` when defining an absence of value tells the compiler to load a register and store a 0-length buffer with a address like 0x0 or does it do nothing at all at compile-time?

1574173558
fengb
For safe builds, it sets the value to 0xaaaa to assist with debugging

1574173619
fengb
For release it’s the same as not setting it in C, so whatever garbage was at that location (undefined behavior)

1574173845
kenaryn
As always, thank you fengb for teaching me. I will add it to my memorandum immediately.

1574176332
frmdstryr
Would it be difficult for zig to support function "kwargs"? Eg

1574176341
frmdstryr
fn foo(struct{ a: u32, b: []const u8, c: bool = false}) void { //...

1574176362
frmdstryr
foo(.a=1, .b="abc")

1574176375
frmdstryr
or something like that

1574176436
mq32
frmdstryr: it's not necessary

1574176445
mq32
if you want to do that, just make a parameter a struct

1574176454
mq32
foo(FooArgs{.a = 1, .b = "abc"});

1574176664
frmdstryr
I know but then code gets cluttered when using outside, eg

1574176667
frmdstryr
var server = net.StreamServer.init(net.StreamServer.Options{});

1574176705
mq32
i don't know how that will work with anonymous struct literals

1574176709
mq32
maybe you can even just do

1574176714
mq32
foo(.{.a = 1, .b = "abc" });

1574176804
frmdstryr
Does zig infer what the first . there means? That'd also work

1574176884
mq32
yeah, that's a new thing

1574176893
mq32
i think andrew knows most about it right now :D

1574177404
mq32
btw, wo did the godbolt implementation for zig?

1574177443
frmdstryr
Just using . works, nice!

1574177651
mq32
so it looks like that zig accidently got a kind of default args as well as named parameters?

1574177651
mq32


1574177712
frmdstryr
Yeah, I was going to create an issue to ask but it seems like it already works :)

1574177744
frmdstryr
It should be documented

1574177763
mq32
go for it!

1574177772
mq32
make a fork, write some documentation

1574178014
FireFox317
mq32: That is so cool!

1574178094
fengb
I've been using godbolt 0.3.0 :/

1574179371
mq32
FireFox317: simplicity + creativity → Zig

1574179478
mq32
hmm

1574179478
mq32


1574179489
mq32
this looks like it could be adjusted to work with newer zig versions than 0.3

1574181994
andrewrk
mq32, I found this building RetrOS with master branch:

1574182142
mq32
interesting

1574182152
mq32
i didn't run into this, but two other bugs related to

1574182165
mq32
also i have some weird runtime crash where the code is doing ... stuff

1574182186
mq32
i have to track that down, but i short: the text editor is kinda exploding in my face

1574182198
mq32
the panic handler triggers (which is nice) and outputs random memory(which is not nice)

1574182344
frmdstryr
That happend to me yesterday as well. It ended up being me using a pointer from the stack instead of allocating one.

1574182460
mq32
frmdstryr: afaik it should not be possible to @panic with a runtime pointer and i'm sure i'm not using one

1574184509
adamkowalski
andrewrk: I watched your video about compile time programming in zig and your implementation of the perfect hash function for switching on strings at compile time. During that episode you mentioned that you weren't a huge fan of SFINAE. I'm curious what your thoughts are on Concepts and generic programming as a whole. In my eyes SFINAE solves the problem when you want to have many generic functions with

1574184515
adamkowalski
the same name and want to exclude a particular one from the list of possible candidates

1574184569
andrewrk
sfinae solves a meta problem that shouldn't exist in the first place. I'm interested in solving actual problems

1574184579
adamkowalski
This is really usefull when for example you want to deal with random access iterators differently then forward iterators. Maybe if you have random access capabilities in your data structure you want to support sorting. Otherwise if you have a linked list for example, you can can match on the forward iterator generic function and do something else. Maybe you can copy the contents to a vector, sort that,

1574184585
adamkowalski
and then move things back to a linked list

1574184631
andrewrk
"debug your application rather than your programming language knowledge"

1574184649
adamkowalski
Fair, but how would you approach a similar problem in Zig?

1574184679
adamkowalski
Right now when I need to support both slices and static arrays I find myself using vars

1574184692
scientes
what even is "SFINAE", it is a LAIDKBLAI?

1574184700
andrewrk
adamkowalski, why do you need both? just use slices

1574184701
adamkowalski
substitution failure is not an error

1574184717
adamkowalski
andrewrk yeah that was my plan, but I had a matrix rather then a vector

1574184718
andrewrk
scientes,

1574184750
adamkowalski
scientes I recommend this video

1574184772
adamkowalski
I had a static array of static arrays

1574184776
scientes
adamkowalski, if you have to watch a video to understand a small language feature, then the language feature is too complicated

1574184785
adamkowalski
it's not a small language feature though

1574184797
adamkowalski
it's one of the main things that you can do in modern c++

1574184812
adamkowalski
it's getting simpler now with concepts

1574184820
adamkowalski
but generic programming is all the rage these days

1574184832
adamkowalski
but it can be explained simply

1574184839
mq32
adamkowalski: scientes statement is still correct though

1574184856
adamkowalski
you want to write a generic function. but you want to constrain the possible inputs to only types that meet certain requirements

1574184857
mq32
SFINAE is a horrible way to implement generic code and zig doesn't require such thing, it just works different

1574184880
adamkowalski
however, you want to utilize overloading as well

1574184886
mq32
just @compileError your asssumptions on the types then ;)

1574184897
adamkowalski
if you use static assert, then you prevent other people from adding to the overload set

1574184899
scientes
adamkowalski, you just don't get it. Good programming is all about data structures. These endless features can all be implemented in the language, rather than being part of it. LLVM re-invents many C++ features for various reasons (like std::map), which shows that the features were unnecessary and poorely thought-out

1574184941
scientes
The only reason you want these features is that you don't understand what they really do. You only see them in the context of the language that has these features.

1574184943
adamkowalski
it is about data structures, I absolutely agree

1574184957
scientes
sorry, that might have come accross as harsh

1574184963
companion_cube
D has contracts on generic argiments

1574184971
mq32
adamkowalski: why that? i can assert type structures in zig without problems

1574184974
adamkowalski
yeah D has template constraints which works really well

1574184992
scientes
like GNU's IFUNC was porely though out, like C++ features

1574184993
companion_cube
I mean you can say taht a function must comptime-evaluate to true when applied to a type

1574184994
mq32
"a requires to be an array of size N×X, b requires to be an array of the same element type as a and also of size X×N"

1574185017
adamkowalski
companion_cube yeah we can express compile time constraints on types in zig

1574185022
adamkowalski
by having a predicate on a type

1574185032
scientes
adamkowalski, you can just use function pointers

1574185035
adamkowalski
you can for example say that I accept any function that has a .next() method

1574185048
adamkowalski
however, what if you want to do something different if you have a .nth() method

1574185049
mq32
this is much more powerful than any non-programmable kind of "concepts", "constraints", ...

1574185063
scientes
no reason function pointers can't be comptime

1574185076
adamkowalski
and someobody else on your team comes in and says, hey I want to add an additional specialization

1574185091
adamkowalski
if your data structure actually exists on the gpu, I want to do yet another thing

1574185107
adamkowalski
so you have two functions, both which operate on random access data structures

1574185116
companion_cube
mq32: I'm not completely sure Zig is more powerful than D when it comes to comptime

1574185116
mq32
adamkowalski: if(@hasDecl(@typeOf(arg), ".nth()") { … } else { … }

1574185118
adamkowalski
but one specializes further to utilize the gpu

1574185125
companion_cube
(preconditions are neat)

1574185132
scientes
companion_cube, D has a garbage collector

1574185148
mq32
companion_cube: zig is "fully programmable at comptime", so no, nothing can be "more powerful" in computation

1574185148
adamkowalski
mq32 right but then all the logic gets placed into one function

1574185158
mq32
also not necessary ;)

1574185167
scientes
mq32, well, its limited right now. there is no comptime memory model

1574185167
adamkowalski
mq32 c++ and D also have compile time evaluation

1574185168
companion_cube
mq32: note the negation

1574185171
mq32
replace "…" with "callFunWithNth" and "callFunWithoutNth"

1574185177
companion_cube
D might still be as powerful

1574185196
adamkowalski
I think we shouldn't be so quick to dismiss language features and whole languages in general

1574185202
mq32
companion_cube: then it's programmable by definition ;)

1574185209
companion_cube
it is, yes

1574185218
adamkowalski
you may think zig is more powerful, but learning from how others approached problems is always useful

1574185218
scientes
adamkowalski, "whole languages"---this does not exist

1574185227
scientes
turing complete languages are recursively enumerable

1574185230
companion_cube


1574185304
scientes
the biggest problem with garbage collectors, from my point of view, is that they are too complicated to model

1574185309
scientes
like the OOM killer

1574185321
andrewrk
D's compile time function features I believe are more powerful than zig's since you can generate arbitrary strings. But there are downsides to that too

1574185340
companion_cube
oh interesting

1574185364
andrewrk
e.g. I'm not sure it respects the target when cross compiling

1574185388
andrewrk
either it has that downside, or it's not more powerful than zig's. one of those 2 is true

1574185417
andrewrk
but yeah SIFNAE is right out. absolutely not. that's c++ cruft that has no place in zig

1574185421
companion_cube
no one said it's more powerful :D

1574185435
companion_cube
(but it might as powerful, all I'm saying)

1574185494
mq32
btw, it's interesting how little zig code you need to achieve quite complex stuff

1574185571
mq32


1574185602
mq32
this is a 1500 LOC assembler, from parser to code generation, everything included. most complex piece i use from the std library is std.StringHashMap

1574185651
mq32
if i'd written that in C/C++ i probably would've used at least flex which produces easily more code than this in a single invocation

1574185653
scientes
mq32, awesome

1574185671
mq32
but beware: the code isn't beautiful :D it was written in like 4 hours or such :D

1574185687
scientes
fn isHexDigit(c: u8) bool {

1574185693
companion_cube
I wrote a tiny http server in OCaml recently, it's funny how simple it can actually be (if you support a reasonable subset of the RFCs)

1574185701
scientes
ahh whatever, I don't need to blah

1574185711
companion_cube
now I think I understand better the idea that the package manager could bootstrap from a simple handmade HTTP client

1574185714
companion_cube
(+ hashing)

1574185721
scientes
companion_cube, http 1.1 is beautifully easy

1574185731
companion_cube
yeah I was surprised

1574185744
scientes
you can do it over netcat

1574185747
companion_cube
there are some weird corners, but to get to a point where curl is happy, is quite easy

1574185767
scientes
much easier than SMTP

1574185772
companion_cube
scientes: if you can count the size of bodies accurately yeah

1574185778
tgschultz
most protocols from the early days of the net can be done by hand.

1574185867
mq32
yeah, HTTP is actually really easy :)

1574185888
mq32
i think the most complex part is header parsing when it comes to those weird header-parameter stuff

1574185893
fengb
Was* :P

1574185900
mq32
fengb: true

1574185901
tgschultz
IRC is even easier. FTP has some weirdness with addressing.

1574185910
scientes
I have not worked with it, but WebDav also looked quite nice

1574185923
scientes
and you can even use ranged requests with that

1574185932
scientes
but i guess there is no locking

1574185977
scientes
the problem with sftp is that you get 2 or three round trips to do a write then fsync()

1574186027
scientes


1574186043
mq32
i really have to code a tftp client+server some day, that protocol is just so handy some times

1574186358
andrewrk
adamkowalski, I don't understand why having a matrix rather than a vector means you can't use a slice

1574187176
gruebite
okay, found the issue. gonna submit a bug report though

1574187199
gruebite
encountered a " This is a bug in the Zig compiler"

1574187219
gruebite
relevantly, how can i escape keywords that could be names in C?

1574187228
gruebite
there's a struct with "type" as a field

1574187241
gruebite
backticks ` are common in some languages

1574187249
fengb
@“type”

1574187376
gruebite
fengb: thanks

1574187386
gruebite
still getting the bug though

1574187403
gruebite
i cannot seem to build master (need to rebuild with debug symbols to get stacktrace)

1574187428
reductum
andrewrk, I had a lot of fun doing advent of code 2018 in our zig group. Are you planning on setting another one up this year?

1574187431
gruebite
`zig/src/zig_clang_cc1as_main.cpp:511:23: error: ‘Value’ may be used uninitialized in this function`

1574187495
andrewrk
reductum, sure! that starts dec 1st right?

1574187541
andrewrk
I can't believe it's been an entire year

1574187646
reductum
Yeah I just checked the website. It starts 2019-12-01 at midnight eastern time.

1574187657
reductum
Yeah it's amazing how fast this year passed!

1574187695
gruebite
how can i build zig with debug symbols?

1574187707
gruebite
2019 has been weird :P

1574187745
gruebite
andrewrk: do you live in seattle?

1574187758
scientes
gruebite, New York

1574187777
gruebite
ahhh. so just visiting the past weekend

1574187781
reductum
andrewrk It was great to meet you at HMS 2019, btw. Thanks for flying out! I'm enjoying my Ziguana.

1574187805
andrewrk
reductum, nice to meet you too :)

1574187814
adamkowalski
andrewrk: about not having SFINAE, I think we don't need it. However, what are your thoughts about something akin to traits/protocols/concepts/etc

1574187817
andrewrk
gruebite, if you build from source, the default is debug symbols on

1574187839
adamkowalski
Some way of saying that I can accept anything that has this particular form

1574187856
adamkowalski
or do you recommend just accepting a var and then using compile time functions to introspect on the type

1574187858
andrewrk
adamkowalski, that's something that is not stable yet. the open issue is

1574187878
adamkowalski
Also about the matrix, the issue I was having was i wanted to write a matmul function

1574187887
adamkowalski
I accepted two matrices by [][]T

1574187903
adamkowalski
however, the matrix I was passing in was a [3][3]

1574187911
adamkowalski
lets say it was called x

1574187915
adamkowalski
so I said x[0..]

1574187920
adamkowalski
which gives you a [][3]

1574187983
adamkowalski
what I ended up doing was this:

1574188023
andrewrk
that looks pretty reasonable to me

1574188032
adamkowalski
And then i'm going to write a second version, which is almost identical except which takes matrices where the len is only known at runtime and it takes in a allocator and returns the slices

1574188062
andrewrk
the fact that the one that can fail and requires an allocator will be a different implementation also makes sense to me

1574188074
adamkowalski
so the reason I wanted concepts/traits/protocols/whatever was so rather then saying var I can communicate my intent to the consumer of the api

1574188089
adamkowalski
I can say I take in a matrix like thing which has it's dimensions known at comiple time

1574188094
adamkowalski
thats the concept I require

1574188142
adamkowalski
so the way I wrote it sounds reasonable to you though?

1574188204
andrewrk
yes this pastebin code looks fine to me

1574188236
andrewrk
I think in a given project, the matrix math code is likely to be the least maintenance required component

1574188252
adamkowalski
my project is entirely matrix math haha

1574188269
adamkowalski
it's all data science, machine learning, data visualization

1574188276
andrewrk
ah interesting

1574188289
adamkowalski
it's currently in Python, and it works pretty well as long as you stick with Numpy/TensorFlow/PyTorch/Jax

1574188308
adamkowalski
but as soon as you need to do something custom or god forbid a loop, performance goes down the drain

1574188326
adamkowalski
and lack of static typing has bitten us over and over again when refactoring as the code size grew

1574188341
andrewrk
this sounds like a job for zig's portable simd

1574188343
adamkowalski
so I'm hoping zig can be the replacement for it haha

1574188358
adamkowalski
i'm really excited about the simd support here

1574188382
adamkowalski
I'm also curious if you've thought about automatic differentiation and gradient descent based optimization in zig?

1574188526
andrewrk
I have to go learn what those are to answer that question

1574188560
companion_cube
I was going to link

1574188582
gruebite
if I do not have -DCMAKE_BUILD_TYPE=None i get compilation errors

1574188598
andrewrk
-DCMAKE_BUILD_TYPE=None is not supported

1574188605
adamkowalski
Okay i'd really like to talk with you further about that at some point. Those are the basis for all the neural network hype you hear about with machine learning these days

1574188650
adamkowalski
if you can define a loss function (the distance between your prediction and the correct value) and differentiate it with respect to the parameters of your model

1574188663
gruebite


1574188664
adamkowalski
then you can improve the weights iteratively, shrinking the loss and causing your model to (learn)

1574188686
gruebite
interesting. the aur PKGBUILD has that as the default and it works

1574188697
gruebite
so I commented it out and now the build fails with that paste

1574188733
adamkowalski
tensorflow/pytorch/jax/whatever pretty much provide a linear algebra library and a automatic differentiation tool. thats it

1574188802
gruebite
this fails, but uncommenting works:

1574188957
FireFox317
gruebite: You are doing this because you want stack traces right? Note that when an assert in cpp land happends the stack trace won't work anyway

1574188998
FireFox317
Well that is for me the case. When I get an assert hit, I always just gdb it and use that to get a backtrace

1574189018
companion_cube
adamkowalski: does mypy not fit the bill for y'all?

1574189158
gruebite
FireFox317: hmm, should i just try to create a minimal replication case?

1574189185
adamkowalski
mypy is okay but it's not enforced. it doesn't lead to compile or runtime errors

1574189203
adamkowalski
it's just hints for humans and ides

1574189233
FireFox317
gruebite: If you want to submit an issue, its always a really good idea to have a minimal replication case yes.

1574189262
adamkowalski
I think statically typing is quite useful. In addition I like the value proposition of Zig which is to build performant, reliabile systems

1574189294
Snektron
andrewrk: Any thoughts on a strong alias builtin? So like @OpaqueType but for every type. (i mentioned this before but im not sure if you read back)

1574189336
adamkowalski
Can't you do that with a compile time function?

1574189345
Snektron
no

1574189346
adamkowalski
Have a function which takes a type, and generates a new type which has the same fields

1574189378
Snektron
Well:

1574189391
FireFox317
gruebite: And if you still want debug symbols in your zig compiler the options for -DCMAKE_BUILD_TYPE are "Debug Release RelWithDebInfo MinSizeRel"

1574189413
FireFox317
Debug by default I think

1574189416
Snektron
The builtin to create types doesn't support structs (yet).

1574189427
Snektron
and my intended usecase was for primitive types rather than structs

1574189453
Snektron
What i mean is that strong aliased types retain their operators

1574189483
Snektron
`const A = @StrongAlias(i32); const a = @as(A, 10) + @as(A, 20);` would be valid

1574189496
adamkowalski
I don't think that would work without operator overload or a numeric trait

1574189502
Snektron
but `const A = @StrongAlias(i32); const a = @as(A, 10) + 20;` would yield a type error

1574189522
adamkowalski
but if instead of using operatros you define an add method on the struct

1574189534
adamkowalski
Thats why I tend not to use operators

1574189540
adamkowalski
you cannot write generic code with them

1574189552
Snektron
nah thats just lame plus too much work

1574189555
adamkowalski
but if you just way I have an add function, then create a new struct and add the add method

1574189592
Snektron
thats just because theres no operator overloading

1574189603
Snektron
Strong aliases are something different

1574189631
adamkowalski
well they are a type that looks and behaves like the old type but has a different name

1574189651
adamkowalski
so if you want a meter type that can contain a float so you have type safety for your units

1574189662
Snektron
exactly

1574189796
gruebite
how can I create a [*c] pointer in zig?

1574189798
gruebite
casting?

1574189824
gruebite
FireFox317: thanks :)

1574189828
andrewrk
gruebite,

1574189863
gruebite
i'd like to know how to initialize a [*c]([*c] Foo) type

1574189921
andrewrk
that's any double pointer

1574189970
andrewrk
set up your data the correct way and it will implicitly coerce to that type

1574190615
gruebite


1574190626
gruebite
tried &[_] and & and [*c]

1574190692
andrewrk
gruebite, don't use [*c], use normal pointer types

1574190767
andrewrk
your code is planned to be a compile error with

1574190818
gruebite
i'm getting a "this is a compiler bug" error though

1574190866
andrewrk
the workaround is not to use c pointers

1574190922
gruebite
i see. cast it to a non-c pointer when interacting with a C api?

1574190979
andrewrk
let me rephrase: whatever your workaround options are, putting C pointers in your zig source code is never the answer

1574191035
andrewrk
zig's pointer types implicitly coerce to and from C pointer types. the only reason C pointer types exist is for auto translated C code

1574191295
andrewrk
gruebite, if the code in your paste used normal pointer types it would be easier for me to see what you are trying to do

1574191475
gruebite
stuck on learning how to initialize this :D

1574191485
gruebite
.ext = [_](*const Foo){&foo0} not quite

1574191500
gruebite
[1]* != [*c][*c]

1574191533
andrewrk
you haven't provided the information I need to help you, which is the type of `ext`

1574191549
gruebite
in my previous paste: .ext = [_](*const Foo){&foo0}

1574191555
andrewrk
that's not a type

1574191557
gruebite
oops

1574191563
gruebite
ext: [*c]([*c]const Foo)

1574191579
andrewrk
stop using c pointers. try again

1574191611
andrewrk
c pointers do not tell me enough information about the type

1574191618
gruebite
i'm attempting to replicate the compiler crash "this is a compiler bug" by replicating the generated C header code

1574191647
andrewrk
oh, you're working on a test reduction, not trying to write code?

1574191651
gruebite
yeah

1574191657
andrewrk
I see

1574191660
gruebite
sorry if that wasn't clear :D

1574191699
Pistahh
andrewrk: does (or will) zig have any answers on stale pointers or use after free?

1574191721
gruebite
what i'm doing in my real code is iterate through a C type which is a linked list, so I end up looping a [*c][*c] type. i assume you're saying i shouldn't access this directly and should coerce them to zig pointers before accessing?

1574191746
gruebite
erm, linked list with a C array of pointers*

1574191754
gruebite
in each list node

1574191774
andrewrk
Pistahh, I'm planning on addressing use-after-free in this release cycle

1574191820
gruebite


1574191837
andrewrk
gruebite, I'm saying in any code that you type into your editor, you will need `[*c]`, because zig pointers implicitly coerce to and from those. so use zig pointer types for everything

1574191846
andrewrk
sorry, you will

1574191918
gruebite
my zig code is using zig pointers, but i'm accessing the C stuff like `something.*.field`

1574191985
FireFox317
and gruebite you are probably getting that compiler error because you are using [*c] in your code, and as stated by andrewrk don't put any [*c] in your own zig file

1574192019
andrewrk
FireFox317, there's a compiler bug gruebite is in the process of creating a reduction for

1574192072
FireFox317
Oh yeah sorry, ignore me gruebite :)

1574192104
gruebite
line 61 is where I get a crash

1574192108
gruebite
removing that line no crash

1574192130
gruebite
trying to replicate it but i'm stuck on initializing the type that line 61 accesses

1574192168
andrewrk
what error do you get

1574192189
gruebite
Assertion failed at /home/grue/packages/aur/zig-git/src/zig/src/list.hpp:31 in at. This is a bug in the Zig compiler.

1574192201
andrewrk
so you have successfully created the reduction then? what's the problem?

1574192229
gruebite
not yet, still haven't figured out how to initialize a [*c]([*c]const Foo) type :D

1574192239
gruebite
still learning zig as i do this

1574192250
lunamn
andrewrk: is there a plan to have implicit coercion for c pointer parameters when passing extern functions?

1574192269
andrewrk
gruebite, my advice to come up with a real type for ext is still valid. What is the actual type? without c pointers

1574192283
gruebite
it's an array of pointers

1574192288
andrewrk
lunamn, I'm pretty sure there already is

1574192306
lunamn
andrewrk: sadly, that didn't work in practice when using libexpat and passing callbacks

1574192327
andrewrk
lunamn, sounds like a bug

1574192336
FireFox317
I think it's not really clear to new Zig user that if you just import c stuff you can just use zig pointers, instead of the special c pointers. Same holds for when exporting stuff, you can just export zig pointers and they are valid c pointers

1574192361
andrewrk
FireFox317, I completely agree. I don't know how to solve this. The underlying problem is that .h files have shit pointer types

1574192405
gruebite


1574192411
gruebite
this gives me that compiler error

1574192416
gruebite
reduced case

1574192448
gruebite
not sure if can be reduced further

1574192500
FireFox317
That is a good reduction gruebite!

1574192528
lunamn
andrewrk: for example, "expected '?extern fn(?*c_void, [*c]const u8, [*c][*c]const u8) void', found 'extern fn(?*c_void, [*]const u8, [*][*]const u8) void'"

1574192533
lunamn
maybe its caused by it being slice of slice?

1574192573
andrewrk
lunamn, are there any error notes?

1574192671
FireFox317
gruebite: Do you also get the error if you don't use the type field in the Foo struct?

1574192672
lunamn
andrewrk: no notes other than "referenced here", so no

1574192702
FireFox317
gruebite: I mean if you name the field different

1574192781
andrewrk
lunamn,

1574192818
andrewrk
lunamn, you need `?`

1574192854
gruebite
FireFox317: testing

1574192905
gruebite
yeah it still crashes when field is not type

1574192963
gruebite
i'll reduce this further heh

1574193169
gruebite


1574193186
gruebite
i'm on HEAD

1574193276
gruebite
is there an online zig sandbox? :D

1574193292
FireFox317
godbolt.org

1574193382
gruebite


1574193441
gruebite
seems like a simple case, no?

1574193510
FireFox317
Maybe it's actually because you have nothing in the switch case?

1574193581
gruebite
possible

1574193622
gruebite
also, there should be something official called "zag"

1574193624
gruebite
zigzag

1574193627
gruebite
hehe

1574193637
FireFox317
Yeah that is the issue gruebite:

1574193662
gruebite
yep

1574193711
gruebite
maybe I can submit a pull request?

1574193714
gruebite
seems like a simple one

1574193751
FireFox317
If you would like to do that, yes!

1574193777
gruebite
:D

1574193806
gruebite
i can do it this afternoon (6 hours) if that's not too long?

1574193806
FireFox317
Should probably add a compile error when there is nothing in a switch indeed :)

1574193811
gruebite
yeah

1574193836
gruebite
or should empty switches be allowed?

1574193840
gruebite
just like empty ifs?

1574193857
FireFox317
Yeah I don't know actually, andrewrk?

1574193971
andrewrk
empty switch is useful for empty error sets. you get an error if an error possibility is added

1574194038
frmdstryr
Is there something like a mem.replace?

1574194059
gruebite
what about switching on other types like an int?

1574194073
FireFox317
Ah jup indeed, but when switching on anything other than error sets give a compile error?

1574194627
FireFox317
gruebite: The error is on line 24762 of ir.cpp, it sees that there is no else prong so it will check if all the possible integer values are switched on.

1574195038
FireFox317
gruebite: Are you making a PR? If not I have a patch ready

1574195790
dimenus
i like how I can do `const file = @This()` and not have name collisions

1574195817
dimenus
eg i can have `file.createVertexBuffer` which takes granular params and a `context.createVertexBuffer` which takes fewer params

1574196374
lunamn
andrewrk: would it be interesting to have an issue open to have compile notes in regards to making the parameters optional or?

1574196412
gruebite
FireFox317: I was going to do it this evening when I'm back at home

1574196436
gruebite
You can go ahead and submit it :)

1574196443
gruebite
I'll look at it and learn

1574196472
FireFox317
Are you sure? You can try it first and I can submit it tomorrow if you don't figure it out.

1574196493
FireFox317
Or I can just submit it now yes xd

1574196515
gruebite
I'll take a stab at it :D

1574196524
gruebite
I may have questions tonight

1574196561
FireFox317
I can't answer them, because of different timezones I'm afraid. Tonight is already here :)

1574196572
gruebite
Europe?

1574196591
FireFox317
West Europe yes

1574196602
gruebite
Nice, I've only ever visited eastern europe

1574196622
gruebite
I'm in Seattle, currently looking at the olympic mountain range. It's quite cloudy

1574196683
FireFox317
Ah cool, we don't have mountains in the Netherlands :^)

1574196688
andrewrk
lunamn, yes, in fact I'm pretty sure it's a TODO in the compiler already, just needs a bit of glue code to wire that up

1574196739
gruebite
you have clouds though

1574196862
FireFox317
gruebite: Yes unfortunately we have those too, btw the patch is just adding 33 chars on one line :)

1574196878
gruebite
and a test case?

1574196936
FireFox317
Yeah, you could add that as well

1574196950
mikdusan
corner case: `var x: u0 = 0; switch (x) {};`

1574197004
andrewrk
yes that should be allowed

1574197044
gruebite
`var x: u1 = 0; switch(x) {};`?

1574197053
FireFox317
Then it won't be 33 chars on one line xd

1574197075
FireFox317
For `u1` it should give a compile error I think

1574197082
gruebite
seems like this is a fairly important decision based on how the compiler wants to enforce things

1574197086
companion_cube
`var x: unreachable; switch(x) {};` ? :)

1574197089
gruebite
is it lax with non-error types and switches?

1574197120
gruebite
or should it be exhaustive for integer types

1574197156
andrewrk
it's always exhaustive

1574201249
muffindrake
Is there some way to express 'this passed-in buffer must be at least this many elements big'? In C, function parameters are still pointers, but the language does support something along the lines of `int arr[static 5]` for 'this parameter is a pointer to at least 5 elements of type int`

1574201358
andrewrk
muffindrake, the closest zig has to that is doc comments + assert

1574202183
mq32
fun fact: zig has now 6,666 commits

1574202239
mikdusan
👹

1574202473
adamkowalski
Has anybody worked on vim-test integration for zig?

1574202493
adamkowalski
I've implemented test file, and will start working on test nearest

1574202504
adamkowalski
but if somebody else has already done all that too I don't want to duplicate effort

1574202556
andrewrk
I believe you would be the first

1574202602
adamkowalski
Alright cool, I was just checking. Once it's in a reasonable state I'll make a PR to vim-test

1574202689
adamkowalski
Also i've been talking with the maintainer of the zig lsp implementation. We've been discussing anonymous structs. Those currently don't work. They currently implement parsing on their end as well. So when the compiler adds new features the lsp falls behind. Is there any way we can rely on the compiler to generate the AST and use that?

1574202698
gruebite
anyone else making zig bindings to godot native? :p

1574202756
adamkowalski
I think currently if you use the standard library zig parser it stops on the first misparse. They wanted to collect all the errors at once and then lint your file afterwards

1574202792
daurnimator
companion_cube: scientes: http 1.1 is terrifying difficult...

1574202801
daurnimator
it looks easy on the surface but is full of footguns

1574202841
companion_cube
yeah, if you want to make a fully featured thing (like nginx)

1574202886
andrewrk
I bet it's easy if you're willing to return "501 not implemented" and "413 request entity too large" for various things

1574202894
andrewrk
which IMO is entirely appropriate

1574202910
daurnimator
or even not be vulnerable to desync attacks.... or not fail terribly on a badly created server (if you're a client) or not fail on a bad client (if you're a server)

1574202939
daurnimator
e.g. what do you do when you receive two Content-Type headers back from the server? Did you remember to check for that?

1574202999
andrewrk
zig is an ideal language for a perfect implementation of a spec such as this

1574203014
daurnimator
uh I meant to say Content-Length; but Content-Type is a simpler starting point

1574203023
daurnimator
andrewrk: yes! but its foolish to say that http 1.1 is simple

1574203239
andrewrk
I agree it's not simple, but I also want to point out that it is desirable to put resource limitations on the implementation, and this this does make things simpler

1574203349
andrewrk
e.g. if you have `content_length: ?u64` rather than `header_map: StringHashMap`, dealing with double content length is going to be in your face

1574203363
andrewrk
although with zig not letting you ignore return values and put() returning the old value, even the hash map version would help

1574204956
kristoff_it
I have a function with this signature: `pub fn init(keys: []const []const u8) Self`, when I call it like this `init(.{ "lol", "123", "test" });` I get an error. Is it reasonable to expect an automatic conversion for this case in the future?

1574205130
andrewrk
kristoff_it, yes, that's planned to work just fine

1574205155
andrewrk
there are a few issues related to anon struct/list literals to work out

1574205253
kristoff_it
andrewrk: very cool. I'm asking because this is an API I want to present to my users. Anonymous structs and arg lists are very powerful, I'm having a blast. Also all the async/await issues that I encountered in the past seem solved (with the occasional work-around) so great job on that too!

1574205408
fengb
expected type 'main.struct:512:31', found 'main.struct:512:31'

1574205432
fengb
Shouldn't that mean they're the same type?

1574205527
daurnimator
andrewrk: where should I put AFD struct definitions? make a new file windows/afd.zig ?

1574205599
andrewrk
sorry, I need to focus on a bug for a moment

