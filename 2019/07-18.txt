1563408200
scientes
dimenus, src/ir.cpp:22152

1563408210
scientes
(fix it)

1563408378
dimenus
ooor we could just have  @memcpyBytes

1563408383
dimenus
for true no rules

1563408397
dimenus
and not muck with @memcpy, as that would screw with a bunch of existing callsites

1563408493
daurnimator
andrewrk: did you see this link overnight?

1563410646
ltr-
q: how can i add an include dir for c files? without build.zig*

1563411047
ltr-
doh! isystem

1563419929
diltsman
Stupid question, is there a way to specify a function that will be used unless the function is defined elsewhere?  My particular usecase is an interrupt handler.  I would like to provide a default no-op and then override elsewhere if it is actually used.

1563419994
daurnimator
diltsman: are you looking for @export with a weak linkage?

1563420107
diltsman
daurnimator: possibly.  Will it keep the linker keep the weak function if there is a strong definition?

1563420147
hryx
diltsman: to wit, you could either provide an init function which takes an optional function pointer, or use something like `if (@hasDecl(@import("@root"), "customInterruptHandlerFunction")) ...`

1563420160
hryx
caveat, I'm not actually sure if that second one would work, I've never tried it

1563420176
diltsman
Cool.  Thanks.

1563420217
daurnimator
diltsman: I think the answer to that changes based on shared vs static and depends on the target

1563420233
diltsman
Makes sense.

1563420259
diltsman
Given that the weak function would be an empty function, it is not a deal breaker either way.

1563421021
daurnimator
diltsman: weak linkage vs hryx's root file suggestion: it depends if you want to override it from zig or from your linker scripts/when mixing object files with e.g. C

1563421052
diltsman
Overriding from Zig is fine, given that the entire thing is written in Zig.

1563424067
emekankurumeh[m]
zig's grammar isn't context free is it?

1563424592
emekankurumeh[m]
why do people even like regex?

1563427920
IntoxicatedHippo
Is this meant to work or are comptime blocks not meant to be used like this?

1563429521
mikdusan
IntoxicatedHippo: i think there's an issue with `var array3 = [1]S{ S{ .x = 5 }, } ** 2;`

1563429561
IntoxicatedHippo
mikdusan, I just worked that out, `var array3 = [2]S{ S{ .x = 5 }, S{ .x = 5 }, };` works as intended

1563429566
mikdusan
if you manually size it `[_]S{ S{ .x = 1 }, S{ .x = 2 }};`

1563429570
mikdusan
yeah that's what i found too

1563433026
ffddr
Hi! Is there some ready to use lib to parse json to an arbitary struct? I fill that this should be doable with std.json and something like std.io.Deserializer, maybe it was done somewhere?

1563434014
emekankurumeh[m]
no, that would depend on something like @reify

1563434046
daurnimator
emekankurumeh[m]: why?

1563434062
daurnimator
emekankurumeh[m]: e.g. as an API, you could provide a struct, and you would parse json

1563434111
emekankurumeh[m]
that makes sense

1563434130
daurnimator
const myparsedjson = try json.deserialize(struct { x: u32, y: bool }, "{\"x\": 42, \"y\": false}");

1563434133
emekankurumeh[m]
I suppose it's about time o went to bed

1563434138
daurnimator
^ somerhing like that should be writable

1563434367
ffddr
but not yet implemented somewhere, right? Just double checking before rolling my own thing)

1563441325
ffddr


1563441774
IntoxicatedHippo
Doesn't @field only work at compile time?

1563441861
ffddr
I guess it works in runtime while argument is comptime string

1563441943
IntoxicatedHippo
Oh, I thought `field` was the field name from the json

1563442103
IntoxicatedHippo
I'd have an init function in that struct that creates a hash table mapping struct field names to fields so you can parse the json serially rather than loading it all in to memory

1563442845
ffddr
hm, will the std.json.Parse.parse load the entire json anyway?

1563442894
Pwipwi
how can I get argv ?

1563442899
IntoxicatedHippo
it supports field lookup so it either scans the entire string each time or loads the structure in to memory

1563442972
Pwipwi
I see there's an argiterator in os

1563442986
Pwipwi
but isn't there something more simple that gets us a [][]const u8 ?

1563443113
IntoxicatedHippo
std.process.argsAlloc and argsFree

1563443124
ffddr
IntoxicatedHippo: hm, I dont quite understand your idea :( If deserialize is going to return T, it probably will need to load entire json anyway. I dont see how  hashmap with struct field will help there :(

1563443291
IntoxicatedHippo
Something like this:

1563443293
IntoxicatedHippo
for field in json:

1563443293
IntoxicatedHippo
if field.name in struct_fields:

1563443293
IntoxicatedHippo
struct[field.name].value = parseAs(struct[field.name].type, field.value)

1563443564
IntoxicatedHippo
An example of when it would help: If you have a json string that you want to parse in to an array of structs, loading the entire structure of the json string in to memory will use a lot more memory than just stroing information about the one zig struct

1563443652
Pwipwi
IntoxicatedHippo, I can't find std.process ?

1563443682
ffddr
I see, in this way we can feed std.json byte by byte, get the new tokens and put it to the fields without any additional memory

1563443694
IntoxicatedHippo
exactly

1563443788
IntoxicatedHippo
Pwipwi, std.os.argsAlloc in Zig 0.4.0, it's been moved in master

1563443823
Pwipwi
ah ok, thank you

1563443834
Pwipwi
in general, is it recommanded to stay on master ?

1563443835
ffddr
and parseAs is a great idea also, with moving parsing to parseAt function :)

1563443890
Pwipwi
why do we have to go through copying all the arguments to get them ?

1563443903
Pwipwi
aren't argv and argc given already ?

1563443942
Pwipwi
to the process I mean

1563443957
Pwipwi
I don't understand why more memory is to be allocated

1563443961
Pwipwi
and copied

1563444054
IntoxicatedHippo
You can use std.os/process.args() which returns an ArgIterator

1563444079
IntoxicatedHippo
argv doesn't exist on a lot of the platforms zig supports

1563444737
Pwipwi
but for those where it does, it seems a little convoluted :-|

1563444950
hryx
It's generally important to provide a platform-agnostic API. Providing a second, simpler interface that only worked on some platforms would be redundant and encourage writing unnecessarily OS-specific code

1563445094
hryx
and providing more than One Way To Do Things is un-zig

1563454897
Tetralux
Here's a question

1563454902
Tetralux
A hypothetical

1563454915
Tetralux
Suppose you have a big codebase, writte in Zig.

1563454936
Tetralux
You want to profile it to find which procedures are called most often, and how long they take, etc.

1563455008
Tetralux
In Jai, (I'm sorry) the metaprogram can be instructed to automatically insert the necessary code into the top and bottom of every function to measure how long it takes to run at compile time without modifying the actual source code - even with stdlib procedures.

1563455095
Tetralux
My guess would be that in Zig, the status quo is that you do the same as C: Manually write the instrumentation code.

1563455111
Tetralux
Is this true, and is this the way Zig will ship with?

1563455130
scientes
Is there an easy way for be to debug build failures on OSX and Windows but not Linux?

1563455529
fengb
Tetralux: that'd be "aspects" or "function decorators". I don't think that'll ever happen automatically since it's very much not explicit, but I'd like to see something like function decorators

1563455565
fengb
The challenge is how do you write "come from" code without being magical

1563455603
fengb
I guess arguably we don't need it since you can do something like `const profile = Profile.start(); defer profile.end()`

1563455613
Tetralux
For reference, in Jai, you'd have a constant variable (eqiv to const PROFILE_FNS = false) that you'd toggle in order to activate the insertion of instrumentation code.

1563455628
fengb
Yes I know how it works. It's just magic control flow that Zig abhors

1563455638
fengb
You can't see it happen in the function body

1563455653
Tetralux
I'd argue that you don't need to - and in fact - shoudn't.

1563455664
Tetralux
It's not part of the function, that it is being profiled.

1563455674
Tetralux
You

1563455676
fengb
But it's not obvious it's happening

1563455680
Tetralux
It is.

1563455682
Tetralux
Because you activated it.

1563455686
fengb
Not looking at the code

1563455700
fengb
At a large codebase, you can't tell where all of these "aspects" are happening

1563455700
Tetralux
Not looking at the procedures being instrumented, no.

1563455710
Tetralux
But looking at the variable that turns it on, you would.

1563455711
fengb
Not talking about just instrumentation

1563455725
fengb
Zig also doesn't like "language only" features

1563455732
Tetralux
This variable is probably in the same file as the entry point.

1563455734
fengb
So something like this would probably be available in userland

1563455748
fengb
e.g. logging

1563455765
fengb
Debuggers?

1563455796
fengb
There's a lot of styles this would enable, but it'd also be a pain to debug later since any function at any time could have arbitrary code happening somewhere else in the codebase

1563455806
Tetralux


1563455818
Tetralux
"Abitrary" is quite a stretch.

1563455826
Tetralux
It's known what the code is.

1563455834
Tetralux
And it's probably even as a string in your program.

1563455847
fengb
So... only profiling can be done this way?

1563455863
Tetralux
Obviously not.

1563455903
Tetralux
But if you wanted to profile you'd toggle that variable; if you wanted to count the number of variables that start with an underscore, you toggle that variable, or whatever else you want.

1563455915
fengb
So how do you limit what's done. And which ones to run for what function

1563455934
Tetralux
The point in Jai

1563455938
Tetralux
But also

1563455945
Tetralux
Jai has what it calls "notes"

1563455949
Tetralux
like

1563455958
fengb
Yeah that's sort of my point. If there's no limit, this can just happen. For "reasons" unclear to the current control flow

1563455958
Tetralux
(the equiv of...)

1563455976
Tetralux
fn doLongThing() @NoProfile { ... }

1563455984
Tetralux
In Jai, it'd look like this:

1563455993
Tetralux
doLongThing :: () @NoProfile {...}

1563456005
Tetralux
And the @NoProfile thing is a metaprogram accessible thing.

1563456013
fengb
Those are annotations

1563456019
Tetralux
Indeed.

1563456024
fengb
I guess I was confused when you said "automatically"

1563456032
fengb
I assumed "at any point without any reference"

1563456042
Tetralux


1563456052
fengb
Yeah I think annotations are a good thing

1563456058
Tetralux
Although, you could use rand() in the metaprogram to do that if you

1563456063
Tetralux
But you wouldn't do that.

1563456073
fengb
But it's more obvious you're deferring control flow to

1563456086
fengb
I don't want control flow redirected automatically ever

1563456095
Tetralux
You mean when you do const x = Profile.start() etc?

1563456100
fengb
Well... not in Zig. I'm happy to make concessions in other languages :P

1563456133
Tetralux
I should note, that the code you'd insert via the metaprogram would

1563456157
Tetralux
It would be exactly the code you chose to insert - be it a call or just imperative statements.

1563456215
Tetralux
But yes - the point is that it allows the code to not even think about profiling, and still be able to profile trivially.

1563456221
Tetralux
The metaprogram would not be hard to write.

1563456232
Tetralux
And you can turn it on and off at will.

1563456278
Tetralux
Personally, I find that very helpful.

1563457233
fengb


1563457239
fengb
C is just full of errors waiting to happen :/

1563457254
scientes
oh god

1563457268
scientes
but in zig that would be a compile error

1563457271
scientes
then you would add "try"

1563457275
scientes
and then it would be correct

1563457301
fengb
I'm just trying to port this and I might have to spend more time fixing bugs than getting this to work

1563457322
scientes
you might want to be an asshole and make a list of all the errors you fix

1563457350
fengb
Well... I'm the asshole that's rewriting this in Zig and exporting a C compatible version :P

1563457374
scientes
exactly, so better do it properly

1563457396
scientes
and publicly post all the suck in the orig.

1563457416
fengb
lol

1563457420
gonz_
Would a PR count as that? :P

1563457430
scientes
no this is even better

1563457436
tgschultz
he's right, it'll be a good example of how zig brings value over C

1563457500
fengb
Actually that's a pretty good point. Maybe I should document and write a blog post

1563457510
gonz_
Given a very low smugnesslevel I'd agree

1563457526
fengb
I didn't even intend to fix anything. I just don't wanna deal with a C api

1563457541
fengb
And this isn't too long of a program. Just scratching my own itch

1563457605
gonz_
I'm not sure the "here's how our language fixes the issues in yours" strategy is what's worked before

1563457634
companion_cube
it's good advertisement for Zig, but not that helpful for people attached to C

1563457636
gonz_
Rust seems to attract people who mostly weren't interested in low level programming before, not C++ users

1563457660
companion_cube
people whose pain threshold was too low for C++

1563457664
gonz_
So I guess everyone who's like "I want something simple but I don't know that C is the language I'm looking for" would be the target for something like that.

1563457820
fengb
The error handling is elsewhere. It's not non-existent... it's just far away

1563458106
fengb
I think it's because Rust is the only major non-GC language with modern features, and a systems language that's vaguely ML-like

1563458129
tgschultz
Even people who like C a lot recognize it has flaws, I don't think pointing out how zig has dealt with those flaws is the same as smuggly beating up on the language.

1563458155
fengb
Yeah, I only stuck with C so long because C++ is... not good

1563458229
companion_cube
gonz_: except the pain threshold for C is super high too 🤷

1563458372
gonz_
tgschultz: I think it's a good bet that most users of C++ know it has issues (many of them choosing not to use major parts of the language), but that hasn't really meant that good-natured "Hey, here are all the problems with your language that we fix" campaigns have succeeded

1563458470
gonz_
I think Rust seems to have a great community internally, but their interaction outwards in general has been pretty awful.

1563458485
fengb
How so?

1563458508
gonz_
PRs amounting basically to "Rewrite in Rust?", the Rust Evangelism Strikeforce, etc.

1563458515
gonz_
Smug, insufferable

1563458519
fengb
Oh

1563458541
tgschultz
well, zig has kinda already crossed that bridge by calling itself a "better C" hasn't it?

1563458565
tgschultz
I'll agree about the evangelism, we don't want to go there

1563458623
gonz_
tgschultz: No, I think that attitude is very appropriate to have in a community. It's an ideal to strive for, with a lot of spirit and a certain  set of ideas that go with it. Outwards it's a terrible attitude, however.

1563458625
fengb
I think it's massively different to prove by example vs by proselytizing

1563458755
gonz_
fengb: In the end it comes down to delivery and I think subtlety is key. Saying "Here's a PR with some robustness fixes that I noticed... while doing some zig stuff with the project, (check it out here)"

1563458840
gonz_
I think zig is a good candidate for something that sells itself within a very short time once people get some exposure, given it's still (and hopefully will remain) small.

1563458949
Tetralux
Just my two cents: don't put a link to the project; call it by name instead: 'Zig Programaming Language.'

1563458969
gonz_
Even better, yeah.

1563458999
gonz_
If people are interested, they'll find it and feel like it's something they to some extent discovered.

1563459003
Tetralux
It's not like Zig's hard to find or anything - esp if you cutnpasted that into Google.

1563459048
gonz_
If they're sold it by someone who begun the conversation by saying "Do you have some time to talk about our lord and savior Ctulhu?" it's harder to take it in, I think.

1563459088
gonz_
Fun fact: I found Zig (again) when googling "nim programming language" and remembering the recurse center talk I'd seen before.

1563459108
gonz_
It was the first result for that phrase

1563459517
gonz_
I can't seem to reproduce it now, though

1563460377
tgschultz
oh, I didn't catch that this was in the context of a PR, I would agree that isn't the place to talk about how zig improves upon C.

1563460385
tgschultz
a blog post though

1563460570
euantor
scientes: >Is there an easy way for be to debug build failures on OSX and Windows but not Linux?

1563460594
euantor
Not sure, I don't think there's anything in place for that, easiest way would be to run a VM I guess

1563460607
scientes
you can't even do that for OSX

1563460619
scientes
OSX is finicky with the hardware it accepts

1563460632
euantor
Yeah, I know

1563460641
euantor
MS do have free VM images for Windows 10 for 90 days:

1563460656
euantor
and Azure and OVH both offer hosted VDI

1563460658
scientes
what happens after 90 days?

1563460664
halosghost
scientes: it reports you to the FBI

1563460669
euantor
No idea, I've never tried it

1563460669
halosghost
s/FBI/Adobe/

1563460714
euantor
If you need access to a Windows 10 machine for a few days/weeks, I'd be happy to provide that

1563460738
scientes
how does that even work?

1563460756
scientes
I don't have enough bandwidth for screen casting

1563460785
fengb
Microsoft actually recommends a workaround for their own 90 day limit

1563460789
scientes
I'll just install a pirated Windows 7 VM

1563460792
fengb
It's kinda funny

1563460802
euantor
fair enough

1563460810
scientes
its just a PITA

1563460811
fengb
"These virtual machines expire after 90 days. We recommend setting a snapshot when you first install the virtual machine which you can roll back to later."

1563460812
euantor
The way I've done it before is using

1563461014
fengb
Should we support octal escapes in Zig?

1563461024
fengb
In string literals

1563461157
andrewrk
the answer to "should we support __ in zig?" is "no" unless there is a really compelling reason to do it

1563461233
fengb
I'm looking at terminal escape sequences, and they look super foreign in hex

1563461270
fengb
There's a decent number of old octal based stuff. Not sure if that's compelling enough since it's still representable

1563461875
tgschultz
does zig still support octal literals? if so, maybe we should support octal escapes... then again maybe we shouldn't support octal literals.

1563461946
ffddr
@freenode_IntoxicatedHippo:matrix.org: did not yet implement the hashmap thing, but come pretty far with parseAt :)

1563462041
companion_cube
why not have octal literals?

1563462047
companion_cube
they're useful for file perms, right?

1563462060
Tetralux
I've never used one, to be fair.

1563462081
Akuli
if they are added, please don't use the 0755 syntax from c, make it 0o755 or something instead

1563462103
Akuli
python 2 used the 0755 syntax, and they switched to the 0o prefix in python 3

1563462104
Tetralux
I think we already have octal literals, and they are 0oXXX IIRC.

1563462149
Akuli
hmm, but it wouldn't be too hard to create a comptime usable function that does octal("755")?

1563462168
companion_cube
0o644 is much more clear indeed

1563462191
tgschultz
I know we did have them, do we still? I vaguely recall something about removing octal literals.

1563462270
tgschultz
the only time I have ever used them was with defining constants for linux API. That's probably the most common use case and I'm not sure it's a big enough one to jsutify it.

1563462289
Tetralux
It always puzzled me why the didn't just make it an enum.

1563462291
andrewrk
fengb, it's also possible to introduce your own string formatting function that supports octal

1563462300
Tetralux
Why 755 has anything to do with permissions idk.

1563462311
Tetralux
"It just does."

1563462313
Akuli
you could do that with my octal() function too:  const PERM_MASK = octal("777");

1563462324
Akuli
755 is the default perm for folders

1563462335
Tetralux
I was thinking more outside the box than that.

1563462343
companion_cube
Tetralux: it's a bitmask with 4 bits for user/group/other? it makes sense

1563462354
tgschultz
Tetralux, because it's a set of binary flags in 3 groups of 3, and old unix guys really hated typing.

1563462367
tgschultz
it is 4 isn't it? oops

1563462378
Akuli
hmm. how about a hex2oct function so that you can do hex2oct(0x755) or something :D

1563462386
Akuli
tgschultz, no its 3

1563462391
Akuli
hex is 4

1563462397
Tetralux
See - "because old unix guyts really hated typing" sounds more like the reason I'd expect xD

1563462429
tgschultz
mv, rm, cp...

1563462431
Tetralux
Since it's a bit mask anyway... why would you not just have flags for it and be obvious about it?

1563462459
Tetralux
You could even have a flag for READ+WRITE.

1563462508
companion_cube
how do you write that in bash?

1563462535
Tetralux
There's your first mistake

1563462535
Akuli
bash supports 0755 i think

1563462545
Akuli
Tetralux, uh, you mean:  ((READ|WRITE|EXEC)<<6) | ((READ|EXEC)<<3) | ((READ|EXEC)<<0)

1563462549
Akuli
i don't want that :D

1563462554
Tetralux
Not quite xD

1563462555
companion_cube
😱

1563462571
Akuli
there's ur 0o755

1563462596
Akuli
or you know, compute the constants with bash and hard-code them into the code

1563462597
Akuli
$ echo $((0755))

1563462597
Akuli
493

1563462744
companion_cube
yay for readability 🙃

1563462767
Tetralux
There's three "blocks" in user perms

1563462773
Tetralux
One is group, one is user, and the other is?

1563462774
Tetralux
I forget.

1563462778
Akuli
everyone else

1563462781
fengb
We already have it for literals: 0o777. I meant as a string escape sequence

1563462783
Akuli
ugo, user group others

1563462799
fengb
"\x1B[?1000h"

1563462801
fengb
That just looks weird

1563462826
Tetralux
There's multiple ways you could have the interface.

1563462837
fengb
I know its a convenience thing, but I've been subliminally accustomed to "\033"

1563462841
Tetralux
setPerms(group(ALL) | user(ALL) | others(ALL))

1563462856
Tetralux
Where group, user shift by the appropriate amount.

1563462869
Tetralux
Or you have seperate args for each one

1563462874
Akuli
hmm

1563462888
Tetralux
Or

1563462894
fengb
I actually didn't realize it was octal. Shame on me >_>

1563462907
Tetralux
setPerms(group(READ) | user(ALL) | others(NONE))

1563462923
Tetralux
(.. This would work wherever an oct-lit would)

1563462932
Tetralux
Or you could have a seperate arg for each one thus:

1563462935
Akuli
if you forget user(ALL) it gets user(NONE) implicitly

1563462964
Tetralux
(.. Akuli: Indeed. But you could also have a call for setAllPermsExcept)

1563462972
fengb
Bitfields: `permissions.group.read = true` :P

1563462979
nrdmn
why can't I return an enum(usize) with calling convention ccc?

1563462989
andrewrk
I think there is an argument to be made that since we have hex literals as "0x" and hex character escapes with "\x" and we have octal literals with "0o" then it would be consistent to have octal escapes with "\o"

1563463000
Tetralux
ALL, ALL, ALL.

1563463022
Tetralux
(.. Personally I'd use kwargs preferably.)

1563463028
halosghost
is now a bad time to throw in my lot with the arbitrary-radix literal camp?

1563463030
halosghost
:)

1563463031
fengb
andrewrk: yeah that's what I meant. I'm only weakly proposing since it's not a blocker and I think it's just a historical quirk

1563463060
andrewrk
nrdmn, I think there may be an issue for that. note that it requires a C extension to specify the integer size in a C enum

1563463064
Akuli
i would be quite confused if i saw an octal literal in a string, in any language

1563463084
fengb
Akuli: I don't disagree... but I've been using octals in Bash for 2 decades without realizing now

1563463100
Tetralux
HAHA

1563463116
scientes
octals need to die

1563463123
companion_cube
I must say I just think of 3 separate digits

1563463126
scientes
they only make sense with byte sizes other than 8 bits

1563463140
companion_cube
ôO

1563463173
Akuli
how about perms in binary? 0b111101101 for 0o755

1563463188
fengb
Yeah I don't really get octals either. But they exist in the real world

1563463189
scientes
oh well yeah permissions are naturally octal

1563463195
fengb
lol

1563463195
Tetralux
Akuli: Underscores in literals anyone?

1563463199
scientes
but that is unusual

1563463201
Akuli
that too

1563463218
Tetralux
0b111_101_101

1563463231
companion_cube
that's not too bad

1563463242
scientes
Tetralux, go just added that syntax

1563463242
Tetralux
I'd be annoyed if I couldn't do that in that situation.

1563463251
scientes
but yeah its better than octal

1563463256
Tetralux
scientes: Allowing arbitrary unders?

1563463262
scientes
yes

1563463264
Tetralux
Ah

1563463266
Tetralux
Also

1563463272
scientes
Tetralux, its actually 0b0_111_101_101

1563463278
Akuli
new pythons allow underscores in literals too

1563463279
Tetralux
I'd say it's better than octal, sure - I still have to know wtf each bit means though xD

1563463285
scientes
don't forget the sticky bit

1563463299
scientes
/ setuid bit

1563463310
fengb
Wouldn't it make more sense to do a packed struct bitfield?

1563463316
Tetralux
Part of me would like to pour super glue over all of this octal-file-perms business...

1563463317
nrdmn
andrewrk: but I can return usize. Just not enum(usize)

1563463322
Tetralux
...it is so short to type though..

1563463327
scientes
well yeah unix file permissions are broken

1563463343
scientes
although I don't get why no-one has promoted the obvious solution, that leaves the permission bits as-is

1563463349
scientes
just have a groups be a DAG

1563463356
Tetralux
wetf is DAG? XD

1563463361
scientes
so groups can include other groups, and eventually point to users

1563463382
scientes


1563463398
andrewrk
nrdmn, usize maps to uintptr_t in C. what does enum(usize) map to?

1563463407
Tetralux
God I hate complicated terms that I need to figure out what they mean anyway xD

1563463475
fengb
DAG is the "standard graph" that most people would use

1563463485
fengb
Just more computer science-y

1563463498
Tetralux
It looks like a linked list where each element can point at multiple other elements and not just one or two.

1563463503
Tetralux
MultiLinkedList. :)

1563463507
scientes
basically

1563463508
nrdmn
andrewrk: I would have thought enum(T) maps to whatever T maps to

1563463513
scientes
except it can't link back onto itsself Tetralux

1563463520
scientes
that is the "acyclic" part

1563463532
fengb
It's from the graph family, where you can make cycles and have bidirectional references

1563463537
andrewrk
nrdmn, I believe enums have their own C ABI

1563463538
Tetralux
MultiLinkedQueue then :)

1563463547
scientes
yeah basically

1563463565
Tetralux
I'm not sure why I'd need that, but that at least I understand the structure of XD

1563463571
scientes
DFTAs (that implement regular expressions in O(n) time) are also DAGs

1563463586
scientes
*DFSA

1563463608
Akuli
Dubai Financial Services Authority?

1563463611
Akuli
i googled dfsa

1563463617
Tetralux
I'm afraid I'm not seeing the useful part in that fact. xD

1563463626
scientes


1563463634
Akuli
what is the S then

1563463639
scientes
ahh there are three differn't acronyms for it haha

1563463652
scientes
DFA, DFSM, or DFSA

1563463676
nrdmn
oh there's `extern enum`

1563463702
fengb
Tetralux:

1563463863
Tetralux
Ah... One of

1563463894
Tetralux
"Why are these things important?" - "Because they can represent a problem in a computer."

1563463900
scientes
There is a large section in TAoCP on graphs

1563463902
scientes
and DAGs

1563463910
Tetralux
I'm not sure I'd actually

1563463915
companion_cube
DAGs are incredibly useful ♥

1563463921
scientes
Tetralux, systemd is internally a big DAG

1563463937
scientes
so is the instructions in the Zig compiler

1563463943
Tetralux
But if I did I'm not sure that makes the

1563463955
Tetralux
Also I've tried using systemd before.

1563463971
Tetralux
To reset the network manager at startup to work around a faulty drive in Ubuntu.

1563463973
fengb
Any dependency tree is a DAG, whether you want to believe or not

1563463981
companion_cube
git is a DAG ♥

1563463987
scientes
companion_cube, yes, good example

1563463995
scientes
that's why git bisect can seem wierd

1563463999
Tetralux
And it was only yesterday that I discovered --user...

1563463999
companion_cube
also, yeah, most ASTs are

1563464000
fengb
Welll hopefully it's acyclical lol

1563464000
scientes
because its more of a tri-sect

1563464010
Tetralux


1563464017
scientes
Tetralux, --user comes from Tizen

1563464033
Tetralux
"git is a big DAG" -- "good example" -- "that's why bisect can seem weird" <-- That seems like a bad example.

1563464093
scientes
in the worst case bisect will only eliminate 1/3 of commits

1563464098
scientes
because its really a trisect

1563464118
very-mediocre
Tetralux:

1563464156
scientes
oh that is great

1563464161
fengb
scientes: but what about the 8 way merges? :troll:

1563464200
scientes
<Tetralux> It looks like a linked list where each element can point at multiple other elements and not just one or two.

1563464207
scientes
actually you only need one or two

1563464219
scientes
cause you can always just use a bunch of two-way branches to make higher-level branches

1563464237
scientes
that's how git does it

1563464259
Tetralux
True. But I assume there's a reason why you'd have those branches. Otherwise you'd just use a linked or double-linked list and be done with it.

1563464265
scientes
its not a queue because of the two-way branches (which have three arms)

1563464289
Tetralux
It is. But it's elements have branches.

1563464302
very-mediocre
most things in the real world are non-linear

1563464307
Tetralux
And it's elems can have more than two.

1563464314
scientes
its also not a tree, because it can merge back on itsself

1563464343
very-mediocre
+ you can have weights on each edge (arrow between nodes)

1563464348
Tetralux
By merge back, I assume you mean, can go down several branches and then point back up somewhere else.

1563464368
Tetralux
.. Which is still a queue with branching elements.

1563464371
scientes
yes, they can converge

1563464385
scientes
well yeah, like a queue it is O(n) time

1563464412
very-mediocre
Tetralux: Picture a set of positions with different distances, and you have to find the shortest path

1563464426
scientes
very-mediocre, that complication is not necessary to get what a DAG is

1563464437
very-mediocre
I'm trying to make it less theoretical

1563464440
scientes
(and I myself have not dealt with it yet)

1563464445
very-mediocre
you can't model that with a queue

1563464447
scientes
yeah but this

1563464450
scientes
explained it well

1563464457
scientes
one thing has to finish before another

1563464469
scientes
dependancies are naturally DAGs (until you have recycling)

1563464992
dimenus
are defer statements executed in decl order or like you're popping a stack?

1563465048
scientes
dimenus, stack

1563465053
scientes
/ If multiple defer statements are specified, they will be executed in

1563465053
scientes
/ the reverse order they were run.

1563465069
dimenus
thanks

1563468374
Tetralux
very-mediocre, scientes: I daresay the structure is useful under certain circumstances, but in my experience, fancy names like DAG only seem to get in the way of what's actually going on.

1563468389
scientes
its not that fancy of a name

1563468395
scientes
it say exactly what it is

1563468414
Tetralux
Try describing it with concrete terms.

1563468419
scientes
yeah

1563468421
scientes
directed

1563468423
scientes
acyclic

1563468424
scientes
graph

1563468430
scientes
three concrete terms

1563468452
Tetralux
I meant structure kinds.

1563468461
Tetralux
Like LinkedList, Array etc.

1563468473
scientes
but that is irrelevent

1563468506
Tetralux
You're not seeing my point xD

1563468511
scientes
i am

1563468517
scientes
and i am saying it isn't a point at all

1563468526
scientes
this is math

1563468540
Tetralux


1563468558
scientes
I think the pictures on wikipedia are the best

1563468572
scientes
applying a flat RAM model totally misses the point

1563468630
Tetralux
Allow me to illustrate my point like this.

1563468659
scientes
but there are bazillions of implmentations

1563468660
Tetralux
Nothing about anything that's been said allows me to understand

1563468671
Tetralux
The closest we've got is a "shortest-distance" algorithm.

1563468672
scientes
except we mentioned systemd, zig, git

1563468674
scientes
et cetera

1563468681
scientes
and a lemonade stand

1563468682
Tetralux
None of which actually tells me anything.

1563468687
Tetralux
"Trees use wood."

1563468691
scientes
well yeah you won't get it until you use it

1563468694
scientes
as with any math

1563468699
scientes
but that is not our fault

1563468701
Tetralux
Any that's exactly my point.

1563468728
Tetralux
I don't care much for things that are so abstract that it is impossible for me to understand them without some kind of deep explanation.

1563468739
scientes
but its not that complicated

1563468743
mq32
Tetralux, "LinkedList" is also an abstract concept

1563468752
mq32
the same as Directed Acyclic Graph

1563468752
scientes
just happens to be one you already know

1563468773
scientes
and all lists are graphs

1563468777
scientes
graphs are a superset of lists

1563468787
mq32
A (singly) linked list is actually a special kind of DAG

1563468788
Tetralux
mq32: You mean there's other kinds of linkedlist besides struct { next: ?Node, value: T }?

1563468796
mq32
Tetralux, sure

1563468798
Tetralux
(.. and of course the double variant.)

1563468803
mq32
one with index into an array for example

1563468804
Tetralux
Which

1563468810
scientes
or even a flat array

1563468811
Tetralux
Have a fundamentally different structure.

1563468816
mq32
every node contains an index into an array to the next entry

1563468819
scientes
is a version of a linked list

1563468820
Tetralux
(That last one is the key point.)

1563468835
Tetralux
The word "version" there is important.

1563468837
mq32
linked list ist just "every node either points to the next node or none"

1563468839
mq32
that's all

1563468845
Tetralux
Every programmer knows what a LinkedList is.

1563468849
mq32
nah

1563468851
Tetralux
There are variants, sure.

1563468857
mq32
HOW the pointing is done is completly irellevant to the term "linked list"

1563468895
Tetralux
Sure - but a pointer is how it's almost always done without getting really specialized.

1563468915
mq32
have you ever worked on platforms where you can't store pointers in objects? :P

1563468989
mq32
brb, then i'll explain my point further

1563469006
scientes
Tetralux, in LLVM there are linked lists that are just flat arrays

1563469017
scientes
which confused the hell out of me

1563469038
Tetralux
I'm not sure what exactly you mean by flat xD

1563469046
Tetralux
The elements are contiguous?

1563469048
scientes
yes

1563469055
Tetralux
The nodes are? Or the actual values are?

1563469059
scientes
both

1563469065
scientes
oh wait, nodes

1563469070
Tetralux
I was gonna say.

1563469079
Tetralux
Yeah - that's fairly standard.

1563469086
scientes
except not treating it as a linked-list

1563469088
Tetralux
It's a way to make it not break the cache line.

1563469111
Tetralux
The LinkedList doesn't treat it's nodes as a linkedList? xD

1563469152
scientes
its because C++

1563469162
scientes
in C++ you can do addition and it can write to global memory

1563469181
Tetralux
But yes - the short form argument is just: I suggest you refrain from describing structures using mathmatical terms if it is intended to be used to program a computer by a programmer.

1563469195
scientes
except in C++ anything can mean anything

1563469201
scientes
so you really can't explain anything any other way

1563469214
Tetralux
That's... open-ended xD

1563469234
scientes
i mean i could overload the addition operator so 2+2 yields 5

1563469242
Tetralux
Indeed you could.

1563469247
scientes
(not my use of math term "yield" because = can also be overloaded)

1563469253
scientes
or rather ==

1563469278
Tetralux
I should note that you do want op-overloading for vector types.

1563469301
scientes
no, llvm already implements those operators for vector types

1563469332
Tetralux
I'm not sure I understand how that helps me the programmer.

1563469336
Tetralux
I'm not using LLVM.

1563469364
scientes
vector types are going to work similarly to the way SIMD hardware works

1563469368
Tetralux
If I have to do vector math and cannot overload +, -, *, /, etc, then I'm prob not gonna use your language to do it in.

1563469371
Tetralux
And yes

1563469380
gonz_
I think we ought to deprecate focusing on helping the programmer at write-time.

1563469388
scientes
^^^

1563469391
scientes
reading is more important

1563469395
scientes
and maintinance

1563469398
Tetralux
I think that I want to not hate programming. :)

1563469404
Tetralux
If I want that, I have C++ xD

1563469413
Tetralux
But I get your point.

1563469415
scientes
zig will NEVER support operator overloading

1563469429
scientes
the only function call is the call operator

1563469439
Tetralux
If I cannot multiply two matrices together then I prob won't make a game in Zig.

1563469455
Tetralux
At least .mul is

1563469459
scientes
you just do matrix.mul(other_matric)

1563469461
fengb
I hate all languages. I just hate some less than others

1563469466
gonz_
You will always be able to multiply them together.

1563469473
Tetralux
And the inplace version?

1563469478
scientes
and LLVM is considering built-in complex number support

1563469479
andrewrk
I'd probably word it differently than scientes, but I think it's fair to say that operator overloading is not planned and that is unlikely to change

1563469505
Tetralux
andrewrk, I'm not sure I'd  mind that honestly.

1563469517
Tetralux
What I mind is that matrix usage of basic operations isn't a chore.

1563469543
andrewrk
here's how I multiply matrices together in the tetris example:

1563469555
scientes
yeah but operator overloading isn't the way to do that

1563469560
dimenus
is there any way to require that a type passed into a func is a slice (at comptime obviously)?

1563469562
scientes
because you will never be able to optimize it

1563469576
andrewrk
dimenus, you mean other than by making the parameter type a slice?

1563469579
Tetralux
scientes: It does allow you to have *= and * pretty easily though.

1563469587
scientes
when llvm adds complex numbers, zig might also add complex number types

1563469608
andrewrk
dimenus, you could follow the pattern in std.mem and accept the element type as a parameter, and then the next parameter can be []T

1563469623
scientes
andrewrk, yeah that's what i'm doing with vectors

1563469625
mq32
re

1563469634
Tetralux
dimenus: Like f(comptime T: type, s: []T) ...

1563469636
gonz_
If we reach a point where the biggest problem is typing I think that'd be a success. For any long standing (or just moderately long-lived) code the issue won't be typing at the end of the day.

1563469654
dimenus
eg in Odin I could do $T/[]$E

1563469673
scientes
oh, so I don't really want vectors to implicitely widen their elements

1563469677
scientes
but i do want to have a cast for that

1563469680
Tetralux
(.. Which means: E is the eltype, T is the slicetype.)

1563469681
scientes
what do you think andrewrk ?

1563469686
gonz_
I do think there's a cross section where typing more leads to more errors, i.e. copy-paste errors, though.

1563469703
scientes
because zext/sext on vectors is not as trivial as with scalars

1563469703
fengb
I do agree that sometimes having operator overloading can make code more readable, especially when it maps closer to math

1563469710
Tetralux
(.. It means 'T is a slice of E')

1563469727
andrewrk
scientes, I'm not sure yet and I have a lot of stuff I'm already thinking about, not much room in my brain for SIMD for a couple hours

1563469727
fengb
But it's complicated and seemingly abused in every language that supports it

1563469733
Tetralux
(.. 'T is a slice of E elems)

1563469737
scientes
oh fair enough

1563469757
andrewrk
scientes, I do hope to get SIMD usable by 0.5.0 though

1563469761
Tetralux
fengb: I think for math types, it makes sense.

1563469764
scientes
andrewrk, so do I

1563469770
Tetralux
I'm not sure you want it for anything else.

1563469785
gonz_
What are your opinions on using ` to on-demand infix a function? I think it's pretty intrusive in terms of syntax but it's arguably better than operator overloading for clarity.

1563469799
fengb
Tetralux: the problem then becomes how do you limit it to math types

1563469806
mikdusan
in stage1 ir.cpp `static void copy_const_val(ConstExprValue *dest, ConstExprValue *src, bool same_global_refs);` does same_global_refs typically have to be false when `dest` is comptime?

1563469816
Tetralux
fengb: I mean the obvious is have them built in.. If you wanted to limit it.

1563469845
Tetralux
Vec2(T) Vec3(T)

1563469848
Tetralux
Vec4(T)

1563469851
Tetralux
Vec(T, n)

1563469868
Tetralux
const Vec3 = Vec(f64, 3)

1563469873
Tetralux
etc etc.

1563469882
Tetralux
Those are just off the top of my head.

1563469891
andrewrk
mikdusan, same_global_refs is a hack, the answer to how it works is hacky logic everywhere. we need some kind of copy-on-write system for values in zig. that's a big project that will fix a whole class of bugs

1563469992
mq32
Tetralux, we already have those vector types

1563469992
Tetralux
dimenus: You could do f(comptime S: type, s: S) and then use @typeInfo to ensure it's a slice, and use .Slice.child to get E, IIRC.

1563470003
mq32
@Vector(3, f64)

1563470003
andrewrk
mikdusan, see for example the TODO comment in ir_analyze_store_ptr

1563470010
Tetralux
mq32: This is good.

1563470019
Tetralux
However they are arrays without op overloading :)

1563470037
andrewrk
mikdusan, apologies for this mess - this is one of those things where everything made sense at first, and then the language changed and the implementation couldn't keep up cleanly

1563470048
dimenus
Tetralux: thanks, I spose that does cover my needs

1563470078
mq32
Tetralux, you

1563470104
andrewrk
dimenus, did you see my suggestion? it does not involve @typeInfo

1563470142
Tetralux
mq32: What does "using SIMD types" mean.

1563470167
Tetralux
That's just used by LLVM to implement @Vector, and therefore isn't something I have to use directly, right?

1563470170
fengb
gonz_: I think it'd be interesting to have arbitrary infix functions. But Elm did remove it too...

1563470170
dimenus
andrewrk: yeah, that's that I'm going to go with for now

1563470174
dimenus
thanks as well

1563470176
mq32
Tetralux:

1563470206
gonz_
fengb: If people crave some way to infix stuff I think it's a more obvious candidate because at least it indicates a function call and which one is made, since there is a name.

1563470238
gonz_
You

1563470254
fengb
Yeah, I'm more curious why Elm removed it since they did have the same `backtick` syntax you're mentioning

1563470255
Tetralux
andrewrk: Can you get the eltype of a slice without typeinfo?

1563470268
Tetralux
Or no

1563470270
Tetralux
wrong question

1563470284
Tetralux
the std.mem approach gives you 'E' and not 'T'.

1563470284
mq32
Tetralux: better example:

1563470290
fengb
I think maybe because Elm pipeline `|> function` is almost as good

1563470304
Tetralux
whereas the Odin version gives both.

1563470318
gonz_
fengb: It's anyone's guess. I don't agree with most of the choices made in Elm. That's in the context of functional abstraction, though.

1563470351
fengb
I just want to visit why they do thing. I hate that Elm is notorious for "because BDFL says so" reasoning because it doesn't really explain why

1563470356
gonz_
I don't know in practice if people have issues grokking the backtick infix model.

1563470389
gonz_
Most of the design choices have been made with the rationale that they're hard features for people to use.

1563470404
gonz_
That's the argument for not having user-defined type classes, for example.

1563470419
gonz_
Even though they let you design APIs to be safer and easier to use.

1563470430
fengb
But they do have operator overloading. It's just "blessed" to specific repos :shrug:

1563470436
gonz_
Mhm

1563470442
Tetralux
mq32: Okay, so @Vector types

1563470443
Tetralux
That's good.

1563470452
mq32
not overloading, but default operators

1563470461
mq32
or better: "builtin operators"

1563470476
Tetralux
If the syntax is the same... :)

1563470551
gonz_


1563470566
mq32
andrewrk, are you going to stream later?

1563470576
andrewrk
yes

1563470577
gonz_
And I think it also illustrates how simple type classes really are when you observe that they're just definitions of constraints for generics.

1563470743
gonz_


1563470746
mq32
andrewrk, cool. do you have an estimate when you start the stream? i hope i can watch it live without having to download the stream again :)

1563470766
andrewrk
17:00 EDT. that's in 3.5 hours

1563470809
mq32
thanks :) that's gonna be a short night then :D

1563470897
dimenus
andrewrk's suggestion is close enough to what I need, it just seems like a logical extension to able to verify type kinds at the callsite

1563470925
dimenus
maybe not beceause Zig's type system is more complex than Odin's (or it seems that way from this layman's perspective)

1563470969
omglasers2
is it ok to stay on master branch or better on 4.0 ? I've run into 2 compiler bugs on master and I'm wondering if 4.0 is more stable

1563470995
andrewrk
fengb, for what it's worth, it is my goal for all the major proposals, whether accepted or rejected, to have documented reasoning on them

1563471078
andrewrk
dimenus, it's the other way around. zig's type system is simple: all or nothing. to do something in between starts to move towards traits and all that stuff

1563471189
gonz_
It's amazing how much you can get out of a few very simple parts in zig with regards to types.

1563471259
mq32
gonz_: I'm always impressed how much you can get with a small, but well-thought system

1563471264
mq32
Lua does the same thing for me

1563471274
gonz_
Smalltalk is also a good example

1563471282
gonz_
A few very simple rules and off you go

1563471306
mq32
you can just create any kind of DSL/Markup Format for your special needs even without touch metatables/obscure features

1563471416
mq32
and the same thing is for Zig: you can just build a lot of higher-level features with the type system that is present. and it's clear what you are doing all the time :)

1563471420
gonz_
Haskell98 is essentially like that, but sadly it suffered the same fate as C++. Scheme would be an obvious candidate too, but people who don't like macros probably wouldn't agree so much.

1563471562
mq32
it always depends on the spirit of the language

1563471588
mq32
if macros are a fundamental part (and for scheme i think this is true) they should be used

1563471629
gonz_
They are, yes. There's a pretty small core in a Scheme, and the rest is essentially macros on top of that.

1563471659
gonz_
The main idea to me is that you have a small set of core concepts and the language falls out of those.

1563471718
mq32
yeah i think scheme and Lua are good examples for this

1563471759
gonz_
My current perception of zig is that explicitness and the removal of arbitrary compile time restriction are key concepts that most things fall out of.

1563471768
mq32
yep, true dat

1563471784
mq32
you can create a lot of awesome stuff with the things already there

1563471878
mikdusan
andrewrk: have a potential fix for #2916 ; can you eyeball before I make into PR? here's patch and writeup:

1563471881
gonz_
Also easily doing the correct thing with errors, obviously

1563471916
andrewrk
mikdusan, looking

1563471921
gonz_
Is anyone on dev.to ? I want to start a #zig tag there.

1563471942
mikdusan
tl;dr all it does is check if comptime, and then copy_const_val with false after first iteration

1563471945
gonz_
The editor currently doesn't support code blocks with zig syntax highlighting so I'll probably have to figure out how to get it in there.

1563472002
gonz_
Or the markup, rather

1563472056
gonz_
Which makes me wonder whether or not you'd have to patch in zig highlighting in whichever library they're using.

1563472199
andrewrk
mikdusan, does it fix the problem if you always pass `false` for same_global_refs?

1563472207
mikdusan
yes

1563472232
andrewrk
I think that's a safe change to make

1563472253
mikdusan
clarification: as-is, or change to always false for comptime?

1563472315
andrewrk
I think if you take master branch and change the `true` to `false` there, and that fixes the problem then I think that's the best bet

1563472355
mikdusan
oh. just the 1-liner. ok. i'll run a quick build test and pr.

1563472397
gonz_
andrewrk: What did you do to get syntax highlighting on GitHub?

1563472409
gonz_
Anything that could be piggybacked on for other platforms?

1563472429
andrewrk
the platform has to perceive that zig is popular enough

1563472496
gonz_
I've sent an e-mail to dev.to asking what would need to be done but it was mostly a technical question. But you're saying there's nothing to really grab here in terms of already existing code?

1563472533
gonz_
If a #zig tag is to be started it'll need syntax highlighting.

1563472952
donpdonp
std.heap.LoggingAllocator.init(some_allocator, outStream) how does one specity stdout for outStream?

1563473041
donpdonp
i saw something close from std.io.File, &stderr_file.outStream(), but endup with " error: expected type '*std.io.OutStream(anyerror)', found '*std.fs.file.OutStream'"

1563473321
gonz_
Would `const standard_out_handle = try io.getStdOut();` work for you?

1563473352
lunamn
iirc don't you need to get the proper stream by doing outStream().stream?

1563473364
gonz_
`@typeOf(standard_out_handle)` == `std.fs.file.File`

1563473596
donpdonp
lunamn: std.heap.LoggingAllocator.init(callocator, &stderr_file.outStream().stream) => error: expected type '*std.io.OutStream(anyerror)', found '*std.io.OutStream(std.os.WriteError) note: pointer type child 'std.io.OutStream(std.os.WriteError)' cannot cast into pointer type child 'std.io.OutStream(anyerror)'

1563473601
donpdonp
lunamn: thats closer :)

1563473703
lunamn
yeah I don't know what you could do from there, that should be already working

1563473752
donpdonp
here i was all excited about stumbling into LoggingAllocator :)

1563473853
andrewrk
daurnimator, ^

1563473919
fengb
He's probably still asleep :p

1563474380
donpdonp
LoggingAllocator just became WarningAllocator :)

1563474454
donpdonp
I naively assumed the output of init was a drop-in replacement for an allocator. const allocator = &logAlloc.init(c_allocator);

1563474466
donpdonp
but later in the code i get error: expected type '*std.mem.Allocator', found '*logging_allocator.WarningAllocator'

1563474539
donpdonp
which is a huge gap in my understanding of how a zig strcut would be a subclass/inherit/compatible_with an existing struct

1563474549
donpdonp
strcut/struct

1563474969
lunamn
donpdonp: get the std.mem.Allocator pointer by doing &logAlloc.init(c_allocator).allocator, the pointer is inside

1563475071
donpdonp
lunamn: ah i see.

1563475085
donpdonp
'allocation of 8 success! free of 8 bytes success!' \o/

1563475086
fengb
donpdonp: Zig doesn't have subclassing/inheritance/embedding yet. We have C style function pointers

1563475095
fengb


1563475618
fengb
... I just realized what ctor and dtor are

1563475827
bwb_
andrewrk: someone must have written a kernel in Zig already, right?

1563475841
andrewrk
bwb_, several

1563475844
bwb_
haa

1563475869
bwb_
any of them kinda nifty?

1563475879
andrewrk


1563475894
andrewrk


1563475929
bwb_
ok, so nothing particularly funky yet

1563475930
bwb_
all super cool though!

1563475949
bwb_
and doesn't look like any custom bootloaders yet either?

1563475968
andrewrk
clashos is not far along but it is its own bootloader

1563476323
fengb
How do you pronounce it? I'm leaning towards two-syllable hel-los

1563477053
dimenus
man, vulkan with zig is going much better than expected

1563477073
dimenus
error return traces + lunarg validation layer catches a lot of things

1563477107
dimenus
the only real pain is bitflags

1563477425
Tetralux
What's lunarg?

1563477438
Tetralux
And by bitflags, do you mean enums that can be or'd together?

1563477585
halosghost
I don't believe I've heard the term bitflag before

1563477605
halosghost
bitfields? sure; bitmasks? definitely; bitbuffers? bien sur

1563477607
halosghost
bitflags?

1563477614
Tetralux
a.k.a enumflags, if I'm understanding correctly.

1563477649
Tetralux
bitflags, since each value takes exactly one bit.

1563477661
Tetralux
(.. I would imagine is the reasoning.)

1563477889
dimenus
yeah enumflags

1563477905
dimenus


1563478019
halosghost
mmk

1563478058
bheads
enum flags suck

1563478068
bheads
since they can have more then 1 bit set

1563478485
fengb
I keep reading about "manual memory management is hard" but there's a big divide between C and Rust

1563478538
fengb
I wonder if there's any breakdown of the levels of hardness. Zig does a pretty good job of fixing most of the issues with out-of-bounds checks and what not, and is that good enough?

1563478559
mq32
fengb, the hard thing with manual memory management is two things:

1563478564
mq32
concurrency and ownership

1563478566
companion_cube
but does it do something for double-free/memleak?

1563478581
mq32
if you understand both well, memory management gets a lot easier most of the time

1563478590
fengb
companion_cube: not yet, but having a debug allocator can find a lot of these issues

1563478614
companion_cube
sure, sure

1563478617
fengb
mq32: I mean more of buffer overflow, etc. I know Zig doesn't resolve all of these things, but it's much better than C

1563478621
companion_cube
at runtime though, and only if exercized

1563478626
fengb
And is that "good enough"

1563478634
gonz_
I'm not sure the premise is all that sound in reality. Most projects would/will have a very simple allocation strategy in practice.

1563478751
fengb
gonz_: I agree. I'm curious if we've had a breakdown on the classes of manual memory problems, rather than lumping them all together

1563478775
dimenus
bheads: why does that make them suck?

1563478792
gonz_
The failure modes associated with manual memory management and using a garbage collector are different, but I think you can end up spending way more effort trying to cajole the language into not allocating unreasonably than you would managing memory yourself.

1563478838
fengb
I think gingerbill? once mentioned that there's like 1% of allocations he actually wants support with. I don't agree with his numbers, but fighting the borrow checker is something I dread in Rust

1563478848
dimenus
by encouraging / requiring passing an allocator - zig gives the programmer a bunch of options AND makes determining if a function allocates much easier

1563478901
fengb
Right. For instance, HTTP request allocation => arena lifetime

1563478966
mq32
i'm not accustomed to using a specific allocator so i'm still a bit confused on how that will work with multiple parallel allocators in action

1563478977
dimenus
errdefer is a simple concept that makes manual memory management way less painful imo

1563479010
dimenus
i felt like I was on gingerBill's side when it came to errors until I spent the last two weeks with Zig

1563479012
dimenus
already a convert

1563479017
gonz_
Agreed. I think the easy to use concepts + the front and center allocators make this issue so much clearer in general.

1563479058
gonz_
And since it's all there, explicitly, you encourage users to experiment and think about their allocation strategies, like you said.

1563479058
fengb
I should watch more of gingerBill's videos. My problem is there's very little written and I sorta think his videos are a bit slow >_>

1563479119
mq32
fengb, 125% speed does the work on youtube

1563479120
fengb
Anyway... I keep hearing about Rust. But I feel like getting that strict might be overkill for a lot of things

1563479136
mq32
fengb, that was my experience with rust at last

1563479143
fengb
wrt Microsoft considering Rust

1563479169
mq32
"oh, you want to do THAT? well, that is unsafe. i can't let you do that, dave (unless you use unsafe)"

1563479171
fengb
70% of their errors are manual memory based. But how much of it is solved by proper bounds checking vs lifetime management?

1563479214
fengb
And how much of lifetime management is just that we've only used malloc/free for 40 years instead of having a better paradigm

1563479220
companion_cube
I guess the idea is that the borrow checker has your back even in teams, where ownership in large codebases might not be obvious

1563479244
companion_cube
(also it's not just borrow check: move semantics is a big feature too)

1563479260
Sahnvour
where it makes sense, lifetime management is still superior by being at compile time

1563479423
gonz_
I think there's room on the spectrum. D has tried to add some interesting stuff in this regard with the `@live` annotation.

1563479428
fengb
Is it better to have the language know all of it, like Rust? Or is it better to have a language that lets you manage it better, like Zig or Jai

1563479479
Tetralux
My inclination is that the programmer should be given the tools (that are really powerful and really good, crucially) and let them do what they need to do the solve the problem they have in a simple understandable maintainable way.

1563479490
fengb
But... I was really questioning whether we know that lifetime semantics is the bigger driver of these bugs

1563479496
Tetralux
.. which also does not occur any more friction than absolutely necessary.

1563479507
Tetralux
Lifetimes drove me from Rust.

1563479514
fengb
And lumping everything into "C manual memory management sucks" doesn't really help

1563479545
fengb
Since C is kinda broken with all kinds of things

1563479546
gonz_
fengb: I think I lean more towards easier and more control, at least. Admittedly, though, I've only ever had experience with "OMG everything is broken" and zero control over anything.

1563479635
Tetralux
What I like about the power of Jai's metaprogramming,

1563479649
fengb
What I like about Zig is that it exists :P

1563479650
Tetralux
Unlike SFNIANE, or however you pronounce it in C++

1563479797
mq32
SFINAE = Substitution FAilure is not an error

1563479801
mq32
evil concept

1563479848
gonz_
What does that mean?

1563479872
mq32
uff

1563479904
mq32
if a template instatiation would result in a semantic error (like field 'x' not found on type 'T')

1563479911
mq32
the compiler silently ignores this template

1563479914
mq32
and tries other stuff

1563480014
gonz_
Hmm

1563480105
mq32


1563480160
dimenus
zig doesn't need move semantics, we don't have constructors

1563481613
andrewrk
the tech director of a company I once worked at sent me a code review where he used SFINAE, and I said "can you please just go refactor the rest of the codebase so that this is not necessary" and he said "no" and merged the code

1563481645
andrewrk
if it exists in the language, it will be abused

1563481739
dimenus
is it possible to create a slice from a ptr?

1563481758
dimenus
i'm trying to make a dumb hack because we can't print out @Vector types yet

1563481823
andrewrk
dimenus, slice the pointer

1563482066
dimenus
that's what i was struggling with

1563482085
dimenus
@ptrCast([*]f32, &self._data[0])[0..15];

1563482116
Sahnvour
andrewrk: I'd argue this is pragmatic :-)

1563482166
Sahnvour
(tongue in cheek because I don't like this cult over pragmatism, but I reckon sfinae

1563482258
andrewrk
dimenus, that looks good to me

1563482290
andrewrk
the @ptrCast asks the question, why isn't self._data the correct type?

1563482316
andrewrk
which hopefully has a good answer

1563482317
dimenus
because for operations I want the vector type

1563482325
dimenus
but we can't print out vectors

1563482337
dimenus
basically i'm just trying to print out the contents of a vector

1563482349
Tetralux
A Vector of f32?

1563482362
dimenus
yep

1563482384
Tetralux
If so, presumably &vec[0] should be *f32 -- which you can't slice, hence the cast?

1563482385
andrewrk
I think a pointer to a vector should let you slice it

1563482414
andrewrk
a pointer to a vector should implicitly cast to a slice

1563482422
dimenus
but i dont need a slice of vectors

1563482424
dimenus
i can't print that

1563482428
dimenus
i need a slice of f32s

1563482455
andrewrk
I'm saying *@Vector(f32, 10) should implicitly cast to []f32

1563482467
dimenus
ah nice

1563482490
Tetralux
It's interesting you know - I'd never come across the idea that a ptr and a slice are kinda the same tihng.

1563482512
Tetralux
I'd always just considered a slice a simple struct with two members that have builtin special syntax for creating and using them.

1563482515
andrewrk
mq32, I'm going to delay the stream by 1 hour - I need to get lunch

1563482529
mq32
hmm

1563482544
mq32
then watching the VOD it is

1563482545
mq32
:(

1563482559
mq32
have to get up in 7 hours again already

1563482570
tgschultz
slice is a fat pointer, a pointer with additional data about what it points to. it's an old concept.

1563482585
Tetralux
But does kinda make sense that *T is the equiv of []T, since it's just "points to one thing" and "points to multiple tihngs"

1563482598
Tetralux
I always just thought of a slice as nothing more than a view into an array.

1563482616
andrewrk
sorry mq32 got busy today and haven't eaten yet

1563482617
tgschultz
which it is, the same way a normal pointer is a view of a single item

1563482620
Tetralux
Just a ptr to memory into an array, and how many elems to consider inside it.

1563482651
mq32
andrewrk, no problem. eating > streaming

1563482674
Tetralux
I do consider it more a struct than a primitive though.

1563482687
Tetralux
I can see the relation though.

1563482708
tgschultz
both are true

1563482708
Tetralux
Maybe that's me and my inclined fondness of being concrete xD

1563482803
Tetralux
tgschultz: I'd be inclined to say a slice is not a primitive, because it's a struct. But an int is a primitive because it's a unit of data that the machine understands.

1563482812
Tetralux
"The machine knows nothing of your structs!" xP

1563482850
Tetralux
But in Zig, and Go, and Odin, slices are builtin to the language and have a primitive-like standing - but I'd not say they're primitive.

1563482873
Sahnvour
they can be primitive to the language but not to the machine

1563482881
Tetralux
Indeed.

1563482893
Tetralux
That's the differentiation I am stating :p

1563482903
mq32
Tetralux, actually the machine (x86_64) only understands like 8 of the 131072 integer types Zig allows

1563482924
Tetralux
mq32: No, no. I'm equally pendantic xD

1563482931
Tetralux
I'd agree with you.

1563482933
mq32
so we can say: integers are structs

1563482937
mq32
and thus: integers are not primitives

1563482937
mq32
!

1563482955
Tetralux
Well no. Ints up to 64-bit is primitive.

1563482973
mq32
only 8,16,32 and 64

1563482976
Tetralux
Indeed.

1563482976
mq32
4 bit is not primitive

1563482981
Tetralux
No it isn't.

1563482997
Tetralux
And niether is 128, although it could be if you always use SIMD perhaps.

1563483027
mq32
but i think it is important only to look at language level primitives

1563483041
mq32
because otherwise you declare stuff primitive always regarding to a platform

1563483048
Tetralux
I think it's important to keep perspective on the fact that the machine cares not for things that aren't primitive.

1563483053
halosghost
I don't know what kind of machine you're on, but I have a 36-bit word-size

1563483063
halosghost
so, i36 is a primitive for me

1563483072
mq32
halosghost, i can offer 19 bit BCD words

1563483081
mq32
or 12 bit architectures

1563483093
mq32
oh, and the really obscure 55 bit one

1563483105
Tetralux
Allow me to point out now that when I said 8, 16, 32, 64 are prim, I was assuming 64-bit xD

1563483115
Tetralux
And 8-bit bytes.

1563483122
Tetralux
And 16-bit words

1563483130
Tetralux
And 32-bit dwords

1563483130
halosghost
we're all adults here

1563483134
halosghost
we can just say octets

1563483134
Tetralux
And 64-bit qwords xD

1563483139
Tetralux


1563483167
mq32
Tetralux: Assuming the original IBM definition of byte, the machine i made my Bachelor thesis about would have 55 bit "bytes"

1563483189
Tetralux
It does make me wonder what exact reason they had to decide on that.

1563483192
mq32
i think x86 has destroyed a lot of wording out there

1563483202
mq32
Tetralux, physics, mostly :D

1563483214
Tetralux
Good reason. :)

1563483232
Tetralux
Although that is a LOT more that 8.

1563483235
mq32
it had to be a multiple of 5 and 55 is luckily made of 5 and 11, which are both prime numbers

1563483254
Tetralux
How fast was it though? ;)

1563483272
Tetralux
Speaking of which

1563483276
mq32
1µs bit time

1563483294
Tetralux
It's worth noting that algorithms that read byte-by-byte are slower (in my experience) than those that operate on machine ints.

1563483302
mq32
yeah

1563483308
mq32
fastest memory access is bus width

1563483329
mq32
*aligned bus width

1563483330
Tetralux
.. Which means that many algorithms could be made faster by understanding that and----keeping perspective on the machine underneath ;)

1563483335
mq32
which makes memcpy implementations kinda harder

1563483342
Tetralux
I mean...

1563483360
Tetralux
Is it really that hard to just copy as many as possible using usize and then the last one in bytes?

1563483365
Tetralux
Or something like that.

1563483384
companion_cube
you'd want to use simd anyway, right? multiple words at once

1563483387
Sahnvour
that's what every reasonable memcpy implementation does

1563483390
mq32
neat thing in zig is: we can query the target machine in code and switch on that, so we can implement target specific code

1563483396
mq32
what Sahnvour says

1563483420
Tetralux
Oh yeah - will there be a way to use SIMD without using @Vector?

1563483424
mq32
or even better: use DMA controllers for memcpy and memset

1563483440
Tetralux
mq32: What are those?

1563483445
mq32
you mean by intrinsics?

1563483459
mq32
on embedded hardware (and also on PC) you have "direct memory access" controllers

1563483466
Sahnvour
Tetralux: llvm should auto vectorize stuff, but otherwise I don't know

1563483466
mq32
for example on an LPC1786 i can say:

1563483481
mq32
"please hardware, copy 120 bytes from here to there and increment both source and destination pointer"

1563483488
mq32
and that just happens while you do other stuff

1563483497
Tetralux
I mean, for instance, "I want to multiply these two 64-bit words by these two other 64-bit words." - where the four words could be contiguous elems in an array, as an example.

1563483501
mq32
so you can memcpy while still working in parallel

1563483509
Tetralux
And I want to ensure SIMD is used.

1563483518
Tetralux
(.. Note 'ensure'.)

1563483536
Tetralux
mq32: Seems legit :)

1563483576
mq32
which is really cool

1563483577
Tetralux
Indeed - I've been casually thinking about algorithms that could be rewritten specifically so that they could take advantage of things like SIMD and be substantially faster.

1563483584
Tetralux
Things like DEFLATE, for instance.

1563483587
companion_cube
mq32: does it also properly update the CPU cache?

1563483591
mq32
yes

1563483604
companion_cube
that seems useful indeed

1563483607
mq32
you allocate some buffer, put a string in there, store the length and then tell your hardware:" please put this stuff into the serial port register and send it"

1563483618
mq32
and then you just don't care anymore

1563483621
mq32
that string gets sent

1563483662
Tetralux
std.mem.simdMul(src[0..1], dst[0..1]), for src and dst being of type []usize.

1563483670
Sahnvour
I thought DMA typically bypassed the cpu caches

1563483683
mq32
Sahnvour, depends on the hardware you use

1563483692
mq32
the hardware i'm talking about does not have caches (cortex-m3)

1563483716
Tetralux
Wait - does the DMA bypass the memory latency delay?

1563483718
Tetralux
I assume not.

1563483733
mq32
depends

1563483748
Tetralux
I mean - I guess the whole point would be to make it faster than doing the whole thing manually.

1563483752
mq32
SOCs are weird and have strange architectures

1563483762
mq32
Tetralux, the most important point on DMA is:

1563483767
mq32
it copies stuff while the CPU works

1563483776
mq32
so CPU is not fetching memory: the DMA is copying your data

1563483800
Tetralux
Ah, so it's like copying the data in the registers but doesn't cause the thread to wait on it while it's doing it?

1563483804
mq32
depending on what kind of DMA you use it can even have priority over the CPU on the memory bus

1563483814
mq32
what thread? :D

1563483816
companion_cube
sounds pretty unsafe though

1563483822
companion_cube
another source of race conditions?

1563483825
Tetralux
mq32: The one that exected the instr.

1563483845
Tetralux
.. Assuming that's how you activate it.

1563483846
mq32
if you implement multithreading, yes :D

1563483856
mq32
and no, you just write stuff into registers

1563483857
Tetralux
Hmm.

1563483868
mq32
(well, memory mapped I/O)

1563483870
companion_cube
what happens if the CPU tries to access the dest memory while the DMA is modifying it?

1563483882
mq32
depends on WHEN you access it

1563483893
Sahnvour
the kind of DMA mq32 writes about does not ge through the CPU at all, I think, that's handled by some other circuitry

1563483926
Tetralux
Wait - do you use the DMA by using specific DMA instructions?

1563483930
mq32
no

1563483941
mq32
you just write into memory mapped stuff

1563483980
Tetralux
And the write blocks the thread but allows the core to do other stuff in the meantime - is the idea?

1563484036
mq32
no

1563484042
mq32
i make you an example

1563484076
Tetralux


1563484247
mq32


1563484259
mq32
sorry for posting C code

1563484327
mq32
you have 64 32-bit MMIO-registers controlling the DMA operation on real hardware

1563484374
halosghost
instead, be sorry about pastebin.com :)

1563484542
Tetralux
Ahhh

1563484544
Tetralux
I see.

1563484586
Tetralux
I'm curious what exactly you'd put in the while loop while you're waiting.

1563484640
mq32
Tetralux, just don't do that while loop

1563484655
mq32
and just wait as soon as you want to access the data

1563484728
Tetralux
Okay - so conceptually then, it's like you did `async memcpy(src, dst, n)`, and then can 'await' it when you actually do want to access it.

1563484758
mq32
yes

1563484762
Tetralux
.. which presumably you'd more often than not, want to do pretty soon after you wrote it.

1563484775
mq32
nah, actually not :D

1563484791
mq32
most of the time i wait for the transaction to finish before i start the next one

1563484802
mq32
as you use the DMA to access your hardware

1563484806
mq32
good example:

1563484835
mq32
you have a framebuffer that contains pixels for a display unit connected to your SPI

1563484863
mq32
then you just tell the DMA to first transfer the "move cursor to position" command to the display, then to transfer the whole framebuffer

1563484882
mq32
and then your display gets filled while you can focus on other things in the meantime

1563485053
mq32
got to go

1563485570
fengb
Another example: Gameboy doesn't let you write to the display when it's rendering, but the "not rendering" period is only 4560 cycles (0.1ms)

1563485595
fengb
So you write to a spot in RAM during the render cycle, and DMA it over when the display is free

1563485708
Tetralux
I see.

1563485715
Tetralux
I think xD

1563485720
Tetralux
Just about XD

1563485726
dimenus
what is zig's equivalent of sprintf?

1563485734
Tetralux
mq32: Thanks for the effort in explaining it :)

1563485737
fengb
std.fmt

1563485745
Tetralux
std.fmt.allocPrint/bufPrint

1563485747
Tetralux
IIRC.

1563485757
Tetralux
Or rather yes - bufPrint.

1563486584
dimenus
one more question, how do I escape '{' in a format string?

1563486692
Tetralux
Double-up the {

1563486705
Tetralux
warn("{{ The brackets are upon us. }}");

1563486711
dimenus
gives me unused args

1563486716
Tetralux
I'm not actually sure if you need to do it with the closing ones or not.

1563486726
Tetralux
You can't \ them right?

1563486730
dimenus
nope

1563486736
Tetralux
Hmm.

1563486742
Tetralux
I know you can do it because I've done it xD

1563486759
Tetralux
Did you try doubling up both?

1563486837
ltr-
error: expected type '', found 'Setter(f64)'

1563486843
dimenus
yep

1563486852
ltr-
sounds familiar?

1563486870
ltr-
the compiler cant infer the type needed, i think

1563486900
dimenus
ah, in my case it's triple

1563486904
dimenus
eg, {{{0}}}

1563486908
dimenus
prints{value}

1563486920
fengb
lol

1563487365
dimenus
all this to print a matrix

1563487366
dimenus
lol

1563488167
andrewrk
ok gonna start the stream in a couple minutes

1563488939
dimenus
does zig support any intrinsics? eg _mm_set_ss?

1563489344
vegecode
Congratulations on getting into the Github sponsors program. I have been donating $10 for a while, but can't do that with the tiers as they are right now. I could go down to five which would save me money, but I will still give ten if that were possible on Github. Can you do a "Choose Your Own Amount" like on Patreon?

1563489430
hryx
vegecode: word is GitHub will add that ability in a few months

1563489435
hryx
for now, there's no way

1563489450
vegecode
K thanks.

1563490601
scientes
so github sponsors is exclusive?

1563490637
scientes
oh its matching

1563491174
ntgg
the test project I wrote has different behavior with -Drelease-(fast|small) modes release-safe works normal

1563491657
Tetralux
Different?

1563491900
ntgg
All the drawing is broken

1563491913
ntgg
using OpenGL

1563491955
ntgg
on release-small, it draws incorrect stuff, on release-fast it draws nothing

1563493336
andrewrk
ntgg, debug mode works normal too?

1563493489
ntgg
andrewrk: yes

1563493549
andrewrk
that means 1 of 2 things: (1) your code is invoking undefined behavior that zig is (at least currently) unable to provide safety checks for, or (2) you are running into a zig compiler bug

1563493702
ntgg
I have no `unreachable` in my code, what else would cause undefined behavior?

1563493777
Tetralux
Uninitialized variables is the obvious one.

1563493811
hryx


1563493965
andrewrk
ntgg, one thing to try is running your code with valgrind

1563493994
andrewrk
with the release modes this can be enhanced with --enable-valgrind

1563494165
ntgg
all variables initialized to undefined are set to somthing the next line, I'll try the valgrind route

1563494362
ntgg
how do I use --enable-valgrind with a build.zig?

