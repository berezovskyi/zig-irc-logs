1565055915
daurnimator
andrewrk: doh. I must have broken #3005 with one of my extra pushes :( will have another look tonight

1565055922
daurnimator
andrewrk: meanwhile, did you see

1565060844
diltsman
Is there a place where 'usingnamespace' is documented?

1565060952
daurnimator
diltsman: no I don't think so. no one was sure if we wanted to recommend it not not

1565060954
daurnimator
*or not

1565060982
emekankurumeh[m]
daurnimator: have you seen phnt?:

1565060987
daurnimator
my hope it still that we can replace it with

1565061055
emekankurumeh[m]
i thought that's what `usingnamespace` would become

1565061067
emekankurumeh[m]
or

1565061073
daurnimator
emekankurumeh[m]: nope. looks interesting. I mainly refer to

1565061079
diltsman
A couple of days ago, andrewrk told me "make your file my_windows.zig and have it do `usingnamespace std.os.windows;`. then you can augment the std lib with whatever you want"

1565061101
daurnimator
diltsman: yes. for now use `usingnamespace`

1565061112
diltsman
I am trying to figure out how to do that.  Sorry, my only experience with Zig up to this point is writing bare metal with no standard library.

1565061132
daurnimator
diltsman: usingnamespace sort of "imports" the referenced struct into your current one

1565061191
diltsman
my_windows.zig has "usingnamespace std.os.windows;"  The compiler just says "use of undeclared identifier 'std'

1565061207
daurnimator
diltsman: have you imported std first?

1565061254
diltsman
There we go.  I was trying to figure out the @import for that.  Thanks.

1565061745
daurnimator
emekankurumeh[m]: you don't use the raw syscalls on windows

1565061753
daurnimator
so that second link isn't useful

1565061776
daurnimator
emekankurumeh[m]: ntdll is sort of like a vDSO that is already in your address space; it contains syscall wrappers.

1565061805
daurnimator
its only for super super rare situations where there is no ntdll wrapper that you'd need to do a syscall directly

1565061849
emekankurumeh[m]
that second link lists ntdll functions as that is the stable syscqll interface (I think)

1565061880
daurnimator
emekankurumeh[m]: you mean the first link?

1565061890
emekankurumeh[m]
the second one

1565061916
daurnimator
emekankurumeh[m]: the second link is the unstable syscall numbers. e.g. see how this changes across minor windows 10 releases:

1565061977
emekankurumeh[m]
that second is just ntdll function availability by windows version

1565062133
emekankurumeh[m]
hmm, it would seem i didn't look too closely

1565062274
fengb
Is release-small an LLVM thing?

1565062331
daurnimator
fengb: I don't know; but I imagine the 'small' is equivalent to `-Os` and the 'release' is more of an instruction to zig

1565062421
fengb
I’m more concerned about the small thing. I have 3 func calls that are being inlined and adds 200 bytes. Not sure if I should just insert @noInlineCall

1565062426
fengb
Sometimes... I should stop counting bytes :P

1565062569
daurnimator
fengb: could you try an equivalent C program with clang and -Os?

1565062673
daurnimator
also am I crazy or did there used to be a `-Oz` option to C compilers that was "really small"

1565062703
emekankurumeh[m]
but, a windows application that didn't rely on ntdll sounds pretty cool

1565062754
daurnimator
emekankurumeh[m]: not really. only useful to avoid things that hook into ntdll for tracing

1565062776
daurnimator
(and hence only really useful for viruses/malware)

1565062810
daurnimator
ntdll is automatically loaded into

1565062983
daurnimator
huh. looks like gcc removed their documentation of the -Oz option. clang still mention it

1565062992
emekankurumeh[m]
ntdll only it is then

1565063030
daurnimator
emekankurumeh[m]: yep. that's called a "native" app. they're really cool and underutilised

1565063056
emekankurumeh[m]
rust also has a "-Oz" option

1565063085
fengb
wasm-opt also has -Oz

1565063248
daurnimator
fengb: maybe you're looking for the LLVM flag optForMinSize

1565063380
fengb
I kinda want @call now so I can swap between call styles on the release type

1565063381
daurnimator
or maybe not.... that flag seems to have been demoted in ~2016/2017

1565063431
emekankurumeh[m]
possibly relevant:

1565063484
daurnimator
fengb: in any case, I think it would be fair to make a feature request for a -Os vs -Oz type flag

1565063541
fengb
-release-smallest?

1565063606
daurnimator
maybe. throw it in your proposal :

1565063630
fengb
I was actually not sure if it was a Zig thing or LLVM

1565063675
daurnimator
fengb: I think the answer is: both.

1565063724
daurnimator
and alternatively: a zig issue. because zig using LLVM is sort of meant to be an implementation detail

1565067073
curtisf
How should I turn a usize (or some other integer of unknown size) into an array `[_]u8`

1565067173
mikdusan2
std.mem.toBytes

1565067272
curtisf
Thanks! If it were to be, say, a `u15`, what would happen to the three "padding bits" if passed to `toBytes`?

1565067298
daurnimator
curtisf: a bug!

1565067310
emekankurumeh[m]
`mem.asBytes`?

1565067311
emekankurumeh[m]
if you don't want a copy

1565067341
daurnimator
curtisf:

1565075628
huuskes
daurnimator: does that mean there are plans to support multiple backends?

1565075650
huuskes
(even if that work would be superfluous right now)

1565075713
daurnimator
huuskes: long term yes I believve

1565079175
gonz_
Is there a function or otherwise like this in the standard lib atm?

1565079605
daurnimator
gonz_: enums don't make good bitflags...

1565079643
daurnimator
gonz_: usually enums are 0,1,2,3,4,5,... if you have 1,2,4,8,16,... you should be using a packed struct with u1 members.

1565079682
gonz_
Why don't they?

1565079732
gonz_
This is for C interop and the enum values are defined as powers of two

1565081192
euantor
thanks for the review @daurnimator :)

1565081212
daurnimator
euantor: no problem. hopefully it's helpful rather than nitpicky. I'm not too sure where to draw the line

1565081245
daurnimator
euantor: btw I liked the previous commit with `err != 0` over the current one with err as a `?u16`.... but I can't articulate why

1565081301
euantor
No problem, I'm fairly new to Zig so any feedback is helpful. I wasn't sure which approach I preferred for errors at all, but `?u16` seemed like it was clear what was actually happening

1565081504
daurnimator
euantor: I was wondering if it would be clearer without `num_read` getting returned from a block? really you want to return both err

1565081592
euantor
Yeah, that's the exact problem I was having. A `Result` type would work, or I could move the block into a function and have it return a `!usize` but I wasn't sure what to do

1565082638
daurnimator
euantor: btw, I should introduce you to my favourite git helper:

1565082722
euantor
That's pretty nice,  I'll be adding that but will need to fix it to work in fish

1565082773
daurnimator
euantor: is your /bin/sh fish?

1565082780
daurnimator
isn't fish incompatible with posix shell?

1565082791
euantor
My user shell is fish, and no it isn't POSIX compliant

1565082818
euantor
it uses `and` instead of `&&` for example

1565082834
gonz_
fish is super nice

1565082845
daurnimator
euantor: right. but your user shell shouldn't matter: the shebang on that script is /bin/sh which should be bash/ash/dash

1565082855
gonz_
back when I used it it didn't have a good vim mode, though

1565082857
euantor
true

1565083300
samtebbs
fish (y)

1565094363
autodidaddict
I'm trying an experiment where I want to see if I can get Zig to encode and decode protobufs. I figured the "easiest" way to try this would be to harness Zig's C integration and use libprotobuf-c . I'm running into a couple of problems: a) I don't know if I'm supposed to compile that library and copy it into a path prior to Zig compilation, or if I

1565094364
autodidaddict
'm supposed to tell Zig to build libprotobuf-c as well. b) I can't get libprotobuf-c to compile because there's no "protobuf.pc" file in my pkgconfig (even though I've done a make install on protobufs)

1565094383
autodidaddict
My lack of familiarity with the C build tool ecosystem is really the root cause of failure here

1565094902
autodidaddict
After finally being able to build protobuf-c and generate the .pb-c.c and .pb-c.h files, what extra stuff would I need to include in a Zig project to get that to compile?

1565094953
Tetralux
It depends on the use of macros in the generate file.

1565094958
Tetralux
If it's all basic stuff

1565094968
Tetralux
@cInclude may be enough in your Zig code.

1565094981
Tetralux
(In which case, Zig will compile it and handle the object for you.)

1565094986
autodidaddict
how would Zig know that it needs the libprotobuf-c library?

1565094994
Tetralux
You'd tell it.

1565095014
Tetralux
Either `--object path/to/lib/file` or in build.zig

1565095050
Tetralux
`addObjectFile` IIRC.

1565095159
Tetralux
I never used build.zig personally, but I think you'd be able to add it with either `addObject` or `addStaticLibrary`/`addSharedLibrary`.

1565095432
autodidaddict
the zig compiler crashes on tabs?

1565095444
autodidaddict
error: invalid character: '\t'

1565095446
Tetralux
It should

1565095472
autodidaddict
I was just editing with vi.. didn't realize it was spaces-only

1565095488
Tetralux
Yeah - that can be a bit of a gotcha.

1565095490
Tetralux
xD

1565095591
autodidaddict
mind is about to be blown. It compiled... but since I didn't instantiate any structs (yet), it could just be that it stripped the protos

1565095631
fengb
Zig is lazy and doesn’t compile unreferenced code

1565095685
autodidaddict
yeah that's why I suspect it compiled ;)

1565095719
Tetralux_
RE mind blown - I know the feeling - you should also take a glance at `zig cc` when you have a moment too  ;)

1565095740
autodidaddict
just trying to figure out how to instantiate a C struct in zig

1565095769
autodidaddict
this is what my import looks like:

1565095773
autodidaddict
const c = @cImport({  @cInclude("addressbook.pb-c");});

1565095803
Tetralux
var s: c.MyCStruct = undefined;

1565095811
Tetralux
IIRC.

1565095895
Tetralux
(.. Assuming that "addressbook.pb-c" is the path (relative to the Zig file) of the generated C file)

1565095907
Tetralux
(.. Which it prob isn't. xD)

1565095930
Tetralux
Should be more like:

1565095930
Tetralux
const c = @cImport(@cInclude("soundio/soundio.h"));

1565095937
autodidaddict
it's in the build directory, and yeah I'm having trouble with locating the file

1565095963
autodidaddict
should I cinclude("./foo.h") ?

1565096002
Tetralux
If your .h includes your .c, then worth trying.

1565096057
autodidaddict
I don't think it does. protoc just generated a pair of files - a .c and a .h

1565096093
fengb


1565096111
fengb
This project imports a C lib. Try that as a reference

1565096127
Tetralux
(.. see the build.zig.)

1565096702
autodidaddict
copying from tetris's build.zig and from the documentation, I get this compile error

1565096703
autodidaddict
error: use of undeclared identifier '_'    exe.addCSourceFile("proto/addressbook.pb-c.c", [_][]const u8{"-std=c99"});

1565097071
autodidaddict
there's a closed issue (

1565097459
autodidaddict
ok, pulled from master and that issue went away. Still can't get zig to find the .h file

1565097690
samtebbs
autodidaddict: I've not used C header files with Zig much but I think you can pass `-isystem <path>` to zig to add the path to where your header files are stored. There should be an equivalent for the build system

1565097773
autodidaddict
how do you get it to find the headers from inside a library? I got it to find my .h file, but now it can't find "<protobuf-c/protobuf-c.h>"

1565098104
autodidaddict
ok, I'm not sure if that was the right way ... but I just included -isystem /usr/local/include

1565098232
autodidaddict
this might be my last question... (yay the newb will be silent!) ... but how do I tell the zig compiler to use the wasm libc (my code requires a libc and so it fails to compile when targeting wasm32-freestanding)

1565098390
fengb
There’s wasm32-freestanding-musl but it’s incomplete

1565098472
autodidaddict
so zig build-lib -target wasm32-freestanding-musl?

1565098517
autodidaddict
I get the same message about "libc headers not available, compilation does not link against libc"

1565098564
fengb
Yeah that looks right

1565098565
fengb
You can also provide an external libc. I used

1565098696
fengb
Oh you need to add --library c

1565098744
autodidaddict
I get another weird error: /usr/local/Cellar/zig/0.4.0/lib/zig/std/fs/file.zig:14:15: error: container 'std.os' has no member called 'fd_t'    handle: os.fd_t,

1565098776
fengb
Do you use std.debug.warn? That blows up in wasm32

1565098787
fengb
I’ve been meaning to fix that

1565098796
autodidaddict
my build command: zig build-lib src/main.zig --object /usr/local/lib/libprotobuf-c.dylib -isystem /usr/local/include -target wasm32-freestanding-musl --library c

1565098818
autodidaddict
let me try building it without the stdout code

1565098876
fengb
wasm doesn't (and freestanding cannot) have stdout so that just dies with a cryptic error

1565098886
autodidaddict
right.

1565098892
autodidaddict
it compiles!

1565098896
fengb
\o/

1565098928
autodidaddict
in theory, I should then be able to export a function that involves the packing and unpacking of protobufs (the hypothesis I'm trying to prove)

1565099134
fengb


1565099142
fengb
Just added that

1565099220
autodidaddict
cool. My apologies for slathering this channel in newbsauce this morning. I've noticed a lot of people exploring Zig come from a place of comfort in the C build system, and that's alien to me so I feel like I'm learning how wheels work while learning how to drive the car

1565099312
fengb
It's fine. Always excited to have another wasm dev :P

1565099360
autodidaddict
I'm trying not to feel like a traitor to Rust after my Rust+Wasm book... but I'm exploring the possibility of hosting Zig-based modules in my Waxosuit host runtime

1565099579
fengb
We're all friends here. I personally believe Rust and Zig are pretty complementary

1565099602
fengb
(I also sorta gave up learning Rust because I couldn't grok it but that's a side note)

1565099623
Tetralux
I tried writing a lexer/parser in Rust, and gave up xD

1565099652
fengb
But I've always been more of a baremetal C guy than C++

1565099681
Tetralux
I might have been, but I like function overloading and auto too much for that

1565099688
autodidaddict
I'm finding it interesting approaching Zig from a Rust background

1565099714
fengb
We give you rope if you need it :P

1565099723
Tetralux
I like having rope :3

1565099735
Tetralux
Means I can use it as a lassoo if I need it.

1565099764
autodidaddict
Every time I see a pointer being used so casually, I freak out. Rust's compiler spends all day stabbing you for free-roaming unsafe pointer access

1565099866
fengb
Most day-to-day you should use single pointers and slices, which have proper bounds checks

1565099950
fengb
Of course I say this as I'm manually carving out a struct from a slice of u8s >_>

1565100325
scientes
Tetralux, zig has auto

1565101562
samtebbs
autodidaddict: newbs are welcome :)

1565102005
scientes
bugs, bugs, bugs, bugs

1565103067
Tetralux
scientes: It does indeed. Not name-qualifying, but still. Better than nothing ;D

1565103200
scientes
there are bugs EVERYWHERE

1565103926
andrewrk
scientes, that tends to happen toward the end of the release cycle (before I spend the tail end doing mostly bug fixes)

1565103953
scientes
no, i'm talking about unreported bugs

1565103964
scientes
and bugs in my own code

1565103968
andrewrk
ah

1565104044
mq32
andrewrk, a question on your planned package manager:

1565104055
mq32
how do you want to handle dependencies of referenced libraries?

1565104085
mq32
does each library enforce a certain other version (by hash, name, ...)?

1565104342
andrewrk
every package declares the exact hash of its dependencies. however there is still a concept of semantic versioning of packages, and one package will be supplied instead of another if it is compatible

1565104398
andrewrk
and then there is an auditing tool (`zig pkg --list` or something) that shows what packages end up being used; whether there are duplicates (due to incompatible major versions, etc)

1565104421
mq32
hm. please add an option to allow arbitrary dependency overrides

1565104451
mq32
i currently have a problem in .NET that one library (A) enforces dependency B¹, but i want to use version B² of it

1565104456
andrewrk
that's a possibility. the decentralized nature of it also means you can fork something and use that fork instead, it wouldn't change the package id

1565104461
mq32
both are "current version", but with different "backends" builtin

1565104978
Tetralux
If you specify a version or hash of a package you need, but you want that specific version only, will it in any circumstances provide different ones without confirming otherwise?

1565104995
Tetralux
And if so, will there be a way to prevent that in build.zig and the cmdline.

1565105100
Tetralux
Will there also be a way to quickly get to a changelog of sorts for updates to packages you are using?

1565105125
Tetralux
(.. So that you might audit those changes before upgrading.)

1565105149
Tetralux
.. without having to dig through documentation or git history or whatever.

1565105200
andrewrk
current plan is if you want a package to not participate in semantic versioning then you'd fork it and change the package id

1565105237
Tetralux
That's if you want to do something akin to what Zig currently does with LLD right?

1565105259
andrewrk
what upgrading looks like is a tool that detects new versions of packages, presents those changes in some helpful way, and you can accept the upgrade(s) you want, which locks them in to the new hashes

1565105321
Tetralux
One issue I've always had with package managers like apt-get etc, is that they tell you nothing more than the version number changes, at best.

1565105329
Tetralux
That tells me nothing about what the changes actually are.

1565105346
Tetralux
And so I can't really make an informed decision on whether I should update yet or not.

1565105356
andrewrk
ultimately it's up to the programmer to decide what to depend on, but I do intend to put effort into tools to make the job more ergonomic

1565105391
andrewrk
a fully informed decision is out of scope of the package manager; it's a social/technical judgment call the programmer must make based on information the tool does not have access to

1565105415
mq32
andrewrk: to solve my problem, it would be enough to make a local copy of the package manifest the programmer could edit

1565105432
Tetralux
Except that where the information

1565105439
mq32
(instead of creating a whole new package to just change a single dependency)

1565105440
Tetralux
Which is why I never read it.

1565105466
Tetralux
Further, I'd maybe want to update

1565105467
andrewrk
mq32, with the current design, you'd have to fork A

1565105487
Tetralux
update A, compile, fix, update B, compile again, fix again, etc.

1565105492
andrewrk
mq32, reasoning here being: the author of A made a clear decision about what to depend on, and to override that decision, you are forking the project

1565105535
Tetralux
Though, since

1565105536
andrewrk
mq32, the difference here, however, being that your fork can "steal" their package id

1565105541
mq32
so i have the decision to either "get my project running and update everything by-hand" or "don't get my project running, but have to option to automatically update my depdencies"?

1565105598
andrewrk
I didn't quite understand that

1565105600
scientes
you don't have to fork both

1565105602
scientes
you only have to fork one

1565105605
scientes
right?

1565105617
mq32
andrewrk: when i fork, i'm the maintainer of the package, right?

1565105627
andrewrk
right, you fork A, change its dependency to point to B2, and then update your URL of A to your fork

1565105642
mq32
so i have to provide updates and everything

1565105652
mq32
just because i edited a *dependency*, not the library itself

1565105661
andrewrk
mq32, right. and you should test issues upstream before reporting issues upstream

1565105663
scientes
andrewrk, oh you can't just MITM the dependancy of A?

1565105693
andrewrk
scientes, you can. by forking it

1565105701
scientes
yeah but that isn't MITM

1565105713
mq32
andrewrk: so you're creating the same problem i'm stuck with ATM

1565105729
andrewrk
is the problem how convenient it is to patch someone else's library?

1565105744
mq32
i don't want to change any bit about the source code of the library

1565105746
mq32
not a single bit

1565105756
mq32
just change a third-party dependency to make my project run

1565105756
andrewrk
yes you do, you want to change the bits of the hash of its dependency

1565105759
gonz_
Please never allow dependency overrides

1565105763
scientes
I think the user should have control over the namespace

1565105774
scientes
if only because there isn't any security loss in doing so

1565105798
scientes
with like an override file or something

1565105870
mq32
andrewrk: why i'm bringing up the topic: exactly this topic forces me to edit .NET assemblies by hand to just say: "god damn, use the library with OpenGL backend instead of DirectX. all public members are literally the same, only the

1565105904
andrewrk
anyway these are good questions. the first step will be the less controversial stuff, basic support, and then we can address the more advanced use cases

1565105913
mq32
i don't want to recompile 10 libraries by hand to get this working

1565105915
scientes
it should always be easy to fork a library

1565105921
mq32
</rant>

1565105940
andrewrk
yes I don't think people here are fully grokking the package id fork thing yet

1565105946
gonz_
Forking is not the same as "I use a dependency and from my project magically override which dependency that has access to"

1565105987
andrewrk
an "override manifest file" is essentially a light weight fork which is stored as a patch file

1565105989
gonz_
Parametric packages would be neat, but magic overrides are not that.

1565105992
scientes
forking a library should be as easy as forking a front-end

1565106018
scientes
but you could print a warning when building with a locally forked package

1565106042
scientes
its essential to debugging to be able to easily fork at any place

1565106058
scientes
that's what open source is all about

1565106075
mq32
because of the propagation effect

1565106083
andrewrk
what's the propagation effect?

1565106094
scientes
mq32, we are talking about the same thing

1565106103
mq32
not sure

1565106110
mq32
i have HtmlRenderer.PdfSharp which depends on PDfSharp

1565106138
mq32
PDfSharp is a project that spills several dependencies: PdfSharp, PdfSharp-gdi, PdfSharp-wpf, PdfSharp-silverlight, PdfSharp-core, ...

1565106157
mq32
*-dependcies +variants

1565106164
mq32
each of these variants has the exact same public API

1565106218
mq32
if i would solve the problem of HtmlRenderer.PdfSharp depending on PdfSharp by forking, would create 5 versions of HtmlRenderer.PdfSharp that have exactly sizeOf(dependency-hash) bytes difference

1565106231
mq32
now imagine a next library depends on HtmlRenderer.PdfSharp

1565106242
mq32
now this library also needs 5 variants to be used

1565106247
mq32
*created

1565106267
gonz_
Isn't your problem actually a lack of parametricity in actual code?

1565106277
scientes
dependency hash is a really bad idea

1565106290
gonz_
Something could easily take these as parameters, i.e. as adapters

1565106292
scientes
unless it can be easily overridden

1565106304
scientes
it makes it to difficult to fix things

1565106318
mq32
gonz_, nah, it's a problem in the base technology (.NET)

1565106333
mq32
the splintered their codebase into several subsystems

1565106380
mq32
and yeah, we could comptime-solve this with Zig easily, but my experience tells me that something like this (having several versions of the same library) may also happen with zig in the future

1565106457
mq32
so there is a requirement to reference libraries based on some settings like platform or similar

1565106536
andrewrk
mq32, in this example, what is the modification that needs to be made? the actual problem?

1565106545
andrewrk
why can't you use the upstream package directly?

1565106564
mq32
"change the enforced dependency to PdfSharp to PdfSharp-gdi"

1565106575
mq32
*from PdfSharp to PdfSharp-gdi

1565106586
mq32
(different assemblies of the same library)

1565106626
andrewrk
that sounds like 1 change to me, not N. I don't get it

1565106689
mq32
the point is: i still want to have the upstream version of the original library to obtain all updates and such

1565106724
mq32
it would be N libraries if we would make the "clean" version, or i could maintain a local package myself with unnecessary overhead to manually check for updates

1565106739
andrewrk
you already have to manually check for updates with planned zig package manager

1565106750
andrewrk
you don't get code that you didn't ask for

1565106793
andrewrk
strict hashing means you get the exact version you decided on. if you want a different version you have to choose a new hash

1565106816
mq32
that is clear

1565106832
mq32
but there should be an option to check for "has any of my dependencies a newer version out there?"

1565106843
scientes
ugggh, i think that is the exact opposite of what i want

1565106850
scientes
if you want to pin the a version, you clone it locally

1565106856
scientes
otherwise you want to always use HEAD

1565106860
gonz_
Ugh

1565106863
andrewrk
nope that's not going to happen scientes

1565106886
andrewrk
mq32, I see, the fork gives up the convenient detection of updates

1565106897
mq32
yes

1565106917
andrewrk
¯\_(ツ)_/¯ try not to fork stuff

1565106920
mq32
updating should be manually triggerd, but then be done automatically (in terms of zig pkg update my-fancy-library)

1565106943
mq32
andrewrk, but you told me forking is the solution!

1565106955
andrewrk
forking was the premise

1565106959
gonz_
Personally I want precision in dependency specs. Ideally whatever identifier you have for a dependency always means the same thing for everyone who downloads the dependencies, today, tomorrow and forever.

1565106962
andrewrk
your premise was that you needed to fork a package

1565106979
mq32
hm

1565107008
andrewrk
clearly, a well-managed package that doesn't need to be forked, would be preferable to depend on

1565107015
mq32
my wish was to manually override the dependency for a single package (because i am the developer of this single thing, i have the right to choose what i want to do)

1565107025
nairou_
Is there perhaps a way to tag local forks as having a parent, and package update checks look at the parent in that case rather than the package itself?

1565107045
andrewrk
nairou_, that sounds like it's worth exploring

1565107080
andrewrk
mq32, if you're the developer of the package, why not release a version that actually does what you want?

1565107099
andrewrk
I don't get it, why use packages if you just want to hack them up? commit all the code to a monorepo then

1565107108
mq32
nah

1565107116
mq32
i don't want to change anything about the source of the package

1565107132
mq32
(if you exclude package specification from the source code)

1565107163
Tetralux
mq32> ecause i am the developer of this single thing, i have the right to choose what i want to d

1565107167
Tetralux
mq32: +1

1565107184
Tetralux
In my mind, the author of the package is only in control of what they are publishing.

1565107200
mq32
andrewrk, and i'm not developer of the package i want to change, but of a package that depends on the thing that is wrong

1565107214
Tetralux
Exactly.

1565107220
andrewrk
that is the definition of a fork

1565107233
andrewrk
you're not the developer and you want to change it

1565107244
andrewrk
so do it

1565107248
andrewrk
fork it

1565107255
Tetralux
It's essentially the same problem as how C libraries may have named something "Quarternion" but I have my own quarternion that has a slightly different, but important meaning.

1565107272
Tetralux
If they'd called it "LIB_Quarternion" I'd be okay, but it'd be annoying.

1565107281
andrewrk
or convince the upstream developer to release a version that includes the ability to do what you want

1565107283
Tetralux
And normally, you have to change

1565107311
Tetralux
The specific case I was thinking of was where the offending Quarternion was in the Nintendo SDK.

1565107320
mq32
andrewrk, in my case that would mean to first bug the developer of library B, then the developer of library A and then i can finally compile my code ^^

1565107321
andrewrk
one related concept here is build options. packages can expose build options which can be configured by downstream packages

1565107327
nairou_
He wants to change a package dependency that requires no code change. Switching from one API provider to another identical one.

1565107336
Tetralux
mq32> That would mean bugging the dev; +10

1565107337
andrewrk
so for example they could expose a Quaternion option with a default

1565107346
andrewrk
or a PdfViewer option with a default, etc

1565107360
Tetralux
Yes - but they haven't.

1565107365
Tetralux
And they

1565107371
Tetralux
Or it might be a pain to contact them.

1565107376
andrewrk
then you need to send them a patch, or fork it

1565107377
Tetralux
Or even convince them to do so.

1565107383
fengb
Has this been solved in any other package system before?

1565107390
Tetralux
I'd rather not use the package and use one that just works TM.

1565107437
mq32
got to go. just wanted to start this conversation as this happendend not only once to me before

1565107450
andrewrk
thanks mq32 for the good use case

1565107453
mq32
:)

1565107478
andrewrk
people here are thinking from the perspective of the application developer. but the perspective of the library author is important too. we need library authors to be able to rely on their dependencies

1565107479
mq32
and if i have to choose between a) bugging the devs until they fix it, b) creating a fork and maintain until death or c) do evil hackery, i will choose c) because it's the way of least unnecessary work in the long term

1565107505
Tetralux
mq32: +10.

1565107516
mq32
andrewrk: yeah, my point is: if i want to fuck things up i should be able to do so AND be responsible for that

1565107538
gonz_
I don't disagree with that last part

1565107590
andrewrk
I definitely think there should be friction going from (a) to (b) and friction going from (b) to (c)

1565107607
Tetralux
Packages I downloaded should essentially become nothing more than "source files that came from someone else" as far as my project is concerned.

1565107617
andrewrk
(a) is best, (b) is second best (someone has to maintain packages, and if (a)'s not happening then you may need to be the one) and (c) is self-admitted evil hackery

1565107622
mq32
also, before i forget: andrewrk, sorry for the issue if it was unnecessary. i tested with upstream (or at least i though i was) and also searched issues for this problem. but i never found similar issues with github search :(

1565107675
andrewrk
(c) is pretending that someone else is the maintainer of a package, but it's actually you.

1565107739
mq32
sadly, i got to go

1565107741
mq32
laters!

1565107741
Tetralux
What about essentially doing `git diff` on packages, and if there's changes, warn you when updating it and alert you that you'll need to resolve any merge conflicts that result - but, **crucially**, allow you to attempt it and give up and revert to the version you originally had, with the changes that were present.

1565107764
andrewrk
packages are a set of files, not a git repository

1565107797
Tetralux
But the local copy could become a git repo for the purposes of tracking changes - or Zig could track them itself perhaps.

1565107810
Tetralux
Where the initial commit is the state it was downloaded in.

1565107814
andrewrk
there's no local copy when you freshly run the package manager

1565107825
andrewrk
only the hashed versions are available

1565107830
andrewrk
this is decentralization

1565107839
Tetralux
Yes - I mean that once downloaded, the version you gets `git init` run on it.

1565107850
andrewrk
what problem are you trying to solve?

1565107877
Tetralux
The one of making local changes to the package, but still wanting to have a relatively easy way to update it.

1565107904
Tetralux
Rather than being stuck on the version you have right now because it's a pain to update it.

1565107905
andrewrk
what you're describing is vastly more complicated than forking

1565107926
Tetralux
In what way?

1565107931
Tetralux
It seems rather the same to me.

1565107956
Tetralux
By changing it, I, the author of the app that is using the package, is accepting responsibility for the changes.

1565107957
andrewrk
I'm gonna go work on async functions

1565107960
Tetralux
XD

1565107965
scientes
andrewrk, yes

1565107976
Tetralux
Please do - I want to try using those things!

1565108010
Tetralux
I honestly hope they'll be so easy to use and not think about that I can just use them without learning about lots of interesting details. ;)

1565108028
donpdonp
whats the way to get 'zig/build$ make install' to target a specific folder?

1565108032
Tetralux
I honestly hope they'll be so easy to use and not think about that I can just use them without learning about lots of interesting details. ;)

1565108120
fengb


1565108174
fengb
I've had trouble with `make DESTDIR=/usr/foo/bar` so I always do `cmake .. -DCMAKE_INSTALL_PREFIX=/usr/foo/bar`

1565108288
donpdonp
fengb: thx.

1565108446
mikdusan2
andrewrk: can u quick eyeball this? i'm thinking the logic needs to be reversed:

1565108449
mikdusan2


1565108543
scientes
mikdusan2, that looks good

1565108551
scientes
mikdusan2, but a test case is always what prooves it

1565108569
mikdusan2
yes i'll run it thru the test guantlet soon

1565108608
scientes


1565108614
scientes
that demonstate the problem you were seeing

1565108808
Tetralux
What's the best way to pass a `comptime T: type` to a fn, which can be any signed or unsigned type, and do something different in the body if it's signed?

1565108844
Tetralux
.. So that I don't have to have a signed and an unsigned version of this function.)

1565108856
scientes
if (@typeId(T) != .Int) @compileError(...) if (@typeInfo(T).Int.is_signed) {...}

1565108893
mikdusan2
12 seconds. not bad scientes :)

1565108927
donpdonp
is it too early for someone to write a book on zig typing o^O

1565108961
companion_cube
don't forget to cite all the literature on dependent types and staged types ;)

1565110978
Tetralux
Is there a way to transmute the element type of a slice?

1565110986
Tetralux
i.e: convert []T -> []U

1565111002
scientes
Tetralux, @sliceToBytes @bytesToSlice

1565111013
Tetralux
Oh dangit - forgot about that xD

1565111015
Tetralux
Ta :P

1565112554
Tetralux
I'm trying to truncate-cast a u64 to a f64.

1565112573
Tetralux
But warn keeps giving a runtime panic with 'integer cast truncated bits'

1565112599
Tetralux
`warn("{}\n", @intToFloat(f64, n) / @intToFloat(f64, d))`

1565112608
Tetralux
Any ideas?

1565112616
Tetralux
I'm expecting something stupid.

1565113245
gonz_
Does anyone know a Freenode (or other network) channel for win32?

1565113798
Tetralux


1565113974
Tetralux
both 'took_sec' and 'len' are u64s that have been @intToFloat'd to f64.

1565114084
mikdusan2
hmm isn't line #3 the error?

1565114148
mikdusan2
presumably bytes.len is > 32 bits, and @intCast doesn't truncate. you'd want @truncate for that

1565114173
Tetralux
I'm not using @intCast.

1565114228
mikdusan2
ok but the error i think is a result of @intCast by std code maybe

1565114238
Tetralux
That's what I was thinking.

1565114242
Tetralux
But I can't do anything about that. xD

1565114244
Tetralux
But bytes.len shouldn't be more than 16 bytes or so.

1565114258
Tetralux
It's literally just formatting a number of bytes to something like "4.5 GB"

1565114280
Tetralux
Takes an f64, and according to how big it is, changes the "G" to a "K" or an "M" etc.

1565114293
Tetralux
I'm not trying to print the world out to stdout xD

1565114326
Tetralux
I'm fmt.allocPrint'ing the string and then passing it directly to warn.

1565114404
Tetralux
Huh. Okay.

1565114419
Tetralux
It seems that it was that when I returned the string, I wasn't `try`ing it.

1565114428
Tetralux
But the return type was '[] const u8`

1565114439
Tetralux
So I'm not entirely sure why I didn't get a compile error.

1565114472
Tetralux
If I put in the try when I return, and when I warn, it works fine.

1565114492
mikdusan2
aside from what you mentioned by try; i would say this smells like a corrupt buffer being sent down the line and that's why bytes.len is bogus.

1565114521
autodidaddict
is there a progressive set of tutorials we can walk through to get the feel for the language rather than just reading that one html doc? In other words, is there an exercism.io course for Zig, or something similar?

1565114557
gonz_
No, there's nothing that I know of.

1565114560
Tetralux
Is there something specific you feel unfamiliar with?

1565114572
gonz_
These are very early days in zig

1565114573
Tetralux
Is there something specific you feel unfamiliar with?

1565114590
Tetralux
Whoops. Did not mean to write that twice lol

1565114597
autodidaddict
no.. it's just more that what's out there is very reference-y, and not very how-to-y :D

1565114654
gonz_
Yeah, it's early days enough where most people are just tinkerers and enthusiasts at this point

1565114680
autodidaddict
ok cool. I like to think of myself as an enthusiastic tinkerer ;)

1565114687
Tetralux
As a matter of interest, can you point to such a thing for a language that does have what you're thinking of?

1565114691
Tetralux
Only I probably agree with you xD

1565114718
autodidaddict


1565114759
autodidaddict


1565114831
Tetralux
Ah yeah - that would be good.

1565114848
Tetralux
The get-started one would be better if it was more on one-page.

1565114860
Tetralux
Feels like I'm wading through tar for some reason.

1565114870
Tetralux
But  yeah - something like that would prob be cool.

1565114887
autodidaddict
that get started page is super noisy

1565114914
autodidaddict
but, I like the concept of the getting started roadmap.. build a hello world, then add a struct, now play with pointers, then do this... etc

1565114917
autodidaddict
just to build muscle memory

1565114939
gonz_


1565114953
autodidaddict
I'd maybe be interested in doing a zig book if/when it stabilizes on 1.0

1565114995
Tetralux
gonz_: Oh yeah - that is

1565115036
gonz_
Most material will be made in time, given an enthusiastic and stable set of early adopters that evolve into it, I'm sure.

1565115173
nairou_
I really liked what they have for Go (

1565115227
Tetralux
I do remember liking the ability to play with it before moving on when I went through the Go tour.

1565115245
autodidaddict
oh yeah.. the Go tour is awesome

1565115357
nairou_
But I agree with autodidaddict, learning Zig is slow when all you have is reference documentation. Requires searching for examples or just trial and error, for each piece you want to figure out.

1565115495
gonz_
I don't think anyone disagrees, really.

1565115549
Tetralux
How do you fmt print a float as a normal float?

1565115555
Tetralux
Like 2.55?

1565115571
gonz_
It's a matter of whether or not zig has the user base and is in a position to have materials like that yet. I think it's worth starting something like that if interest is there and seeing whether or not it's maintainable.

1565115621
nairou_
I've been tempted, if only I had the time

1565115680
gonz_
Having a cookbook repo might be a good start that's not too much of a commitment.

1565115706
gonz_
With common idioms, etc.

1565115839
Tetralux
Prey tell, where might one look to discover the characters that can be printed in a reasonable way, for example in warn, to allow me to feast my eyes on a floating point number that is nicely assembled into a 4.55 kind of way with a specifically assigned number of decimal places? :'3

1565115848
Tetralux
And no I'm definitely not going mad trying to find out how I do that.

1565116406
gonz_
`"{d:.2}"` will give you a decimal representation with two decimals

1565116414
gonz_
To get that I read the source

1565116506
gonz_
`fmt.format` for the general precision/width specifiers, `fmt.formatFloatValue` for the `d`

1565116567
Tetralux
OH MY GOD THANK YOU

1565116723
gonz_
This might be one of those cookbook things.

1565116774
donpdonp
reminds me of the best thing i found in std.fmt - allocPrint, which uses the fmt magic but returns it in a string. const pathStr = std.fmt.allocPrint(allocator, "./dir/{}", name)

1565116815
Tetralux
Man - trying to read the call stack of the functions in std.fmt in order to figure out what the formatting options are is..... not fun.

1565116820
gonz_
donpdonp: Indeed :)

1565116874
gonz_
I've used that one a lot. You can even make it a cstr by ending the string with `\x00`.

1565116880
donpdonp
which ironically doesnt print :)

1565116905
gonz_
I've used it to debug some win32 stuff with messageboxes and `OutputDebugStringA`

1565117072
Tetralux
I'm slightly amused by the fact that generating random numbers with WyHash goes at 9 GB/s in Zig, but 2.3 GB/s in Odin.

1565117076
Tetralux
I smell a bug.

1565117079
Tetralux
Probably mine x'D

1565117351
fengb
I think the Zig "onboarding" only really makes sense for C programmers

1565117370
fengb
*currently

1565117396
nrdmn
has there been any progress on #786 (configurable error set integer types)?

1565118612
dimenus
what's the best practice for storing common code for personal projects?

1565118622
dimenus
is there an equivalent of a 'shared' collection in zig?

1565119188
nairou_
For source code, or compiled libraries?

1565119225
dimenus
source code

1565119232
dimenus
eg my vulkan wrapper, matrix math etc

1565119754
nairou_
Noob answer: From what I've seen, you would just keep your collection in a shared folder somewhere, and @import the needed file (or entry point file for a larger collection) using a relative or absolute path.

1565119832
gonz_
`deps` folder, git repos / links would be what I would go for

1565119858
dimenus
zig does not tolerate relative paths that are outside of it's root

1565119872
dimenus
error: import of file outside package path: '../zig-shared'.

1565119884
dimenus
and so far, it doesn't seem to correctly resolve fully qualified paths either

1565119914
nrdmn
I've been using git submodules for that

1565119920
nairou_
I wonder if that's a bug. Documentation implies it's should work.

1565119926
fengb
I've just copied files around

1565120053
dimenus


1565120063
dimenus
no, it was explicit change

1565120074
dimenus
*an explicit change

1565120223
dimenus
i understand the long term goal being submodules, but they're not fully fleshed out libraries yet

1565120245
dimenus
i'd much rather have a common spot and just deal with the compile errors if i make changes

1565120275
nairou_
andrewrk's final content on that ticket says to import external code as packages. Was that an early reference to the upcoming package manager, or do packages already exist at some level?

1565120495
dimenus
yeah that's what I'm really looking for is to import the content as a package

1565120722
dimenus
the zig compiler compiles soooooooo much faster on *nix

1565120723
dimenus
than windows

1565120743
nrdmn
nairou_:

1565120764
nrdmn
Looks like they do exist, but I don't know if you can do anything with them

1565120830
nrdmn
there are the command-line options --pkg-begin and --pkg-end

1565121049
nairou_
Oooo

1565121080
dimenus
ah, you can add a package path in build.zig

1565121095
dimenus
that makes sense

1565121099
nairou_
Where'd you find that?

1565121101
dimenus
so i can @import("shared") in my main.zig

1565121103
dimenus
in build.zig

1565121160
nairou_
I mean, how did you figure that out? Digging in source code, or is it mentioned somewhere?

1565121186
dimenus
ripgrep :)

1565121195
nairou_
Nice

1565121202
dimenus
ripgrep 'pkg-begin' $ZLH

1565121210
dimenus
(ZLH is zig lib home on my system)

1565121339
gonz_
dimenus: Relative path to the project root folder and links/repos in there will work.

1565121384
dimenus
gonz_ in build.zig you mean? yeah it's working great now

1565121412
gonz_
I meant even just source, actually, but I must have missed some kind of package support overall.

1565121461
gonz_
What does that even entail? You specify a package directory and every directory in there has its `src` importable?

1565121486
dimenus
gonz_: @import with relative paths below the root tree don't work - sorry should have specified

1565121506
dimenus
yep

1565121544
dimenus


1565121567
dimenus
44-48

1565121597
dimenus
then you pub const foo = @import any files you want within that shared.zig file

1565121670
gonz_
Aha, ok, so it's still very specific.

1565121738
dimenus
that's actually perfect imo, since the location of my shared file is really specific to the build system

1565121741
dimenus
not to my main project

1565121760
dimenus
the dir tree can be organized however you want and the main program doesn't break

1565121803
Tetralux
Is there a way to use SSE instructions?

1565121816
dimenus
for what, vectors?

1565121829
dimenus
zig/llvm will use SSE where necessary

1565121854
scientes
Tetralux, use my simd patch set

1565121870
dimenus
vectors are missing a bunch of operations though, I'm using master with scientes's PR merged

1565121871
scientes
and yes, zig uses -march=native and uses sse and avx and avx2 where appropiate

1565121885
scientes
dimenus, that will be it for that patch set

1565121895
scientes
i've already done more, but it needs to be mergable

1565121903
dimenus
it looks good to me so far

1565121909
scientes
I was able to run a real-world POC

1565121921
scientes
double-precision natural exponent 2x

1565121924
dimenus
when i rebased it on my own i ran into segfaults when assigning via array indexing

1565121927
dimenus
not sure what went wrong there

1565121932
scientes
dimenus, that was a upstream change

1565121938
scientes
it was painful, but i fixed it

1565121947
dimenus
can you give me the 2 minute shpeal?

1565121952
dimenus
i'm curious

1565121972
scientes
I'm going to propose a talk at the LLVM conference in october

1565122000
scientes
i have to submit the prposal this week

1565122013
scientes
it was a zig upstream change

1565122015
scientes
not llvm

1565122026
scientes
although big llvm changes are coming for variable-length arrays

1565122045
halosghost
oh?

1565122050
halosghost
what's llvm doing about VLAs?

1565122053
batok
I like the way that zig "build" uses zig, but... what do you thing about bazel?

1565122086
batok
s/thing/think

1565122128
dimenus
scientes: what was the zig upstream change?

1565122180
dimenus
I use meson in my C projects

1565122197
dimenus
cmake makes sense in large / cross platform projects though

1565122199
scientes
dimenus, d105769926fd5360a5309

1565122242
scientes
no this one : a5cb0f77d11bdcc

1565122412
Tetralux
dimenus: I would have thought a unity build makes more sense honestly.

1565122547
scientes
I'm not sure what to say about SIMD in Zig in my presentation, besides that it doesn't work in C

1565122735
dimenus
Tetralux: I've done Unity builds in the past and they're great, until you start using intellisense

1565122739
dimenus
or you want to refactor anything at all

1565122961
Sahnvour
what does that has to do with it ?

1565122980
Sahnvour
usually the unity file is created by the build system and doesnt interfere with how you program

1565123094
dimenus
visual studio can parse unity builds for valid symbols, but eg vs code can't

1565123099
dimenus
and neither can clangd

1565123186
dimenus
If you have a system where symbols are not as interdependent, it totally works

1565123201
dimenus
Per Vognsen made this point early on in his bitwise series

1565127852
AlexMax
I suppose the inability to do greater than/less than comparisons between two [*]T's is purposeful?

1565127925
mq32
AlexMax, what should that do?

1565128083
AlexMax
compare memory addresses?

1565128157
mq32
for what purpose?

1565128172
mq32
just "random, but fixed order of things"?

1565128870
fengb
You can always cast to ints

1565128871
fengb
I think with a strong enough usecase, it's supportable. I actually can't see much of a downside

1565128906
mq32
i find it semantically weird to order stuff by the location in memory

1565128928
mq32
this

1565128945
fengb
Array index comparison would be a decent fit

1565128954
gonz_
IIRC pointer comparison is undefined behavior for things coming from different allocations in C

1565128974
fengb
I'm not quite sure the usecase... but I also don't see a big downside either. It's a lot simpler and straightforward than pointer math

1565129340
mq32
gonz_, true. you may only compare pointers into the same "object"

1565129343
mq32
(may it be static, stack or heap memory)

1565129521
gonz_
I've never written imaginative enough C/C++ to rely on it, I heard about it much later.

1565129537
fengb
Wouldn’t it be just comparing the ints?

1565129741
fengb
Not according to C spec... but couldn’t it just compare the int values?

1565129783
gonz_
You would think it should

1565129826
gonz_


1565130772
mq32
integer representation may be different for the same address in C

1565130786
mq32
i just throw in NEAR and FAR

1565131086
mq32
for those who don't know: FAR is a 32 bit pointer in DOS that does 16 bit segmentation

1565131100
mq32
and 0x00FF:0x0000 is the same (linear) as 0x0000:0xFF00

1565131109
mq32
but integer repr. is differnt

1565131113
AlexMax
Well, I found it curious.  I was basically testing out the C-substitute-ability of zig by rewriting a C function in Zig, and I was starting out by doing a very much like the original translation

1565131156
mq32
AlexMax, what does the original code with those magic pointers?

1565131190
AlexMax
the original function does the "keeps multiple pointers into the same stream" thing that C is so well known for

1565131223
AlexMax
I know Zig does things differenty with slices with known lengths and such

1565131247
AlexMax
but it was basically comparing two unsigned char*'s to check to see if was past the end of some scan

1565131284
mq32
ah

1565131304
mq32
then i would recommend using slices, but you could also do @ptrToInt

1565131418
AlexMax
Well, the thing is, the function's input is a [*]u8 coming from C, so it might take some reworking

1565131435
mq32
a single [*]u8?

1565131440
mq32
then just slice it

1565131473
mq32
fn(ptr: [*]u8, len : usize) void { var slice = ptr[0..len]; }

1565131477
AlexMax
Well, actually, I have a question about that, if I'm exporting a function with C linkage, should the parameter be [*]u8 or [*c]u8?

1565131586
fengb
[*], [*c] should only be used from translate-c

1565133223
Tetralux_
The number of people getting pinged from the fact that we have @Builtin functions must find it a little amusing... xD

1565133428
nairou
Huh... I tried creating a build.zig for a small C-only program, just to get my feet wet. Finally got zig building it without error. But when I run the resulting program, it's an immediate SIGSEGV. Clang by itself builds the project fine, so it's not that.

1565133570
Tetralux
Does it do the same thing if you try to compile from the cmdline?

1565133606
nairou
It consists of multile c files and multiple libraries, that's why I went with the build.zig file

1565133738
nairou


1565133828
fengb
Can you try with `--verbose-cc ` to see what the compiler is emitting?

1565134293
nairou
Only thing that stands out is it's linking against a local stage1 copy of libc. Can that be overridden to use the system libc?

1565134600
fengb
Yes, I'm just not sure how using build :P

1565134738
fengb
Looks like exe.setLibCFile(file) is the same as --libc [file]

1565134738
fengb
Running `zig libc` generates the file for native

1565134928
nairou
Interesting

