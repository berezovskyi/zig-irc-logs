1549355328
schme245
is there something like C++ "pass-by-reference" in Zig or is it C-style "pass-by-value" all the way?

1549362096
Hejsil
schme245, Well passing a pointer is pass-by-ref :)

1549362124
schme245
but the pointer is still copied, right?

1549362130
Hejsil
Well, yes

1549362135
Hejsil
Like in any language

1549362210
Hejsil
If you're trying to avoid copying big structs, then I'm happy to inform that zig does some pass-by-ref behind for you when you pass-by-value

1549362276
schme245
I'm just trying to figure out the exact semantics, coming from a Java background :)

1549362305
schme245
from what I gather, C++ has "reference parameters" that don't involve any copying whatsoever, is that correct?

1549362311
Hejsil
Well, assume that the type you passed is copied

1549362327
Hejsil
fn a(p: T) void passes T by value

1549362338
Hejsil
fn a(p: *T) void passes *T by value

1549362391
Hejsil
Well, c++ has void a(T &p)

1549362405
Hejsil
This is a pointer behind the scenes

1549362425
schme245
the one I'm thinking about is `void a(int& i)`

1549362439
Hejsil
Ye, that's the one

1549362478
schme245
ahh, ok

1549362503
schme245
so, to sum up, assume Zig copies, but sometimes it might decide not to, based on the whim of the compiler?

1549362597
Hejsil
Yeah, it's an optimization

1549362627
Hejsil
Here is a C pass by pointer vs C++ pass by ref

1549362644
Hejsil
I generates the same code (actually c++ has one more instr for some reason)

1549362700
schme245
is it correct that "copy elision" is about providing precise semantics for this optimization, so that you can guaranteed under some conditions?

1549362702
Hejsil
Oh wait, no it doesn't. My code was wrong

1549362713
Hejsil
Yes

1549362719
Hejsil
But it is mostly for returning values

1549362722
Hejsil
And not passing them

1549362751
Hejsil
But then again, we have guaranteed copy elision for parameters already. Pass by pointer

1549362768
schme245
hehe yeah, makes sense

1549362785
schme245
thank you for the explanations, much appreciated

1549362817
Hejsil
np

1549370418
schme245
is there a good tool on osx to view the assembly generated by the Zig compiler?

1549370424
schme245
preferably terminal-based

1549371689
Hejsil
Is objdump a thing on osx?

1549371732
schme245
yes, but I'm not sure that it works the same as on linux

1549371812
Hejsil
Hmm. Well, for small pieces of code, i paste it into

1549371826
Hejsil
Not in the terminal though

1549372028
schme245
that's a great resource, I didn't think Godbolt could do Zig!

1549372126
Hejsil
Some awesome people got it to work. It even has a very current version of zig master branch

1549376831
andrewrk
schme245,

1549377010
schme245
yeah, I saw that but I was a bit confused by the wording: "In Zig, structs, unions, and enums with payloads can be passed directly to a function"

1549377034
schme245
does "passed directly" mean "not as a pointer"? is that not possible in C?

1549377050
schme245
and what about types that are not structs, unions and enums?

1549377058
andrewrk
I see, let me try to clarify the wording

1549377229
schme245
in some parts of the documentation there's implicit reference/comparisons to C, which totally makes sense, but they can sometimes be hard to understand if you don't have a C background

1549377259
andrewrk
I'd like to improve those parts - ideally this document should stand alone

1549377280
andrewrk
people who have never used C are very much in the intended audience

1549377764
Akuli
if i have a function that takes an argument of type []const u8, how do i call it? myFunction("Hello") doesn't work

1549377794
andrewrk
how doesn't it work?

1549377807
Akuli
error: expected type '[]const u32', found '[5]u8'

1549377820
Akuli
hmmmm maybe i should have read that message

1549377845
andrewrk
it's ok, sometimes I do the same thing when asking for help in #llvm :)

1549378014
andrewrk
schme245, how's this?

1549378169
companion_cube
are blocks able to return values, like proper expressions, without the label: break thing?

1549378207
andrewrk
companion_cube, you have to use labeled break syntax to take advantage of blocks as expressions

1549378226
companion_cube
is there a reason for that choice?

1549378259
andrewrk
sounds like you may be interested in

1549378374
andrewrk
the reasoning is: we do need labeled break for some things. you can use labeled break for blocks as expressions, so that works today. and then the final decision has not been made yet about whether there is a shorthand for simpler expressions

1549378386
companion_cube
I'm not sure I understand why `{foo; x}` can't be the value of `x`

1549378401
andrewrk
it used to be that way

1549378404
companion_cube
(there seems to be a lot of inspiration from rust in Zig, so that would seem natural)

1549378431
andrewrk
one issue was that it lead to inconsistent code for function body blocks

1549378452
andrewrk
fn foo() void{ return x; } vs fn foo() void{ x }

1549378502
andrewrk
there's probably a closed issue lying around with more reasoning on it

1549378517
companion_cube
fn food() void { x; }

1549378621
companion_cube
(I admit that `void`, as a concept, has always seemed super weird to me, unlike `()`)

1549378727
halosghost
companion_cube: what makes `void` weirder than `()` (which I'm presuming you're using to refer to unit)?

1549378765
companion_cube
well, void doesn't have values, yet you can return it (?!)

1549378792
companion_cube
unit has a single value, so it's easy to tranform `fn foo() unit { x; }` into `fn foo() unit { x; () }` as rust, OCaml, etc. do

1549378872
halosghost
that's fair

1549378911
halosghost
I guess it has always felt natural to me because I started in C and it just seemed like the type-level version of NULL

1549378956
halosghost
I suppose I also really like that unit (depending on the language) can map to the empty tuple

1549378985
andrewrk
companion_cube, void is the unit type in zig. fn foo() void { } is secretly translated to fn foo() void { return void{}; };

1549379057
andrewrk
(`void{}` being the only value of type `void`)

1549379175
companion_cube
ah, so it's unit, ok

1549379192
halosghost
simplifies that :)

1549379194
companion_cube
(so then you can have a distinction between `x;` and `x`)

1549379268
Akuli
halosghost, not a zig question anymore but i'm curious, what do you think about 1-element tuples then? :D if you like 0-element tuples and tuples with >=2 elements

1549379317
halosghost
Akuli: 1-element tuples don't bother me. Actually, I find them to be a reasonable approximation/alternative to OOP langauges' boxing

1549379320
companion_cube
you can optimize (T,) into T quite easily :)

1549379350
halosghost
companion_cube: which is a little like auto-{un,}boxing

1549379370
Akuli
hmmm this turned into #proglangdesign

1549379374
halosghost
Akuli: above almost everything else, I prize consistency

1549379385
halosghost
when languages manage consistency, it makes me very happy

1549379395
companion_cube
can you talk about a language at version 0.3 without talking about design? :)

1549379416
halosghost
companion_cube: personally, I find it hard to talk about any language without talking about some aspect of design :P

1549379448
companion_cube
right.

1549379521
Akuli
better ideas?

1549379683
Akuli
nevermind, i figured it out

1549379703
Akuli
const arr = []u32{ 'P', 0xf6, 0xf6 }; then std.mem.eql(u32, thestuff, arr);

1549379802
Akuli
const arr = []u32{ 'P', 0xf6, 0xf6 }; then std.mem.eql(u32, thestuff, arr);

1549379803
Akuli
oops

1549380291
schme245
andrewrk: that's much more clear! the one thing that I still find confusing is the test name: "pass aggregate type by non-copy value". the section above mentioned that the thing can be passed either by value or reference, so calling it "non-copy value" muddles that up a bit IMO

1549380318
andrewrk
schme245, thanks, I'll change that and then push

1549380415
schme245
great, thanks!

1549380775
forgot-password
Regarding schme245's pass-by-value discussion: I haven't really figured out when I can just return something from a function and when I have to allocate it on the heap.

1549380817
forgot-password
I have a function which returns a struct with two slices. When I pass the result of this function to another function, however, it seems like the data got partially corrupted.

1549380839
andrewrk
forgot-password, you have to think about where your bytes are. slices are reference types - the bytes are somewhere else

1549380841
forgot-password
I assume that's because I shouldn't be using that memory anymore and something else has written over my intial data.

1549380888
andrewrk
if you return a struct with 2 slices, then that raises the question - where are the bytes that the slices are pointing to?

1549380902
forgot-password
That makes sense

1549380920
andrewrk
one possible answer to that question is: on the heap. And when you're done with the struct, you have to free them

1549380943
andrewrk
another possible answer is: global constants. no need to free

1549380989
andrewrk
Rust makes you answer this question at compile-time. In Zig you have to answer this question at runtime, with potentially disastrous consequences if you mess it up

1549380997
forgot-password
And if they are on the stack the data is basically unusable as soon as the function returns, right?

1549381010
andrewrk
correct

1549381075
andrewrk
I plan to look into improving debug runtime safety checks to be able to detect dangling references to stack data

1549381093
andrewrk
that will be a fun research project

1549381127
forgot-password
The thing is, I fully understand what you are telling me, but I feel like it's a whole different beast to actually apply that in your code...

1549381170
schme245
forgot-password: what's your language background?

1549381180
andrewrk
sounds like you're all set then, just need some practice :)

1549381254
forgot-password
schme245: 99% gc languages. I do Web-Stuff for work, but in my free time I love to play around with Haskell and Zig :)

1549381281
schme245
haha, then we're on the struggle bus together :D

1549381291
schme245
I think the way to learn to apply this in the code is to just make all the mistakes

1549381312
forgot-password
I figured that from your questions the other day :p

1549381318
forgot-password
Yeah, seems like it

1549381321
andrewrk
valgrind is a nice tool, don't be afraid to use it (you'll have to use the --no-rosegment workaround for now though)

1549381327
schme245
dangling pointer to stack data, overflow the stack, forget to free etc etc... everytime you make a mistake you learn something and you remember it for the future

1549381337
Akuli
forgot-password, you could pass a struct as a pointer to the function and have the function modify it

1549381346
forgot-password
I'm using lldb, is that any different? Afaik valgrind is for memory-related stuff, right?

1549381394
andrewrk
valgrind decompiles your machine code, instruments it, and then JITs it, and detects a lot of mistakes, printing useful stack traces

1549381404
andrewrk
it's also instrumental in leak checking

1549381457
schme245
speaking of, what do you suggest for profiling Zig code?

1549381476
forgot-password
Akuli: Thanks, but I don't think that helps in my current situation

1549381496
andrewrk
schme245, valgrind does that too

1549381513
Akuli
valgrind does profiling? :D i never knew that

1549381541
emekankurumeh[m]
it's sad it only works on unix though

1549381548
andrewrk
videos are not for everybody, but I did a couple of streams on some topics relevant to you, schme245 and forgot-password

1549381565
andrewrk
Allocators & Memory Management:

1549381582
andrewrk
Using Valgrind and GDB to debug memory issues:

1549381596
andrewrk
Using valgrind for performance profiling:

1549381618
schme245
awesome, I'll check 'em out later tonight!

1549381647
forgot-password
andrewrk: Thank you !

1549390297
Akuli
is there a more elegant way to do this?

1549390581
Akuli
hmmm the errdefer is wrong

1549390592
Akuli
after the realloc, it would do a double free

1549390612
Akuli
i should define buf with var and then  buf = allocator.realloc(...) catch unreachable;

1549390837
andrewrk
Akuli, I think there's already a function that does that

1549390866
Akuli
i think i looked around in std/unicode and couldn't find it :D

1549390872
andrewrk
oh, it's for utf-16le, not fully decoded u32 codepoints

1549390879
andrewrk
you could use it for inspiration though

1549390925
Akuli
/ optimistically guess that it will all be ascii.

1549390939
Akuli
hmm this is the other way

1549390944
Akuli
let me find the correct function

1549390947
andrewrk
we have allocator.shrink for your snippet at the end there

1549390966
andrewrk


1549390968
Akuli
oo nice, i'm just used to doing this realloc thing in c

1549390997
Akuli
even though in c it's trickier because i need to check whether realloc returns NULL, and the only reliable way to actually free the original pointer then is a temporary variable etc :D

1549391020
andrewrk
the errdefer looks correct to me

1549391029
Akuli
it isn't

1549391037
andrewrk
why not?

1549391037
Akuli
there is code after the last line in my paste, think about what happens when that code fails

1549391053
andrewrk
I don't see anything that can fail after the alloc

1549391055
Akuli
realloc can return a different buffer than what was passed to it, so buf and new_buf aren't necessarily the same

1549391068
Akuli
this is only a part of my function :D there's more stuff below it

1549391080
andrewrk
I still think the errdefer is correct

1549391096
Akuli
if that stuff fails, the defer will free buf, but the buf was passed to realloc which may make it unusable

1549391120
Akuli
what the errdefer should do is to free the new buf that came from realloc

1549391182
andrewrk
you want: buf = allocator.shrink(u32, buf, i);

1549391187
andrewrk
the errdefer is correct

1549391191
Akuli
yes i do :D then it is correct

1549391208
Akuli
shrink is nice

1549391256
andrewrk
the whole point of defer/errdefer is that it can for the most part remain independent of the rest of the body of your function

1549391272
andrewrk
you can edit parts of a function without having to change everything

1549391286
Akuli
yes, and using the buf= shrink(buf) thing helps with that

1549391366
Akuli
if i do this:  const x = 'a';   what is the type of x? u8?

1549391387
andrewrk
try this: @compileLog(@typeOf(x));

1549391394
Akuli
ok :D

1549391443
Akuli
hmm comptime_int of course

1549392971
Akuli
is some_string[1..] like some_string+1 in c?

1549393011
andrewrk


1549393101
Akuli
i think it is :D

1549399898
Sahnvour
hi all

1549399916
Sahnvour
can anyone explain to me what

1549400080
andrewrk
Sahnvour, yes, it tries every PATH directory looking for the executable

1549400190
Sahnvour
andrewrk: I see, but I miss something to understand why the return of a !void function (windowsCreateProcess) is used in the `if` where it was previously handled with `catch` ?

1549400215
andrewrk


1549400224
andrewrk
I should break this code up a bit, but look at the "if error union" test

1549400423
Sahnvour
thanks

1549400491
gamester
I just tried the newly added Serializer and Deserializer and they're great! Cool improvement over C++ (though C++ may catch up with reflection coming up). The only problem I had was when I tried to use a NullOutStream with it because it's "Error" is simply "error{}" and this doesn't work with the "try" syntax it seems, so you get the following error inside the Serializer:

1549400495
gamester
"function with inferred error set must return at least one possible error"

1549400538
gamester
Anyway I'm currently tethering my PC to my phone and its not working so great so im going to be offline mostly

1549400545
andrewrk
gamester, you can thank MajorLag for those new APIs. There are a few ergonomic issues with error sets, not done with design iterations on those

1549400559
andrewrk
you have to be careful serializing errors anyway since the error codes are not stable across different builds

1549400604
andrewrk
if the code is trying to auto serialize an error, it should probably do it based on the name

1549400649
andrewrk
oh, I see the problem you are describing is not what I am talking about

1549400654
andrewrk
sorry

1549400688
gamester
yeah the problem is simply when you attach the Serializer to a NullOutStream

1549400775
gamester
to be more precise, Serializer takes a comptime Error: type and it can't be "error{}"

1549400961
gamester
I'm sorry, I mean it can't be NullOutStream.Error, which is error{}

1549401010
gamester
andrewrk: yes I've seen on github that error sets are still being worked on / there are known pain points. Anyway, thanks MajorLag for the great library!

1549401637
andrewrk
there has got to be a bit twiddly way to "align forward" without remainder division and branching

1549401658
andrewrk
addr = alignForward(addr, 8);

1549401700
andrewrk
7 -> 8, 8 -> 8, 9 -> 16, 10 -> 16, ... 15 -> 16, 16 -> 16, 17 -> 24, etc

1549401887
gamester
here's what I was talking about:

1549402103
nbjoerg
andrewrk: (addr + alignment - 1) & (~alignment - 1) ?

1549402115
nbjoerg
assuming alignment is power of two

1549402134
andrewrk
ahh that's it

1549402138
andrewrk
stealing that

1549402179
gamester
I have two places where I can use that, nice

1549402288
rohlem
nbjoerg, andrewrk: Hmm, I've been using: ((addr - 1) & ~(alignment - 1)) + alignment

1549402312
shachaf
Oh, that's ~(alignment - 1), not (~alignment) - 1

1549402316
shachaf
That makes more sense

1549402350
rohlem
I can say that my variation has worked in production so far, though I've not stress-tested it since inception...

1549402432
nbjoerg
my variation is classic round up, e.g. the equivalient of (addr + alignment - 1) / alignment * alignment

1549402470
nbjoerg
your's is not wrong, just a bit stranger to read :)

1549402475
rohlem
Okay, whether you add alignment first or later doesn't make a difference with wrapping arithmetic, overflowing in both scenarios.

1549402522
nbjoerg
and yeah, should be ~(alignment - 1)

1549402541
andrewrk
and in zig syntax, ~(alignment -% 1)

1549402550
nbjoerg
but works fine in C at least due to operator order :)

1549402563
andrewrk
err, wait that doesn't actually matter, my mistake

1549402565
rohlem
andrewrk: Actually, I don't think wrapping it is expected behaviour.

1549402580
rohlem
andrewrk: I'd advise leaving the alignment >= 1 check in.

1549402587
nbjoerg
wrapping can only happen if you allow alignment of 0

1549402588
andrewrk
agreed

1549402591
nbjoerg
which is typically a bug

1549402704
rohlem
If address space is wrapping then the addition should be made wrapping, but I don't think that's a safe assumption generally.

1549402725
rohlem
Actually, is wrapping pointer arithmetic implemented / allowed status-quo?

1549402807
andrewrk
status quo, pointer arithmetic is safety-checked undefined behavior if it wraps. I'd have to double check to make sure we have a test covering this

1549402843
andrewrk
hmm no test for it. I'll open an issue at least until we have test coverage

1549402859
rohlem
So operators +% and -% result in an error?

1549403231
andrewrk
yes: error: integer value 1 cannot be implicitly casted to type '[*]u8'

1549403306
andrewrk
status quo, if the addition would wrap the address space, then it invokes undefined behavior and there is no safety check for it

1549407400
MajorLag
gamester: I thought I'd accounted for empty errorsets in serialize, but I guess I missed it. I'll take a look at it when I get home and do a PR to fix. I suppect it will be a 5 character diff.

1549407545
MajorLag
...yeah, I just need to not infer the error in `serializeInt`.

1549407608
MajorLag
I got it right in the deserializer, probably because SliceInStream.Error is error{}.

1549407670
Sahnvour
what's the idiomatic way to concatenate two strings (one being comptime) ?

1549407731
andrewrk
where do you want the resulting bytes to live?

1549407921
andrewrk
std.fmt.bufPrint will put them in a slice. std.fmt.allocPrint will give you a slice of heap memory

1549407941
andrewrk
if you have a stream you can use the print method

1549407956
andrewrk
all of these will let you do "{}{}", a, b

1549407995
Sahnvour
I don't really know yet, now that you ask

1549408159
Sahnvour
I'm in build.zig, just saw that there's already a fmt utility in there

1549408196
Sahnvour
but it seems like it's allocating a lot of strings and never freeing them ?

1549408220
andrewrk
yeah, that's going to be fine because it's a build script - you run it once and then everything gets freed when the build exits

1549408700
Sahnvour
I see, thanks

1549410852
daurnimator
andrewrk: speaking of valgrind... there's some PRs that need merging :)

1549410880
andrewrk
working on it

