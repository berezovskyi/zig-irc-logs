1565223585
fubd
has anyone made a minimal imgui-like in zig yet?

1565223591
daurnimator
sorry all; have been out sick for a couple of days

1565223742
daurnimator
anything good I missed in scrollback?

1565223781
Tetralux
asyncfn semantics back and forth

1565223800
Tetralux
talk about 'defer return'/'defer try' xD

1565224121
scientes
fubd, if you mean imgur, there is no networking

1565224149
fubd
scientes: I meant more an immediate mode UI library, like the kind useful for example, games

1565224160
fubd
like

1565224184
scientes
dimenus is working on a vulkan library IIRC

1565224204
scientes
I'm also working on SIMD

1565224214
daurnimator
someone was working on sokol

1565224218
scientes
which would be essential for ray tracing

1565224269
scientes
daurnimator, what is sokol, all I can find is what it was named after

1565224280
daurnimator
scientes:

1565224283
scientes
looks similar to YMCA

1565224357
scientes
oh i see, its a pun on vulkan

1565224415
scientes
oh, vulcano != vulture

1565224476
scientes
qt6 is also writing a graphics api compat layer

1565224491
scientes
there are so many of them!

1565224554
daurnimator
qt? no thanks. although its the best, you really

1565224581
scientes
C++17 too

1565224587
daurnimator
I was so hopeful for libui (

1565224676
daurnimator
I'm hopeful that letoram can suggest good UI primitives for zig....

1565224974
daurnimator
nrdmn: I don't understand in your uefi PR why you have the default values set to undefined

1565225118
fubd
I'm really missing odin's function overloading

1565225136
fubd
i find myself writing tons of wordyFunctionsThatLookLikeObjectiveC

1565225159
fubd
and not feeling like making comptime type switches for every overload is sustainable

1565225172
daurnimator
fubd: got some examples to share?

1565225204
scientes
fubd, and it doesn't work for optional arguments either

1565225205
daurnimator
fubd: note that you

1565225215
scientes
opt1: var, op2: var, op3: var

1565225219
fubd


1565225241
daurnimator
fubd: that looks like a good usecase for switching on the type of an argument

1565225243
scientes
daurnimator, unless its (comptime T: type .. @typeOf(T)

1565225262
scientes
or rather switch (T)

1565225336
scientes
what are those vector types? because you can write code that works with any vector length

1565225351
scientes
although I kinda need to make pointer arithmatic work for that...need to polish up the patch

1565225382
daurnimator
fubd: `fn setUniformInt(uniform_id: c.GLint, value: var) void { switch(@typeId(@typeOf(value))) { .Int => c.glUniform1i(uniform_id, value), .Float => c.glUniform1f(uniform_id, value), else => @compileError("invalid type to setUniform"), } }`

1565225387
fubd
scientes: struct { x: f32, y: f32, z: f32 }

1565225399
scientes
Vec3, Vec4...

1565225403
fubd
if I used something like data: [N]f32

1565225417
fubd
then everywhere I access the vector, I have to use my_vec.data[1]

1565225454
scientes
that isn't a vector

1565225474
scientes
use (comptime vlen: u32, v: @Vector(vlen, foo))

1565225526
fubd
I was scared away by the docs on using @Vector yet

1565225538
fubd
but if anyone has actual game code that is using it and wants to share examples I'd love to see

1565225544
fubd
s/game/anything

1565225548
daurnimator
fubd: yeah @Vector needs more work. scientes has been doing most of it.

1565225555
fubd
awesome :)

1565225623
scientes
I really need inferred return types to be implemented

1565225645
scientes
I know that can be a foot-gun, but it means that much more can be implemented in user-space

1565225665
fubd
oh yeah, i ran into that with something else...

1565225715
scientes
also, maybe someone could help with C ABI for @Vector

1565225825
fubd
daurnimator: one thing that nags at me about using :var for overloading is definitely that you use the clarity of seeing function types for each parameter in the function definition

1565225835
fubd
in odin you can just say

1565225836
fubd
foo :: proc{

1565225851
fubd
and then look to the definitions of each function for the possible matches

1565225872
fubd
i suppose having proper pattern matching could let you unpack types right in the first couple lines of a var function

1565225896
fubd
but yeah it definitely feels less readable/discoverable

1565225911
fubd
\/toolable

1565225924
scientes
yeah but the only "fix" for that is something like Haskell's type system, which honestly I don't understand

1565225959
scientes
this is kind of a side-effect of powerful comptime

1565226051
fubd
the syntax for explicit function overloading couldn't just write out the comptime function for a set of type switches?

1565226060
daurnimator
fubd: you might want to follow

1565226087
fubd
daurnimator: thanks, i'll dig into more of the active issues and try to contribute there too

1565226311
scientes
this is good

1565226365
scientes
because you can still use named

1565226366
scientes
its clear

1565226572
fubd
yeah I like that

1565226600
Tetralux
+10

1565226614
scientes
i just got something better

1565226616
fubd
now I'm deep into var-ifying this function, and i need a "is this thing stringlike" function

1565226622
scientes
not sure about the syntax though

1565226640
Tetralux
I don't use the explicit proc overloading very often in Odin, but when I do, I love it.

1565226650
Tetralux
If I had my way, we'd already have function overloading.

1565226653
fubd
i passed [4]u8

1565226653
scientes
we can just allow functions to be types

1565226659
fubd
but I compared to

1565226661
fubd
if (@typeOf(uniform) == []const u8) {

1565226666
scientes
the problem is getting a handle on the current function

1565226693
scientes
but i guess the "overload" keyboard is exactly that

1565226702
scientes
except we could split the matching from the execution

1565226743
Tetralux
I'm not sure I like the idea of anon fns with overloading like in that comment.

1565226751
Tetralux
I'd rather they just be named

1565226792
Tetralux
pub const init = overload { initNamed, dup }

1565226796
Tetralux
Or even

1565226803
Tetralux
pub fn init = overload { initNamed, dup }

1565226818
Tetralux
Then it's easier to change from no overload, to two overloads.

1565226845
Tetralux
Though the former is perhaps more important.

1565226861
scientes


1565226874
Tetralux
It's depends on how much syntax you save from changing when you change it.

1565226943
Tetralux
It's not clear why burying what's happening from the compiler is useful for that.

1565226994
Tetralux
How are tools meant to determine the overloads if they can't just be told by the compiler?

1565226995
Tetralux
Besides which, having 'overload {}' makes parsing all you need to do to discover it.

1565227564
Tetralux
I actually quite like `fn { overload1, overload2 }` .. quick to type - easy to understand, surely?

1565227611
daurnimator
Tetralux: I'm not a fan.... requires a lot of context to understand

1565227631
Tetralux
A lot of context? You mean like is it `fn(` or `fn{` ? xD

1565227657
Tetralux
Gotta say - that seems fairly trivial to me.

1565227662
Tetralux
Did you have a specific example in mind?

1565227734
daurnimator
Tetralux: like... why would that not be an array initialiser of functions?

1565227756
daurnimator
i dunno, it just looks quite close to other things to me.

1565227765
Tetralux
Wouldn't functions need to have the parens `fn()` so that you know it takes no args?

1565227793
daurnimator
no? it could be referencing functions in scope

1565227803
daurnimator
the only difference would be [_] preceding it

1565227874
Tetralux
I mean, if you have fns that have different signatures -- or the same for that matter -- and you wanted to store them in a typed array, you would not be able to specify them as the eltype because the signature is part of the type.

1565227898
Tetralux
But also, `fn` is not a function pointer, `*fn` is.

1565227994
scientes
Tetralux, did you look at my proposal?

1565228009
Tetralux
scientes: You mean

1565228015
scientes
yes

1565228027
Tetralux
It's not too bad.

1565228030
scientes
the way of having a function without a type signature, not sure about that

1565228047
scientes
`naked` is a similar concept

1565228069
Tetralux
Maybe you get around it with `.{initWithString, initWithSelf}`

1565228099
scientes
no, don't need new syntax

1565228113
Tetralux
Yeah, but we're getting that syntax anyway right.

1565228142
Tetralux
the `fn {` seems weird in that though.

1565228150
scientes
now its naked fn() {

1565228154
Tetralux
`init = fn {` that is.

1565228160
scientes
init = naked fn() {

1565229978
nairou
So this is confusing... I wrote a build.zig to compile an existing C-only program (no zig code). Compiles fine, but immediately crashes when run. I try to debug it, and the very first thing it does (before even reaching main) is hit a panic. zig code. "Cannot access memory at address 0xfffffffffffffff8". I'm not sure where to start with this. Why is there zig code in here? What would cause it to crash before it even began?

1565232974
Tetralux
scientes: Maybe you could do something more like `pub const init = std.dispatch.overload(@This(), .{initWithString, initWithSelf});

1565232978
Tetralux
Still though.

1565232990
Tetralux
nairou: That's a weird one.

1565236123
andrewrk
nairou: you can start with --verbose-cc

1565236136
andrewrk
And --verbose-link

1565236177
andrewrk
You can try substituting the system linker, or you can try substituting clang, or you can try changing flags to narrow down the issue

1565236232
andrewrk
When you say it hits a panic in zig code, where do you see zig code? Can I see the error message?

1565236263
fengb
andrewrk: should aliasing builtins be supported? `const smallNoInlineCall = @noInlineCall;`

1565236315
andrewrk
fengb: there are a lot of problems with that

1565236379
andrewrk
As a workaround for your use case for now can you put your call/inline call in an if statement?

1565236414
fengb
Yeah, I was gonna write a proposal for @call but that wouldn't be useful without aliasing

1565236587
andrewrk
best thing to do is to detail your use case. you'll at least get something recommended of how to do it

1565237025
fengb
Sounds good thanks

1565237074
daurnimator
fengb: aren't you after something like: `const callFunc = if (builtin.mode == .ReleaseSmall) @noInlineCall else @call; callFunc(myfunc, arg1, arg2)`

1565237176
emekankurumeh[m]
with @call we can remove @noInlineCall, @inlineCall and @asyncCall. perhaps @newStackCall as well.

1565237227
daurnimator
I think a solution to this should consider

1565237936
fengb
daurnimator: yes but I can’t alias builtins so adding @call doesn’t fix things :/

1565238065
daurnimator
fengb: indeed. however you can hack something up using my stupid workaround in that issue :p

1565238080
fengb
My current solution is to have a inline wrapper func to do the dispatch but it looks clunky

1565238096
fengb
But less clunky than your proposal lol

1565238131
daurnimator
fengb: I was more suggesting that your wrapper func could be more 'universal'

1565238144
emekankurumeh[m]
#2930 should be fixed by tuples/anonymous structs right?

1565238176
daurnimator
emekankurumeh[m]: tuples might get us closer (or might not): but still need the "arguments of function X as tuple" function.

1565238193
daurnimator
I was also meaning to experiement with varargs to see if that 9 argument limit could be fixed with some recursion

1565238279
fengb
I think we all have a different idea of what @call should do :/

1565238317
emekankurumeh[m]
well if we are removing varargs then a anon struct is the way to go right?

1565238341
daurnimator
emekankurumeh[m]: how does an anon struct solve the issue?

1565238378
daurnimator
emekankurumeh[m]: for 2930 the question is how to call a function with an arbitrary number of arguments.

1565248208
gonz_
04:10:50 <Tetralux> If I had my way, we'd already have function overloading.

1565248238
gonz_
If everyone had their way with one thing we'd have everything.

1565248328
gonz_
Overloading is obviously popular, I'm not discounting that. Most bad features that complicates languages at the very least start out popular enough to be implemented.

1565248397
gonz_
This is why I was trying to stress values as an up-front thing a while ago. If you have certain values that you can point to and say "These things are more important than X, and this compromises them" it's much easier to coalesce on these kinds of things.

1565248421
gonz_
But also to actually have concrete examples would be good.

1565248543
gonz_
It would be more helpful if people could infer easily that "my unwillingness to type 10 lines is not as important for zig as the willingness to keep odd keywords and complication out of it"

1565254161
mq32
hey

1565255756
samtebbs
mq32: o/

1565255865
mq32
i had a realization the last days:

1565255916
mq32
if zig gets both the function literals (#1717) and the proposed object semantics (#2938), making closures would be quite elegant via interfaces

1565255994
mq32
having a generic interface Callable(T:type) that has only one function "invoke" with the same signature as T

1565256009
mq32
a closure could then be an object that just implements this interface

1565258679
samtebbs
Then you'd need to figure out how capturing would work

1565258719
samtebbs
You could go with the C++ route and make each "closure" a struct that has a field for each variable captured, and then assign to those fields when creating the closure

1565258742
samtebbs
The suitability of that to Zig is up for debate though

1565258793
mq32
it seems like the only possible way to do so

1565258809
shachaf
D has a nice feature for closures that are only used while a stack frame is active, where captures are made relative to the stack frame.

1565258845
mq32
that only works when you have stack frames

1565258898
shachaf
Yes, it's not suitable for general closures.

1565258907
mq32
samtebbs: the idea behind this interface thing is: i

1565259023
mq32
let's say we capture everything by-value, but expose the captured variables as pub struct fields

1565259097
mq32
var counter:i32 = 0;

1565259102
mq32
var closure = fn() i32 { counter += 1; return counter; };

1565259105
mq32
_=closure.invoke(); _=closure.invoke();

1565261667
samtebbs
Looks good to me

1565263736
daurnimator
what if closures took a @Frame?

1565264366
mq32
daurnimator: i don't think @Frame and closures are compatible without doing more hacks

1565264443
daurnimator
Aren't @Frames essentially a struct of local variables to a function?

1565264481
daurnimator
I guess with a closure you'd want to refer to multiple parent scopes...

1565264614
mq32
it depends on how @Frames are generated

1565264638
mq32
if they capture all local variables, it would be inefficient because closures can allocate all local variables on the stack and require only the captures to be stored

1565264766
daurnimator
mq32: I would think that they are a union of all local variables in scope at the various suspend points

1565264784
daurnimator
though now I'm having some memories bubble up of that time I implemented closures in another thing...

1565264790
daurnimator
let me go read my old code for a min

1565264824
mq32
👍

1565264890
daurnimator
okay nope; that implementation used stack indirection. let me go check lua's which I've audited before...

1565264949
daurnimator
okay. lua's implementation is at least more translatable to zig; but it may violate the "hidden control flow" rule.... so we may need to make things explicit

1565264979
daurnimator
In lua,

1565265089
daurnimator
what does that mean? => closure always use values by reference; however, each variable in the closure has an additional "hidden-ish" field

1565265115
daurnimator
when a closure is "closed", then it swaps the reference from a reference to the parent's variable, to storing it in the hidden field

1565265236
daurnimator
Lets imagine the following zig code: `fn foo() (fn() i32) { var x = getx(); const bar = fn() u32 { return x; }; return bar; }`

1565265328
daurnimator
at the point

1565265356
daurnimator
mq32: ^ make sense?

1565265625
mq32
i'm trying to follow

1565265651
mq32
but if i understand correctly, this would require move semantics, right?

1565265679
mq32
(when the closure is moved(closed), the reference stored in the closure must update)

1565265728
daurnimator
yes.... though you may want to define what you mean by "move semantics"

1565265743
mq32
(moving the closure would require to change the captured reference)

1565265755
daurnimator
what do you mean by "moving the closure"

1565265772
mq32
copying/returning/otherwise changing its address

1565265798
daurnimator
we haven't got to "moving closures" yet (which is another topic we should get to). with the example above the value of `x` will get moved though

1565265873
mq32
so our closure requires to have some transparent field "x : *i32" and "x_backing_store : i32" and as soon as we close the closure, x will point to the backing_store, right?

1565265881
daurnimator
yep

1565265908
mq32
what value will bar reference, then?

1565265944
mq32
because returning the closure "bar" in the example will "change" the location of x

1565265964
daurnimator
ah yes. that's what you mean

1565265979
mq32
address of x_backing_store will change then

1565265982
mq32
also when i copy the closure value

1565265987
daurnimator
I haven't brought that up yet because copy elision semantics means we haven't hit that yet ;)

1565266006
mq32
heh

1565266017
mq32
assuming i would only use the return value at the point where i got it

1565266045
mq32
var a = make_closure(); var b = a; // this would break stuff

1565266061
daurnimator
mq32: well one thing is that it means the return value is a "fat function"

1565266091
daurnimator
==> it's more than a function pointer getting returned; it's a function pointer + the closed variables

1565266108
mq32
that's clear

1565266124
mq32
but we just said that we require a backing store for the closed variables

1565266129
daurnimator
so... what if it returned a value of type @Closure

1565266131
mq32
and a reference that may be changed

1565266198
mq32
imho for most usecases it would be sufficient to have "downward closures" (so passing them

1565266215
mq32
creating closures that allow this is easier (proposed solution is above)

1565266227
mq32
but: having full-featured closures would be still nice

1565266300
daurnimator
what would be the point of a "downward closure" as you call them?

1565266488
mq32
it's simpler in terms of memory management, implementation and explanation

1565266516
mq32
(because every captured variable just needs to be a pointer to the original var

1565266532
mq32
but that will not work if you leave your current stack frame

1565266725
daurnimator
I meant in terms of usage

1565266788
daurnimator
and also... I wouldn't call this a closure

1565266800
daurnimator
the whole thing about closures is the ... closing :P

1565266812
daurnimator
otherwise they're just "functions inside of functions" or something

1565266938
mq32
ah

1565266949
mq32
it's an improved callback thing

1565266972
mq32
so passing a compare function with dynamic comparison value

1565267037
daurnimator
So what if we had... `const bar = @Closure(somefunc); var x = bar.valueOf("x"); bar.close("x", &x);`

1565267084
daurnimator
mmm no. that wouldn't work well with the above example

1565273097
fengb
Do processors naturally span alignment boundaries? e.g. struct { a: u29, b: u6, c: u29 }

1565273431
daurnimator
'processors'?

1565273444
daurnimator
fengb: in general: no unless you use `packed`

1565273499
fengb
I mean can CPUs even access that type of data or should I split it out to pairs of u29 + u3 and merge the u6 together manually

1565273579
Tetralux
I feel like that version of a closure is WAY too overcomplicated for zig.

1565273617
fengb
This scrollback is long

1565273622
Tetralux
The idea of an interface for a closure is also a no-no. I hate FnOnce/FnMut in Rust. It's not clear what those names even mean at face value.

1565273632
Tetralux
Things should be trivial to understand by their transparency.

1565273650
Tetralux
Otherwise, it becomes like exceptions: I don't really know how it works, but it does.

1565273655
Tetralux
I'd consider that a bad thing.

1565273679
fengb
We need something like an interface if we have fat closures

1565273703
Tetralux
I'm not sure we even need closures.

1565273712
fengb
That's a different topic then

1565273722
Tetralux
Whereas, the embedded type semantics I'd probably use a decent amount.

1565273740
Tetralux
I'd rather have locally-defined fns than closures personally.

1565273802
gonz_
Tetralux: The issue is mostly that everyone has their own pet feature. I think I agree mostly with what you said but I also am skeptical that my personal feelings about "Things that would be nice to have" have much merit.

1565273854
Tetralux
I mean... things are emperically useful.

1565273869
fengb
Therefore C++ is the most useful >_>

1565273870
Tetralux
You can look at code that uses certain features.

1565273875
mikdusan1
Tetralux: what do you mean by "locally-defined fns" ? we already can define fns

1565273879
Tetralux
See how readable, understandable, and neat it is.

1565273889
gonz_
Tetralux: The usefulness of things can be less than the complication they add in the long run.

1565273898
Tetralux
And think about how features could be used, maybe gravitate usage towards the best one.

1565273900
Tetralux
etc, etc, etc.

1565273918
Tetralux
mikdusan1: I prepared a paste for that:

1565273943
Tetralux
The point being: The syntax is the same regardless of declaration scope.

1565273944
mikdusan1
ok so just sugar. we can do that today with struct.

1565273953
Tetralux
In

1565273965
gonz_
I keep harping on about explicitly stating values and here's where I think that's useful. Making clear what zig emphasizes and examples of what that encompasses is valuable.

1565273970
Tetralux
It just means "f is not visible outside this scope."

1565273994
Tetralux
But it's a static fn,

1565274035
fengb
I think anon functions need local definition semantics

1565274084
Tetralux
Wait - why would I want a struct in order to declare a fn locally?

1565274084
mq32
<Tetralux> The idea of an interface for a closure is also a no-no.

1565274090
Tetralux
That makes no sense xD

1565274124
fengb
Implementation detail. Functions can only go "inside" of structs

1565274141
Tetralux
An incorrect detail. xD

1565274165
Tetralux
That comment is somewhat tongue-in-cheek, since

1565274179
Tetralux
It's VERY clear what that paste does.

1565274192
mq32
why is that a no-no?

1565274232
Tetralux
We don't need anything so opaque, for one thing.

1565274245
mikdusan1
Tetralux: looks like sugar to me.

1565274262
Tetralux
mq32: I do not want interface things for fns.

1565274272
fengb
mikdusan1: we need it for anonymous functions to be remotely useful

1565274282
Tetralux
That's OOP

1565274289
mikdusan1
fengb: i know that

1565274312
Tetralux
f() should be a fn call.

1565274316
Tetralux
Not f.invoke.

1565274326
Tetralux
Only-one-way-to-do-things.

1565274332
mq32
yeah

1565274342
Tetralux
*fn(...), not Closure

1565274346
fengb
Um... Zig has OOP already, sorry to say

1565274364
mq32
but it will probably result in having two different function types

1565274370
Tetralux
It does - and I don't especially love that.

1565274384
mq32
that's what i want to solve with the interfacy-stuff

1565274392
Tetralux
But we have `if () {}` (the parens) so without it it'd be painful like C.

1565274398
mq32
it would be obvious if something takes a "callable" or a "function"

1565274402
mq32
which are different things

1565274418
Tetralux
It only really bothers me a decent amount when adding methods to a poly struct.

1565274428
companion_cube
Tetralux: what's x.f() though?

1565274440
Tetralux
Method or field call.

1565274449
Tetralux
Whereas without methods, it'd always be field call.

1565274451
companion_cube
so it's not really one way of doing things? :p

1565274466
Tetralux
Correct.

1565274486
companion_cube
@callable seems unavoidable if you want closures, but not anonymous functions

1565274488
Tetralux
Personally, I'd prefer UFCS than methods.

1565274491
Tetralux
But that's just me.

1565274492
fengb
I wonder if we should borrow some Lua there, i.e. different syntax for method call

1565274512
Tetralux
I like dot honestly.

1565274524
Tetralux
I'm not sure what else you'd put there.

1565274528
mq32
as long as we don't do PHP-Style (using -> for method call)

1565274532
Tetralux
I'm not a fan of ':' from Lua.

1565274537
Tetralux
xD

1565274538
companion_cube
mq32: so you're find with --> ?

1565274541
companion_cube
fine*

1565274544
mq32
a=>b()

1565274551
companion_cube
a~~>b()

1565274567
fengb
... I can't not read that as "a sperm into b"

1565274574
fengb
Embrace the inner 13 year old

1565274575
gonz_
a8===D~~~d()

1565274585
Tetralux
I'd honestly prefer -> over any of those xD

1565274604
companion_cube
a🍆b()

1565274623
fengb
What I mean is, "a.b" can sometimes stick the self variable as first arg

1565274625
Tetralux
a->f(), method call; a.f(), field call

1565274631
fengb
But it depends on field vs method

1565274645
fengb
If we had a different invocation type, there'd be no ambiguity

1565274654
daurnimator
there's an issue for that

1565274664
Tetralux
Either way, I care a lot less about that than I do about closures being sane xD

1565274683
daurnimator


1565274687
Tetralux
And I care a decent amount less about that than I do about composition.

1565274712
daurnimator
Tetralux: you have a weird definition of a closure if it doesn't close over anything

1565274734
fengb
Trips up newcomers that you have to do allocator.reallocFn(allocator, ...)

1565274742
Tetralux
I don't consider non-capturing local functions, closures.

1565274749
Tetralux
But they fill the same role for me.

1565274755
Tetralux
I don't need closures if I have those.

1565274772
mq32
it's definitly a different thing

1565274773
Tetralux
But they're a helluva lot simpler than closures though.

1565274777
daurnimator
fengb: see just above in my link for my issue...

1565274792
Tetralux
mq32: Different, but not

1565274800
daurnimator
Tetralux: very different...

1565274800
Tetralux
Just 0-captures vs >0-captures.

1565274805
mq32
i meant closures and function literals

1565274821
daurnimator
and I believe function assigning syntax is accepted

1565274824
mq32
syntactically not much, but semantically

1565274829
daurnimator
so Tetralux you already have your feature coming

1565274845
Tetralux
I'm not sure I like the idea of having to do

1565274851
fengb
daurnimator: I was actually thinking the other direction. a:foo() always invokes as a.foo(a) whereas a.foo() never does

1565274864
Tetralux
`pub const f = fn(args...) returnType {}`

1565274866
Tetralux
everywhere.

1565274871
Tetralux
vs

1565274872
mikdusan1
daurnimator: in that proposal, i wonder when a->b() and a.b(), if compiler should emit shadowing error?

1565274877
Tetralux
`fn f(args...) returnType {}

1565274887
daurnimator
mikdusan1: that would be one solution

1565274959
mikdusan1
personally i prefer a:foo() over a->foo() . the "extera vertical dot" is clear enough that something extra is happening.

1565274974
daurnimator
Tetralux:

1565275061
fengb
There's also a⫶foo()

1565275068
fengb
lol that looks like a smudge on my screen

1565275089
mikdusan1
a→Foo()

1565275118
mq32
a»foo()

1565275137
daurnimator
a⇒foo()

1565275193
daurnimator
which could be pass 2 arguments automatically

1565275202
daurnimator
or a⭆foo() to pass 4 arguments ;)

1565275393
rsdimenus
has anyone done a stack allocator in zig  yet?

1565275408
daurnimator
rsdimenus: huh? what do you mean by that?

1565275418
daurnimator
rsdimenus: just use a FixedBufferAllocator on some stack allocated memory

1565275431
Tetralux
Is the idea for interfaces that they are an comptime-only thing that doesn't make it to machine code?

1565275444
Tetralux
Or are they really more a Go-like thing?

1565275481
fengb
We probably need something like vtable dispatch

1565275489
Tetralux
That sounds awful.

1565275493
scientes
ehhhh

1565275502
scientes
i don't want a runtime

1565275516
fengb
You don't but people do

1565275520
daurnimator
tiehuis has gone through 4 or 5 different interface proposals

1565275524
daurnimator
you should have a look at them

1565275540
Tetralux
I'd rather it was just the structs that implement the interface and the interface it just a way of saying "yes, this struct must have these methods" or something.

1565275550
fengb
tgschultz also has some ideas

1565275579
gonz_
rsdimenus: There is a `StackFallbackAllocator` in `std.heap`

1565275625
daurnimator
oh right sorry it was tgschultz not tiehuis

1565275652
mq32
comptime solution for interfaces is quite restricted and we already have that (just pass a var parameter and validate it's interface)

1565275664
rsdimenus
gonz_: thanks that's what I'm looking for I think

1565275667
fengb
Current ideas are keeping it in userland unless proven otherwise

1565275687
gonz_
rsdimenus: I suspect so too, but honestly I have neither used it nor really read the source, I've just seen it in passing.

1565275714
fengb
@fieldParentPtr can be used as an adhoc interface, but it's a slight footgun

1565275730
fengb
That's how we currently do it and it works, but there's a few issues

1565275760
rsdimenus
basically i just have a bunch of work to do in a function and I want to free the whole chunk in a block

1565275770
daurnimator
fengb: I've been messing around in traceback generation and the current Steam/SeekableStream interface is

1565275776
mq32
fengb: vtable-interfaces would require a "fat pointer" with pointer+vtable

1565275778
daurnimator
rsdimenus: that's ArenaAllocator

1565275821
fengb


1565275822
gonz_
Yeah, you can just set up the arena at the top, defer `deinit` and just allocate wildly

1565275841
fengb
Here's the idea I like the most right now but it also has a hidden footgun

1565275879
rsdimenus
it's kind of a combination of both, I could have a top level arena allocator and a stack allocator below it

1565275891
rsdimenus
because eg if I'm reading a file, I only want one open at once anyway

1565275895
rsdimenus
so I should be able to reuse that memory

1565276238
fengb
Sorry, I didn't mean vtable specifically. But we do need dynamic dispatch for libraries

1565276353
mq32
fengb, is there a simple example on how to use that pull request?

1565276489
fengb
Definition:

1565276490
fengb
Consumption:

1565276542
fengb
It's very similar to how we do @fieldParentPtr, but with an explicit wrapping instead of pointer math to break into the parent

1565276724
mq32
ah yeah

1565276729
mq32
it's pretty much just vtable stuff

1565277031
mq32
i rather have a fat pointer than having the stuff that c++ does

1565277059
fengb
Well I don't know what C++ does >_>

1565277083
mq32
they prepend a vtable pointer to a struct if it inherits virtual functions

1565277108
mq32
so struct X : Y { int x; } gets struct { Y::vtable_t * vtable; int x };

1565277112
fengb
I don't really want inheritance

1565277176
mq32
object inheritance or interface implementation/inheritance?

1565277182
fengb
Oh I see

1565277203
fengb
Object inheritance

1565277243
mq32
yeah. C++ can't differentiate between interfaces and classes

1565277259
mq32
if you implement multiple interfaces, it starts to get weird

1565277294
mq32
Object o; InterfaceA * a = &o; InterfaceB * b = &o; if((void*)a == (void*)b) // fails

1565277306
mq32
same object, different pointer

1565277311
mq32
because of vtable offset

1565277319
mq32
(pointer to interface vtable must be at offset 0)

1565277375
fengb
I prefer Go interfaces or Rust traits, or even status quo manual vtable like generic interfaces

1565277389
fengb
Although I do think a fat closure could solve it more elegantly

1565277420
mq32
go interface is duck typing?

1565277448
fengb
Defined duck typing yeah

1565277461
mq32
"if it looks like a duck and walks liks a duck, it's a duck" :P

1565277475
mq32
so: if the struct implements all required methods, it can be cast to that interface

1565277478
fengb
Structural typing, not nominal

1565277486
fengb
Yeah

1565277508
mq32
i'm more the fan of explicit stuff, but i can understand why that is appealing :)

1565277523
mq32
can i store references to go interfaces?

1565277554
fengb
no, they only have method definitions

1565277602
fengb
I actually kinda prefer Zig status quo. You have a "generic" struct you cast into

1565277620
fengb
But there's a loss of flexibility if you only need a partial interface

1565277659
mq32
<fengb> no, they only have method definitions

1565277663
mq32
that's not what i meant

1565277677
mq32
but i just checked with a online go compiler and it "works"

1565277700
fengb
Oh I totally misunderstood your question

1565277717
fengb
I thought you said "can i store references

1565277743
mq32


1565277756
mq32
tiny words can make huge difference

1565277803
mikdusan1
weakness with go is looking at a struct and it's implementation, how do you tell that oh this struct conforms to an interface by... you know... looking at the code

1565277846
mq32
mikdusan1, yeah i prefer the explicit statement: "i want to implement this interface" better

1565277855
fengb
But the strength is you can define adhoc partial interfaces and don't need to muck around with consumed code

1565277857
mq32
rust does that for traits with separated blocks

1565277884
mq32
fengb: yeah i can see that point beeing a good argument

1565277970
fengb
Hey wat, you're not allowed to agree with me on the internet

1565278029
mq32
ha! i'm breaking the law of the internetz!

1565278129
mq32
i really like that we can explore programming language concepts here without everyone saying: "this is stupid"

1565278163
companion_cube
mq32: this is stupid

1565278171
mq32
kek

1565278173
companion_cube
(don't thank me)

1565278189
scientes
mq32, hehe

1565278199
scientes
I got good feedback on my SIMD questions here

1565278205
fengb
There are no bad ideas, only tradeoffs

1565278209
scientes
it was much faster than github

1565278230
companion_cube
I don't know, I feel like some things truly are bad ideas

1565278239
companion_cube
like auto coercions à la JS' ==

1565278239
mq32
fengb: we could do a malloc on every local variable we have and store them in a malloc'd frame for every function call!

1565278249
fengb
I'm trying to be nice :(

1565278253
companion_cube
:D

1565278269
mq32
companion_cube: I can find positive arguments for the == thing :D

1565278299
mq32
oh and another one: we could make the default number type a 16 bit half-float!

1565278304
mq32
got to go

1565278347
fengb
The only number type

1565278366
companion_cube
why not f17? 🤔

1565278367
fengb
Okay, let's remove JS from the equation >_>

1565278506
scientes
yeah lets do NAN packing for no reason at all :)

1565278513
scientes
even though we don't have a gc

1565279500
rsdimenus
does linux append a newline to files on disk automatically?

1565279502
rsdimenus
or maybe vim does?

1565279508
fengb
vim

1565279530
scientes
i had to set vscode to add those because daurnimator was giving me grief :)

1565279547
fengb
Linux kernel doesn't care about terminating newlines but a lot of userland utils do

1565279550
rsdimenus
why would it automatically append a newline?

1565279552
rsdimenus
ah

1565279587
fengb


1565279593
fengb
Also it's the posix standard apparently

1565279603
companion_cube
so… an empty file is invalid?

1565279627
fengb
Just text files

1565279638
fengb
And only posix purists

1565280561
rsdimenus
that's just an annoying feature/bug

1565280567
rsdimenus
imo

1565281153
rsdimenus
ah, the bug was actually with SplitIterator

1565281161
rsdimenus
it was returning true for an extra loop than it should have

1565281485
andrewrk
rsdimenus, double check those docs

1565281507
andrewrk
you might be getting mem.separate and mem.tokenize mixed up

1565281546
rsdimenus
no, i can see the docs say that it should return null

1565281549
rsdimenus
but it doesn't

1565281588
rsdimenus
if start and end are both 0, it still returns a valid slice not the '

1565281592
rsdimenus
null value

1565281636
nairou
andrewrk, you asked last night what the error was when my C-only program panics in zig code when I run it. Here's what I see in gdb:

1565281639
andrewrk
looks like that behavior is documented in a test case

1565281689
andrewrk
nairou, can I see your build script?

1565281772
andrewrk
I'm guessing you're running an old binary that didn't get updated as you thought it did

1565281812
nairou
andrewrk:

1565281827
nairou
I delete zig-cache before builds, to be safe

1565281857
rsdimenus
andrewrk: my apologies, of what use is the first scenario?

1565281862
rsdimenus
eg an empty string

1565281894
andrewrk
nairou, I'm pretty sure you depend on libc

1565281898
andrewrk
but you're not linking it

1565281968
andrewrk
linkSystemLibrary with "dl" "m" "pthread" those are all part of libc. delete those and uncomment your linkSystemLibrary "c"

1565282016
nairou
andrewrk: Thanks. I had that line uncommented before and got all sorts of other linker errors, but now I'm thinking I might know what the other errors come from. I'll try that, thanks.

1565282036
rsdimenus
nevermind, I get it. sorry false alarm!

1565282047
andrewrk
no worries rsdimenus there are plenty of bugs so your paranoia is justified

1565282104
rsdimenus
tokenize is the right one for line parsing, eg tokenize(file_slice, "\r\n")

1565282105
nairou
Yup, that did the trick, after fixing the other link error. Woot

1565282190
andrewrk
rsdimenus, yes and the other one is good for deserializing, e.g. CSV

1565285604
mq32
andrewrk, do you have a plan when you stream next?

1565285654
nairou
Yeah I've been loving the status update streams

1565285753
andrewrk
planning to do one today at 17:00 EDT (3.5 hours from now)

1565285802
mq32


1565289946
Akuli
midnight here in finland, lol

1565291901
lunamn
are there plans for a future 'zig build test' where the test build links against the libraries in build.zig?

1565292096
andrewrk
lunamn, you can already do that

1565292124
andrewrk
have a look at zig's own build.zig for example

1565292167
lunamn
oh i see so not given by default, gotcha

1565295971
rsdimenus
how do you debug the zig compiler? gdb detaches after the child process is spun up

1565296019
Tetralux
theres a child process?

1565296044
andrewrk
any time a child process is spawned and crashes, zig will print out the command line of it so you can debug it directly

1565297580
andrewrk
I'm going to start the stream soon

1565302324
mq32
stream broke down and i got to go

1565302335
mq32
but: andrewrk, the stuff you showed looks very promising

1565302388
andrewrk
I see what you did there

1565302410
fengb
Maybe you could sync up later?

1565302615
Firefox317
Yeah you were about to run the cool code ;(

1565302636
mq32
cool_demo = await stream_frame;

1565302660
vramana
Can you some explain typeToId function here

1565302727
andrewrk
oh did the part where it produced invalid LLVM not show up?

1565302802
Firefox317
Nope you didn't run any of the file url download example

1565302818
Firefox317
Before that the stream already went down

1565302897
andrewrk
maybe I'll have the bug fixed by the time it finishes uploading to youtube :)

1565302934
fengb
Twitch said “no more bugs” and it was good

1565302997
vramana
if (T == @field(Node, @memberName(Id, i)))   This line is incredibly confusing.  @memberName call will gave possible value in Id enum after that @field will be called with Node and a value of Id  but that's not a field of  Node at all. I am misreading something I don't know what.

1565303106
Firefox317
So you are not gonna continue the stream? Anyways the progress on the branch is awesome

1565303283
andrewrk
Firefox317, I finished it offline and uploading to youtube now. Next week's demo should be more complete

1565303355
Firefox317
Great!

1565303435
vramana
I get it now. It accessing the struct type inside the Node.

1565303446
vramana
I feel so dumb.

1565303707
batok
what was the name of the branch shown in twitch?

1565303827
andrewrk
batok, rewrite-coroutines

1565303852
batok
cool thanks

1565304603
fengb
These new async semantics are so elegant

1565304888
fengb
Is there something equivalent to @packedSizeOf?

1565305156
Tetralux
Is that not just @sizeOf?

1565305168
Tetralux
Does @sizeOf ignore if the struct is padded or not?

1565305170
Tetralux
Surely not.

1565305195
fengb
@sizeOf is padded size

1565305236
fengb
I’ll just hardcode this stuff for now. No need to make it generic yet

1565305470
andrewrk
fengb, pay attention to

1565305502
andrewrk
here's the vid with the missing stream content. give it a few dozen minutes for HD to become available:

1565305712
fengb
Ah I see

1565305775
andrewrk
fengb, I just fixed one of the issues; another remains

1565306704
fengb
Will there be a way to await on multiple coroutines like promise.all?

1565306771
fengb
Or the opposite, await until the first one completes

1565306806
fengb
First completion, not first listed coroutine

1565307074
andrewrk
that sounds like std.event.Group and std.event.Channel, respectively

1565307086
fengb
Ah okay

1565307089
andrewrk
there's also std.event.Future

1565307110
andrewrk
I did a lot of proof of concepts before determining I needed to redo the semantics

1565307383
fengb
I think it’s funny that I can grok all of this but still have no clue how continuations work

1565307406
shachaf
Continuations are quite a bit more general.

1565307425
shachaf
In fact I'm pretty sure they're more general than anyone needs.

1565307497
shachaf
(But they're also pretty simple.)

1565307508
fengb
I use Redux every day and its continuation passing style still boggles my mind

1565307523
shachaf
I'll watch that video at home, I'm curious how things ended up.

1565307614
shachaf
I don't know Redux but I agree that writing in CPS is very awkward.

1565308218
fengb
andrewrk mentioned that these async functions are basically CPS. And he somehow made it understandable. It's good stuff 👍

1565308704
shachaf
Hmm, it's a special case of continuations (as are most kinds of control flow).

1565308729
shachaf
In particular it's a kind of "one-shot continuation", which is much easier to implement efficiently.

