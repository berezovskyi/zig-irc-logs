1564360572
daurnimator
scientes:

1564360626
scientes
@0 = internal unnamed_addr constant [3 x i1] [i1 false, i1 true, i1 false], align 1

1564360633
scientes
it then converts this into a vector

1564360660
scientes
and then loads the middle element

1564360663
scientes
and then tests it

1564360665
scientes
and it is false

1564360778
scientes
despite being true in the array

1564362782
v1zix
Would anyone be able to help me figure out why this code doesn't work as expected?

1564362802
scientes
what do you expect?

1564362809
v1zix
From debugging with gdb it was showing the []const u8 passed to `buf.replaceContents` is being modified

1564362825
v1zix
At the end the `buf` should be `foo`

1564362833
v1zix
instead of `fo` with a null byte at the end

1564362877
hspak
\

1564362880
hspak
oops

1564362924
rjtobin
Newbie question about inferred error sets: if I have a recursive function with return type "!void", I get an error of the form: "cannot resolve inferred error set ... function 'recursive_foobar' not fully analyzed yet".  If I make the error explicit it works, but it's slightly painful. Is there a best-practice for this?

1564362980
fengb
Zig can’t infer circular error sets yet so it’ll have to be explicit

1564363159
rjtobin
Got it. Is inferring circular error sets planned?  My use-cases are all pretty simple (my cycles are all self-loops, ie. f() calling itself)

1564363570
daurnimator
rjtobin:

1564363716
rjtobin
daurnimator: thanks!

1564363819
hryx


1564363836
hryx
According to that, the incompatibility with recursion may be overcome in a future version

1564363878
hryx
but I don't think there's actually an issue to track it as a proposal. seems like it should either be a proposal (whether rejected or accepted) then documented

1564363973
rjtobin
hryx: yeah, fair enough. Still I'm just being lazy, it's not an important feature

1564364038
hryx
rjtobin: don't sell yourself short. I think it will be important when we get around to making a real language specification

1564364049
rjtobin
v1zix: I'm pretty ignorant, so take this with a grain of salt, but isn't val pointing to the same memory as the buffer's internal list?  So you're trying to write to the thing you're copying from

1564364124
rjtobin
hryx: Point taken. It's pretty incredible how fully-featured it is already with such a small dev team.

1564364168
daurnimator
v1zix: `" foo\n "` is an array. `buf.toSliceConst()` is a slice.

1564364360
v1zix
rjtobin: Ah, that looks like that's the issue. For some reason I thought that would be a compiler error, but I'm still pretty new to Zig as well

1564364430
v1zix
Thanks for the help!

1564364566
daurnimator
oh right

1564364584
daurnimator
v1zix: it could make sense to propose that `replaceContents` gets memmove semantics?

1564364610
daurnimator
or just assert that the argument doesn't overlap...

1564364695
v1zix
daurnimator: Yeah, that could help. I thought gdb was lying to me when it said `val` and `buf` were occupying the same memory, but it makes sense now

1564365859
daurnimator
v1zix: I think mem.copy is missing an assert... and the comment above it is wrong

1564365984
v1zix
daurnimator: An assertion that the `dest` and `source` don't occupy the same memory?

1564365989
daurnimator
v1zix: yep

1564366037
daurnimator
and the comment above it says `dest.ptr must be <= src.ptr.` which isn't true: really if they

1564366113
daurnimator
trying to add that assert I get failures building libuserland

1564366119
daurnimator
will have to look harder later

1564366284
daurnimator
v1zix:

1564366316
v1zix
daurnimator: Sounds good, thanks for looking into that!

1564366774
daurnimator
v1zix: you might want to throw a comment on there mentioning that it caused you a confusing issue due to usage via buffer.replaceContents.

1564367200
hryx
rjtobin: I made an issue to track error sets in recursion:

1564367263
v1zix
daurnimator: Sounds good, I added a comment with my sample code

1564367322
rjtobin
hryx: Great, thanks!

1564367725
daurnimator
hryx: "based on the color of the giant spaghetti monster's mood ring" <-- I like that

1564367805
hryx
:P

1564368316
daurnimator
btw, I had a thought about functions overnight... its sort of weird how we treat functions as function pointers, rather than an actual struct containing code.

1564378518
emekankurumeh[m]
is there a way to prevent translate-c from producing all that "junk" code?

1564378547
emekankurumeh[m]
translate-c on an empty header file produces a 300 line file

1564378852
emekankurumeh[m]
also enums produces both zig enums and a bunch of constants

1564379029
daurnimator
emekankurumeh[m]: not right now

1564379151
daurnimator
I recall a proposal to make #include in a header file emit @cImport. but I can't find it now

1564379407
emekankurumeh[m]
the "junk" being produced seems to be fixed in self-hosted

1564379482
daurnimator
emekankurumeh[m]: is it the same stuff as if you run `clang -E -dM - <<< ''`

1564385733
gonz_
andrewrk: Have you seen

1564385765
gonz_
It's easy to infer values from the zen of zig as well as the website, but it's also very easy to infer what's not really there.

1564387891
daurnimator
gonz_: interesting talk.

1564388008
gonz_
It's a great talk, yeah. I had seen it 2 times previously but only recently started taking it into account in everyday life. It's easier to deal with stuff if you consider that values are underlining everything.

1564388035
gonz_
It sounds trivial and obvious, but I don't think it actually is.

1564388155
daurnimator
gonz_: makes me think I should go off and write out what my values are for various things

1564388167
daurnimator
including zig.... and then compare notes to andrewrk :P

1564388211
gonz_
I actually think it's a very useful exercise. The reason I came back to this recently was because I started questioning some of my values very intently and started re-evaluating things that I saw as truths.

1564388355
daurnimator
Thinking out loud: the most important things to me for zig are: 1. be able to replace C in all reasonable(*) places that C is used. 2. It should be better(*) than C.

1564388457
daurnimator
From those 2. I can infer further things; but also the (*)s there give lots of flexibility.

1564388496
gonz_
I've built my career on expressivity and velocity for the most part, but as I became more and more obsessed with correctness and robustness most of my tools seemed bad. Lately I've  started questioning expressivity as even a secondary value as well as came around to simplicity and predictability probably being more important.

1564388587
daurnimator
I think "simplicity" is a bad word to use: it means different things to different people. and when you encounter a complex task.. the complexity has to live somewhere, but if everyone is trying to be simple then you end up shoving it in a corner -> that is where "Edge cases matter." from the zen of zig wins.

1564388615
gonz_
You can do complex things with simple tools

1564388617
daurnimator
gonz_: you might enjoy

1564388632
gonz_
I think complexity lives better in the product than it does in the tool

1564388640
gonz_
Yes, I've seen it

1564388831
gonz_
It's a great talk and very thought provoking

1564388848
gonz_
I don't think the takeaway should be to not use "simple" as a word

1564388856
gonz_
Simplicity exists

1564388896
daurnimator
gonz_: I think it's very telling that there

1564388916
gonz_
Well, it explains that people should say "easy" sometimes

1564388928
gonz_
0 to blog in 60 minutes is likely the result of "easy", not "simple"

1564388935
daurnimator
I'd rather you said e.g. "composable" if that's what you mean

1564388970
gonz_
That's not really the same thing

1564388992
gonz_
Haskell has more composable entities than OCaml does, but OCaml is undeniably simpler

1564389000
gonz_
It's a smaller language that tries to do less

1564389017
daurnimator
I'd say the definition of simple is that talk is 90% "composable"

1564389022
daurnimator
s/is/in/

1564389059
gonz_
Things that aren't intertwined with other things are more composable, yes, but I think it's just one point of many about simplicity

1564389061
daurnimator
I could probably s/simple/composable/ in the transcript and have the same talk

1564389138
gonz_
I think the bigger point in all of this is that without indications of core values and examples of those values being cited it's very hard for a burgeoning community with many different people in it to coalesce on a coherent idea.

1564389187
gonz_
I think there are a lot of people with a lot of different values in zig and I think mine differ wildly from a lot of the more prominent contributors at the moment. It's helpful at some point to know if one belongs.

1564389419
gonz_
In many ways it's the absence of stating a value that's important. I don't care about approachability as a core value, for example, and I don't know that I care about velocity when it comes to long-lived things either.

1564389469
gonz_
If a small language is more approachable that's great, but it's not something I'd explicitly aim for. Learning about memory, etc., is clearly not super approachable and that's fine.

1564389498
mq32
hey

1564389532
gonz_
Guten tag

1564389551
mq32
:)

1564389583
mq32
gonz_, i think it's weird that basic memory stuff is actually simple (just a huge table), but not easy to explain (or at least i never found anyone who actually teached it well)

1564389676
gonz_
Yeah, I think it's interesting that the resources I see from random people nowadays actually are better than anything I remember from back in the day. At this point I don't even remember how I learned any of it.

1564389718
mq32
yeah, me too

1564389744
mq32
i'm usually explaining all of the memory stuff (adress, word/byte access, pointers, …) in an excel sheet

1564389756
mq32
and i noticed that it works great because it's a visual thing

1564389787
daurnimator
I once explained it to my wife on a 20 min walk .... I think I did a good job cause she asked questions the next day :P

1564389846
daurnimator
explained using a "list of things on lined paper" analogy

1564389948
daurnimator
--> "you can only fit so much on a line" "if you want two lists on one piece of paper how do you know when they start/end?" "how can we reference one list from another"

1564389991
gonz_
I wish some of these explanations were given to me when I was 14

1564390013
gonz_
I was so bad at learning and on top of that I had so much to learn in C++

1564390047
daurnimator
gonz_: so I had a go at using Cantrill's list of things and pick them out for my thoughts on zig. I got: Interoperability > Robustness > Composability > Debuggability

1564390080
gonz_
Cool :)

1564390088
daurnimator
I find it interesting that "maintainability" isn't in there... despite it being in the tag-line of the zig website

1564390091
gonz_
I think this is actually a great thing, even as you noted for oneself

1564390106
gonz_
For self-reflection

1564390132
gonz_
It's useful to see other peoples' lists also because you end up reconsidering things

1564390172
daurnimator
I ordered them too: e.g. I think that when you're trying to interoperate with

1564390271
gonz_
Yeah, you've actually given me food for thought

1564390344
daurnimator
Another interesting choice of my own (I think) was debuggability over safety: I see zig's safety features as merely enablers of debugging; rather than the end goal itself.

1564391379
SimonNa
ls

1564391394
mq32
.

1564391395
SimonNa
Oh, hi

1564391395
mq32
..

1564391436
SimonNa
I looked at Zig a year ago, recently got annoyed with null references in D again and every time the desire grows to write something substantial in Zig

1564391446
daurnimator
SimonNa: welcome back then :)

1564391451
SimonNa
hnn :)

1564391856
daurnimator
SimonNa: so what are you going to make?

1564391928
SimonNa
Sorry, no project. I'm reading the 0.4.0 doc. Last time I dabbled in Zig, it was still 0.1.0.

1564391941
SimonNa
Probably it'll be only quick helper tools for personal use

1564391973
SimonNa
The urge is there though to use Zig for something more than 10-line example programs :)

1564392025
daurnimator
SimonNa: probably better to look at master

1564392045
daurnimator
there have been enough changes from 0.4.0 now....

1564392056
SimonNa
Hmm, because of new features that or better docs?

1564392063
daurnimator
changes

1564392079
daurnimator
e.g. array literal syntax: `[_]`

1564392108
daurnimator
SimonNa: if you're looking for a project,

1564392159
SimonNa
Hmm, I have the Arch zig 0.4.0 package installed, but will install zig-git by hand then

1564392159
SimonNa
Thanks, will keep in mind

1564392203
daurnimator
SimonNa: I think the AUR package might be a bit outdated too?

1564392230
daurnimator
nope looks like it was updated :D

1564392261
SimonNa
package zig-git should pull from master, package zig is the 0.4.0 stable

1564392272
SimonNa
heh

1564392291
daurnimator
SimonNa: yeah I made it ;)

1564392311
SimonNa
Hah, thanks thanks. It's already happily CMakeing

1564392667
SimonNa
All right, now I have version 0.4.0+c47b75312, happily reading the docs

1564392768
daurnimator
SimonNa: re: AUR package being outdated; I meant due to changes in how zig builds that the PKGBUILD needed updating. But tiehuis already updated it in AUR.

1564392842
SimonNa
Ah, okay. Yes, it built seamlessly the current master head.

1564393525
SimonNa
documentation of master: TODO: pub fn main

1564393554
daurnimator
SimonNa: documentation welcome :)

1564393556
SimonNa
Aww. Tried to declare: pub fn main(str: []const u8) anyerror!void { ...

1564393576
SimonNa
But will look at how to pass command line args. Yep, if I manage to find out and understand :)

1564393582
daurnimator
SimonNa: the `anyerror!void` should work I think. though usually you'd just want `!void`

1564393602
daurnimator
SimonNa: the issue is the argument list: main takes more than a single string!

1564393616
SimonNa
Ah, sure

1564393632
SimonNa
Right, u8 is single character

1564393665
daurnimator
SimonNa: I think `const args = try std.process.argsAlloc(allocator)` is the way to get args

1564393720
daurnimator
the allocator is required because the API for getting arguments in utf8 on windows and in wasi requires an allocator.

1564393852
SimonNa
Hmm, interesting way to make explicit the unicode problem on Windows, and that the conversion of Windows's native args to UTF-8 allocates.

1564393898
daurnimator
oh there's also the ArgIterator API

1564393910
daurnimator
see

1564393971
daurnimator
SimonNa: one rule of zig is no hidden allocations.

1564393999
SimonNa
Even before main runs :O

1564394116
SimonNa
I'll look at the compiler source to see how one takes command line args :P

1564394192
SimonNa
yep, it does exactly what you wrote

1564394326
daurnimator
SimonNa: there's this as well which is nicer IMO:

1564394462
SimonNa
Thanks, why is it "this as well", are there two different ArgIterator?

1564394494
daurnimator
SimonNa: one it "I want a copy of the arguments all at once". one is "I want to iterate over args"

1564394517
SimonNa
Hmm

1564394519
daurnimator
and yes, that should probably get cleaned up

1564394700
SimonNa
"Are you making a library? Let users pick your allocator" <3 <3

1564394718
SimonNa
Fully encouraging choice of the strategy from the top down, even if it is painful

1564394902
SimonNa
It's already annoying in other languages with exceptions when the app uses none (and want to declare nothrow wherever possible), but calls into libs that throw. Same for allocation.

1564394980
daurnimator
indeed. and that seems to always end up in the situation where developers pretend that allocation never fails

1564394988
daurnimator
that whole saga is why I left rust

1564394995
SimonNa
Hmm

1564395037
SimonNa
It rarely fails, and if it fails, crash the app. It's usually a good strategy, did you need more control?

1564395065
daurnimator
SimonNa: yes!

1564395180
daurnimator
SimonNa:

1564395252
SimonNa
Hmmm, if your application has an elaborate caching system, very interesting idea

1564395293
daurnimator
SimonNa: or not even elaborate

1564395387
daurnimator
SimonNa: there's also plenty of good memory models I'd like to support e.g. in a HTTP server, use a per-connection and per-request arena allocators

1564395433
SimonNa
Hmm, to guard against any single peer taking all resources for itself :)

1564395437
daurnimator
that 1. lets you drop a connection on the ground if low on memory for some important operation (e.g. admin command or config reload). but also 2. impose a e.g. 10MB limit on per-request memory usage.

1564395483
daurnimator
--> how would you ever accomplish either of those if you just had a single global allocator where libraries panic on failure?

1564395500
SimonNa
It's possible in other languages to do it, but that's the same argument that comes in the D forum very often: Use this elaborate template to get what you want, you don't need a langauge feature.

1564395604
SimonNa
Hmm, even C++ without GC will use the C heap e.g. when std::vector allocates, and you don't want that; I remember one could supply custom allocators as template parameter but I've never tried that.

1564395627
daurnimator
SimonNa: yeah C++ is probably the best language for it: you can pass an allocator as a template parameter.

1564395674
daurnimator
SimonNa: however the code bases that rely on this sort of thing often end up reimplementing their own "standard library". e.g. look what EA made:

1564395718
daurnimator
others (e.g. nginx) just end up demanding that everyone uses their allocation APIs instead of C's.

1564395863
SimonNa
Nnn, that demand violates that the top-most code chooses the strategy >_>

1564395933
SimonNa


1564395941
SimonNa
"make it work with any buffer the user provides"

1564395994
SimonNa
It also advocates making every library a plain C library with imperative usage, because that fits into most strategies

1564396230
SimonNa
Anyway, "Choosing an Allocator", highly inspiring section in the manual. Even for video games where one would jump to conclude that one must reference count or manually free, it recommends the arena that frees once per loop.

1564403787
scientes
SimonNa, reference counting and mmanually freeing is slow

1564403810
scientes
malloc/free is probably the slowest part of C

1564403830
scientes
and, yes I just called C slow :)

1564403850
gonz_
Treating everything as its own little thing that needs to be managed as a unit is slow

1564403889
mq32
scientes, fun fact: you can write java programs that are faster than C programs, even with optimizations turned on

1564403897
mq32
(assuming you use the same algorithm)

1564403908
l1x
nice

1564403911
scientes
only if your C program sucks ass

1564403918
mq32
hrhr

1564403921
l1x
not really

1564403924
mq32
yeah, if you replace any "new" with "malloc"

1564403940
mq32
but: a garbage collector beats free/malloc with thousands of small allocations

1564403945
scientes
or if you are compiling your C program to CPUs from 2008

1564403999
scientes
cause Java

1564404003
scientes
don't believe the hype

1564404025
scientes
it also does extremely poorely with swap

1564404046
nrdmn
mq32: doesn't that depend on the specific malloc implementation?

1564404115
fengb
Yeah it doesn’t have to be slow. FixedBuffer or object pooling is blazing fast

1564404178
mq32
nrdmn, yeah it does

1564404264
fengb
Java can be faster because the JIT can inline things that are always indirect in C, like function pointers

1564404277
nrdmn
there are better reasons why C could be faster than it is

1564404291
nrdmn
its aliasing rules, for example. You can declare parameters as `restrict`, but who knows that?

1564404317
gonz_
Predictability can be nicer than raw potential

1564404364
nrdmn
I wouldn't call C predictable if you're not a language lawyer

1564404371
mq32
it's crazy with modern CPUs

1564404387
fengb
More predictable than a GC :People

1564404390
gonz_
nrdmn: I wasn't referring to any one language, to be honest. There's also the elephant in the room in terms of compilers.

1564404391
mq32
i wrote a "shitty" basic interpreter and it runs with 1.7 Mio Lines of Basic per second

1564404397
gonz_
Some of them are more predictable than others.

1564404649
gonz_
Given the opportunity I think a language could carve out a nice niche out of predictability. The best case solution if you don't have that seems to be to rely on tools that at least let you know what the end result was.

1564404826
fgenesis
SimonNa, daurnimator: re:allocators, my main gripe with C++ allocators in containers is that they are used as template args, ie. no swap() possible between containers using different allocators

1564404882
fgenesis
my understand is that once you go into your allocator you go into DRAM anyway, so an allocator object with a virtual method or a simple allocator function pointer would be a lot more useful, because it's possible to change it at runtime, including swap(), etc

1564404905
fgenesis
so perf is not an argument to baking allocators into the type

1564405400
nrdmn
are there any languages yet that treat allocation as a side effect?

1564406418
daurnimator
nrdmn: what do you mean by "side effect"?

1564406857
nrdmn
daurnimator: "side effect" as in 1. anything that affects the outcome of a function that is not in its parameters, e.g. fetching the time, random bits, or keyboard inputs from the system, and 2. any state changes to the environment outside of the function, e.g. console output

1564406939
gonz_
Haskell allows you to annotate essentially everything in the type system. For the most part imagination would be your limit there.

1564406948
nrdmn
for example, haskell treats i/o, time and random as side effects and represents them in its type system but not memory allocation

1564406999
gonz_
`createVector :: MonadAllocatingVector m => Int -> m (Vector ...)`

1564407053
gonz_
The caveat being that allocation can't safely be avoided so you'd essentially have to change the tools you use internally

1564407076
gonz_
Which is probably not a useful path to go down, considering

1564407164
gonz_
ATS might be able to actually do it

1564407205
gonz_
It's possible to use ATS unsafely, but it's also, as far as I understand it, very easy to create safe layers on top of raw `malloc` that require passing proofs of freeing around, etc.

1564407231
gonz_
So in that sense allocation at least becomes something you

1564407853
nrdmn
gonz_: you'd need an allocator for infinite lists, too

1564407861
nrdmn
and any kind of recursion

1564407878
nrdmn
I think that's just not feasible in haskell

1564407901
gonz_
I agree

1564407990
fengb
Wait, you're not allowed to agree on the internet

1564408138
nrdmn
:)

1564408484
nrdmn
daurnimator: I threw out most of my uefi PR because I'm not sure how to implement the std lib parts. I think it is mergeable for now, but for the missing parts (wrapper functions, abort, panic...) I'd wait for some feedback.

1564409936
gonz_
Ugh

1564409950
gonz_
There are like 3 different proposals that basically amount to "private struct fields" from the same person

1564410110
fgenesis
only let friends touch your privates, or what was the saying in C++...

1564410144
gonz_
Something like that :D

1564410274
fgenesis
i like the way that some languages do it, like prefix with _ to make private

1564410287
fgenesis
but i like it even more not as a language feature rather than as a convention

1564410311
fgenesis
don't touch stuff that starts with _, easy enough

1564410317
gonz_
For the things where it makes sense I think opaque pointers mappable internally to actual data is fine

1564410334
gonz_
You have to really want to create issues if you take it upon yourself to go in and do it manually in those cases

1564410351
gonz_
Or am I just crazy?

1564410373
fgenesis
pointering everything probably not a good thing

1564410383
fgenesis
means extra allocations etc

1564410407
fgenesis
and going via opaque pointers just to force a certain part of a struct to be inaccessible is just a road to disaster

1564410435
gonz_
Not a bigger disaster than changing the language for this feature, IMO

1564410448
fgenesis
yes ,so to both, the answer is don't do it

1564410456
fgenesis
KISS and so on

1564410465
gonz_
People are coming up with all kinds of insane ideas. Readonly but only for other packages, etc.

1564410502
fengb
I'd only use opaque to reference literally unknown sized data

1564410522
fengb
I don't like real private in general because you can't work around other people's limited assumptions

1564410723
nrdmn
"but why would you want that?"

1564410781
fgenesis
i've always thought that putting private stuff into headers was stupid

1564410831
fgenesis
for one thing it's there and laughs at you because you can't access it, but it also means classes are larger than the public part by a known number of bytes, and everything is still part of the ABI/memory layout

1564410840
fgenesis
so kinda worst of all worlds

1564410843
fgenesis
(C++ ofc)

1564410925
fengb
How else would you do private memory though? Stick it in a void pointer?

1564410981
fgenesis
for things that always return a pointer: stick it at the end behind the struct

1564410984
halosghost
mmmmmmmmmmmmmm void pointers

1564410991
fgenesis
if the struct is public: add void *privmem;

1564411040
fgenesis
or, for 1) if the user can control the location of the struct but the implementation needs private data

1564411054
fengb
Now you have the possibility of copying the struct != copying private data

1564411071
fgenesis
yes

1564411092
fgenesis
it's really a case-by-case thing and there's no universal golden hammer

1564411162
nrdmn
why would you want private fields?

1564411212
fengb
Maintaining ABI compatibility is a good reason

1564411234
fengb
Hiding fields for encapsulation purposes is a not-that-good reason

1564411262
fgenesis
but if the private fields contain native OS stuff

1564411286
fgenesis
my solution so far was to have some void*[N] array with N large enough for your typical OS

1564411314
fgenesis
so the struct is public but the void*array is private and OS-defined, and copying a struct by-value is always passing it

1564411336
fengb
But if I'm only on 1 OS, it's hiding things that I could have access to

1564411352
fgenesis
if you're only on 1 OS you're doing it wrong :P

1564411379
nrdmn
fgenesis: what's the reasoning for making that field private?

1564411415
fgenesis
nrdmn: in my case it's sort of an mmap() wrapper that hides things like alignment requirements (on linux) and file mapping objects (on windows)

1564411415
fengb
Your library shouldn't dictate how my code should function. I don't think it's good to depend on privates, but more often than not, there's no way other than forking

1564411441
fgenesis
so depending on the OS those pointers contain different things (original, non-aligned pointer on linux and OS cruft on windows)

1564411465
nrdmn
your structs contain executable data?

1564411465
fgenesis
and no such thing as fork() on windows so good lucjk

1564411472
fgenesis
lol, what, no

1564411534
fgenesis
(to be clear, not talking about zig but struct design in general, which i assume we were doing anyway)

1564411665
fengb
In Zig, we'd probably just comptime the differences away

1564411848
fengb
Hmm... how will Zig handle ABI if the compiler is allowed to reorder struct fields?

1564412179
fgenesis
not. that's what extern struct is for

1564412186
mq32
fengb:

1564412196
fgenesis
extern struct for abi, normal/packed struct for internal-foo

1564412209
gonz_
mq32: :D

1564412209
fgenesis
mq32: lol

1564412232
mq32
that was my immediate brainfart when i've seen your last messages :D

1564412434
nrdmn
what would I use a packed struct for if not for an abi?

1564412619
mq32
maybe memory mapped IO or similar

1564412628
mq32
which could also be considered ABI

1564412637
fengb
My expectation is: packed for guaranteeing exact memory layout and extern for guaranteeing stability

1564412665
fengb
e.g. extern struct probably wouldn't convert bool to u1

1564412682
nrdmn
what would it convert a bool to?

1564412708
halosghost
following that logic mentioned, presumably a u8

1564412746
mq32
yeah, probably u8

1564412764
fengb
u8 is most flexible. u32/u64 might be "faster". u1 would be slow and kill any sibling fields that aren't aligned properly

1564412801
fengb
Actually if it was (bool, u32) side-by-side, it'd most likely do (u32, u32)

1564412821
mq32
i think it's actually ABI and platform dependent what "extern struct" is doing

1564412839
mq32
in contrast to "packed struct" which is defined as "everything in ordner, no single bit padding"

1564412845
fengb
Yeah, it's just the C ABI atm, which is implementation dependent

1564412876
fengb
C is allowed to pad fields but not change the order

1564412981
scientes
if we really want to be "safe" we could test that every pointer is reachable before assigning it

1564412986
scientes
but that would be really slow

1564413027
scientes
but if would catch segfaults at the store, rather than the load

1564413079
fengb
Dereference on copy?

1564413116
scientes
we would be checking that every point holds a reachable value, by keeping track of memory maps.

1564413138
scientes
/proc/self/maps

1564413278
nrdmn
on linux and only if you have access to /proc

1564413303
scientes
nrdmn, no, we do every allocation so we can keep such information internally

1564413304
scientes
on every OS

1564413685
samtebbs
packed structs are useful when the CPU expects an exact layout in memory, such as interrupt handler entries and page tables on x86

1564413693
fengb
Unless we use the C allocator

1564413753
nrdmn
or run on a platform that does allocation for us

1564413858
marijnfs
is andrew in his cave?

1564413963
halosghost
packed structs are useful for when I want to do all the alignment things myself

1564414052
mq32
are also useful for platform-interop (eg. file storage, networking, …)

1564414079
nrdmn
so, ABIs

1564414104
scientes
<marijnfs> is andrew in his cave?

1564414105
scientes
hehe

1564414111
scientes
he's working on coroutines

1564414156
marijnfs
is that like threads?

1564414288
scientes
sort of

1564414309
scientes
except you don't have a scheduler

1564414381
mq32
*except you are the scheduler ^^

1564415829
SimonNa
scientes: Yes, refcounting is slow, lots of small deallocs is also slow. I had known that one could call a language's GC every cycle, but the arena per cycle is even cleaner and likely faster. GC would scan the entire app. This speed has never been a problem in D, but others complain about the suboptimal D GC, yeah.

1564415860
SimonNa
I have no opinion about the speed of Java, never wrote anything performant in Java :)

1564416081
fengb
Modern GCs have separate arenas for different lifetimes

1564417086
halosghost
I really wish we would leave GC alone

1564417226
gonz_
As in?

1564417245
gonz_
I don't think anyone was necessarily criticizing GC in general, if that's what you mean.

1564417254
gonz_
Most D users don't think that the D GC is all that great, though.

1564417263
gonz_
If that's the bit you were remarking on

1564417390
SimonNa
Yeah, the standard D GC; it's fine for everything I've done, but others would prefer finer control/not stop-the-world to scan entire app.

1564417524
halosghost
gonz_: on the contrary: I'm criticizing it in general

1564417550
gonz_
halosghost: Right, sorry for the misunderstanding.

1564417555
halosghost
it's okay :)

1564417883
halosghost
all I want is a type-safe memory allocator

1564417897
halosghost
there's very limited need for a GC after that point

1564417905
halosghost
well, that and defer

1564417907
halosghost
:)

1564417913
halosghost
zig has 1/2 already

1564417924
halosghost
I'd be very happy to see the type-safe allocator get merged as well

1564417928
fgenesis
tape-safe? memory is memory

1564417963
halosghost
fgenesis: a type-safe memory allocator essentially does two things: when a bit of memory is allocated for a particular type, it tags that bit of memory with the type it was allocated for

1564417999
halosghost
fgenesis: if ever that bit of memory is allocated again (e.g., it was freed and is now going to be allocated again), it will only allow that bit of memory to be allocated for the same type it was allocated for originally

1564418024
halosghost
fgenesis: that alone is enough to turn the vast majority of memory-safety bugs from security vulnerabilities to logic errors

1564418027
fgenesis
why would anyone even want that

1564418036
halosghost
cf. my last comment :)

1564418058
halosghost
tada: memory-safety

1564418070
fgenesis
yeah no

1564418070
halosghost
no need for GC, no need for lifetimes

1564418076
halosghost
fgenesis: okay :)

1564418087
fgenesis
that's kinda not how it could ever work

1564418108
halosghost
what makes you say that?

1564418118
fgenesis
also you wouldn't catch type aliasing issues at runtime, only at allocation time, which is way too late and too coarse

1564418133
fgenesis
so effectively to be type-safe you'd have to check types on every access if you're serious about it

1564418153
halosghost
that's not my understanding, but okay

1564418173
fgenesis
also doesn't save you from not freeing and accidentally re-using as something else

1564418249
halosghost
use-after-free wouldn't be a vulnerability though, just a logic bug

1564418289
fgenesis
also it's easy to write what you described, just alloc some more plus alignment, stick a magic uint32 in front of the allocation, fix the alignment, and use the rest as the actual object. tada, type annotations that you can keep even thru free()s

1564418308
halosghost
indeed

1564418330
halosghost
though, having language-support for it would be lovely

1564418333
fgenesis
plus some sort of pre-init an area to already contain the type every xx bytes, assuming all of your objects are of the same size

1564418344
halosghost
ideally, in the case of zig, via a special allocator

1564418346
fgenesis
it's nothing that needs language support

1564418381
fgenesis
no, you want an allocator, you provide it, and if you want that behavior, it's up to you

1564418388
halosghost
I can't tell if you like this idea or hate it since you went from “this is stupid, it can't work that way” to “it would be so easy to write this yourself and have it work”

1564418395
halosghost
fgenesis: no kidding

1564418406
fgenesis
this doesn't need any kind of language support because whatever you do, this can't be safe, and this can't save you from an attacker

1564418412
halosghost
okay

1564418415
halosghost
have a great day :)

1564418438
fgenesis
giving false impression of safety is not what anyone would like

1564418459
fgenesis
like "file-system shredder" tool to delete files safely on SSDs

1564418495
fgenesis
great, file is gone, but if you desolder read out flash chips

1564418500
fgenesis
ah dan

1564418515
fgenesis
if you desolder and read out chips then wear leveling still has original data

1564418524
fgenesis
that's what i mean with false impression of safety

1564418773
tgschultz
I wrote something like what's being described, but it worked differently. It used different pools of memory for each type. It isn't an 'Allocator' though, since it doesn't implement the allocator interface.

1564418778
halosghost
anyway, gc seems to be impossible to have with predictable and reasonable performance

1564418787
halosghost
tgschultz: interesting

1564423198
SimonNa
Are there reference webpages for the Zig standard library? Or is the source the documentation?

1564423215
halosghost
there are some docs

1564423233
halosghost
for master:

1564423239
SimonNa
Ah, where?

1564423276
Sahnvour
there is none for the std lib at the moment, your best bet is to read the code or find examples

1564423286
Sahnvour
you can follow this issue

1564423292
halosghost
ohh

1564423295
halosghost
the standard library

1564423296
halosghost
my bad

1564423299
halosghost
I misunderstood ):

1564423306
SimonNa
Ah, no prob

1564423334
SimonNa
I'm fine with looking at the source :)

1564423854
SimonNa
Yep, subscribed to issue 965. Thanks!

1564423915
scientes
the std lib is also...meh

1564423933
scientes
let me just say it could be better

1564423944
scientes
if you have too much documentation it gets harder to change

1564424061
scientes
the focus should be on increasing the quality over writing documentation

1564424126
Sahnvour
I hope stdlib's quality improves faster than documentation which is basically nonexistent

1564424131
SimonNa
Autogenerated docs go a long way, even if it's only the signatures

1564424176
scientes
yes, progress on autogenerated docs would be great

1564424185
scientes
something like ruby's documentation

1564424205
scientes
but actually writing documentation, meh

1564424209
scientes
too much other stuff to do

1564424223
SimonNa
Yeah, any documentation that's not autogenerated from the source file would get stale fast, agree.

1564424260
SimonNa
Heh, it's all good, I don't mind looking at the source. I merely would have preferred bells-and-whistles docs had they existed.

1564424276
scientes
SimonNa, do it! it would be a great way to learn zig

1564424289
scientes
actions speak louder than words

1564424331
SimonNa
Hah, I took an hour today to write the program that takes cmdline args and prints them to stdout :) If I stick with Zig, I'll certainly consider to look at easy issues.

1564424518
scientes
well yeah, maybe do some easier stuff first

1564424549
scientes
an hour isn't bad however

1564424556
scientes
and the cmdline arg handling in zig is...meh

1564424557
SimonNa
Yeah, day-one Zig feels like procuding code with hammer and chisel.

1564424565
scientes
I actually re-wrote it

1564424574
scientes
but didn't have the energy to seel a differn't way of doing it

1564424614
scientes
because my vision got a bit bigger

1564424767
SimonNa
Hmm, I stuck with std.process.argsAlloc, I've seen that there are iterator solutions.

1564424823
SimonNa
Hoh, didn't know that argv can be so big

1564424848
SimonNa
Also, Zig coding style. E.g., I want to write a function that takes an allocator. Since I didn't know the type *std.mem.Allocator, I was tempted to write a generic function and let the compiler figure out the types. But I'd guess that explicit types are favored?

1564424952
andrewrk
SimonNa, one trick you can do is to use the wrong type (e.g. i32) and look at the compile error

1564424963
SimonNa
Heh

1564425000
SimonNa
Yeah, nice idea, the compiler is happy telling the tyeps

1564425010
fengb
Improve your zig code with one neat trick!

1564425063
SimonNa
I already used std.debug.warn(@typeName(stuff)), but just writing wrong type is easier, no need to get everything to compile first

1564425109
Akuli
:D

1564425112
andrewrk
you can use @compileLog instead of std.debug.warn for that

1564425132
SimonNa
Hmmm, thanks :)

1564425184
SimonNa
yeah, common D hack is pragma(msg, typename(typeof(a)), this is the exact equivalent, nice

1564425243
andrewrk
there are a bunch of things that D & Zig independently came up with

1564425258
andrewrk
another example is errdefer / scopeexit(error)

1564425280
SimonNa
Right, where Go only has one defer, Zig has both

1564425290
andrewrk
sorry, it's scope(failure)

1564425307
SimonNa
yep, and the third is scope (success) but that's practically never required

1564425563
SimonNa
The strong non-nullability guarantees are my reason to follow Zig, happy to spend a day on it again after so long.

1564426429
SimonNa
Assume I have err: anyerror. I can print its name with std.debug.warn("{}\n", @errorName(err)); but std.debug.warn(@errorName(err)); fails -- why does it fail with "Unable to evaluate constant expression" when the {} worked with the same expression?

1564426445
gamester
People on twitter are having a fit over C++:

1564426453
gamester
One more:

1564426458
gamester
These aren't random people, haha

1564426478
andrewrk
SimonNa, the format string parameter of std.debug.warn is marked comptime

1564426497
andrewrk
so that parameter must be compile-time known

1564426515
SimonNa
Ah, makes sense. Thanks :)

1564426515
Akuli
std::web_view wtf

1564426544
Akuli
c++ still calls itself a "programming language"?

1564426834
scientes
leaky kitchen sink more like it

1564427220
fgenesis
as a c++ person i facepalm hard and scream for help. someone please apply sanity

1564427225
gonz_
I'm planning on trying to map out some relevant parts of `user32` for win32 stuff and I'm underway with the basics at the moment. How do people feel, should it land in a library or be PRd into std?

1564427687
scientes
Is there a good reason you can't do binary arithmatic on bools?

1564427688
scientes
return true ^ true;

1564427692
scientes
this isn't seem right

1564427789
fgenesis
scientes: != is xor for bools

1564427805
scientes
yeah but why can't you also use ^?

1564428068
mq32
gonz_: Sounds more reasonable to make a user32 library

1564428597
scientes
fgenesis, not true

1564428608
scientes
false ^ false

1564428617
scientes
oh nvm, my bad

1564428620
scientes
i'm confusing with nor

1564428635
scientes
with |

1564429270
scientes
fgenesis,

1564429305
scientes
oh your right

1564430568
scientes
fgenesis, hmmm, gcc has a warning for it

1564430573
scientes
../src/ir.cpp:16841:58: error: ‘~’ on an expression of type bool [-Werror=bool-operation]

1564430573
scientes
scalar_out_val->data.x_bool = ~operand_val->data.x_bool;

1564430574
scientes
~~~~~~~~~~~~~~~~~~^~~~~~

1564430574
scientes
../src/ir.cpp:16841:58: note: did you mean to use logical not (‘!’)?

1564431869
hryx
dumb question about sr.ht... to reply to a message and keep it in the thread, does one have to click the user's name in the browser? The docs don't say anything about simple reply/reply-all in e.g. Gmail

1564431913
scientes
I found a bug that only happens at run-time if you enable comptime

1564431931
scientes
so we arn't checking comptime right somewhere

1564432026
scientes
codegen needs to assert that it isn't generating code for comptime stuff

1564432151
scientes
hryx, do you think if (!~(a == b)) is better than if ((a == b).any()) ?

1564432210
hryx
scientes: what would those do?

1564432224
scientes
I guess we could also have a "ifany", but then not any would become if (!(ifany(a == b) true else false)), which is horrendus

1564432237
scientes
hryx, comparisons of vectors return vectors of bools

1564432256
scientes
so you have to do wave-form scheduling, when you branch if

1564432308
mq32
scientes, i prefer either the method-version or the free function version

1564432321
hryx
on interesting. I'm generally not into new sigils unless it's broadly applicable in everyday code TBH

1564432326
scientes
there are basically three ways to cast these vectors of bools to bools

1564432328
mq32
if(std.vector.all(a == b)) { }

1564432334
scientes
all, any, none, and notany

1564432365
scientes
hryx, well yeah, that's why i realized that !~(a == b) could do it

1564432379
scientes
with an implicit any() cast to bool

1564432389
scientes
**implicit all() cast to bool, sorry

1564432430
scientes
mq32, so you don't like if (!~(a == b)) ?

1564432442
scientes
its kinda funky but it doesn't have to add new syntax

1564432452
scientes
and std.vector.all is way too verbose

1564432479
scientes
hryx, well for me this vector stuff is everyday

1564432525
hryx
I gotcha. I'd have to look at it later (a little busy at the moment) and understand its use a little better

1564432555
hryx
without me totally understanding: what about a @builtin?

1564432583
scientes
I prefer a build-in method to a whole new built-in intrinsic

1564432598
scientes
or even the method as mq32 pointed out, std.vector.all() which can be done

1564432623
scientes
actually std.vector.any()

1564432638
hryx
that sounds solid

1564432638
scientes
any() is the weird (and most useful) one

1564432663
mq32
scientes: i don't like the operator overloaded one

1564432668
mq32
it isn't understandible at all

1564432672
scientes
mq32, its not overloaded

1564432680
scientes
its well defined, but it is confusing

1564432684
scientes
english is better

1564432685
scientes
any()

1564432698
mq32
also we can import stuff into global namespace, so any/all/… can be global symbols if you want

1564432716
scientes
mq32, well yeah, its like .is_signed and .bit_count

1564432728
scientes
I actually can't even add the () until after the anon function stuff lands

1564432759
scientes
I already have the any() implemented, but I second-guessed it

1564432796
mq32
scientes, take a look at how GLSL does vector comparisons

1564432796
mq32


1564432806
mq32


1564432814
scientes
well the actual comparisons are easy

1564432823
scientes
we should just use the operators we have, which is how llvm does it

1564432831
scientes
the only issue is dealing with the vectors of bools

1564432846
scientes
oh wow, any all none

1564432880
scientes
on they didn't do none, I thought of that one later, because its simple and English

1564432900
mq32
but my preference lies in a std function

1564432919
mq32
for me it feels natural

1564432926
scientes
uggh

1564432931
mq32
more natural then a method `(a==b).any()`

1564433023
hryx
my personal preference is same as mq32. I like most things which can be implemented in std implemented in std

1564433039
hryx
(only if it can be, of course)

1564433162
scientes
It would be kinda nice if we could write methods to builtin-types in user-land

1564433178
scientes
but that is kinda niche

1564433397
scientes
I'm also not sure if the optimizations are there for doing it in user-land

1564433408
scientes
@llvm.ppc.altivec.vcmpequw.p

1564433500
scientes
so what about & ^ | and ~ on bools?

1564433526
scientes
I'll open a separate PR

1564434122
halosghost
is bool an alias for a u1?

1564434209
hryx
you can't treat a u1 as an operand in a boolean operation far as I know. it's a u1 I think, but dunno if that's a guarantee per se

1564434238
hryx
so effectively no

1564434278
hryx
scientes: what about @bootToInt?

1564434290
scientes
hryx, already done in my local branch

1564434293
halosghost
let me put that a different way, are bools implemented as a u1?

1564434301
scientes
halosghost, llvm doesn't have a concept of bool

1564434304
scientes
it is just i1

1564434311
halosghost
I'm aware, but we're talking about zig

1564434318
halosghost
which does have a concept of bools

1564434320
scientes
hryx, @boolToInt was actually generating invalid IR

1564434325
halosghost
so, how are bools implemented? :)

1564434332
scientes
halosghost, they are a distinct type

1564434342
halosghost
ok

1564434348
scientes
which means you can't do false + true == true

1564434396
halosghost
so why are you interested in having bitwise arithmetic on them?

1564434410
hryx
scientes: I don't think bit ops on bools would get merged without an approved proposal. if the IR is invalid, that should be a bug report/fix

1564434419
scientes
because I want ! to return true or false, and not a vector of bools

1564434434
scientes
so you then need to use ~

1564434481
halosghost
hmm

1564435473
scientes
hryx, ^= &= and |= already work

1564435476
scientes
just not ^&|

1564435502
scientes
actually, let me check

1564435604
hryx
hmm, operator table says that bitwise ops only work on integers

1564435785
andrewrk
with perhaps one or two exceptions, an operation which works on a primitive type also works on vectors (or is planned to work). the documentation has not been updated for SIMD/vectors yet

1564435802
andrewrk
e.g. float ops work on vectors of floats; pointer ops work on vectors of pointers

1564435812
scientes
I've implemented a bunch of them

1564435829
scientes
so ! can return a vector of bools?

1564435865
scientes
i'd kind of rather have it enforce bool-ness, and then use ~

1564435886
scientes
I mean, we could even have == and != always return bool, and force vector uses to use ^ and then >

1564435895
scientes
^ and then > 0

1564435915
scientes
but that seems a little weird

1564435971
andrewrk
! on a vector of bools will return a vector of bools with ! applied to all of them

1564435994
scientes
but don't you see the consistancy I am talking about, where ! != and == always return bool?

1564436012
scientes
considering that they all have bitwise equilivents: ~ and ^

1564436080
scientes
yeah either way however

1564436111
scientes
Its all the same too me

1564436185
scientes
andrewrk, because the consistancy of the operator is ruined by the lack of consistancy in the return type

1564436234
scientes
so ! != and == would then be illegal on vector of types other than bool

1564436294
scientes
*on vectors

1564436311
andrewrk
I don't see what you're talking about - it seems like you want set operations but you want to repurpose !, ==, != to be those set operations

1564436322
scientes
while it would require learning, the error message would be good, and it would make the code easier to read

1564436349
scientes
andrewrk, no, I just rejected doing any overloading or implicit casting from vectors to non-vectors

1564436362
scientes
the point is that ! != and == will always return the same type

1564436375
andrewrk
I don't see why that is inherently valuable

1564436387
andrewrk
int + int always returns an int

1564436397
andrewrk
bool == bool always returns a bool

1564436502
Sahnvour
andrewrk: just rebased my PR

1564436509
andrewrk
thanks Sahnvour

1564436514
scientes
oh, wait, its borked because it would work for floats

1564436519
scientes
particularly NaN

1564436535
scientes
ok, that is settled

1564436536
gonz_
Is there no actual proposal with some set ideas for these things?

1564436543
scientes
only ! could be done that way

1564436553
gonz_
This seems awfully unstructured

1564436555
scientes
and if it was just one operator it would be confusing

1564436591
scientes
gonz_, there were no comments

1564436597
scientes
so I just went ahead and did it

1564436602
scientes
and i've done it three ways now

1564436673
andrewrk
gonz_,

1564436704
andrewrk
gonz_, to be clear, scientes is working on a fork of zig, not zig itself

1564436711
scientes
yes

1564436731
scientes
but people have already done cool stuff with it:

1564436744
andrewrk
nice

1564436766
andrewrk
scientes has some pull requests open which I have not reviewed yet

1564436784
scientes
the SIMD one really isn't ready, but I'm happy with the reception I've gotten

1564436811
scientes
I'm pushing towards a MVP for replicating the paid work I did for IBM on non-portable SIMD

1564437002
Tetralux__
What's a good example of the use of .format interface?

1564437024
andrewrk
Sahnvour, good stuff.

1564437084
andrewrk
it's probably better to avoid adding default struct field values of `undefined`

1564437119
scientes
oh yeah, doing this in user-space is going to run into the undefined issue....

1564437131
scientes
sometimes use of an undefined behavior is defined

1564437137
scientes
*undefined value

1564437148
andrewrk
Sahnvour, unless the intention is to let the API user directly initialize structs

1564437195
andrewrk
but if it's the initializer's responsibility to make sure the fields are eventually defined, having them explicitly initialize to undefined at the initialization site is a good way to make people remember to do it

1564437277
scientes
what about allowing ^ & ~ and | on bools?

1564437306
Sahnvour
thanks, I assume you're talking about MsfStream ? In this case this is not really a type I expect the user to instanciate directly, and the ones created with default values

1564437364
Sahnvour
but I didn't think about this too much (small oversight), no problem in changing it

1564437518
gonz_
What's a MsfStream?

1564439685
Sahnvour
gonz_: MSF is a file format that can contain multiple interlaced streams of data, that's what you find inside .pdb for windowws debug symbols. I was replying to andrew about default undefined struct members

1564439721
gonz_
Yeah, I was just wondering what it represented

1564439726
gonz_
Cool

1564439887
Sahnvour
I don't know if it's used in other things, probably stands for microsoft stream file or something like that but there aren't many references outside .pdbs

1564440664
dazhbog
hi, is there a way to make zig compiler handle -framework option on macos?

1564440688
scientes
dazhbog, you can always word around such things by using build-obj

1564440695
scientes
and then manually calling the linker

1564440892
dazhbog
scientes, thanks, I'll look into that. What worries me though is that the frameworks move around with macos versions so I can't assume paths to stay the same..

1564441354
andrewrk
scientes, dazhbog, there are better options to explore before resorting to build-obj and using the system linker

1564441412
andrewrk
there is an option to add paths for the linker to look in for frameworks

1564441514
dazhbog
andrewrk: that sounds like the right tool for the job :)

1564441615
dazhbog
andrewrk: I managed to build and run the tetris-example on macos but I'd like to do it the right way

1564441742
andrewrk
dazhbog, what changes did you have to make?

1564441822
dazhbog
andrewrk: in the end the only problem was that OpenGL/gl.h cannot be found (because it's hidden behind a framework)

1564441860
dazhbog
so I had to .. persuade the build system to find it

1564441894
dazhbog
but that was it.. it built and ran happily. I was pleasantly surprised :)

1564442012
scientes
dazhbog, welcome!

1564442062
andrewrk
dazhbog, here's a related issue:

1564442078
andrewrk
darwin frameworks currently represent a cross compiling obstacle. I haven't tackled this problem yet

1564442136
dazhbog
okay :)

1564442306
dazhbog
andrewrk, thanks for answering and for creating zig!

1564442358
andrewrk
:) are you working on something open source that I can watch?

1564442449
dazhbog
I'm very much a newbie when it comes to zig but I'm hoping to write a small game with it

1564442488
dazhbog
I'll probably continue learning it on my linux machine .. might be a bit smoother experience :)

1564442499
dazhbog
and yes when I get somewhere it'll be open source

1564443114
daurnimator
fgenesis: huh? fork exists on windows.

1564443133
fgenesis
fork() ?

1564443144
fgenesis
CreateProcess() is lol

1564443416
daurnimator
fgenesis: yeah there is a DuplicateProcess() available in ntapi

1564443426
daurnimator
problem is that it breaks csrss

1564443456
fgenesis
what else? TLS? file descriptors? other HANDLEs?

1564443473
fgenesis
i'd guess it's more of a clusterfuck than anything else

1564443485
daurnimator
fgenesis: huh?

1564444110
daurnimator
fgenesis: NtCreateUserProcess has a set of flags that indicate that a process should be cloned.

1564444163
fgenesis
what's important is that it works on xp

1564444203
daurnimator
fgenesis: it works all the way back to 2000

1564444214
daurnimator
and TBH it probably works before that too. never bothered testing on NT

1564444225
daurnimator
(note that you do need a different code path for older windows)

1564444248
daurnimator
fgenesis:

