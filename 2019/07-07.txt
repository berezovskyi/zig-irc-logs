1562457747
andrewrk
`error` used to be the global error set, which is why anyerror was a keyword and why anyerror.Something still works

1562457767
andrewrk
but now `error` is a keyword more like `struct`

1562457813
hryx
should there be a different word for a literal error in the global error set?

1562457833
hryx
since now it does double duty of `error {...}` and `error.Something`

1562457859
hryx
if so we could rename the keyword to `errorset` ?

1562457885
andrewrk
`error.Something` is syntax sugar for `error{Something}.Something`

1562457915
andrewrk
I don't think we need a new keyword

1562457922
hryx
ah I see

1562462488
daurnimator
andrewrk: do you want a bloom filter in the standard library?

1562462652
hryx
daurnimator: interesting discovery about a bug you found

1562462745
hryx
or maybe not interesting, I dunno yet

1562462898
emekankurumeh[m]
i wish assert was a macro that would give line numbers/file names

1562462968
hryx
in c++? yeah. the above was sort of a pain in the butt to find

1562464449
hryx
one day when the self-hosted compiler is feature complete, would it make sense to automatically generate the C/C++ source for stage1?

1562464471
hryx
I realize that means translating zig->C/C++ which might be abused (and is its own project) but it would mean only maintaining one code base

1562464623
hryx
it also means that stage1 behavior would never stray from self-hosted (barring bugs)

1562464692
daurnimator
hryx: I think a C target has been mentioned before...

1562464778
hryx
surely it's not novel. and other that use case, I'd frown upon it. but that specific use case does seem compelling

1562465234
fengb
hryx:

1562465260
hryx
fengb: thanks! I was just raeding that :>

1562465282
fengb
I find myself revisiting that every so often

1562465287
fengb
And questioning my life choices

1562465440
hryx
life choices make good target practice

1562465460
hryx
> Compiling the stage2 compiler to C or WebAssembly does not satisfy the problem, because the C code or WebAssembly code would be output, rather than source code

1562465468
hryx
^ I suppose that answers my curiosity

1562465499
hryx
my instinct is "that's too bad". but I'll read it over again and think some more

1562465518
fengb
I think it's good to have multiple compilers, even in the same source root

1562465524
andrewrk
if you think about it, why not use the generated assembly code to bootstrap, right? assembly can be source code

1562465534
andrewrk
but it's the same thing as generating C, if you're generating it, then it's not source code

1562465558
emekankurumeh[m]
zig ir is undocumented right?

1562465559
hryx
presumably, the distinction is that a human wrote it directly?

1562465579
hryx
as opposed to a machine transformation

1562465581
andrewrk
emekankurumeh[m], it is extremely undocumented. not only is it undocumented but the meaning of different instructions changes arbitrarily from commit to commit

1562465582
fengb
One day, we'll have AI generate readable source code :P

1562465644
andrewrk
emekankurumeh[m], also if you were to redesign zig ir today, rather than evolve it as it has been, you'd probably make very different decisions

1562465670
fengb
Will Zig IR be stable at some point? Or is it an implementation detail that'll just vary

1562465682
andrewrk
hryx, yes. if you're looking for well written beard-stroking, chin-scratching philosophy about what constitutes source code or not, I believe the Debian Free Software Guidelines have really taken it upon themselves to do that

1562465701
andrewrk
fengb, implementation detail

1562465744
andrewrk
we can potentially reconsider this after the first non-llvm backend

1562465801
hryx
I see. andrewrk, if it were up to you and not Debian, would you just maintain self-hosted and maybe output C? (Maybe that's an unfair or unproductive question)

1562465828
hryx
I don't mean to belabour the point though, it just grabbed my interest tonight

1562465840
andrewrk
no, I see value in maintaining stage1 independent from debian

1562465860
andrewrk
hryx, btw I started looking into a webassembly build of zig, and I got stuck at emscripten not being able to compile LLVM:

1562465911
andrewrk
one important thing is how small the path is from source to source to source to working zig binary

1562465945
andrewrk
if we were really sophisticated, zig would come with a kit to bootstrap a compiler from straight-up machine code - no c

1562465998
fengb
How would that work?

1562466001
andrewrk
"type this tiny machine code file with a hex editor. next, use that to build this primitive assembler. next, a simple C compiler. next, clang. etc"

1562466031
hryx
that'd be hecka steps

1562466042
hryx
but an interesting thought!

1562466044
andrewrk
the idea is that you start with readable, documented, commented steps where everything is easily verifiable

1562466054
andrewrk
I saw a related project recently, what was it called...

1562466065
andrewrk


1562466099
hryx
oh yes, that showed up on the ole hacker newspaper if I recall

1562466160
hryx
there is something kind of beautiful in it. like, start with nothing and build a computer

1562466451
fengb
How does compiling GCC or LLVM work? I thought they have architecture specific stuff

1562466732
andrewrk
fengb, not sure what you mean, can you elaborate?

1562466846
fengb
The stage0 docs mention the bootstrapped C compiler to be able to compile GCC on any platform

1562466897
andrewrk
you build the cross compiler for the native target, but it's capable then of building for other targets

1562466950
fengb
Oh I see

1562467122
fengb
I need a better name for my project

1562467132
fengb
It started as a drunk joke and now I cringe every time I look at it

1562467147
hryx
do tell

1562467168
fengb


1562467244
hryx
neat interface :>

1562467260
hryx
fengboy

1562467398
daurnimator
andrewrk: want a bloom filter implementation?

1562467513
andrewrk
sure if it's a reasonably self contained implementation and has tests

1562467530
andrewrk
usual caveats apply with regards to moving stuff out of std as the language matures

1562467577
fengb
What's the story of naming Zig?

1562467625
andrewrk
random 3-letter word generation and using internet search engines to make sure "$name language" had 0 results

1562467655
fengb
That's less epic than I had hoped >_>

1562467674
andrewrk
I was going to call it ark but somebody beat me to it:

1562467705
andrewrk
with... amazingly the same goals

1562467744
andrewrk
"why didn't you just join their efforts?"

1562467750
andrewrk
scientes is going to love my answer to this question

1562467759
fengb
It doesn't look alive

1562467762
andrewrk
because I wanted to go fast and make all the decisions

1562467827
andrewrk
it was active back then

1562467842
andrewrk
but I went real fast :]

1562467874
fengb
Oh Zig is over 3 years old huh

1562467879
emekankurumeh[m]
is it possible to construct a @Vector that doesn't own it's memory?

1562467920
andrewrk
emekankurumeh[m], not sure what you mean

1562467965
andrewrk
a @Vector is a primitive type, like an integer

1562467971
emekankurumeh[m]
i think i'm looking for a vector of pointers

1562467999
andrewrk
that works. note that a bunch of stuff isn't implemented yet.

1562468036
daurnimator
oh that reminds me of a question I had

1562468046
daurnimator
do vectors work universally across targets?

1562468069
daurnimator
e.g. if I target avr and use 128bit vectors...will it do the right thing?

1562468083
andrewrk
I say this without having tested it: yes

1562468101
emekankurumeh[m]
i think that's up to llvm?

1562468109
andrewrk
zig the language defines the answer to be yes

1562468161
andrewrk
it should work fine, because llvm knows whether a target has vectors and how wide they are, so it's easier to flatten vectors into non-vectors

1562468175
andrewrk
that's the whole point of using vectors is that de-vectorizing is much simpler than vectorizing

1562468345
fengb
Some of these old issues are enlightening and confusing

1562468650
ntgg
what does [_] mean? I can't find it in the documentation

1562468760
daurnimator
ntgg: its a inferred length array literal

1562468843
fengb
It's in the latest:

1562468889
emekankurumeh[m]
does zig have automatic pointer dereferencing?

1562468928
andrewrk
emekankurumeh[m], yes for struct fields

1562468948
emekankurumeh[m]
but not in capture groups right?

1562469000
ntgg
in general if I want to be playing around with zig should I be building from master?

1562469033
fengb
At this point yes, there's quite a few breaking changes since 0.4.0

1562469059
fengb
The nightly build works pretty well for Linux and Mac if you don't want to build it yourself

1562469244
andrewrk
it's also available for windows and freebsd

1562469290
ntgg
is the AUR package any good?

1562469389
emekankurumeh[m]
i wish zig had a check mode where it would check the semantics of all branches to make sure things like types matched up

1562469446
emekankurumeh[m]
i know the lsp will help with that, but in the mean time that doesn't seem too hard to implement

1562470021
IntoxicatedHippo
> if so at top of collector file just put `comptime { _ = @import("file1.zig"); _ = @import("file2.zig"); ... }`

1562470046
andrewrk
emekankurumeh[m], it is hard to implement

1562470058
IntoxicatedHippo
mikdusan, That doesn't seem to work unless I also put an @export in collector file

1562470093
andrewrk
emekankurumeh[m], it's a consequence of lazy analysis

1562470121
IntoxicatedHippo
Is there a way I can return a string from a function at compile time and store it in an array without having to use an allocator?

1562470135
IntoxicatedHippo
Alternatively is there a comptime allocator

1562470167
daurnimator
IntoxicatedHippo: pass the array into the function?

1562470177
emekankurumeh[m]


1562470254
IntoxicatedHippo
I want to be able to change the length of the array but I suppose I could just make the array bigger then I'll ever need

1562470320
daurnimator
IntoxicatedHippo: you can use ++ to concat arrays at comptime

1562471901
emekankurumeh[m]
if you have `@This()` in a struct and you `usingnamespace` that struct, does `@This()` refer to the original struct or the one that `usingnamespace`'ed it?

1562471951
scientes
emekankurumeh[m], yes you can do a pointer to a vector

1562472003
scientes
but it has an alignment requirement and that is very important

1562472019
daurnimator
andrewrk: why are AT_* constants in bits/linux/$arch.zig instead of just bits/linux.zig?

1562472025
scientes
haven't tested unaligned vectors, but llvm should also work for that

1562472031
emekankurumeh[m]
scientes: i mean  you have some bytes and you want to do vector/SIMD operations on those bytes

1562472054
scientes
emekankurumeh[m], yes you can do that

1562472062
scientes
but I haven't tested unaligned

1562472086
scientes
it probably only works with aligned, cause that is what is like in C

1562472097
emekankurumeh[m]
my alignment should be 1 because i'm using packed types

1562472328
emekankurumeh[m]
how would you go about doing that?

1562472345
scientes
I've been doing that with assembly in C

1562472376
emekankurumeh[m]
so zig `@Vectors` don't support that yet?

1562472386
scientes
It is certainly a valid use case, but I have not managed to get the generic stuff to work with that

1562472394
scientes
but I have not looked into it

1562472456
scientes
not sure what the interface should be either, (or for other unaligned loads), because in C you would have two versions of the struct, one with align 1 and another with native alignment

1562472504
emekankurumeh[m]
perhaps support for only packed structs?

1562472516
scientes
maybe zig should have a @unalignedLoad @unalignedStore

1562472554
scientes
or some other way to change the alignment just for a load-store separate from aligned pass-by-reference

1562472569
andrewrk
zig already has alignment in pointer metadata that correctly propagates to loads and stores

1562472638
andrewrk
btw scientes here's a sneak peak at what I'm working on:

1562472640
andrewrk
good night

1562475639
ntgg
can I have a function that returns an anonymous struct?

1562475663
ntgg
something like `fn foo() struct { a: u32, b: u32}`

1562475708
ntgg
alternatively is there a tuple-like type?

1562476346
daurnimator
ntgg: yes

1562476360
daurnimator
ntgg: just return your struct :P

1562476376
daurnimator
fn foo() type { return struct { ..... }; }

1562476534
ntgg
I don't want to return a type, I want to return an instance of that struct

1562476608
daurnimator
you can do that too.... just go for it :P

1562476712
ntgg
I am trying that, but I get an error:

1562476964
daurnimator
ntgg: your function is returning the type itself, not an instance of it

1562476992
daurnimator
ntgg: `struct { a: u32 = a, b: u32 = b }` is a struct

1562477054
daurnimator
ntgg: I'm wondering why you want a single instance of an anonymous type?

1562477117
ntgg
I want to return more than one thing from a function

1562477413
daurnimator
ntgg: hrm. maybe something like: fn foo() struct { a: u32, b: u32} { return @typeInfo(@This()).ReturnType{.a = a, .b = b}; }

1562477628
ntgg
daurnimator: I was able to get it working by doing this:

1562481323
ntgg
is there a way to take in a value of any type without specifying the type?

1562481444
ntgg
like fn anyType(val: <value?>) @typeOf(val) {...}

1562484280
daurnimator
ntgg: var

1562484297
daurnimator
ntgg: fn anyType(val: var) @typeOf(var) { .... }

1562484411
ntgg
daurnimator: thanks! you have been super helpful

1562485480
daurnimator
Has anyone got sample Vector code?

1562485499
daurnimator
==> how do I access a vector element? I'm getting: error: array access of non-array type '@Vector(128, u8)'

1562487605
ntgg
daurnimator: I

1562487658
ntgg
daurnimator: see example here:

1562487696
ntgg
daurnimator: like if you want to add a bunch of numbers you can add two @Vector's

1562487852
ntgg
daurnimator: I don't think you are able to access an element of a @Vector

1562489391
daurnimator
looks like I have to cast it to an array...

1562489502
daurnimator
grrr... and it makes it hard with a pointer

1562489515
daurnimator
error: expected type '*[128]u8', found '*@Vector(128, u8)'

1562489808
ntgg
daurnimator: I think they are designed to be build from arrays

1562489823
ntgg
daurnimator: ie:

1562489934
ntgg
row is supposed to be col in the for loop

1562489943
ntgg
but that is just naming

1562490272
ntgg
I havn't done too much work with them, but iirc that is how they work in Rust

1562492544
ntgg
I keep getting expected type *<type> found *const <type>

1562492557
ntgg
essentially on any array acesss

1562492608
ntgg
but sometimes I can access an array without that error, seemingly in the same situations

1562492953
daurnimator
ntgg: on an *access*? that error should only be on an assign/mutate

1562493042
ntgg
daurnimator: I am getting it here: error: expected type '*Vec(4)', found '*const Vec(4)' return self.data[col].get(row);

1562493075
ntgg
little arrow is pointing at the first '['

1562493105
daurnimator
ntgg: what is the signature of .get ?

1562493222
ntgg
daurnimator: pub fn get(self: *Self, i: usize) *f32 { return &self.*.data[i]; }

1562493266
daurnimator
ntgg: there's your problem :)

1562493300
daurnimator
ntgg: you either want `self: Self` or `self: *const Self`

1562493358
ntgg
daurnimator: ah! that makes sense, thanks again

1562493366
daurnimator
`self: *Self` is a mutable pointer => and you get your error depending on if `self.data` is constant or mutable

1562493427
daurnimator
ntgg: in general, `self: Self` is what you want if you're not modifying anything

1562493549
ntgg
if I wanted to set a value at a point, would I have a set method, or would I return a non-const pointer from a getter, or something different?

1562493929
ntgg
what is the zig way of doing that?

1562494043
daurnimator
ntgg: I don't think there's a simple answer.

1562495031
ntgg
that's fair, I guess I'll figure it out as I learn zig.

1562495415
daurnimator
hmmmmmmm '@Vector(1024, u1)' has size 1024

1562495511
daurnimator
likewise '@Vector(1024, u24)' has size 4096

1562495516
daurnimator
which I guess does match arrays

1562495520
daurnimator
but wasn't what I expected

1562495902
ntgg
is there a way to run tests in all files?

1562495983
daurnimator
ntgg: in the standard library? or in your project?

1562495994
daurnimator
ntgg: basically..... `zig build test`

1562496044
daurnimator
ntgg: but also. usually you run `zig test libraryentrypoint.zig` and in there you would import your tests from other files

1562496804
ntgg
daurnimator: In my project. Why is the file with all the tests imported preferred? seems much more complicated than automatically collecting all tests.

1562496813
ntgg
to the user, not the compiler.

1562496897
daurnimator
ntgg: I'm not totally sure; you'll have to ask someone else

1562496952
daurnimator
but in general zig isn't meant to be easy to write; it's meant to be simple to understand/read/debug. I would think that explictly listing paths is the path of least "magic" so that someone can follow exactly why a given test is being run

1562497081
IntoxicatedHippo
Is there a cleaner way to do this? std.mem.copy(u8, code[5..], @sliceToBytes(([_]usize{@ptrToInt(func)})[0..]));

1562497110
IntoxicatedHippo
func is a fn()

1562497187
daurnimator
IntoxicatedHippo: o.o why are you seemingly serialising a function pointer?

1562497211
IntoxicatedHippo
I'm generating machine code at run time

1562497224
daurnimator
IntoxicatedHippo: what is `code` there? perhaps you would rather a `packed struct`?

1562497264
daurnimator
IntoxicatedHippo: otherwise perhaps you want to be writing to `code` via a std.io.OutStream

1562497435
IntoxicatedHippo
code is just a string, I didn't realise outstream had integer writing functions, that will certainly make this slightly cleaner:

1562501117
daurnimator
How do I get from a u1 to a bool?

1562502215
mq32
daurnimator: what about (my_u1 == 1) ?

1562503930
ntgg
is it possible to switch on a string?

1562504330
daurnimator
mq32: ah yep that works. but to complicate it, I need to do it when the dest type is dynamic: bool_or_u1(0)

1562504367
daurnimator
I'm currently writing out: if (dest == bool) x != 0 else x

1562504375
mq32
introduce a new function "to_bool_or_u1" which takes a u1 and outputs a comptime type?

1562504707
ntgg
daurnimator: is there a reason you can't use @boolToInt for the bool?

1562504716
ntgg
@boolToInt returns a u1

1562504770
daurnimator
ntgg: that's the opposite way around

1562504784
daurnimator
ntgg: I have a u1, and I want either a bool or a u1 depending on the variable `type`

1562506111
via
i'm trying to link my mostly embedded c project (which requires newlib) against newlib, but when i specify "c" as a library, and even specify the correct library path for my newlib installation, zig complains about being unable to provide a libc

1562506125
via
is a way i can make it treat it as any other static library i want to link against?

1562506522
via
i see where need_system_paths gets set in build.zig, but i don't see that its used in any non-native case, thus it just kinda prevents "c" from being linked against?

1562506551
via
i suppose i could rename the static archives ...

1562508559
very-mediocre
Say you've got `const next_byte = somethingThatCanError() catch |err| switch (err) { error.EndOfStream => null, else => return err, }` in the body of a function that returns `!void` - it seems zig things the outer function can return error.EndOfStream?

1562508580
very-mediocre
thinks*

1562509095
daurnimator
currently getting "error: unable to evaluate constant expression".... and no other info =>

1562509164
andrewrk
daurnimator, that's a good thing to do, will take some nontrivial changes to semantic analysis to implement

1562509282
daurnimator
no but really.. wtf am I doing wrong here >.<

1562509298
daurnimator
`const BF = BloomFilter(128 * 8, 8, Cell, builtin.endian, HashFunc(128 * 8));`

1562509312
daurnimator
and it's pointing at the opening parenthesis of after HashFunc

1562509367
daurnimator
where HashFunc is:

1562509842
andrewrk
if you're willing to crack open the debugger, you can look at the zig ir instruction it's pointing at, by putting a breakpoint on add_node_error and then going up the stack until you get into ir_exec_const_result

1562509864
andrewrk
it's looking at a zig ir instruction that it's determining has side effects and wasn't able to be determined at comptime

1562509887
andrewrk
the id of the ir instruction and type could be a clue

1562509939
andrewrk
function calls are runtime known unless the return type requires comptime, so your HashFunc call is probably returning a runtime-known function pointer

1562509983
andrewrk
I think I opened a proposal recently that would solve this

1562510041
andrewrk


1562510060
andrewrk
daurnimator, I suspect this might be it ^

1562510353
daurnimator
andrewrk: ah yes it was!

1562510423
andrewrk
one hint is that if it's pointing at the ( then it's actually talking about the entire function call result. self-hosted handles this a bit better (underlines the entire expression)

1562510439
ntgg
fg

1562510451
ntgg
whoops

1562510941
daurnimator
Also re: @popCount: I think the argument checks are wrong?  I'm getting `error: expected type 'u6', found 'u8'` when I call `@popCount(u6, a_u8)`

1562511023
andrewrk
that looks correct to me. the first argument just sets the type of the second parameter, and you can't implicit cast a u8 to a u6

1562511051
andrewrk
if the first arg feels redundant then use @typeOf(a_u8)

1562511066
daurnimator
andrewrk: I thought the first argument set the type of the result?

1562511091
andrewrk
daurnimator, the docs explain this

1562511109
daurnimator
andrewrk: the docs for @popCount are pretty broken. I commented on that just a few hours ago :P

1562511136
andrewrk
how so?

1562511150
daurnimator
andrewrk: uh... have you tried reading them?

1562511178
daurnimator
"@popCount(comptime T: type, integer: T) Counts the number of bits set in an integer."        okay so far

1562511197
daurnimator
"If integer is known at comptime, the return type is comptime_int." ... but what is T for?

1562511224
andrewrk
the first argument just sets the type of the second parameter

1562511234
andrewrk
if the first arg feels redundant then use @typeOf(a_u8)

1562511270
daurnimator
andrewrk: the result of a @popCount should be Log2Int of the argument

1562511289
andrewrk
that's also mentioned in the docs

1562511325
andrewrk
it's not necessarily Log2Int

1562511332
andrewrk
because of non-power-of-2 integers

1562511373
daurnimator
ah right its Log2Int+1

1562511383
daurnimator
e.g. I have the u8 0b11111111 => the max population. which is 8. which fits in a u4.

1562511397
andrewrk
ok so the popcount doc issue can be closed then?

1562511402
gonz_
Am I missing something? It says pretty clearly what it returns and why T is there

1562511517
daurnimator
I guess I'm used to the many functions where the first parameters is the result type. e.g. all the casts, or mem.readVarInt.....

1562511598
daurnimator
andrewrk: okay wait a second then.... if the integer is comptime known it suddenly changes the return type?

1562511622
daurnimator
@popCount(u8, comptime u8(42+5)) // is the result a comptime_int?

1562511652
andrewrk
that's a bit of a weird characterization of the behavior, lots of operations have a comptime_int result when the operand(s) are comptime_int

1562511712
andrewrk
oh I see the question here. yeah that is how it works. comptime_int is designed to be always preferable when possible

1562511744
daurnimator
is there anything else in zig that has that special case?

1562511756
daurnimator
being comptime-known affecting the type seems.... super weird

1562511790
andrewrk
implicit casting integers works when comptime known, where otherwise it would be a compile error

1562511804
andrewrk
e.g. a u64 to a u8 normally can't implicit cast, but it can if comptime known

1562511819
gonz_
I was gonna say, it's only bad if it puts more restrictions in the special case

1562511827
gonz_
but this is the opposite (?)

1562511884
andrewrk
you can think of the result type of @popCount as "as few bits as possible" and when the operand is comptime-known, that's even better

1562511921
andrewrk
however it would be reasonable to make the type consistent, because the result would still be comptime known

1562511931
andrewrk
so it could still participate in casts and such

1562511959
gonz_
andrewrk: What's the policy on the standard library and Win32 headers? There's a lot of expansion to be / that can be done there, but maybe bloating the standard library code base with everything kernel32, etc. is inadvisable?

1562512041
andrewrk
gonz_, the plan is to have whatever we need in there for the standard library itself. the endgame will be to have a separate package (available with the package manager) for a more complete windows API. such a package can import the std lib namespaces and add the rest, so as to be compatible

1562512054
daurnimator
gonz_:  we do essentially need to translate all kernel32 and nt headeres into zig

1562512054
gonz_
Mhm, ok

1562512164
via
is there any way with zig build to link against newlib for a non-native target? the code seems to special-case linking against c or m

1562512211
andrewrk
via, what target os?

1562512218
via
arm freestanding

1562512240
andrewrk
is it a special fork of newlib or is it actual newlib?

1562512255
via
i have newlib static archives, i just need to link against it

1562512259
via
actual newlib

1562512281
via
but i would like to link against what the archives i have for consistency if possible

1562512288
andrewrk
what functions are missing when you don't link it?

1562512318
andrewrk
consistency with what? sorry for all the questions, just collecting data on this use case

1562512330
via
i'm trying to use zig to compile an existing c project, so that i can start slowly porting parts to zig

1562512344
via
it uses various libc things, including sprintf and family

1562512375
andrewrk
if zig was able to provide sprintf & family automatically, would that be satisfactory?

1562512431
via
probably not, but maybe, but even if it can i want a baseline that is more or less what i have now with very few changes

1562512452
via
i can ween it off the libc deps, but i need to make it work first

1562512500
andrewrk
stick with me for a minute though, why would that probably not work? what would go wrong?

1562512527
andrewrk
I'm suggesting that you'd be able to build your existing c code with no changes with zig, without even needing newlib, and everything would build

1562512587
via


1562512643
via
i would really like to change as little as possible at once, i'm pretty familiar with the limitations and performance of the arm newlib code, and want to be able to benchmark my z vs zig-built code

1562512650
via
c*

1562512664
via
its already a big jump for me to be building with clang instead of gcc

1562512710
andrewrk
I see, ok, that's fair enough. so I think what I'm suggesting is still a good idea, it's just a bit unscientific to go from where you were before to there all at once

1562512740
via
yeah, i mean, i've got no issue with going that route, but for me in this particular case, making changes is dangerous

1562512770
andrewrk
one way to make a smaller leap is to use zig to build a library and still use gcc to link

1562512795
andrewrk
so build all your C code into a .a with build-lib, but still do the link step with gcc

1562512800
via
yeah, i was considering that too, but was hoping to switch to zig-build given that i don't love my makefile

1562512805
via
yep

1562512825
andrewrk
this is just a test though right? if it went well, and then if zig was able to provide the rest of those symbols, you could go all in

1562512834
via
though it does feel a little silly that i can't just linkSystemLibrary("c") when i have a libc.a here

1562512844
via
yeah, but this is a long term thing, it might be a while

1562512858
andrewrk
fair enough. hmm ok, let me think about how to solve this use case

1562512880
via
is there a hack i could do now to try it at least? short of recompiling zig without that check

1562512890
via
i was looking at the libc-path file thing, but that doens't seem to be used by zig-build

1562512938
andrewrk
I'll push a quick patch to add a zig build API for the --libc parameter

1562512961
via
then it would respect a path file?

1562512996
andrewrk
use `zig libc` to create a template file, then edit those paths, and you'll be able to use this file in the build

1562513015
via
okay, cool, thank you

1562513033
andrewrk
there may need to be a couple other changes if newlib has different path conventions

1562513060
via
i was wondering -- is {static_}crt_dir used to determine where the alib is?

1562513089
andrewrk
by alib you mean libc.a right?

1562513098
via
yeah

1562513259
andrewrk
I think for this workaround right now, you'll need crt_dir set and nothing else. and we'll pass --library-path for libc.a

1562513276
andrewrk
you can test this without zig build to make sure it works with `zig build-exe` while I make this patch

1562513496
andrewrk
via, ok, pushed

1562513561
andrewrk
does newlib have crt1.o?

1562513646
via
apparently not --

1562513672
andrewrk
also what's this __assert_func?

1562513699
andrewrk
what's in that directory?

1562513742
andrewrk
I know how to solve the other stuff - crti.o, crtn.o, -lgcc, -lgcc_eh

1562513768
via
some of my stuff uses some newlib-specific functionality (implementing _write for the abort handler, etc)

1562513836
via


1562513884
andrewrk
ok so it's crt0.o in this case, hmmm

1562513897
via
i don't think i actually need that

1562513905
andrewrk
really?

1562513906
via
i'm handling startup myself

1562513925
via
libopencm3 owns the reset vector and calls main

1562513986
andrewrk
ok. I'll put some logic in here that disables crt*.o for freestanding

1562513986
via
the only thing i actually need is to link against libc.a and libm.a

1562514006
via
i can rename them and verify that

1562514006
dimenus
why would zig print out a [*c] const u8 as a u8@<addr> even though the format string specifies a string?

1562514022
andrewrk
via, if that's all you need, I think you can simply not pass --library c, and pass --object libc.a --object libm.a

1562514035
via
oh

1562514050
via
can i do that through zig-build?

1562514060
dimenus


1562514061
andrewrk
addObjectFile

1562514085
dimenus
do i have to deref pCallbackData somehow?

1562514100
andrewrk
dimenus, probably a bug or oversight

1562514107
andrewrk
sounds like it should be improved

1562514139
andrewrk
I think it should be a compile error actually, unless the format string specifies that it's null terminated

1562514183
dimenus
how do you do that?

1562514211
via
andrewrk: well, that worked perfectly

1562514222
via
i mean, i think, let me test some things

1562514250
dimenus
hmmm, casting / assigning it a new name as type [*]const u8 makes it work

1562514267
dimenus
so it's maybe it's just the user level code not handling the type properly?

1562514289
andrewrk
via, I still want to make it work without the newlib dependency though :)

1562514332
via
i think thats hard to do in a way that matches the newlib nosys use case

1562514342
andrewrk
why's that?

1562514355
via
i mean, how do you implement things that do io? with newlib the idea is it gives stubs for things like _write

1562514366
andrewrk
your linker errors didn't include any io

1562514391
andrewrk
were you planning on using those features?

1562514414
via
it did, through _exit and _abort -- other than that i did just use _write myself

1562514423
via
but those won't show as missing symbols, its just that i'm implementing stubs that newlib expects

1562514454
via
i know with zig i can do that by implementing the panic handler myself

1562514484
via
but with newlib you can implement a few stubs and more or less use fopen and fprintf directly if you want, and i'm guessing some embedded projects do that

1562514494
andrewrk
that's good to know

1562514503
andrewrk
how does fopen work in this case?

1562514561
dimenus
why do we truely need *T and [*]T? wouldn't it be better to just always ensure that an array/slice is created before trying to index/slice/etc?

1562514562
andrewrk
my idea is that zig will provide all the non-os functions in freestanding mode, and if you get linker errors for, e.g. fopen, then you can simply export that function to satisfy the linker

1562514586
dimenus
[*]T is non-safe anyway

1562514591
dimenus
unless I'm missing something

1562514596
andrewrk
*T is also non safe

1562514604
dimenus
agreed

1562514621
andrewrk
we don't truly need anything, we could just use C

1562514627
dimenus
hah

1562514629
andrewrk
the idea is to make it harder to shoot yourself in the foot

1562514640
via
that would be nice, though newlib does that a bit more lower level -- there are like 17 syscalls it expects to be implemented. newlib implements fopen, but expects _open and _isatty to be implented if you use them (it provides empty stubs if you don't, through -lnosys)

1562514669
andrewrk
via, and then you keep track of integer file descriptors? that's a bit of an invasive abstractino

1562514707
via
thats true. though i tihnk most people using them only implement stdin/stdout

1562514723
andrewrk
oh that's a good idea, zig could provide weak symbols that return ENOSYS unless you override them

1562514794
via
yeah

1562514816
via
well, my binary does nothing seemingly, i'll get swd and a debugger hooked up, but i think i've got it from here

1562514819
via
thanks for the help

1562514827
andrewrk
no problem thanks for indulging my questions

1562515914
via
unfortunately i'm running into some llvm-y issues that might be above my head (zig compiled c code is using blx instead of bl to jump to code when it shouldn't be switching modes, and its already in thumb)

1562515956
andrewrk
via, hmm, is this something that also happens if you use clang instead of gcc?

1562515968
daurnimator
is there a constant time compare in the std lib?

1562515976
via
i haven't tried, probably should have before doing this. i'll dig further

1562516038
andrewrk
via, btw you can pass --verbose-cc to see the args passed to clang

1562516055
andrewrk
daurnimator,

1562516087
daurnimator
andrewrk: so... "not yet"

1562516139
andrewrk
yeah. "don't even try, you'll be fighting against the language."

1562516161
andrewrk
inline assembly is the only solution for now

1562516169
daurnimator
:(

1562516214
andrewrk
is this for the bloom filter? my suggestion is to document it as vulnerable to timing attack and move on

1562516225
daurnimator
andrewrk: no. I was finishing up my gimli branch

1562516235
daurnimator
andrewrk: bloom filter PR is already submitted ;)

1562516241
andrewrk
crypto functions which are vulnerable to timing attacks are still useful

1562516285
daurnimator
btw, gimli Prng was so simple

1562516362
daurnimator


1562516415
daurnimator
though I should note that our Prng.init interface only takes a 64 bit seed. For any sort of security you need at least a 128 bit seed.

1562516501
andrewrk
sounds like that's worth changing

1562516625
daurnimator
andrewrk: how can I get a vector literal?

1562516685
andrewrk
implicit cast from an array

1562516714
daurnimator
how do I do that?

1562516743
daurnimator
`@bitCast(@Vector(12, u32), [_]u32{0} ** 12)` seems to segfault the compiler :P

1562516790
andrewrk
implicit cast, not bitcast

1562516822
andrewrk


1562516976
daurnimator
well I tried calling the vector type, and not failing with at least a message in my segfault: `unreachable: /home/daurnimator/src/zig/src/analyze.cpp:handle_is_ptr:4086`

1562516977
via
andrewrk: the intermediate objects have the correct calls, so i think the linking stage is whats breaking -- is there any way to add lld options?

1562516981
daurnimator
s/not/now/

1562517113
andrewrk
via, you can use --verbose-link to find out the linker line, and then manually invoke lld (if you have it installed)

1562517149
via
i didn't have it installed, was trying to figure out how zig used it lol, but yeah i'll just install it

1562517169
andrewrk
maybe we're not passing the correct -m option

1562517199
andrewrk
via, can you advise on this code?

1562517278
andrewrk
I'll note that clang has the same logic

1562517313
andrewrk


1562517357
andrewrk
maybe we need -mthumb?

1562517584
via
the issue is very specific to strcmp, and probably related to `ld.lld: error: ../../../../../../../newlib/libc/machine/arm/strcmp-armv4.S:127: unrecognized reloc 40

1562517633
andrewrk
yeah sounds like it

1562517652
andrewrk
LLD devs are pretty active with ELF stuff, are you up for filing an upstream bug report?

1562517669
andrewrk
they haven't branched for LLVM 9 yet so the timing is good

1562517684
andrewrk
also we can carry LLD patches in zig source

1562518411
via
i can, though i'm pretty unfamiliar with exactly whats not working here, might be an unimplemented relocation. let me see if i can get more

1562518468
andrewrk
it sounds like an unimplemented relocation, which would hopefully be straightforward to fix, and a nice upstream bug report would hopefully provide some motivation to the devs to do it

1562518523
via
R_ARM_THM_CALL, though it looks like they're all that, so why is strcmp failing specifically...

1562518637
via
i can't see that there is a relocation type 40

1562518661
via
oh, R_ARM_V4Bx

1562518796
via


1562519205
andrewrk
via, if you have a source build of zig you can try that patch

1562519233
andrewrk
deps/lld/lib/ReaderWriter/ELF/ARM/ARMRelocationHandler.cpp

1562519368
via
i need to build llvm8, might be a while

1562519741
via
actually i might have just fixed it, will report back in a minute

1562521179
via
holy crap it works. newlib has many sets of static libs, i was using the ones in thumb, i needed to be using the ones in thumb/v7e-m

1562521211
andrewrk
ah

1562521218
andrewrk
zig's provided libc would have solved that :)

1562521248
via
maybe, though do you really want to be basically maintaining your own libc?

1562521254
andrewrk
yes

1562521265
via
fair enough, though that sounds like a project by itself

1562521275
andrewrk
zig is ambitious

1562521289
andrewrk
simplicity is hard work

1562521782
via
for whatever reason i have to also build libopencm3 with clang, or else it hangs forever waiting for the oscilator to stablize. i dunno how to even begin debugging that

1562521836
andrewrk
sounds like an ABI mismatch

1562521868
andrewrk
if you look at the output of `zig targets` that's the purpose of the C ABIs list

1562521893
andrewrk
maybe hf vs non-hf?

1562521959
via
i'm building everything with hf, and actually if i build with clang either hf or nonhf it works, gcc it doesn't

1562521970
via
i mean, i kinda want to know wtf, but it is working, and i'm fine using clang

1562522024
via
i should probably do a lot of testing before i go plug this into my car

1562522804
via
performance looks good, not more than about a 10% perf decrease vs gcc with lto (a critical part taking 250 us instead of 220 us)

1562522849
andrewrk
hmm I have not considered doing LTO across the C and Zig code, but that is in fact possible

1562522866
via
yeah, thats what i started asking/talkign about in here last week

1562522882
via
i got everything to build using lto, but zig wouldn't auto inline the c parts

1562522892
via
but ... meh, not a huge requirement, just a nice to have

1562522905
andrewrk
would you mind opening an issue to track this use case?

1562522910
andrewrk
I think it's reasonable

1562522928
via
sure, i had a good test case handy, let me get it more presentable

1562523837
HelloThere54321
Hello the people, i was wondering if it is possible to provide extern values to a zig test

1562523865
HelloThere54321
Im writing an OS and the original externs come from the linker script

1562523904
andrewrk
HelloThere54321, here is an example:

1562523927
andrewrk
linker script:

1562523946
andrewrk
build script lines:

1562523967
HelloThere54321
yes, but when i run 'zig test FILE.zig' i get lld: error: undefined symbol: KERNEL_PHYSADDR_START

1562524002
andrewrk
oh for a test. you'll have to pass your -target and --linker-script args to `zig test`

1562524018
andrewrk
and it probably won't be able to run your test

1562524026
HelloThere54321
are, coolio, i didnt know if u could provide the linker script to the test command

1562524032
andrewrk
because it'll be a non-native target

1562524444
via
andrewrk:

1562524468
andrewrk
thanks via

1562524948
via
i'm awful at computers, dunno how i closed that, but fixed the description and reopened

1562531570
emekankurumeh[m]
andrewrk: why does windows have 2 bits.zig files?

1562531593
andrewrk
one is posix

1562531634
andrewrk
all the msvcrt libc stuff that is compatible, such as types that go with fopen

1562537969
hryx
I just spent a while brainstorming and mocking up what closures might look like in zig. it's so tricky when you want to have explicit memory management

1562538009
hryx
I'm wondering if it's worth it. What would closures bring to zig that isn't already possible?

1562538027
hryx
I think I've been staring at it too closely

1562538071
Tetralux
Personally, I think that being able to have fns in imperative scope are just fine.

1562538084
Tetralux
The most you want, if anything, is a lambda syntax.

1562538105
Tetralux
So you can do things like `var filtered = array.filter(x -> 2*x);`

1562538122
Tetralux
(.. That's the obv example, but you get my point.)

1562538128
hryx
I think the anonymous function syntax is great (hence my proposal) but it's the closure state that I'm questioning

1562538168
emekankurumeh[m]
perhaps we can reuse the `@Frame` concept that async is introducing?

1562538176
Tetralux
The only reason closures are handy at all is that you remove the need to pass a thing in as an argument that you otherwise would have to.

1562538190
hryx
Tetralux: for reference, here's the proposal for anonymous function syntax, but does not address closure-specific issues

1562538200
Tetralux
hyrx: Ta.

1562538239
hryx
emekankurumeh[m]: I was thinking about that, but my brain hasn't evolved enough yet to figure anything out

1562538286
Tetralux
I'm not sure about using the syntax for fn declaration.. but for anonymous fns, sure.

1562538314
Tetralux
You could have some sort of explicit variable capturing.

1562538330
hryx
Tetralux: yep, but that's not the big problem

1562538347
hryx
the problem is, what happens if you capture a stack variable reference, then go out of scope?

1562538375
Tetralux
What's an example of code that does that?

1562538394
Tetralux
Do you have a specific example in mind?

1562538398
hryx
maybe I can whip up an example and share it

1562538410
mq32
hryx: C++ does it the easy way: don't do it or die trying

1562538431
mq32
(capturing stack references)

1562538431
Tetralux
Oh -- I think I understand

1562538432
hryx
mq32: that makes sense and is so far the best I've come up with O_o

1562538444
mq32
yeah

1562538453
mq32
c# had its problems with capturing as well ^^

1562538464
Tetralux
A var you capture in the closure is a var in the fn you're creating the closure in, and is therefore a stack var.

1562538477
mq32
foreach(var x in list) { add(() => print(x)); } would capture a reused loop variable ^^

1562538498
mq32
so all captures would reference the same variable

1562538524
Tetralux
The simple way to solve that is to not have implicit captures.

1562538548
mq32
hryx, maybe you want to look up the GCC nested functions:

1562538549
mq32


1562538567
Flaminator
c# has nested functions also.

1562538587
mq32
money quote: If you try to call the nested function through its address after the containing function exits, all hell breaks loose.

1562538614
mq32
Flaminator, yes, but first since c# 7

1562538683
Tetralux
for(list) |x| { add(fn() [x] { print(x); }) }

1562538726
Tetralux
Eqiv to: for(list) |x| { add(fn(e) { print(e); }(x); }

1562538731
Tetralux
.. Something like that.

1562538738
mq32
the question is: how to implement that?

1562538750
mq32
i think the only reasonable way is what GCC does with trampolines

1562538762
mq32
because Zig does not have callable types

1562538782
Tetralux
That seems overkill.

1562538785
mq32
trampolines would also have the advantage to be compatible to existing C code

1562538792
Tetralux
Why not just have it be syntax sugar?

1562538792
hryx
anonymous functions, and functions-in-functions, are coming to zig I believe. I don't think they're huge issues. I'm just stuck on closure state

1562538817
mq32
what hryx says. thinking (and talking) about the same problem

1562538844
mq32
nested functions are no problem for a compiler, that's just a different name to assign

1562538846
Tetralux
I forget what trampolines are - I've never needed to care about the terminology xD

1562538866
mq32
"runtime composed function stubs" would most probably fit

1562538877
Tetralux
I'm not sure that's any clearer xD

1562538889
Tetralux
But it sounds overcomplicated.

1562538902
mq32
it's just some runtime generated assembler instructions

1562538911
mq32
"push those arguments to the stack, then jump to this function"

1562538923
Tetralux
Is there a good reason not to have closures just be normal fns that get auto-generated and the captured vars are just passes as invisible ptrs into it or something?

1562538938
Tetralux
(.. Which could also be inlined.)

1562538954
hryx
Tetralux: here's a small example showing a captured variable which has automatic storage, and therefore becomes garbage after `newCounter`:

1562538959
mq32
nah, invisible pointers are more complex to understand

1562538972
Flaminator
Was a nice feature in c# 7, I was passing local functions around that were using local variables from the functions it was passed from.

1562538973
hryx
(very small and forced example, also uses yet-nonexistent syntax, but you get the idea)

1562538995
mq32
Flaminator, local functions in C

1562539013
mq32
*c# are pure syntactic sugar for capturing lambda expressions (closures)

1562539046
Tetralux
nq32: I disagree. I have no idea what a trampoline is - and the computer doesn't either, to my knowledge.

1562539070
Tetralux
Whereas a simple fn with a ptr argument is a primitive.

1562539073
Tetralux
And simple, at that.

1562539084
Tetralux
Maybe I'm missing something.

1562539095
mq32
you want a hidden pointer?

1562539095
Tetralux
But I'm generally against theorectical sounding things.

1562539098
mq32
where does it pass?

1562539167
mq32


1562539199
mq32
Tetralux, have you ever programmed in assembler?

1562539211
mq32
trampolines can only be created in assembler, it's a really low level feature

1562539266
mq32
anyways, i have to go to sleep

1562539291
Tetralux
mq32: Ahhhh.

1562539310
Tetralux
Yeah - not done much of that.

1562539330
Tetralux
I know a few asm instructions - that's about it. xD

1562539363
Tetralux
hryx: Based on the fact that I'd have to read that code several times to understand what it was doing, that seems like a bad idea xD

1562539406
Flaminator
I am pretty sure local functions in c# are not syntactic sugar for lambdas.

1562539406
Tetralux
I guess every time you call c() it incrs count and gives you it.

1562539424
Tetralux
.. But count goes out of scope.

1562539447
Tetralux
I mean... could you global it I suppose.

1562539457
hryx
Tetralux: it's tricky isn't it! I just updated that gist with a more sinister example

1562539539
hryx
good night mq32

1562539589
Tetralux
Hmmm. I think I'd expect the captured count to be the same var as the original count.

1562539596
Tetralux
That's what it reads like.

1562539605
Tetralux
In which case, count is the count in newcounter.

1562539613
Tetralux
But that's also a stack var.

1562539643
hryx
yeah. the second example works a bit like how captures work in today's for loops, for example. |x| vs |*x|

1562539648
Tetralux
But when you return a fn that captures a stack var, Zig could do something speciail with it.

1562539673
Tetralux
In this case, it's clear it can't remain a stack var after newcounter is called.

1562539678
hryx
yep, but exactly what that something is... that's the problem :)

1562539702
Tetralux
How is the allocator thing being solved with the coroutine rewrite?

1562539710
andrewrk
hryx, it can work if the reference to the function does not escape the outer function

1562539745
Tetralux
andrewrk: You mean if you don't return c?

1562539747
hryx
andrewrk: would adding escape anlysis be worth it? I'm starting to wonder if the effort outweighs the benefits

1562539759
Flaminator
The one thing I noticed from most languages that reverse the order of name and type is that they don't reverse it for function signatures.

1562539771
andrewrk
escape analysis is planned

1562539792
hryx
holy moly, I almost forgot about the "make everything safe in Debug mode" idea

1562539798
andrewrk
yeah for that issue

1562539817
hryx
game changer then, maybe. maybe closures are allowed with certain constraints then?

1562539823
hryx
*could be allowed

1562539832
andrewrk
your example wouldn't work with what I'm saying

1562539856
hryx
yeah

1562539870
andrewrk
what you've created is basically a generator. there's a good possibility we will have those after coroutine rewrite

1562539886
andrewrk
because coroutines are functions that have more complicated lifetimes

1562539893
Tetralux
Ohhhh - That's true.

1562539926
andrewrk
I have a suspicion that any use case that wants closures can be rewritten to use stackless coroutines

1562539939
andrewrk
oh there's a 2nd example here

1562539943
hryx
that's exciting. honestly I've just had too much coffee and should be focusing my energy on fixing more bugs or something @____@

1562539956
Tetralux
I'm curious about how coroutines will work after the rewrite, because they seem a little mindbending with the docs I read.

1562539968
Tetralux
I have hope in them ;p

1562540006
andrewrk
the main goal is to be able to model pipelines with zig code

1562540022
andrewrk
in a way that allows code reuse-

1562540031
andrewrk
that's essentially what async/await is

1562540064
Tetralux
Define pipeline in this case.

1562540245
Flaminator
Might I ask what is the reason is why functions are not written like: "function_name fn(....) type {}" or something similar instead of the current "fn function_name(...) type {}"?

1562540283
Tetralux
andrewrk, Either way, I'm looking forward to some example code that uses it. :)

1562540364
Tetralux
I guess it'd be useful when you have several parallel things you need to do and you have work that makes it's way through each one of them.

1562540405
Tetralux
Or I suppose the "several parallel things" is the important part.

1562540435
Tetralux
I'm not sure how/if you'd use it for anything else though.

1562540465
Tetralux
I guess that's the problem I have. I'm having a hard time visualing where/how I'd use it.

1562540655
andrewrk
a pipeline is a directed graph of nodes and the goal is to complete the pipeline or otherwise maximize the throughput / minimize the latency of data flow

1562540675
andrewrk
directed meaning that some nodes depend on each other

1562540700
andrewrk
nearly all software can be modeled as a pipline

1562540749
hryx
QQ, will "hot swapping" involve some kind of JIT or being able to execute writable memory?

1562540757
hryx
(not sure if that's the right way to ask the question)

1562540782
hryx
mainly curious becaue macOS is going to have some special requirements for that in upcoming releases:

1562540795
andrewrk
hot code swapping is something that will have a minimum viable product and then incremental improvements

1562540808
andrewrk
it can depend on OS-specific features

1562540832
andrewrk
an MVP will probably be as simple as all functions being dynamically linked, and then atomically updated on a new version

1562540852
hryx
oh, I gotcha

1562541025
andrewrk
there could potentially be taking advantage of debugger features (ptrace on linux)

1562541038
andrewrk
that would require special privileges on macos, but I think that is reasonable

1562541053
hryx
yeah

1562542441
andrewrk
damn, I appear to not have debug symbols for zig0.exe on windows

1562542715
hryx
andrewrk: I was just looking at what it would take to implement #211 (runtime check for undefined). this caused me to look at optionals under the hood. does the "maybe bit" eat into the size of a scalar type?

1562542743
andrewrk
it does not

1562542773
hryx
interesting. trying to see where that bit lives

1562542782
hryx
for pointers I assume 0 means null

1562542786
andrewrk
yes

1562542822
andrewrk
the generated type for optionals is struct { payload: T, is_non_null: bool }

1562542848
andrewrk
is_non_null currently takes up a byte; we could simply treat it as a byte and look for 0xaa to detect undefined in safe modes

1562542895
hryx
gotcha, thanks. I was confused because I just tested @sizeOf with nullables, and of course it's the same for both optional and regular scalars (of the same type)

1562542915
hryx
so obviously sizeOf is aware if it's null and looks under the hood

1562542971
andrewrk
I would expect @sizeOf(?u8) to be 2 and @sizeOf(u8) to be 1

1562543026
hryx
I must have screwed something up. It is as you expected

1562543069
hryx
That 0xAA detection seems appealing since it doesn't involves messing with types in the compiler

1562543108
hryx
thanks for answering all my questions. hoping this knowledge will accumulate to the point where I can help with compiler internals a little

1562543207
andrewrk
looking forward to it :)

