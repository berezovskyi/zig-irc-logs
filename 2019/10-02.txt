1569997496
Gertm
How far along is Zig in terms of libraries? I couldn't find a reference to that on the website.

1569997574
Gertm
Not the stdlib, but third party libraries. Or is this too early in Zig's development still?

1570011592
samtebbs
Hi all. What would be the best way to read a packed struct T from a file?

1570011735
mikdusan
binary? you could write it out usual way. then later open file, mmap, close file, cast and copy, munmap

1570011876
samtebbs
Ok, that sounds a bit more complicated than just reading in the fields (they're all integers) and assigning them to an instance of the type.

1570011915
samtebbs
In C I would do something like `T t; read(file, &t, sizeof(T));`

1570011961
mikdusan
that'll work too

1570012028
mikdusan
std.mem.toBytes() and std.mem.asBytes() would be of service

1570012386
tencho
Hello.

1570012410
tencho
How do I make a struct non copyable ?

1570012566
samtebbs
mikdusan: oh nice, thanks

1570012808
mikdusan
tencho: i believe zig does not currently support non-copyable. but see these 2 issues that discuss it:

1570012811
mikdusan


1570012821
mikdusan


1570012901
rifkik
andrewrk

1570012908
rifkik
Can you please merge this?

1570012917
rifkik
or is there something preventing you?

1570012943
tencho
mikdusan: Thanks! Aha I had the second problem yesterday. I took me some time to figure it out.

1570014969
Sahnvour
andrewrk: ah, yes, the mandatory codegen bugs with new cl.exe ;)

1570015454
Barabas
It's so hard to find out what version you have of what in visual studio...

1570015465
Barabas
It really is amazing how they manage to make such a mess of things

1570016854
Sahnvour
Barabas: since VS 2017 it's actually OK by using visual studio installer, not the mess it used to be

1570016909
Barabas
Yeah it got better

1570016938
Barabas
Still they manage to put vcvars in a different magical place every time, and finding the version of the compiler is ehm... well just use the command line :P

1570018630
tgschultz
samtebbs: there is also serializer/deserializer in the standard library for more precise control and handling things like differing endianess.

1570021569
kenaryn
Hello, my good people.

1570021619
kenaryn
Please, is there any difference in time (i.d. microprocessor cycles) and/or space (i.d. memory) between a std.testing.except and a std.debug.assert instruction?

1570021643
kenaryn
testing.expect*

1570021695
kenaryn
I'm asking because both have some use cases in common.

1570022191
dingenskirchen
expect calls the panic handler, but assert invokes safety checked UB

1570022198
dingenskirchen
ie you can't rely on assert in release modes

1570022225
dingenskirchen
in debug mode it shouldn't make a difference since unreachable code (assert) just jumps to the panic handler too

1570022229
fengb
You can in release-safe

1570022245
dingenskirchen
true.

1570022469
kenaryn
What does it mean UB?

1570022527
kllr_sbstn
UB = undefined behaviour

1570022530
fengb
Undefined behavior

1570022549
fengb
Fancy way of saying the optimizer can do whatever it wants to

1570022611
kenaryn
Allright, thank you dingenskirchen, fengb and kllr_sbstn

1570022618
fengb
Assert is preferable in normal code if it’s a developer error

1570022649
fengb
And if it’s an actual error case, it should be handled with an error return

1570022751
kenaryn
Duly noted in a knowledge base. :)

1570023321
kenaryn
I would like to add there is a discrepancy between undefined and unspecified. The former one deals with invalid data construct or invalid data input while the second one deals with valid data construct or valid data input (see:

1570023322
kenaryn


1570024130
fengb


1570024161
fengb
I’m curious how many of these issues Zig’s debug allocator can catch at dev time

1570027319
_Vi
How do I make u32 enum of various "recognized" values, but also with support of custom values that has no official variant? Like `union(enum) { Variant1 = 0x1234, Variant2 = 0x5544, ..., Unknown: u32,}`, without exceeding u32?

1570027407
_Vi
Also how do I fill in large enum variants in comptime?

1570029315
_Vi
How do I include one Zig source file into another (without creating a struct wrapper)? Like `const content = [_]u32 = {  @include("content.zig") };`?

1570029978
mq32
_Vi, what do you want to achieve?

1570029997
mq32
@import already returns you a struct type (which is used as a namespace)

1570030567
_Vi
mq32, Include a generated part (based on information from network) without using trailer/footer in the source file.

1570030932
mq32
i would recommend a precompiler step

1570030944
andrewrk
Sahnvour, we can downgrade to MSVC 2017 if you think that's a good idea

1570030962
andrewrk
I'll have to rebuild the windows tarball and update all the wiki instructions

1570031425
sarahzrf
hi

1570031435
sarahzrf
im having trouble trying to do what essentially amounts to an algebraic data type

1570031458
sarahzrf
i think the problem is actually visible in the minimal case of just a binary tree with empty leaves, so—how would you write down that type in zig?

1570031510
sarahzrf
basically, it seems like if i try to do a self-referential tagged union where one of the variants needs to be an aggregate containing the self-reference, such as in a branch node of a binary tree, i have two options, both of which cause problems:

1570031540
sarahzrf
1. try to factor out the aggregate—in which case i get an error about there being a dependency loop;

1570031553
sarahzrf
2. use an anonymous struct type—in which case, how do i construct values?

1570031586
mq32
sarahzrf, you can use something like this:

1570031604
sarahzrf
i suppose in the simple case of a binary tree you could get away with nullable pointers, but that won't cut it for me, since i have a bunch of variants

1570031607
mq32
const Tree = struct { const Self = @This(); left : ?*Self, right : ?*Self };

1570031652
mq32
@This() allows self-referencing

1570031705
sarahzrf
ooh, if i make a local definition in terms of @This() instead of in terms of Tree, will that get rid of the dependency loop error

1570031760
sarahzrf
nope, it didn't :

1570031762
sarahzrf
nope, it didn't :|

1570031806
sarahzrf
mq32: that's not what my problem is, though

1570031864
sarahzrf
here, i can post my actual type for clarity if you like

1570031872
Cadey
how would I do memory-mapped I/O in zig?

1570031875
Cadey
assume no OS

1570031887
Cadey
like writing and reading to arbitrary addresses

1570031887
sarahzrf


1570031911
andrewrk
Cadey,

1570031927
sarahzrf
what ive pasted up there works fine, but im not sure how to actually /construct/ values of that type, since i dont have names for the fields of the Tens, Par, etc variants

1570031934
andrewrk
Cadey, if memory has side effects (e.g. MMIO) then you want volatile.

1570031938
tgschultz
_Vi, if you're including binary data (an array of u32s) you can generate it as actualy binary data and use @embedFile `const content = @bytesToSlice(u32, @embedFile("content.bin"))`. This assumes the same endianess of course.

1570031940
sarahzrf
*names for the types of the fields

1570031987
andrewrk
Cadey, there are a bunch of great bare metal zig projects to look at if you get stuck

1570031999
andrewrk
also #osdev is nice

1570032026
_Vi
tgschultz, Is it a good idea to generate functions and types based on `@embedFile` content in comptime? E.g. embed a `*.proto` Protobuf file and generate serializable Zig struct for it.

1570032039
samtebbs
mikdusan: Congrats on joining zig :)

1570032055
Cadey
andrewrk: thanks!

1570032095
mq32
sarahzrf: just name your struct types ;)

1570032101
andrewrk
Ah yes, please everybody welcome mikdusan as the newest Zig core team member!

1570032106
mq32
TensTerm instead of literal type

1570032111
halosghost
:D

1570032117
halosghost
mikdusan: congratulations!

1570032128
sarahzrf
mq32: as i said when i initially asked my question, that creates a dependency loop error

1570032131
konv
mikdusan, congrats!

1570032149
sarahzrf
at least, whatever it is that i've attempted does

1570032161
sarahzrf
so if you know a way of naming them that won't cause that error, please show me the actual code :)

1570032180
mq32
sarahzrf, give me a second

1570032182
andrewrk
sarahzrf, if you have a small code example that has a dependency loop error, and it seems like a false positive, can you open an issue for that? I recently introduced this concept "Lazy Values" to break such dependency cycles, but I don't think I covered everything

1570032206
sarahzrf
aaaaaaa

1570032207
tgschultz
_Vi The issue you will have is that there is no way to create a new struct at comtime with a dynamic number of fields. I created the PseudoStruct as a demonstration of how to do the same thing in userland code though.

1570032215
sarahzrf
maybe later...

1570032224
sarahzrf
btw, how much inlining does zig do

1570032236
sarahzrf
of function calls, sorry

1570032284
andrewrk
sarahzrf, you can semantically force inlining at the callsite or at the function definition. After that, nothing is semantically guaranteed by the language; it's up to codegen (which is LLVM in this case) how much inlining it does

1570032287
tgschultz
_Vi: I should clarify

1570032303
andrewrk
sarahzrf, in other words, it's state-of-the-art inlining

1570032314
sarahzrf
hrm

1570032324
mq32
sarahzrf:

1570032383
sarahzrf
im currently rewriting a small C file into zig, 1/2 because i would rather be using rust but im using pointers in a way that rust is not meant for and zig is an ok compromise, and 1/2 because im wondering if i can fine tune the inlining of some of it

1570032400
sarahzrf
so if clang wasnt already inlining something, it probably wont in zig if i dont ask it to with the @

1570032402
sarahzrf
?

1570032441
sarahzrf
mq32: wait, i couldve sworn i tried that!

1570032444
sarahzrf
what the heck

1570032500
mq32
also works with BinaryTerm outside of the term definition

1570032503
mq32
are you on 0.5.0?

1570032517
mq32
brb

1570032521
sarahzrf
oh

1570032523
sarahzrf
no, i'm on 0.4.0

1570032527
sarahzrf
i guess that explains it ;A;

1570032581
mq32
re

1570032588
sarahzrf
well, no, it doesn't, because i changed it to 0.4.0 on godbolt and it still compiled

1570032591
sarahzrf
hmm

1570032651
sarahzrf
oh wait what on earth

1570032654
sarahzrf
okay, i figured it out

1570032662
sarahzrf
the problem is that what i tried was actually a more thorough version of what you posted

1570032666
sarahzrf
with a few more definitions

1570032673
sarahzrf
and the dependency loop error was coming from a different one

1570032696
sarahzrf
namely: i was defining Node inside Term, and using it for Link and so on

1570032702
sarahzrf
and

1570032714
sarahzrf
??

1570032732
sarahzrf
but defining it inside Term and then using it to define Nodes and then using Nodes is fine

1570032738
sarahzrf
yall got a weird language

1570032759
sarahzrf
oh no wait it's not fine to use it to define Nodes

1570032769
sarahzrf
but it /is/ fine to use it to define BinaryTerm

1570032771
sarahzrf
¯\_(ツ)_/¯

1570032788
sarahzrf
oic, is struct {} lazy but * isn't?

1570035608
Sahnvour
mikdusan: congrats !

1570035766
Sahnvour
andrewrk: are we sure we hit the same bug as the ticket linked in

1570035813
andrewrk
Sahnvour, I can't be completely sure, but reading the thread it does seem to match

1570036546
Sahnvour
disabling optimizations on buffer.cpp doesn't make the bug disappear, so I doubt it's linked to the fnv hash

1570036597
Sahnvour
let's see what RelWithDebInfo has to say

1570036916
Sahnvour
build passes ... great. maybe CMake is doing a bit more than just enabling debug info in this target

1570036977
_Vi
Is it OK to use `type` as identifier?

1570036996
scientes
no

1570037002
scientes
_Vi, type is a keyword

1570037004
_Vi
It seems to be accepted without warnings.

1570037013
mq32
afaik type is not a keyboard, but just a name

1570037017
_Vi
`fn type()void{}`   `struct { type : u32 }`

1570037022
mq32
(as type is a type variable)

1570037026
scientes
hmm, there were some changes

1570037034
scientes
of semi-keywords

1570037035
_Vi
If no, what to use instead?

1570037052
scientes
much as you can name a variable "true" in C

1570037063
_Vi
`type_`, `typ`, `typee`, `typE`?

1570037094
Sahnvour
_Vi: keywords can be used as identifiers with the @"" operator, for example @"fn"

1570037102
andrewrk
convention is to make names of types TitleCase

1570037110
scientes
^

1570037112
andrewrk
so, Type or even T is pretty OK

1570037131
_Vi
Is `@"type"` a recommended variant for naming a function or struct field that denotes some sort of type?

1570037143
Sahnvour
probably not

1570037149
andrewrk
also related: counterintuitively, zig might benefit from making more things keywords, because then we can use @"syntax"

1570037169
Sahnvour
iirc it's mostly needed for interfacing with C where identifiers can exist that are reserved in zig

1570037202
andrewrk


1570037224
_Vi
In Rust it is OK to use similar feature (`r#some_name`) not only for compatibility, but also for naming things without workarounds.

1570037291
_Vi
So I don't expect it to be very wrong to just use `var @"test" = "content of the test";`.

1570037324
_Vi
What other keywords or semi-keywords in Zig are full words, not abbreviations?

1570037544
_Vi
`error: declaration shadows primitive type 'type'`. Looks like unlike struct fields, functions are not OK...

1570037568
_Vi
How do name it then? `get_type`?

1570038896
tgschultz
functions are usually named like `getType()` unless they return a type, then they're named like types, i.e. `GetType()`

1570038943
tgschultz
I often use `kind` in place of `type` as a name.

1570038988
tgschultz
or `x_type` where x is some meaningful descriptor.

1570039043
nrdmn
I've named a few struct members 'type' where the original specification called them 'type'

1570039048
nrdmn
should I change this?

1570039426
andrewrk
nrdmn, I think sticking to the spec names is good

1570040230
Sahnvour
I don't understand cmake. I modified CMakeLists.txt but need to wipe the build dir, reinvoke cmake from scratch, otherwise it wasn't taken into account when invoking ninja

1570040308
andrewrk
I'm not a fan of cmake

1570040326
andrewrk
the main feature of cmake is ubiquity

1570040370
Sahnvour
as I understand it, it's just becoming actually usable in the recent versions

1570040418
andrewrk
it still won't let us run `zig build` on `make install` :-(

1570040419
Sahnvour
if I had time I'd probably write fastbuild scripts and use that to build zig on my machine

1570040486
Tetralux
What's that?

1570040524
Cadey
wait, why would you build during make install?

1570040528
Sahnvour
Tetralux: a build system,

1570040543
Tetralux
Cadey: My money's on stage 2; andrewrk?

1570040570
torque
clearly rewrite your cmake build system in meson

1570040577
torque
that definitely won't cause insanity

1570040587
andrewrk
Cadey,

1570040592
Cadey
torque: are you implying our entire industry isn't insanity?

1570040616
Tetralux
How about you rewrite it in C++ - one language then xD

1570040624
Cadey
oh jesus

1570040642
Cadey
andrewrk: also slightly related, why is the standard library named with the same acronym as sexually transmitted disease?

1570040661
andrewrk
just to keep people on their toes

1570040666
Cadey
xD

1570040682
Tetralux
I always read 'std' as 'standard' anyway xP

1570040686
Tetralux
NO STD HERE BUDDY

1570040689
companion_cube
aren't a lot of stdlibs… "std"libs?

1570040709
Tetralux
companion_cube: Which I read as "standard libs" x)

1570040733
Tetralux
Just like 'ptr'; I always read it 'pointer' and not "pudder"

1570040761
fengb
pooter

1570040785
Tetralux
Yours is worse xD

1570040801
Tetralux
Also - stupid question - why do people feel the need to even have a build system?

1570040812
Tetralux
Why not just make a compile-time program that does it all?

1570040815
Cadey
god died?

1570040815
Tetralux
Like, really.

1570040829
fengb
Because C compilation is hard and not solved well

1570040832
companion_cube
Tetralux: isn't it exactly build.zig?

1570040836
Tetralux
Cadey: That implies they we ever alive ;P

1570040847
Tetralux
companion_cube: Yes and no; not imperative code.

1570040849
torque
because there are an insane number of bizarre and broken system configurations and it's easier to let the build system try to wrangle that mess

1570040854
Cadey
Tetralux: C's lack of a build system out of the gate is what killed god

1570040856
Cadey
tbh

1570040862
companion_cube
writing imperative code for the build? :/

1570040871
companion_cube
makes parallel/incremental build basically impossible…

1570040887
scientes
Cadey, it had a build system, things like ports

1570040898
Tetralux
companion_cube: Incremental introduces a whole class of problems that are hard to detect and easy to avoid.

1570040901
scientes
before the internet was very different

1570040910
companion_cube
except when you want stuff to build quickly…

1570040915
Tetralux
Parallel building isn't that hard with imperative code.

1570040919
Tetralux
But more to the point

1570040926
companion_cube
also, you need to handle dependencies manually…

1570040931
Tetralux
You don't really need it if your compiler is intelligently designed to be fast.

1570040940
Cadey
Tetralux: it's a surprisingly hard problem regardless

1570040959
Cadey
if you have a better idea, i'd challenge you to make it a reality

1570040960
companion_cube
somehow I doubt zig will always compile quickly, given the existence of comptime

1570040971
andrewrk
I have a lot of tricks up my sleeve

1570040979
andrewrk
I won't give up on the fast compilation goal

1570040981
companion_cube
I mean, in non incremental settings :D

1570040994
Cadey
i wonder what the kubernetes sized codebase in zig is going to be

1570040997
companion_cube
if there's an expensive comptime computation, hard to not do it ^^

1570041008
companion_cube
Cadey: llvm in zig, obviously :°

1570041034
fengb
If Go can write their own backend, why can't we?

1570041043
andrewrk
compiler backend in zig is inevitable. people want more backends than llvm provides, and also llvm is slow

1570041062
Tetralux
companion_cube: Yeah, but you're smart enough to understand that if you try to simulate the universe at comptime that it might impact your compiles times ;)

1570041064
companion_cube
for -O0 or -O1, sure

1570041075
companion_cube
Tetralux: yeah but incremental compilation can help there ;)

1570041096
fengb
Increment the universe 🤔

1570041110
Tetralux
companion_cube: I'd rather just be able to compile at 1 MLoc/s.

1570041119
Cadey
Tetralux: let's leave that metric to V

1570041120
companion_cube
give a try to V ;)

1570041124
Cadey
lol

1570041127
companion_cube
heh 😂

1570041132
Tetralux
Cadey: I was thinking more of Jai, but :)

1570041147
Cadey
companion_cube: i reran my million lines of code benchmark on V recently

1570041151
Cadey
double-free segfault

1570041151
andrewrk
Cadey, they removed "wip" from the speed claims regarding compilation perf, is it accurate?

1570041165
companion_cube
does it segfault under a second though?

1570041175
Cadey
andrewrk: i can't replicate their benchmakrs on any hardware i have

1570041179
Tetralux
I consider V to be an early-access at best.

1570041181
Cadey
hold on let me rerun it to be sure

1570041186
Tetralux
Definitely not worth writing anything in yet.

1570041195
companion_cube
or ever

1570041208
Sahnvour
hooray, managed to overide cmake's default optimization flags, now onto debugging

1570041218
andrewrk
sorry Sahnvour  :(

1570041220
Tetralux
IMO, Jai has more promise, in spite of not being available - that should tell you something about how I feel about the situation./

1570041223
torque
on the other hand, Jai isn't even real so it makes even less sense as a point of comparison

1570041230
fengb
Isn't the compiler just converting the code to C?

1570041231
andrewrk
if you decide that it would be best to go back to 2017, I'll do the related chores

1570041233
andrewrk
Sahnvour, ^

1570041242
Cadey
it doesn't double-free anymore, but it does fail at 50,000 statements 2 seconds into the compile

1570041249
torque
you're going to build a time machine???

1570041254
Sahnvour
andrewrk: I hope we won't have to resort to this and can workaround/have MS fix it quickly

1570041264
andrewrk
torque, yes a time machine to back when MSVC compiled zig correctly

1570041272
Sahnvour
now that uninstalling VS is easy I'd rather not have multiple versions of it :p

1570041280
Cadey
at least on kahless (Intel(R) Xeon(R) CPU E3-1245 V2 @ 3.40GHz)

1570041292
Tetralux
I really hate it when people say "This ain't real" - that's not how English works - you mean "I haven't [been able to] use it yet."

1570041296
Cadey
i can check my mac when i get home

1570041309
Tetralux
Like c'mon - you

1570041315
andrewrk
Cadey, but like give them the benefit, do the 50,000 multiplied out to a million or whatever

1570041329
andrewrk
the question is what's the actual perf

1570041336
fengb
Maybe it's IO bound

1570041337
Cadey
andrewrk: i need to refind the lobsters thread that had a better generated file

1570041347
Tetralux
andrewrk: Question, why

1570041353
Tetralux
Or is that a stupid question?

1570041371
torque
no, I mean it isn't real, but it's not worth arguing the semantics about

1570041373
fengb
No such thing as stupid questions

1570041380
Tetralux
fengb: +100.

1570041387
fengb
But sometimes we have stupid people asking questions 🙃

1570041387
ave_
Heya

1570041390
Sahnvour
Tetralux: it does already work

1570041399
andrewrk
Tetralux, clang support on windows is in scope too, but I haven't the time & energy yet to provide support

1570041431
Tetralux
andrewrk: I ask, because it's easier than using VC.

1570041445
andrewrk
the point of stage1 is to be able to get built by a large variety of systems. then self-hosted only has to be able to get built by stage1

1570041456
Tetralux
And since I already using clang on Linux anyway to build Zig...

1570041464
Cadey
it's over a second and it's still chugging

1570041471
Tetralux
One might say..

1570041482
Tetralux
That's it's a local maximum to resort to the likes of VC on Windows ;)

1570041487
andrewrk
Cadey, I don't even know how speed of compilation is on the table when it's

1570041489
Cadey
at least using this benchmark to make a file:

1570041500
Cadey
andrewrk: my car can fly with the power of lies

1570041530
Tetralux
andrewrk: I believe the idea, based on the intro, was that 1Mloc/s will be achieved by a custom x64-generating backend.

1570041539
andrewrk
Tetralux, but they removed the "wip" label

1570041564
Cadey
gcc is currently very confused compiling it

1570041565
Tetralux
Does `v -x64 file.v` work now or something then?

1570041567
fengb
This thread makes my brain hurt and I'm 1 comment in

1570041616
Cadey
yeah it's been over a minute and it's still not built

1570041619
THFKA4
let's extend this

1570041631
andrewrk
ok. I don't think V is an interesting language, if we talk about it, it's just going to be circle jerking, and that's not what #zig is for

1570041632
THFKA4
maybe we can reach 3M loc/s

1570041654
fengb
I'm so happy that gitdab is a thing

1570041676
Cadey
sent details in DM to companion_cube

1570041681
Cadey
(of the bench)

1570041705
companion_cube
wtf is gitdab? :DD

1570041712
andrewrk
it has a dark mode, I'm into that

1570041732
companion_cube
and thus started the great migration

1570041745
Cadey
ah gitea <3

1570041770
companion_cube
I want to see this vig be better than V, tbh

1570041793
lunamn_
I don't plan on writing more on vig because it's cursed, lol

1570041802
Cadey
lunamn_: let's be honest

1570041806
Cadey
cursed computing is the most fun

1570041810
tgschultz
re build systems: is it really the system configurations that are broken if the build system isn't able to keep its state separate from the system's?

1570041815
ave_
Cadey: I can agree with that

1570041862
andrewrk
tgschultz, I probably agree with you, but not sure what you're referring to

1570041871
tgschultz
expecting an entire system to conform to your idea of what a build environment should be strikes me as madness.

1570041877
tgschultz
the cmake discussion from earlier.

1570041892
tgschultz
this is why containers are now popular for building things

1570041909
Cadey
"It works on your machine? Let's ship your machine!"

1570041911
companion_cube
tbh seems like static builds are not possible at all on arch, for example :/

1570041916
companion_cube
so, alpine+docker

1570041923
Tetralux
.. except that if the language provides enough comptime code to build a program.... ;)

1570041929
andrewrk
companion_cube, why are static builds not possible on arch?

1570041939
Cadey
is this the glibc ns resolver fun?

1570041939
companion_cube
because libraries don't ship with a .a, only a .so

1570041943
andrewrk
does the zig linux binary from ziglang.org/download work on arch?

1570041945
tgschultz
yeah, I'm explicitly blaming the way C building has evolved

1570041946
companion_cube
I mean, it's possible, if you recompile all the deps

1570041947
Cadey
lollll

1570041955
companion_cube
I didn't mean for Zig, but in general

1570041957
andrewrk
ah

1570041964
andrewrk
zig can create viable static binaries on arch

1570041975
andrewrk
but yeah if you want the glibc ns resolver, you have to target glibc

1570041977
companion_cube
unless you want to link gmp or something, hmm ? :D

1570041996
tgschultz
one of zig's best features: I just need zig to build zig stuff.

1570042000
andrewrk
companion_cube, well that's the thing, we'll be able to create a zig package for gmp

1570042008
companion_cube
yeah, taht's cool

1570042016
andrewrk
if you're willing to sit through a gmp build (at least it's cached), then you have gmp independent from any system

1570042018
companion_cube
(the system gmp won't do though, and it's ok)

1570042053
andrewrk
I think we'll probably end up with a way do prefer a system dep, and fall back to compiling from source

1570042061
tgschultz
I can have multiple versions of zig on the same system, anywhere I want, and they all can still build stuff without conflict.

1570042083
companion_cube
builds should be per-project, it's a nightmare to have a global state for a package manager

1570042104
andrewrk
companion_cube, 100% agreed. any global state is just caching, with proper invalidation

1570042128
andrewrk
`zig id` shows you the cache id for the compiler binary itself

1570042138
andrewrk
this is a different concept than zig version

1570042161
andrewrk
if zig dynamically links libc, and you fix a bug in the system libc's memcpy, `zig id` will be different.

1570042182
companion_cube
daaaamn tcc builds 1Mloc in .67s

1570042196
andrewrk
yeah, now there is an interesting project

1570042208
andrewrk
we're not competing with vaporware, we're competing with tcc

1570042243
Tetralux
tcc is C-only, correct?

1570042273
companion_cube
with a simple native backend, zig could aim at that, yeah

1570042307
halosghost
Tetralux: yes

1570042314
Cadey
i wish i knew C++ enough to make a native webassembly backend for zig

1570042331
companion_cube
hmm, gitea seems cool, I wonder why sr.ht wasn't built on it?

1570042342
halosghost
companion_cube: because sircmpwm has NIH

1570042346
companion_cube
:D

1570042350
companion_cube
oh well

1570042352
halosghost
(which is not to suggest that that's a bad thing)

1570042356
halosghost
(or that I don't also have it)

1570042363
halosghost
tcc is incredible

1570042368
Tetralux
sircmpwm?

1570042375
companion_cube
tcc is from the same guy as qemu… :o

1570042376
halosghost
in fact, I'm planning on it being the only C compiler I have installed full time on my next machine

1570042380
halosghost
companion_cube: indeed

1570042385
Sahnvour
competing with tcc is quite some goal :)

1570042403
ave_
that name is weirdly familiar, sircmpwm I mean

1570042403
halosghost
Tetralux: the author of sourcehut, and various other projects (including wlroots)

1570042408
halosghost
ave_: ^

1570042409
companion_cube
and aerc

1570042416
andrewrk
Cadey, do it in pure zig. the parser is already in the std lib

1570042429
Cadey
andrewrk: interesting

1570042440
companion_cube
bootstrapping from wasi… ;)

1570042448
Cadey
actually

1570042449
Cadey
tbh

1570042455
Cadey
i think that's a better idea than people think

1570042463
Cadey
it's like

1570042464
companion_cube
I think it's a great idea :p

1570042465
Cadey
what's it called

1570042471
companion_cube
OCaml bootstraps from its own bytecode

1570042473
mq32
<companion_cube> tcc is from the same guy as qemu… :o

1570042480
mq32
companion_cube: and from the same guy as ffmpeg

1570042481
Cadey
i forget what it's called

1570042485
companion_cube
mq32: godamn

1570042493
Cadey
ah i'm thinking of ocaml yeah

1570042494
mq32
yeah, bellard is one bad ass coder

1570042496
Tetralux
WAIT

1570042505
Tetralux
The same guy made tcc, qemu, ffmpeg?

1570042505
ave_
Oh wow, this person did a lot.

1570042511
ave_
I think I know them from sway.

1570042515
companion_cube
now that's the good kind of NIH

1570042516
mq32
Tetralux, companion_cube:

1570042526
companion_cube
yeah I remember having seen that on HN some time ago

1570042528
mq32
(and BPG image format)

1570042552
Cadey
and quickjs

1570042559
Tetralux
How on earth have I only heard of this person's name once?

1570042569
companion_cube
The TCCBOOT boot loader demonstrate the speed of TCC by compiling and launching a Linux kernel in less than 15 seconds.  <----- excuse me but what

1570042578
ave_
what

1570042583
andrewrk
wait, tcc can build linux?

1570042603
companion_cube
might just be the bootloader, not sure

1570042603
mq32
andrewrk, it can BOOT linux :D

1570042605
Tetralux
Now THAT's a goal to strive for...

1570042606
mq32
from source

1570042608
NotNite
ello

1570042610
Cadey
that's getting into templeos levels of bootstrapping

1570042612
Cadey
hi NotNite

1570042622
ave_
I think I'm in love with tcc

1570042654
mq32
<companion_cube> The TCCBOOT … less than 15 seconds.  <----- excuse me but what

1570042660
companion_cube
just zig translate-c tcc, and you get your native backend ;)

1570042665
mq32
this is on a kernel on version 1.* or 2.* afaik

1570042672
halosghost
andrewrk: I'm not sure if that's still true

1570042674
mq32
not on a modern, billion-lines-of-code-kernel

1570042676
halosghost
but it used to be able to :)

1570042688
halosghost
tcc is phenomenal

1570042698
companion_cube
mq32: :D ok, but still

1570042701
halosghost
and I'm slowly transitioning my personal projects to be able to be compiled using tcc :)

1570042750
Cadey
we almost need a #zig-offtopic

1570042793
Cadey
heck

1570042802
Cadey
i just made it

1570042811
lunamn_
what is going to be the Next Thing(TM) now that 0.5.0 is released?

1570042841
Cadey
i've wanted to make a nanokernel in zig for a while, but i lack hands

1570042850
andrewrk
lunamn_,

1570042876
andrewrk
there's lots of exciting stuff to do to the std lib now that async/await is relatively stable

1570042898
andrewrk
first iteration of package manager is expected this cycle

1570042911
Cadey
is there a spec for the package manager yet?

1570042916
andrewrk
no

1570042929
andrewrk
I promised that a while ago and haven't delivered yet

1570042934
Tetralux
Can we please stop calling that kind of cast an "implicit" cast.

1570042944
Tetralux
It is so blantantly not an

1570042946
andrewrk
Tetralux, yes, the moment that we have a better name

1570042983
andrewrk
Cadey, there are some prerequisites - networking in the std lib, deflate, tarball support, etc

1570042997
Tetralux
Cast? (Just a kind of cast)

1570042999
andrewrk
no spec needed to know those need to be done

1570043010
Tetralux
Explicit cast (since you give the dest type)

1570043023
Tetralux
.. which would make sense if you did it with @cast.

1570043026
andrewrk
Tetralux, ok but how do you disambiguate from the other explicit casts?

1570043037
andrewrk
@ptrToInt is an explicit cast as well

1570043054
andrewrk
also implicit casts are implicit. var x: i32 = not_an_i32;

1570043076
andrewrk
and i32(not_an_i32) is exactly equivalent

1570043096
Tetralux
The first one - that's coercision.

1570043101
Tetralux
(or however you spell it)

1570043115
Tetralux
T(x) is an explicit kind of cast by definition.

1570043120
Tetralux
(You are naming the type.)

1570043123
andrewrk
type coersion, that's a good name, can you propose that?

1570043135
andrewrk
*coercion

1570043159
Tetralux
ptrToInt is little more than @cast(usize, ptr) -- it's just that you want to make that clear so that you don't do it by accident.

1570043172
Tetralux
So yes, it's an explicit cast.

1570043181
Tetralux
They all are.

1570043191
Tetralux
Except

1570043201
Tetralux
In the coersion case.

1570043202
Tetralux
:)

1570043209
tgschultz
explicit coersion then

1570043218
Tetralux
No.

1570043236
Tetralux
Expicit coersion is explicit casting.

1570043244
Tetralux
Coersion is not the same.

1570043297
torque
type coercion is an existing concept in e.g. javascript where it means "the language mangles everything as hard as possible to try to not throw errors"

1570043311
Tetralux
torque: JS is stupid :)

1570043312
torque
it's kind of a loaded term

1570043318
Tetralux
... and not worth citing for anything.

1570043334
andrewrk
let's talk about it on the proposal that Tetralux is opening

1570043335
torque
the point is that people are likely to have an existing understanding of the terminology

1570043352
Tetralux
.. And they'll not be far off.

1570043356
Tetralux
It's just that it's better.

1570043362
Tetralux
In some many obvious ways.

1570043368
Tetralux
At least if I have anything to do with it.

1570043388
Tetralux
(Or anyone else who's competent, for that matter.) xD

1570043507
Tetralux
Short version: if you are naming the dest type of a cast - then it's an explicit cast of some sort.

1570043545
Tetralux
If you are not, it's an implicit cast of some sort.

1570043569
Tetralux
In the case of `var x: i32 = not_an_i32` -- presumably the value would be a smaller-sized signed integer, like i16.

1570043575
Tetralux
So a narrowing cast.

1570043597
Tetralux
This is one example of an implicit cast.

1570043872
mikdusan
Sahnvour: thanks!

1570043993
tgschultz
function definitions as expressions will be a nice QoL improvement for comptime code returning functions.

1570044018
mq32
tgschultz, yeah it's my favourite coming change besides saturation arithmetics

1570044297
andrewrk
it might be nice to reconsider `let` vs `const`  before doing fn defs as exprs

1570044356
mq32
hm, i'm not used to let, but i can understand that typing 60% less per declaration is a nice feature

1570044392
andrewrk
`zig fmt` would auto correct for an entire release cycle

1570044403
mq32
i just took that for granted :D

1570044415
andrewrk
oh that reminds me, I can delete `use` now

1570044425
Cadey
andrewrk: i'm really glad you're combining `go fix` and `go fmt` into `zig fmt`

1570044434
andrewrk
what does go fix do?

1570044442
andrewrk
whitespace?

1570044464
Cadey
it was used pre go 1.0 to update code for the backwards incompatible changes

1570044477
andrewrk
ah

1570044479
mq32
andrewrk: you're doing your work very properly, i just assumed zig fmt will fix that for the release cycle :D

1570044489
tgschultz
I'm not sure I get the reasoning for using `let` vs `const`.

1570044499
Cadey
let is the same length as var

1570044504
mq32
yep

1570044504
tgschultz
so?

1570044516
mq32
combine {typing "var" is easier than "let"} and {people are lazy}

1570044526
Sahnvour
andrewrk: regarding the msvc bug, garbage occurs while building the builtin_fn table ; there's an easy and temporary workaround but we can't be sure there aren't other bugs/places affected.

1570044532
andrewrk
tgschultz, I have noticed that people have incorrectly been preferring `var` to `const`

1570044533
tgschultz
then lets make then `v` and `c`

1570044562
andrewrk
v and c are common variable names and have no precedence in other langs

1570044562
tgschultz
I think that's just old habit though.

1570044599
andrewrk
Sahnvour, it's for sure an MSVC codegen bug then?

1570044602
mq32
non-serious proposal: just infer variable type on "first assignment". if assigned with =, it is a constant, if assigned with := it is a variable: { a = 10; b := 20; }

1570044607
andrewrk
can I see the workaround diff out of curiosity?

1570044620
tgschultz
yeah, that was a toung-in-cheek dismissal of the 'it's shorter to type' reasoning. Which I will note is almost antithetical to one of zig's goals.

1570044642
Sahnvour
looks like it, don't know exactly what is going on but the hashtable is corrupted while growing

1570044682
mq32
it's one of the things that bug me in c++ a lot: "auto static constexpr a = 1;" for "i just want a constant"

1570044690
Sahnvour
andrewrk: the easiest way is to `#pragma otpimize("", off)` around `create_builtin_fn` or `define_builtin_fns` when on msvc

1570044701
andrewrk
Sahnvour, ah, got it, thanks

1570044711
fengb
We should replace all keywords with a smiley. That'd be shorter

1570044717
andrewrk
Sahnvour, wait, that's not even in the hash table code?

1570044737
Sahnvour
I believe it might have to do with the hash table code getting inlined and optimized wrong

1570044759
andrewrk
I see

1570044760
Cadey
fengb: does zig allow for emoji variable names?

1570044798
andrewrk
Cadey,

1570044847
tgschultz
no carriage returns, but you can name things using the poop emoji. That doesn't seem right to me

1570044880
Cadey
i love it

1570044885
andrewrk
you can have carriage returns in names

1570044898
mq32
just name your variable "\r"

1570044898
mq32
:D

1570044900
andrewrk
const @"\r" = 42;

1570044941
mq32
i think this will break the assembler :D

1570044946
andrewrk
zig is a DSL for machine code; object files don't have restrictions on symbol names

1570044958
tgschultz
that's fair. I was so offended by the idea that I failed to notice it required the @"". Objection withdrawn.

1570044968
Tetralux
This is the most fire-hose-at-a-page I've ever written, so

1570044973
Tetralux
You have been warned.

1570044977
Tetralux
But here you go:

1570045034
andrewrk
thanks Tetralux

1570045039
Tetralux
Welcome

1570045054
Tetralux
This terminology has long-since bugged me xP

1570045106
doublex
*coercion, though, fwiw

1570045143
andrewrk
it's true, I checked the dictionary. english is dumb

1570045156
andrewrk
english is the cmake of languages

1570045181
doublex
parser's probably more complicated than perl's

1570045211
Tetralux
[`coersion -> coercion` complete.]

1570045277
Tetralux
Though honestly, I'm inclined to ignore that wierdness.

1570045286
Tetralux
"How else are we meant to make things better?"

1570045307
Tetralux
It's not like people won't know what the word means.

1570045406
fengb
andrew already nixes some terms because Brits and Muricans can't agree

1570045416
doublex
I'm more of a Haskell guy, and to me "coerce" sounds like "reinterpret the bits" whereas "try to represent (morally) the same value" is called "convert."

1570045428
halosghost
heh

1570045430
halosghost
morally

1570045432
halosghost
doublex: I like that

1570045477
mq32
doublex, i like the term "reinterpret" for this more

1570045477
andrewrk
"canceled" vs "cancelled" is unfortunate. Nobody should have to read docs just to figure out which spelling of the word is being used

1570045508
Tetralux
I like "coersion" for this kind of behavior, because that's what it is.

1570045524
Tetralux
Sure, you're converting from one type to another - but it's simpler than converting.

1570045531
Tetralux
There's no complicated work going on here.

1570045540
Tetralux
And, it either succeeds or compile errors.

1570045568
Tetralux
And coerce has a connotation of "[read in a menacing voice] Yes, you will do this."

1570045571
tgschultz
"canceled" vs "cancelled" isn't so bad. They're the same word with two different spellings. Sometimes we have words like "affect" and "effect", both of which can act as nouns or verbs but are subtly different.

1570045610
Tetralux
For cancelled, I'd assume two Ls.

1570045626
Tetralux
The first time I ever saw anyone spell it with one was in your demo, andrewrk. xD

1570045661
fengb
It's a lot more common in murica

1570045734
doublex
i think the shed should be blue

1570045755
Tetralux
Simplest solution: Pick one, compile error the other with a message telling you to use the other one :)

1570045807
tgschultz
there's no way that could be worse than tabs/spaces and \n/\r\n

1570045818
tgschultz
I'm ok with it, is what I'm saying

1570045912
mq32
doublex, such discussions seem like bikeshedding but wording is important for understanding-at-first-glance and that's a primary goal of zig code

1570045925
fengb
There's a (joke) language that deletes your file if  there's a compile error 🙃

1570045929
andrewrk
I have successfully put a C API on top of this monstrosity:

1570045978
andrewrk
whenever someone suggests adding iterators to zig this is what I'm imagining will happen

1570046012
ceymard
where is the .evented field from in this example : `pub const io_mode = .evented` ?

1570046058
andrewrk
ceymard, you can find out by changing it to a bogus name, I believe

1570046072
andrewrk
but the answer is std.io.Mode

1570046079
mq32
andrewrk, correct me if i'm wrong, but ".evented" is a "enum literal", so a value that is of "unspecified enum type" and will only be comparable to enums of that contain such a field

1570046086
andrewrk
mq32, correct

1570046102
mq32
ha! so it's "comptime_enum_member" or something like that :D

1570046291
ceymard
I did not get that :-|

1570046317
mq32
ceymard: ".evented" has a similar type as "comptime_int", but for enum values

1570046341
andrewrk
ceymard,

1570046368
ceymard
ok

1570046375
mq32
so io_mode isn't of a specific enumeration type but "contains" an enum member that can be compared to any enum type that contains a value "evented"

1570046392
ceymard
ok

1570046393
mq32
so you could compare that to enum{evented,timed} as well as the IoMode

1570046399
ceymard
yes ok

1570046402
ceymard
so it's contextual ?

1570046418
andrewrk
yes that is one way to put it

1570046420
ceymard
does it depend on being like for example inside an enum { } declaration or a switch

1570046442
andrewrk
it's analagous to integer literals, which can be coerced to any integer type

1570046442
mq32
it's interesting how much you start to understand programming languages when you have designed one :D

1570046446
ceymard
are there other rules to the way the name is resolved besides the two I cited

1570046486
andrewrk
the only rule is casting related.

1570046514
Sahnvour
andrewrk: 100% sure it's a codegen bug, but maybe not the one affecting memcpy. for every builtin the compiler generates the same pattern every time, and at some point it changes and stomps the memory where the builtin Buf data lies, so no wonder querying the hashtable fails afterwards

1570046563
andrewrk
Sahnvour, it's a rather severe bug, pretty strange that zig's codebase is affected. we barely use 1% of C++ features

1570046569
Sahnvour
building it* fails, because the name contains garbage just before we insert it into the table

1570046614
Sahnvour
ime msvc codegen bugs affect optimization passes, not necessarily linked to arcane c++ features

1570047561
Cadey
how do you convert little endian bytes to an integer in zig?

1570047599
andrewrk
Cadey, std.mem.readIntLittle

1570047617
Cadey
ah, thanks

1570047813
itsMontoya
Hey andrewrk - Is there plans to clean-up simplify the async stuff?

1570047823
itsMontoya
I've been thinking a lot about it all over the last few days

1570047843
itsMontoya
More specifically, I was thinking about how there aren't interfaces or traits in zig yet

1570047860
itsMontoya
but I see something like interfaces being very powerful for something like this

1570047872
itsMontoya
interface Poller {}

1570047877
itsMontoya
poll() bool

1570047897
itsMontoya
Could make it very easy to make async control structures instead of the current approach

1570047918
itsMontoya
Under the hood, the system could handle the suspend/resumes

1570047951
itsMontoya
I've been playing around with rust async quite a bit since their latest beta release. There are a lot of aspects about it I don't like, some things I like though!

1570050121
Tetralux
itsMontoya: One item of note is the ability to specify easily whether the interface relies on runtime fn ptrs or static fn calls.

1570050200
Tetralux
One way perhaps would be to mark a fn argument that is an interface type be either comptime or non-comptime to indicate "should these interface fns be statically resolved during compilation"

1570053530
hasanyasin
Newbie question: When I have a function where I create and return a struct, it returns the exact same instance. I guess this is the expected behavior as mentioned in the documentation, i.e. "Functions called at compile-time are memoized."

1570053530
hasanyasin
How can I create separate instances of a struct with every call of a function? Is there some way of saying non-compiletime? Or am I missing something totally different?

1570053655
andrewrk
hasanyasin, to better understand your use case: what's the problem with what is currently happening?

1570053681
andrewrk
how does this behavior manifest in an issue that prevents your use case?

1570053750
hasanyasin
I want to initialize struct instances with a function like "fn NewNode() *Node" or maybe "Node.New() *Node" where Node was defined as const Node = struct { ... }

1570053870
mq32
you want to build a linked list at comptime?

1570053928
hasanyasin
Like this:

1570053970
hasanyasin
No, I don't want this to run at comptime, actually. I don't know how to make it run on runtime only. --so embarrassed.

1570054190
mq32
you need to use an allocator to create a new node

1570054260
hasanyasin
Thank you. I will try to figure that out.

1570054353
hasanyasin
I was actually trying to implement a kinda-interface-like setup. I got the idea from *Allocator

1570054358
hasanyasin
It is like here:

1570054403
hasanyasin
Node is a struct with only methods calling actual methods. ElementNode, TextNode, DocumentNode, etc will be implementations of this interface.

1570054441
hasanyasin
Thank you all. :)

1570054916
Tetralux
hasanyasin: `return &d.node`

1570054921
Tetralux
You're returning a ptr to stack memory?

1570054970
hasanyasin
Sorry, I now realized that. No garbage collection, no automatic allocation.. This is not go. :D

1570054970
Tetralux
Do `var e = allocator.create(ElementNode); e.* = ElementNode{ ... }; return e;` instead.

1570054987
hasanyasin
Thank you so much!

1570055005
Tetralux
It's okay; returning stack memory is planned to be a compile error in the future.

1570055009
Tetralux
:xp

1570055056
hasanyasin
Other than this, do you find the interface-y approach correct?

1570055075
Tetralux
Seems generally alright.

1570055104
hasanyasin
Each implementing struct will have Node (interface) as a field and methods will access the implementing structs via @fieldParentPtr.

1570055144
Tetralux
I'd have to try using it to really know for sure - but it shows promise.

1570055154
Tetralux
You should check if the fn calls are inlined or not.

1570055161
hasanyasin
I will share it again once working.

1570055163
Tetralux
If not, there's not too much you'd actually wanna use it work.

1570055168
Tetralux
wanna use it for*

1570055270
hasanyasin
As you might have guessed, I am not that low-level yet. I don't mind if there is some performance penalty. In the worst case it will work way faster than any scripting language and probably Go as well.

1570055303
fengb
If you're doing everything on the heap, it may not run as fast as Go

1570055338
hasanyasin
I know Zig doesn't target web and even probably network service developers, but I enjoy this experience of walking in a very different jungle so much.

1570055434
Tetralux
Fair play - it's just worth noting that for production code, you don't want dynamic calls with fn ptrs if you expect to call them often. There's a

1570055449
hasanyasin
Thank you for the good suggestions. Both are noted and I will try to get to those once I have something working no matter how slow. :)

1570055459
Tetralux
Though I should note, I like the general approach and I would like something more supported by the language that is like this.

1570055477
Tetralux
And yes - that's a truly invaluable mindset to have.

1570055494
hasanyasin
I am trying to create a small compiler for a web templating system.

1570055502
hasanyasin
My invention. :D

1570055509
Tetralux
The hackiest possible way is the fast-to-build way - and is good for showing you what you actually need in the end :)

1570055531
hasanyasin
Yes, couldn't say it better.

1570055540
Tetralux
I'm happy you think so xD

1570055547
Tetralux
I wish you luck :p

1570055556
hasanyasin
Thank you so much!

1570055602
hasanyasin
It is 1:30am here (Finland) and I still enjoy the work.

1570055620
Tetralux
The sign of a true enthuiast xP

1570055734
hasanyasin
I build web-based systems as my profession. I have recently been thinking of a web framework built around a templating engine, compiling various components into different platforms such as html/js/css for browser and Nodejs and Go source code for server.

1570055793
Tetralux
Worth noting that Zig can compile for wasm which may help there.

1570055808
hasanyasin
Then I wanted to code it in a different language. Tried Nim but felt too weird because everything changes everything and modules add methods to other  modules' data structures, etc. Maybe I misunderstood it completely, but documentation also felt untidy and carelessly written.

1570055844
fengb
No docs are better than mess docs? 🙃

1570055848
hasanyasin
Rust takes so long to type and I dislike the Ruby-like culture. Maybe my personal tastelessness, I don't know.

1570055873
hasanyasin
Yes, no docs situation is actually better than incompatible documentation.

1570055886
hasanyasin
Not saying anything is always better than lying. :D

1570055912
hasanyasin
I funnily found V and it looked too good to be true.

1570055924
hasanyasin
While reading about V, I found out about Zig.

1570055933
hasanyasin
Very weird way to find Zig, I guess.

1570056011
hasanyasin
Wasm target (LLVM backend) was also attractive @Tetralux, I totally agree with that point too.

1570056046
Tetralux
I'd suggest investigating that over outputting JS :p

1570056057
Tetralux
Though both my be valuable in the short term.

1570056079
fengb
I wasn’t smart enough to learn Rust >_>

1570056114
andrewrk
same

1570056149
Tetralux
I tried using it for a project - got part way there. I found it to have too much friction for my liking;

1570056167
Tetralux
As well as finding lifetimes a little awkward to understand.

1570056180
Tetralux
As well as having them infect all my code the moment I needed them.

1570056266
presiden
I find it fascinating actually

1570056279
presiden
once you grok it, it kinda stick with you

1570056283
Tetralux
They focused on the wrong thing.

1570056300
presiden
there's also that article about the orignal idea in cyclone

1570056304
Tetralux
There's some interesting ideas in there though.

1570056334
fengb
I think it’s fine for what it is. But it also isn’t my thing

1570056379
Tetralux
Thing is, it would be a heckuva lot nicer if it was just relatively slightly different.

1570056396
Tetralux
- Improve error messages.

1570056438
Tetralux
- Remove the borrow checker or make it sigificantly better.

1570056446
Tetralux
Among others.

1570056474
andrewrk
suggesting to remove the borrow checker from rust is trolling. please don't do that

1570056483
andrewrk
I don't care if it's intentional or not

1570056536
Tetralux
That's odd.

1570056618
Tetralux
Please don't do that either.

1570056626
Tetralux
Like I respect you, but really now xD

1570056686
hasanyasin
Borrow checker is Rust's definition almost. Some people like it, some people can't accept if the approach is viable for anything.

1570056742
hasanyasin
Zig is nice for some, but there is a big population who would just leave the page once they see you need to manage memory yourself while some others would find it the most attractive part.

1570056764
hasanyasin
Variety is beautiful.

1570056770
scientes
That would be cool if there was a way to combine code from multiple languages that use llvm

1570056775
scientes
without using the C ABI

1570056784
itsMontoya
I like the borrow checker

1570056792
itsMontoya
I just hate how in flux the language is

1570056796
fengb
Yeah the argument I keep hearing against Zig is that it’s not 100% memory safe

1570056800
hasanyasin
And Tetralux, thank you so much for the snippet. I just copy&pasted and now my experimental thing works perfectly. :D

1570056821
itsMontoya
Yea, memory safe is the new hotness

1570056830
scientes
safety is impossible

1570056831
itsMontoya
Rust

1570056832
itsMontoya
Now D

1570056833
scientes
its turing complete

1570056840
itsMontoya
"safe"

1570056851
itsMontoya
Safer than C

1570056854
scientes
anyways, that's totally differnt

1570056865
scientes
i'd rather a language that doesn't get in my way

1570056875
scientes
and zig is already better than C in that respect

1570056880
presiden
Cyclone really has a rippling impact for a never heard of language

1570056899
Tetralux
andrewrk: In a world where memory safety is the focus of Rust, and in a world where an intense focus on it does not actually help all that much - calling it trolling is honestly kind of insulting. Please don't do that. Like - I think I understand what you are getting at, but really.

1570056924
fengb
I’d like to see a real study on how often different modes of safety helps

1570056935
scientes
I think fully proven code is hot

1570056940
scientes
like seL4

1570056949
scientes
but other than that, please get out of my way, thx

1570056954
mq32
scientes, yeah, but: at what cost?

1570056969
scientes
mq32, cheaper than fuzzing, which doesn't get out all the bugs

1570056971
fengb
Like I’d expect 90% of bad memory errors to be buffer overruns, and Zig is quite safe from that

1570056979
Tetralux
There's more of a case for it in things like rockets that go to mars or whatever, but...... you can do it without being mind-numbing.

1570056985
companion_cube
Tetralux: removing the borrow checker from rust makes it a totally different language

1570056986
mq32
scientes, yeah but we can get a lot of errors by reading code as well

1570056999
scientes
I'm not saying its the only way, but its pretty interesting

1570057006
presiden
buffer overrun? not double free/use after free?

1570057009
mq32
yeah, that's true

1570057014
scientes
its also kinda the "perfectionist" attitude zig

1570057023
companion_cube
damn

1570057091
fengb
I also want to see Zig’s debug allocator in action. See if it can catch most double frees or use after frees

1570057114
presiden
^

1570057116
scientes
ALL

1570057117
mq32
fengb: it should, at least in theory

1570057118
andrewrk
fengb, yeah I should work to get that merged soon

1570057126
mq32
shouldn't be that hard anyways to implement this with mmap

1570057129
andrewrk
it's also the basis for language safety experiments that I want to do

1570057167
fengb
Can’t catch all because tests can’t possibly hit 100% real coverage

1570057176
fengb
Unless you deploy with debug allocator, which I suppose is possible :P

1570057211
fengb
But could it be good enough

1570057303
fengb


1570057347
itsMontoya
Why did Tetralux get banned?

1570057410
scientes
he needs to cool off

1570057417
itsMontoya
fengb: Are you saying the debug allocator will catch double frees?

1570057474
itsMontoya
I'm wondering if there is a way to abstract the async code into a struct

1570057482
itsMontoya
Like a Promise/Future type item

1570057486
itsMontoya
With easily usable methods

1570057499
jmiven
itsMontoya: it is catching double frees :-)

1570057501
mq32
itsMontoya, the async frames are futures

1570057504
mq32
in my understanding at least

1570057528
itsMontoya
jmiven: That's amazing. Let me read more into it before I ask follow up questions. I don't want to waste peoples time

1570057542
fengb
itsMontoya: yes it’s the main goal to detect all the memory errors

1570057551
itsMontoya
mq32: I think you are correct, but it still feels very bare bones. I totally get why it was done this way though

1570057558
itsMontoya
Being able to set the frame and such is super interesting

1570057562
itsMontoya
Gives a ton of granularity

1570057569
itsMontoya
but I think for 95% use cases it's overkill

1570057577
presiden
and speaking of combining allocator and region-based memory management, there's also Cone language

1570057583
fengb
I think one of the unsung killer features in Zig is to seamlessly swap allocators

1570057594
presiden
Cyclone really inspire many people :)

1570057629
itsMontoya
fengb: That's a great point

1570057637
itsMontoya
For one controller I might want ref counting

1570057645
itsMontoya
but another I might want raw manual management

1570057692
itsMontoya
andrewrk: If I were to build a convenience layer around async. Do you think I would have more luck approaching as a macro? Or as a struct with methods?

1570057700
itsMontoya
I'm hoping for the latter

1570057767
mq32
<itsMontoya> For one controller I might want ref counting

1570057774
mq32
ref counting doesn't work by changing the allocator

1570057786
mq32
you still have to implement that 100% manually in zig

1570057798
companion_cube
who said "RAII"? :-°

1570057806
itsMontoya
Right, but technically couldn't a ref counting allocator be built?

1570057812
mq32
nope

1570057815
itsMontoya
Ah, fair

1570057823
itsMontoya
I guess it would have to be on the structure level

1570057827
mq32
the allocator has always "two" functions: free and malloc

1570057833
mq32
you can use refcounting on top of that

1570057842
itsMontoya
OH yes yes, totally

1570057842
fengb
Jimmi has a proof of concept GC. I’ve been meaning to see how that works

1570057860
itsMontoya
I was talking about memory management layer. And somehow I said allocator

1570057867
itsMontoya
It's been a long day, I apologize

1570057895
itsMontoya
GC, ref counting, etc all need an allocator under the hood

1570057901
itsMontoya
To actually allocate and free, totally

1570057976
itsMontoya
Zig's async is eager, correct?

1570057979
itsMontoya
Or is it lazy?

1570058026
mq32
itsMontoya, what do you mean by eager/lazy?

1570058051
itsMontoya
Rust's async is lazy, doesn't start anything until await is called on it

1570058068
itsMontoya
Javascripts async is eager, it is called instantly

1570058082
mq32
i think that's an implementation detail in userspace

1570058097
itsMontoya
True

1570058105
itsMontoya
But there are a few that will be lang level

1570058111
itsMontoya
I/O

1570058115
itsMontoya
Is an example

1570058134
mq32
I/O is also user space, not lang level ;)

1570058414
itsMontoya
I suppose you are correct

1570058422
itsMontoya
I'll sit in the corner now

1570058443
itsMontoya
How do I declare a func as a type?

1570058455
itsMontoya
val: i32;

1570058456
itsMontoya
func: fn() void;

1570058462
itsMontoya
Second one is giving me an error

1570058482
mq32
const FunType = fn() void;

1570058499
itsMontoya
within a struct though?

1570058504
itsMontoya
Sorry I didn't specify that

1570058517
mq32
as a member field or static var?

1570058557
itsMontoya
OH oh oh!

1570058559
itsMontoya
It's compiling

1570058629
andrewrk
translate_c.cpp now exclusively uses the same C API that the self-hosted version uses. shaved off 5 seconds from compiling zig

1570058657
andrewrk
it would be nice to delete these 5,162 lines of C++ code in this release cycle and replace them with self-hosted code

1570058722
itsMontoya
:)

1570058724
itsMontoya
Fucking amazing

1570058739
andrewrk
scientes, I also haven't given up on merging a SIMD commit today

1570058819
scientes
I've got my natural exponent double precision implementation working compiled 5 different way

1570058832
scientes
x86_64 2, 4, and 8 wide, arm64, and arm32

1570058843
scientes
and its performing as fast as the libmvec versions

1570059286
itsMontoya
So I think I have an idea to get something that will feel similar to goroutines

1570059301
itsMontoya
Thread pool, which can spawn coroutines

1570059317
scientes
yeah goroutines can be build on top of async

1570059330
itsMontoya
:)

1570059334
scientes
buf using a global thread pool has

1570059344
itsMontoya
I know it does with gaming

1570059351
itsMontoya
Would it with backend server programming?

1570059360
scientes
everything that go is used for today

1570059403
itsMontoya
Is that the main issue though?

1570059405
itsMontoya
GPU programming

1570059421
itsMontoya
Or is there another issue I'm not thinking of?

1570059561
mq32
pool with 4 elements and 4 tasks that block

1570059567
mq32
=> not async anymore

