1563235805
emekankurumeh[m]
it's gonna be a while before I can test it on my setup, but I'll submit a pr if I find any regressions

1563235825
andrewrk
thanks!

1563236726
hryx
andrewrk: regarding #2897 (de-keywordizing primitive values): Removing the grammar keywords led to removing the special AST node types, which affects ir.cpp. I find myself adding a new primitive_value_table in the CodeGen, similar to primitive_type_table. Does that sound like the right direction?

1563236759
andrewrk
hryx, I think primitive_type_table can be renamed to primitive_value_table and handle both cases

1563236762
andrewrk
since types are values

1563236793
hryx
rad idea, will do

1563237477
scientes
hryx, also, it would be rad if all attributes were just annonmous enums

1563237479
scientes
instead of keywords

1563237521
Tetralux
Attributes?

1563237539
scientes
well we don't have real attributes like C yet

1563237555
strmpnk
Reminds me of true/false in Erlang. They're just atoms and dialyzer (the optional type system) treats booleans as the union of the two atoms.

1563237573
strmpnk
Or "polymorphic variants" is OCaml.

1563237573
scientes
but like comptime

1563237582
scientes
would become .Comptime

1563237593
scientes
.Inline

1563237617
Tetralux
You mean like `fn f() .Inline i32 { return 42; }` ?

1563237625
strmpnk
scientes: The question of that becomes, what can the user of the language do with open enumeration?

1563237627
Tetralux
(.. swap i32 and .Inline)

1563237651
scientes
strmpnk, look at all the gcc attributes. this is just functions

1563237660
scientes
some really useful ones are like .Pure

1563237678
scientes


1563237688
strmpnk
Why not a union(enum) then? But how does one add to the collection or are they all built-in?

1563237693
scientes


1563237695
Tetralux
( .. Or are we talking about things you'd get in the typeInfo or something?)

1563237700
scientes
strmpnk, they are all built-in

1563237713
scientes
this just makes the language (modulo the implementation of the attributes) simpler

1563237737
strmpnk
scientes: Seems like an odd reason then. It mixes names into a space which a user otherwise has clear control over.

1563237756
scientes
no, the user doesn't have control over @import("builtin")

1563237760
scientes
that is generated by the compiuler

1563237775
strmpnk
That's fine. It's still a boundary.

1563237791
Tetralux
I'm still not clear how attribs would be used in Zig.

1563237812
scientes
well what I liked so much about the idea is that annoymous enums are context-specific

1563237815
strmpnk
.Inline seems more like pollution unless it's readily extended in the same way one can define their own errors.

1563237822
scientes
so you get a really curt syntax

1563237848
Tetralux
scientes: I don't understand what that means xD

1563237849
andrewrk
I believe inline will be a calling convention, so it can be one of these:

1563237854
scientes
concise

1563237854
strmpnk
Seems more like overloading syntax (context overloads). I'd find that hard to follow.

1563237860
Tetralux
Are these attached to a declaration or fn to modify their behavoir in some way?

1563237868
Tetralux
In the src code.

1563237896
scientes
same for variable, like align, pointer-namespaces, et cetera

1563237905
scientes
anyways, just an idea

1563237925
andrewrk
hmm no it can't be a calling convention, that won't be compatible with external APIs

1563237940
andrewrk
well, maybe

1563237945
strmpnk
scientes: I don't hate the idea. I am mostly musing about the benefit of generalizing a notation.

1563237992
strmpnk
inline seems to be more parallel with comptime than it is with calling conventions.

1563237997
scientes
andrewrk, perhaps LTO can have inline attribute ?

1563238004
strmpnk
The transformation is done by the compiler.

1563238016
scientes
strmpnk, but also by llvm

1563238020
scientes
comptime is zig-only

1563238047
strmpnk
scientes: I'm pretending LLVM is part of the compiler. Not sure if there is a specific boundary to that term here.

1563238210
scientes
Anyways, at some point zig will probably want something as flexible as gcc's attributes, and I was pleased with this syntax because it is consistant and very short

1563238301
scientes
so sure how to make it take data however

1563238309
scientes
like .Align(8)

1563238379
strmpnk
While they are heavier syntactically, I like the annotations I see in C#/F#. The benefit of having annotations that can be reflected upon (comptime here of course) seems useful. (but perhaps it's just another way to hide parameters to a comptime function call, ¯\_(ツ)_/¯).

1563238404
companion_cube
what do you think of rust's attributes?

1563238443
strmpnk
They remind me a lot of what I did with F# at past jobs but in a much more complicated interaction with macros and compiler built-ins.

1563238638
strmpnk
I do like that one attribute cannot imply another. It's just data, not a transitive closure. It helps keep some amount of sanity interpreting annotations.

1563238827
scientes
has anyone else had a crash that only occurs when not running under the debugger (same binary)?

1563238834
scientes
damn heisenbugs

1563239121
Tetralux
Probably unit memory XD

1563239127
Tetralux
uninit*

1563239142
Tetralux
Dammit can't get even my quip right xP

1563239145
scientes
its a floating point exception in the caching code

1563239830
daurnimator
andrewrk: did you get directory iteration in windows figured out?

1563240318
andrewrk
daurnimator, that's been working fine for a while. it uses FindFirstFile, FindNextFile

1563240336
daurnimator
andrewrk: I meant your experiments with NtQueryInformationFile

1563240365
daurnimator
which I apparently confused with NtQueryDirectoryFile

1563240391
andrewrk
oh, the performance issue turned out to be:

1563240406
andrewrk
std.unicode.utf8ToUtf16Le was really slow

1563240467
andrewrk
the issue I had with NtQueryDirectoryFile was the fact that the FILE_INFORMATION_CLASS was incorrectly documented by microsoft

1563240486
andrewrk
note the missing "= 1" here:

1563240491
andrewrk
compare with:

1563240498
andrewrk
I found that by looking at ReactOS source

1563240538
daurnimator
andrewrk: should put a comment in the zig code saying as such...

1563240562
andrewrk
normally I would use translate-c to find the values for the definitions but the relevant header files appeared to not be available without installing some separate thing

1563240577
Tetralux
You had an off-by-one in an enum? That's a curiousity.

1563240953
andrewrk
I mean it was documented incorrectly

1563241167
andrewrk
so anyway, now `make install` doesn't print a jillion redundant lines and manually adding new files to CMakeLists.txt is no longer required for the standard library

1563241210
andrewrk
and `make` now takes about half as long as it used to to notice that no file copying must be done

1563241234
andrewrk
a small bit of the build just became self hosted

1563241321
hryx
sooooo nice

1563241329
daurnimator
andrewrk: I thought you were working on #2888 :)

1563241386
andrewrk
daurnimator, oh! I see why you thought that now. That was just a coincidence, I didn't realize the function you found was the same one I just took advantage of

1563241397
andrewrk
so I learned how to use Process Monitor, which is an amazing tool

1563241407
andrewrk
all the sudden I feel like I can understand wtf my windows programs are doing and troubleshoot the performance

1563241425
daurnimator
andrewrk: do zig stack traces show up correctly?

1563241492
andrewrk
and I was trying to figure out why copying files was so slow. at first I thought it was inefficiency in GetFileInformationByHandle since the procmon stack trace showed that was simply delegating to NtQueryInformationFile. so I eliminated the middle man

1563241504
andrewrk
but then realized it was not the syscall but the unicode conversion that was slow

1563241552
andrewrk
that reminds me though, I'm going to open an issue which is to propose that the zig standard library migrate towards using NtDll as the only API

1563241577
andrewrk
figuring out how to do that is straightforward with procmon

1563241590
andrewrk
since the stack trace feature tells you the actual low level APIs that you're calling

1563241596
daurnimator
you can't use it as the only API unfortunatly

1563241601
andrewrk
why's that?

1563241623
daurnimator
Some GDI functionality adds hooks into the kernel32 layer

1563241641
daurnimator
and if you bypass it sometimes graphic applications stop working.

1563241659
andrewrk
you're talking about gd32.dll functions?

1563241677
andrewrk
what functions are dangerous to bypass?

1563241706
daurnimator
that's a good question for midipix

1563241726
daurnimator
but it's only relatively specialized ones

1563241730
daurnimator
e.g. fork

1563241760
daurnimator
(yes! windows has a fork syscall....)

1563242116
Tetralux
WAIT

1563242119
Tetralux
WINDOWS HAS FORK

1563242123
Tetralux
WHAT SORCERY IS THIS

1563243107
daurnimator
Tetralux: yep. but if you use it you can't use any graphics APIs. and input processing gets really hard

1563243130
daurnimator
as such, microsoft choose not to document it

1563243132
Tetralux
That's sounds about right for a user-facing API.

1563243140
Tetralux
OH!

1563243142
Tetralux
Even better!

1563243156
daurnimator
hence why no one really knows about it

1563248094
fengb
andrewrk: I noticed Windows libc includes all the h files. Does that mean the Mac version can include everything too?

1563248379
andrewrk
fengb, you're asking about shipping .h files for macos libc?

1563248391
fengb
Yeah

1563248498
andrewrk
I need to double check the license information

1563248519
fengb
They're mostly Apple licence or BSD

1563248520
andrewrk
the windows.h files we ship are all public domain (or similar) licensed, which is one of the main goals behind the mingw-w64 project

1563248546
andrewrk
but yeah if they're compatibly licensed, and it adds a reasonable amount of file size, then we can ship those too

1563248553
fengb
It's just a lot so I'm not sure how much time it'd take for me to prune it down

1563248574
andrewrk
there's likely a project that has done this work already - the mingw-w64 equivalent for macos

1563248676
fengb
Bleh you're right. There's a bunch of private files

1563248801
andrewrk
darwin frameworks are another problem to solve

1563248821
andrewrk
I'll probably save macos for last and solve freebsd first

1563248844
andrewrk
hryx, I have tests running on all platforms for your translate-c PR...

1563249300
emekankurumeh[m]
so will we be writing our own AFD driver like daurnimator was talking about a while ago?

1563249317
andrewrk
what's AFD?

1563249319
daurnimator
emekankurumeh[m]: huh? no you

1563249464
emekankurumeh[m]
I mean write our own abstractions over the AFD driver, communicating with it directly like node does

1563249466
daurnimator
andrewrk: AFD is the piece of windows that handles TCP and UDP

1563249793
andrewrk
hryx, sorry that took so long, but it's in master now :)

1563249907
fengb
:o

1563249951
andrewrk
zig has 5,555 commits

1563250226
companion_cube
🎉

1563250551
andrewrk
emekankurumeh[m], possibly. I'm not well informed on the topic yet

1563250803
diltsman
Does Zig have well defined sequencing?

1563250835
diltsman
Or, I guess, is it well defined enough that you can write a double checked lock that the optimizer can't break?

1563250880
andrewrk
you can use @fence and the other atomic builtins

1563251127
hspak
is there any way to do something like the following with when <some_u8> is only available at runtime? const a = switch(some_u8) { 0 => blk: { warn("stuff"); break :blk 0; }, ...

1563251137
hspak
the code fails with "error: cannot store runtime value in type 'comptime_int'"

1563251163
andrewrk
hspak, yes, cast your 0 to a type

1563251301
hspak
andrewrk: that worked, thanks!

1563251734
diltsman
andrewrk: Does @fence produce code in the binary?

1563251783
andrewrk
on some combinations of architectures and AtomicOrder it does. but mainly it limits what the optimizer can do

1563253058
hryx
andrewrk: awesome! thanks so much for figuring that out — glad to have it solved

1563253070
hryx
also 5555 hail satan

1563254101
daurnimator


1563254170
shachaf
I suspect making a completely explicit reified frame like that isn't the compiler's job.

1563254226
shachaf
I mean, one that can be sent over the network or whatever. It would be interesting to see something like that, though.

1563254260
shachaf
Mostly I think it being about as opaque as a stack frame is fine?

1563254294
shachaf
One thing that would be interesting would be having "stack variables" that are explicitly marked as externally accessible on the frame.

1563254570
daurnimator
shachaf: I think a concept at the moment is a `@Frame(myfunction)` builtin

1563254622
shachaf
Sure, but presumably it's opaque.

1563254664
daurnimator
ehhhh; I don't see why you'd need to

1563254687
shachaf
I'm imagining something like "coroutine fn foo() void { coroutine_exported_var i = 0; ... }" such that if f has type @Frame(foo), you can refer to f.i

1563254730
daurnimator
shachaf: if it wasn't opaque then you'd be able to do some really cool introspection. useful for not only debugging but even serialising.

1563254768
shachaf
Sure, but there are all sorts of tricky things to figure out.

1563254797
shachaf
Presumably you can do liveness analysis on your coroutine frame, so that different variables can occupy the same frame memory at different points.

1563254853
daurnimator
shachaf: yeah I guess. could have it as a union of different states?

1563254909
shachaf
Right, you can imagine it as a tagged union.

1563254943
daurnimator
for now I'm just waiting to see what andrewrk comes up with

1563254944
shachaf
But often you switch just the tag and keep the rest of the memory the same, which isn't a common use of tagged unions at least?

1563254963
daurnimator
easier to suggest actual changes than theorize

1563254981
shachaf
Also, if you're not reifying it, you can store an instruction pointer directly rather than an enum value.

1563254992
daurnimator
shachaf: reminds me of my issue about packing data into low bits of pointers: unions end up really awkward.

1563255033
shachaf
(Which is the way "ret" works, of course. It makes sense for coroutine context switches, I think.)

1563255369
daurnimator
I guess `suspend` is really a way to save data out of registers and into the frame?

1563255406
shachaf
Sure. So is a function call.

1563255443
daurnimator
so really... a frame needs to be the size of stack used by the function... + enough to fit register contents at any `suspend` points.

1563255454
shachaf
Yep.

1563255505
daurnimator
would you need to save

1563255520
shachaf
Just the ones that store whatever you need.

1563255532
shachaf
It's almost exactly like a function call.

1563255552
shachaf
(Except there are also callee-saved registers in typical calling conventions, and presumably you wouldn't have any here.)

1563255574
shachaf
But the compiler knows which caller-saved registers to save, and this is the same thing.

1563256838
daurnimator
interesting

1563256845
daurnimator
I haven't really thought too much about this before

1563256852
daurnimator
this was helpful for my mental model

1563256964
mikdusan
if zig will be "doing it's own impl of coroutines" how does it know what the final frame size will be given register usage is done by llvm?

1563257075
shachaf
Does LLVM also lay out stack frames and do liveness analysis and so on?

1563257105
shachaf
I don't know what API it provides exactly but I wouldn't be surprised if a compiler that does good coroutines on top of LLVM had to reimplement a bunch of that.

1563258464
shachaf
I've thought about some specific use cases of this a bunch but I should get my thoughts in order in general.

1563258503
shachaf
For what it's worth, even without coroutines, it would be nice if functions clearly specified how much stack space they use in a comptime-accessible way.

1563258540
shachaf
So you could allocate stacks yourself and guarantee that the functions will fit.

1563258568
shachaf
As long as you don't do unbounded recursion, or call unknown function pointers, you can figure it all out statically.

1563258596
daurnimator
shachaf: yes that's another open proposal I think

1563258622
shachaf
Aha,

1563258629
daurnimator
shachaf: One thing to note is that such a function can usually only give you an upper bound.

1563258647
daurnimator
shachaf: from there you can follow that any annotated extern function would have infinity

1563258648
shachaf
I mean, obviously I only want an upper bound. A function doesn't have to use all the space it's allocated.

1563258669
daurnimator
but if we introduced an extern function annotation...... :)

1563258681
shachaf
Yes, you can allow infinity if you want.

1563258697
mikdusan


1563258699
shachaf
That woudl allow for recursion and so on. I think it might be even better to have bounded recursion.

1563258738
shachaf
It might also be nice if function pointers could be annotated with their maximum stack usage.

1563258761
daurnimator
mikdusan: ah. good link

1563258764
mikdusan
that's mentioned in #1639 with @ptrCall(worst_case_stack_size, function, ...)

1563258778
shachaf
Aha,

1563258794
mikdusan
big topic. complex. /me backs away very very slowly

1563258831
shachaf
gcc lets you compute stack usage information, by the way.

1563258858
shachaf
But you only get it after the fact, it's not comptime-accessible. Presumably you could do some complicated multiphase compilation thing if you really wanted to.

1563258914
daurnimator
shachaf: yeah it's emitted by gcc for the GCC linker. -fstack-limit-symbol uses it IIRC

1563258924
daurnimator
of course we're on LLVM right now. so that doesn't help us :P

1563259057
shachaf
All of these things have analogies for coroutines, of course.

1563259097
shachaf
In particular, if you have nested async functions such that at frames are local variables and you're only ever waiting on one at a time, it looks exactly like a stack.

1563259125
shachaf
(A stack is just an arena used as @Frame instead of statically allocating it.)

1563259216
daurnimator
shachaf: indeed; that's an interesting way to think about it

1563259334
daurnimator
shachaf: does that mean that a function call is actually sugar for `const cf = current_stack.alloc(@Frame(func)); @newStackCall(cf, func, ...); current_stack.free(cf);`

1563259382
shachaf
If I'm reading what you wrote correctly, I think so?

1563259409
shachaf
Where "free" means "free everything after this pointer" which you can do with an arena.

1563259415
daurnimator
to take things too far: zig says that hidden allocations are bad. should an explicit frame be required for every call? -> why not?

1563259448
shachaf
Because this is why we use compilers.

1563259460
daurnimator
shachaf: maybe the stack analogy is the wrong one.... what if it's actually a nested allocator

1563259461
shachaf
The function call syntax

1563259462
emekankurumeh[m]
ugh, moving the build stuff to userland increased my build time from ~3 minutes to ~30 minutes

1563259479
shachaf
An arena/stack/nested allocator are all the same thing.

1563259508
daurnimator
shachaf: like, what if it was more: `var child_stack = @maxStack(func); @newStackCall(child_stack, func, ...)`

1563259532
shachaf
Yes, that's what I thought you meant.

1563259546
shachaf
I mean, in the case that @Frame(func) is an unbounded size because of recursion or whatever.

1563259554
daurnimator
yep.

1563259589
shachaf
As soon as you call a function you pass it ownership of the entire stack from the stack pointer on.

1563259608
shachaf
And when it returns you get ownership of that back.

1563259660
daurnimator
I guess taking this latter concept would end up with stackful coroutines; vs the earlier would end up with stackless coroutines

1563259749
shachaf
I think the distinction is different (if it exists at all, which maybe it shouldn't).

1563260324
very-mediocre
this seems to crash the compiler:

1563260429
mikdusan
seen that before; i think there is issue for it. recursive struct. Node size is unknown. so it needs to be ?*Node or somesuch

1563260432
daurnimator
emekankurumeh[m]: just first run? or subsequent runs are slow too?

1563260442
daurnimator
emekankurumeh[m]: and which platform?

1563260541
very-mediocre
mikdusan: I see, I thought it might be due to the double optional-ness, since arrays are pointers, using a nullable pointer to the array should point to its first element, and that element itself is also nullable.

1563260683
very-mediocre
so if the array is not null (implies pointer to first element is not null) but its first element is null (iirc optionals compile down to pointers, implying that the first element

1563260780
very-mediocre
nvm that's not it, played around with the optional-ness

1563261065
daurnimator
emekankurumeh[m]: FWIW I just did a fresh build + install and it took ~15 seconds

1563261119
emekankurumeh[m]
first and subsequent, i'm on windows 64bit mingw-w64

1563261217
daurnimator
emekankurumeh[m]: can you profile to figure out what's taking all the time?

1563261249
mikdusan
for me: windows10, vstudio 2019 buildtools, msys64: build from scratch: 3m, 38s

1563261255
mikdusan
(debug)

1563261276
mikdusan
errr. scratch that. Release build.

1563261301
emekankurumeh[m]
mikdusan: that must be nice

1563261390
mikdusan
i do notice a pause on the "install step" which is now quiet (no verbosity). can't tell if it's taking longer or not

1563261483
daurnimator
mikdusan:

1563261519
mikdusan
apropos!

1563262014
emekankurumeh[m]
hmm, now it seems to take much less time

1563262022
mikdusan
emekankurumeh[m]: does this patch improve build time?

1563262058
mikdusan
it nocked a full minute off for me. makes sense, because if build.exe is running the install, a release version is faster.

1563262351
emekankurumeh[m]
mikdusan are you on master?

1563262445
mikdusan
yes 68149f2039bd203514571f0304e72897b4583ff2

1563262481
emekankurumeh[m]
strange, that patch results in a compiler error for me

1563262580
mikdusan
emekankurumeh[m]: ok i only tried it on my windows10 env. it does create an error on macOS. so maybe not good for "unix" style builds

1563262802
mikdusan
yeah that patch is garbage. please trash

1563271198
nrdmn
andrewrk: regarding panic on uefi: uefi provides a stderr interface. However, to use that interface, accessing a parameter that is passed to EfiMain() is required. Either we'd need to wrap EfiMain() or we leave defining panic() to the user.

1563283278
Pwipwi
hello all

1563283294
Pwipwi
I have been asking on the discord on the way to put a literal string into an []u8

1563283307
Pwipwi
var toto = "toto";  var key: []u8 = toto[0..];

1563283312
Pwipwi
this is the only thing working so far

1563283321
Pwipwi
is there any simpler way ?

1563283329
Pwipwi
shouldn't the compiler be able to sort this out ?

1563283340
mq32
you can only put a literal string into an array (mutable) or into a non-mutable slice ([]const u8)

1563283358
mq32
otherwise you would have a mutable slice on the string literal

1563283367
Pwipwi
oh

1563283375
Pwipwi
so is it a bug that the compiler lets me do that?

1563283401
mq32
no

1563283404
mq32
the second example is:

1563283422
mq32
create an array (toto : [4]u8) and take a mutable slice on that array

1563283450
Pwipwi
does it mean that my toto variable can be modified ?

1563283460
mq32
yes

1563283462
Pwipwi
ok

1563283559
mq32
look here:

1563283559
mq32


1563283599
mq32
(notice the compile log below, it outputs your types)

1563283626
fengb
I'm a little surprised a literal became a mutable array

1563283632
Pwipwi
me too !

1563283655
Pwipwi
although it seems the compiler infers the literal as a non const array

1563283656
fengb
I suppose that's why you `const` declare things

1563283664
fengb
Yeah, it's just foreign coming from C :P

1563283670
Pwipwi
yes, I find this actually nice

1563283674
Pwipwi
alright

1563283686
Pwipwi
new question ; can't union be namespaces like struct ?

1563283706
mq32
fengb, i think Zig just does the same as C: char array[] = "toto";

1563283714
mq32
would also create a mutable array of [5]char

1563283730
mq32
Pwipwi, you can declare functions on a union

1563283736
mq32
so they should be

1563283747
fengb
Oh good point

1563283858
Pwipwi
I get an unexpected token when I try to do like with the structs

1563283873
mq32


1563283881
mq32
can you share the code?

1563283939
Pwipwi
on godbolt ?

1563283978
Pwipwi


1563284024
fengb
Test is a keyword

1563284048
Pwipwi
oh

1563284059
Pwipwi
works better

1563284064
Pwipwi
damn

1563284067
Pwipwi
didn't see that one coming

1563284069
Pwipwi
lol

1563284075
fengb
Compile errors could be better

1563284100
Pwipwi
indeed

1563284231
Pwipwi
are there varargs in zig ?

1563284252
mq32
yes, there are. check out the manual

1563284261
mq32
but Zig var args will be removed at some point

1563284272
Pwipwi
I did but ctrl+f didn't help

1563284299
nrdmn
mq32: what are the alternatives to var args?

1563284335
fengb
Tuples

1563284355
mq32
nrdmn, wait a sec, there's an issue on this

1563284381
fengb


1563284405
mq32


1563284503
Pwipwi
so it's recommended not to use them I guess ?

1563284549
nrdmn
will we be able to iterate over tuples and check every element's type?

1563284594
fengb
Oh no tuples? I just reread the issue

1563284628
mq32
nrdmn, it will be anonymous structs and yes, you can iterate them

1563284717
fengb
So... I know it says no tuples... but anonymous struct literals are basically tuples >_>

1563284753
nrdmn
> introduce anonymous array initialization syntax

1563284765
nrdmn
how's that different from []T{a, b, c} ?

1563284851
mq32
you can "mix" types and then the Zig compiler will make an anonymous struct out of the "array"

1563284880
nrdmn
yes but if I don't? wouldn't both syntaxes give the same result?

1563284892
mq32
nah

1563284905
mq32
.{ "hello", 10 } would not be an array, but would be allowed with anonymous syntax

1563284918
nrdmn
I mean if I don't mix types

1563284934
mq32
then it

1563284938
mq32
*result

1563284970
fengb
Hmm, I kinda like that for replacing `[_][]const u8`

1563285420
nrdmn
hmm, did something change about that syntax in the last two months? I have a program that used to compile successfully using the []T{...} syntax. Seems like now I have to use [_]T{...}.

1563285570
fengb
Yeah that's a breaking change

1563285596
fengb
`[_]` means inferred array. It was a little ambiguous when `[]` doubled as both array and slice

1563285605
very-mediocre
nrdmn: _ is required for arrays with a comptime known size, the programmer should be explicit that the size is known

1563285641
very-mediocre
you could write a number or just _ for the compiler to infer the length

1563285771
very-mediocre
You'd use []T for a dynamic array. iirc I've noticed andrewrk referring to that as a slice but I'm not sure if it carries the properties of a regular slice i.e. len

1563285787
very-mediocre
"regular slice" being like `something[0..]`

1563285797
fengb
A slice is just a fat pointer

1563285807
fengb
It was ambiguous syntax that's been updated

1563285814
very-mediocre
yes, I'm saying I'm not sure zig maintains a `len` for dynamically allocated arrays

1563285838
fengb
Arrays have length. It's a compile time quality

1563285855
very-mediocre
Zig maintains a length for slices using something[0..] syntax

1563285869
very-mediocre
I'm saying I remember seeing andrewrk refer to []T as a slice too

1563285880
fengb
Yeah they're always slices now

1563285883
very-mediocre
and I wonder if that implies length is maintained

1563285888
fengb
[N]T and [_]T are arrays

1563285952
very-mediocre
Take `const something = some_allocator.alloc(SomeType, runtime_known_count);`

1563285961
fengb
Arrays are comptime known memory spaces

1563285966
very-mediocre
that a []SomeType

1563285970
fengb
You can't build arrays at runtime

1563285976
fengb
That returns a slice

1563285978
andrewrk
mikdusan, re: your question about coroutine frames - the way it works is we put all the variables of a function into a struct, and then have that function accept a secret pointer to that struct as the first argument

1563286002
very-mediocre
fengb: we're talking in circles, I'm aware that is now called a slice, I just wonder if length is maintained by zig

1563286046
andrewrk
very-mediocre, idk what you mean by "maintained"

1563286071
very-mediocre
Can I do something.len with `something` being of type []SomeType

1563286084
very-mediocre
(I'd test it and find out but I can't right now)

1563286086
andrewrk
yes that's the point of a slice

1563286097
very-mediocre
Well there you go, that's what I was asking about, thanks

1563286116
very-mediocre
Because previously I thought slices were

1563286121
fengb
Slice is a pointer + len. For unknown lengths, it's a [*]T

1563286166
very-mediocre
tl;dr: I know what a slice is, I just did not know dynamically allocated arrays = slice in zig until recently

1563286181
Tetralux
Wait what?

1563286186
andrewrk
the zig language doesn't have dynamically allocated arrays

1563286203
Tetralux
(.. Well - strictly it does - but it's std.ArrayList.)

1563286206
andrewrk
std.ArrayList is a dynamically allocated array and it's a different type than a slice

1563286212
very-mediocre
Sure, that's a semantical argument though

1563286223
very-mediocre
I understand fully now what you mean

1563286237
very-mediocre
and it means I was using the wrong terminology when talking about zig

1563286249
Tetralux
I'm not sure I understand why that's semantical but sure xD

1563286251
fengb
It matters in Zig (and C, Go, etc.) where array == fixed segment of memory

1563286254
andrewrk
a slice does not necessarily mean that it is dynamically allocated

1563286259
andrewrk
there are statically allocated slices

1563286262
Tetralux
^^

1563286277
very-mediocre
Yes, indeed I've used [m..n] on various non-dynamic arrays many a time

1563286325
very-mediocre
while a slice does not mean it's dynamically allocated, I thought that, similarly, an array being dynamically allocated did not mean it was necessarily a slice in zig

1563286335
mq32
andrewrk, what i wondered about coroutines/CPS: can we yield from a second-level function? (so my function is calling a function that yields the coroutine) and does the coroutine frame then contain

1563286514
andrewrk
mq32, when the second function yields, the program counter returns to the first function

1563286530
andrewrk
a coroutine frame contains local variables for the function only

1563286539
andrewrk
there is no coroutine stack, there is only the kernel thread's stack

1563286562
mq32
hm

1563286580
mq32
i think my question was not precise enough

1563286839
mq32


1563286851
Pwipwi
there is no function overloading in zig

1563286852
Pwipwi
?

1563286855
mq32
do i have to handle the async call of the readSome() function in myAsyncTask?

1563286857
mq32
Pwipwi, nope

1563286864
Pwipwi
Damn, that's rough

1563286990
fengb
mq32: readSome isn't invoked as async so I'd expect it to be fully synchronous

1563286993
andrewrk
mq32, this example gets the API semantics wrong. despite the planned changes, the docs do have some good info here:

1563287008
andrewrk
importantly "The result of an async function call is a promise->T type, where T is the return type of the async function. Once a promise has been created, it must be consumed, either with cancel or await."

1563287043
nrdmn
I can't have pointers to anonymous arrays, right?

1563287062
andrewrk
nrdmn, I think you can

1563287081
Tetralux
Is the idea of cancel that it simply doesn't bother to resume a coroutine when it next becomes suspended?

1563287083
mq32
andrewrk, i want to know how that is planned as the proposal for transparent calls of async/sync code

1563287096
Tetralux
So you essentially cannot cancel a coroutine that suspends only once?

1563287113
nrdmn
huh? oh...

1563287126
andrewrk
mq32, here's the way to think about it: when you call a function with async, you must consume it with `await`. Await is a suspend that will be resumed when the awaitee returns

1563287159
andrewrk
suspend/cancel is a lower level API. when a coroutine suspends, it must have a plan for how it will be resumed

1563287222
Tetralux
When would you need to use suspend/cancel?

1563287235
mq32
andrewrk, ah okay

1563287258
very-mediocre
Tetralux: docs say "In general, suspend is lower level than await. Most application code will use only async and await, but event loop implementations will make use of suspend internally."

1563287285
andrewrk
mq32, the idea behind transparent calls of async/sync code is centered around 2 things: 1. inferring that a function is a coroutine if it calls a coroutine. 2. calling a coroutine as a normal function (`foo()`) is syntactic sugar for `await async foo()`

1563287322
Tetralux
Yeah - how the

1563287340
Tetralux
But

1563287346
fengb
andrewrk: does that mean the compiler will have to mark functions as "coroutine-able"?

1563287353
andrewrk
Tetralux, have a look at std/event/loop.zig. after the coroutine changes, the logic will be mostly the same, it'll just be cleaner with better memory management

1563287381
andrewrk
fengb, yes the compiler has to know whether to generate a function as a coroutine by the time it gets to the end of analysis

1563287383
fengb
Expose the "function color" but only dispatch runtime changes

1563287485
very-mediocre
andrewrk: point #2: you can't you launch several coroutines without awaiting them right away?

1563287489
andrewrk
so this does introduce a downside of: you try to pass a callback to a C API, and you get a compile error that says something like: that function has async calling convention, but you're passing it to a C calling convention API. and then there could be a stack of 50 functions in the error message and the last one at the end was a coroutine

1563287517
very-mediocre
I'm thinking of the `await Promise.all()` pattern in JS. Apologies for talking over everyone, timing is hard to get right on IRC.

1563287532
mq32
can't we compile a functiont twice then?

1563287538
andrewrk
very-mediocre, look for "But what if the code wants to express possible concurrency?" in the proposal

1563287545
very-mediocre
thanks

1563287586
fengb
mq32: I think the goal is the function exists as both a regular and coroutine. But running as a coroutine limits its interoptability with C

1563287620
very-mediocre
...unless some kind of an event loop runtime gets codegened.

1563287628
very-mediocre
but yes that seems anti-zig

1563287639
fengb
It's the color problem... but a bit nicer in Zig-land since the execution semantics should be the same

1563287665
andrewrk
all the "depends on" issues in that proposal have been solved except the coroutine rewrite :)

1563287712
fengb
How does Go solve it? Does hiding behind a blocking channel just "fix" the problem?

1563287718
andrewrk
fengb, the goal is that a zig library can have functions that express logic that works in both environments optimally: blocking and event loop

1563287755
andrewrk
goroutines have stacks that grow. every function call checks to make sure there is enough stack space for the function call and might allocate more stack space

1563287758
fengb
Yeah I really like this approach. It just sounds hard and unsolved :P

1563287790
andrewrk
I've always wanted to be able to express the inherent concurrency in control flow, even when it sometimes gets compiled single-threaded blocking

1563287812
andrewrk
like, hey compiler these files can be loaded independently, and then only here do they both need to be complete before continuing

1563287869
very-mediocre
JS gets a lot of hate but imho it deserves credit for popularizing concurrency + some really clean syntax for expressing it

1563287875
andrewrk
agreed

1563287899
andrewrk
std.event.Loop.initSingleThreaded(); // I got your node.js right here

1563287927
fengb
Eventually some clean syntax :P

1563287928
very-mediocre
This is going to be killer

1563287942
fengb
Back in my day, we used callbacks and liked it

1563287944
andrewrk
zig is trying to take it a step further though, with a thread pool event loop. max out those cores

1563287994
very-mediocre
I remember reading the phrase - green threads multiplexed over several cores - on this channel before

1563288304
andrewrk
I believe green threads are equivalent to goroutines, and zig does not have those, and has no plans to have those

1563288328
andrewrk
the only stacks around here are kernel thread stacks

1563288397
very-mediocre
Yeah you're right, I thought the term was more vague than that (I thought it'd work for "multiple coroutines per thread")

1563288426
very-mediocre
but that isn't exactly a "scheduler", just naive multiplexing

1563288468
Tetralux
Q: How easy would it be to go from simple single-threaded code, to coroutine-MT code?

1563288481
Tetralux
Is this just a case of adding async/await in a few places, essentially?

1563288481
andrewrk
(I'm not trying to have a semantic argument with you, just trying to keep the information clear in this channel with 112 people in it, many of them newbies)

1563288536
very-mediocre
I understand, I generally assume everything is said in good faith. :)

1563288595
andrewrk
Tetralux, according to the #1778 it would be nothing more than adding this to your root source file: pub const io_mode = .ThreadedEventLoop;

1563288599
fengb
So... CS-y semantics it'd be fibers?

1563288644
Tetralux
Oh I see - so the idea is you'd write the code with the intention of using an event loop and async/await and then just set it to MT vs ST.

1563288653
Tetralux
So you'd write it as if it was MT to begin with?

1563288668
andrewrk
yes, evented-MT, evented-ST, or blocking-ST

1563288703
andrewrk
you'd write it as if it was evented-MT

1563288720
Tetralux
And the difference between using managing kernel threads yourself and this would be that you have some syntax to help you write it in a more sequential way.

1563288732
Tetralux
.. And presumably have better stack traces for free.

1563288743
andrewrk
just like in status quo zig you should write it as if it was MT but you can pass --single-threaded which does things like make thread-local variables into normal global variables

1563288775
andrewrk
yes stack traces will be a big thing\

1563288778
Pwipwi
is there something like warn() but that outputs to stdout ?

1563288792
Tetralux
Does "write it as if its MT" mean that you are using Mutexs and things to protect for thread safety, but they get simplified out in --single-threaded?

1563288806
Tetralux
But actually making a Thread would still be exactly that.

1563288837
andrewrk
Pwipwi, const stdout_file = std.io.getStdOut(); and then `const out = &stdout_file.outStream().stream;`

1563288863
andrewrk
Pwipwi, need to handle the error from getStdOut though

1563288866
Pwipwi
I've been using stdout.write() for a while

1563288877
Pwipwi
just wondered if there was something that did the formatting for me

1563288882
Pwipwi
on stdout

1563288892
andrewrk
in my example `out.print()` is what you want

1563288896
Pwipwi
oh

1563288937
very-mediocre
stdlib auto-documentation is gonna go a

1563288947
andrewrk
Tetralux, that's correct, std.Mutex turns into no-ops in --single-threaded. making a thread is a compile error with --single-threaded

1563288968
andrewrk
actually std.Mutex turns into deadlock detection safety in --single-threaded debug builds. in release builds it's no-ops.

1563288998
Pwipwi
@very-mediocre that and intellisense :)

1563289029
andrewrk
both planned, both depend on the same thing, both still probably 2 release cycles out

1563289064
Pwipwi
so one year ?

1563289079
andrewrk
that's my estimate yes

1563289096
nrdmn
andrewrk: I've had a look at panicking on uefi. Outputting any message requires accessing an argument that's passed to EfiMain(). So I think we would either have to wrap EfiMain() and do some initialization work hidden from the user or let the user provide a panic(). What's your opinion on that?

1563289100
Pwipwi
sweet

1563289146
Tetralux
So presumably the entire point of --single-threaded is for embedded, and for debugging, essentially.

1563289160
Tetralux
Because in reality, why wouldn't you have it otherwise.

1563289167
andrewrk
nrdmn, it could make sense to support that - have a look at

1563289168
Pwipwi
I've been using the out thing, but now I'm getting a posix error

1563289180
Pwipwi
posix.EBADF => unreachable

1563289196
Pwipwi
note that I'm trying to have stdout and out as global variables

1563289253
andrewrk
Pwipwi, is this a cross platform software? on windows std.io.getStdOut() only works at runtime

1563289267
Pwipwi
linux only for now

1563289302
Pwipwi
Having const stdout = ... at top level and subsequently using stdout.write() works fine

1563289334
Pwipwi


1563289370
andrewrk
Pwipwi, you've run into

1563289378
andrewrk
need to take the address of the stream field

1563289400
andrewrk
I almost said something about it explicitly when I gave you the example code above

1563289417
Pwipwi
ok

1563289432
Pwipwi
yeah, I lexed it but didn't parse

1563289441
Pwipwi
I used to code in C like 10 years ago

1563289448
Pwipwi
trying zig coming from the wonderful javascript world.

1563289481
Pwipwi
I'm trying to keep questions at a minimum, but it's not easy :)

1563289493
andrewrk
questions are more than welcome

1563289510
mq32
every question means that something hasn't been documented well :P

1563289514
fengb
There's a lot of (former) JS programmers here

1563289515
andrewrk
there's nothing more on topic here than questions about how to use zig

1563289529
Pwipwi
sure, but at this moment it's understandable that it wouldn't

1563289536
gonz_
fengb: How do you figure?

1563289553
Pwipwi
I wouldn't consider myself as

1563289555
gonz_
This seems like a foregone conclusion but I'm curious what makes people think so

1563289564
fengb
andrewrk did a bunch of JS work. I do JS with my day job

1563289573
fengb
So 2 most important people do JS :P

1563289576
gonz_
I think in any IRC room there's bound to be a lot of programmers who have been forced to use JS, even. :D

1563289616
Pwipwi
I think JS is enjoyable provided you can use typescript :)

1563289628
andrewrk
I don't think js programmers have discovered it yet but zig is already a pretty reasonable tool for creating node.js modules with wasm

1563289632
Pwipwi
I just wanted to have a more systemy language

1563289649
Pwipwi
andrewrk : that's actually one of my use cases !

1563289651
andrewrk
because the generated .wasm can be uploaded to npm

1563289688
andrewrk
we even have the ability to compile C code for .wasm, and a wasm-compatible libc (that is far from complete)

1563289708
Pwipwi
sweet

1563289734
companion_cube
that's where the next war is fought for low level languages: wasm!

1563289754
companion_cube
I wonder how soon we'll see electron apps mostly written in wasm

1563289761
Pwipwi
never ?

1563289769
gonz_
I don't even know if I can categorize what kind of programmer I am. Not by numbers, at least. I did C++ for seven years but I was terrible at learning and I ended up hating it.

1563289775
fengb
I actually don't see wasm replacing JS any time soon :/

1563289786
gonz_
I work very profitably with Elixir & Erlang, but I dislike them too

1563289796
companion_cube
there's no replacing of it, but competing would be nice already

1563289799
Pwipwi
gonz_ ain't nothing wrong hating cpp

1563289800
fengb
Oh? First I've heard anyone dislike Elixir lol

1563289814
gonz_
It's an unmaintainable mess

1563289820
fengb
Huh

1563289822
companion_cube
lack of types?

1563289825
gonz_
Yes

1563289838
companion_cube
that's the one thing that scares me away from it 🤷

1563289844
gonz_
No way to model anything correctly and enforce any kind of invariants

1563289844
Pwipwi
the fun part is that this unmaintainable mess makes your code an unmaintainable mess ! \o/

1563289865
Pwipwi
I tried to like Rust

1563289867
fengb
The macros have scared me... but they've been scaring me since Lisp

1563289874
gonz_
Not to shittalk another language too much, though. This is #zig :P

1563289885
andrewrk
thanks gonz_ :)

1563289930
Pwipwi
by the way, is there work planned on organizing the standard library ?

1563289997
andrewrk
Pwipwi,

1563290016
andrewrk
for now the standard library is allowed to get big, because it helps test the language

1563290071
Pwipwi
I meant more of a reorganization like a containers folder which different implementations in it

1563290074
Pwipwi
that kind of thing

1563290084
Pwipwi
like the crypto/ folder

1563290088
fengb
andrewrk: I've noticed a lot of "core" things are being extracted out of Go, like crypto. Will we have a "standard repository" for stdlib like stuff that's not included?

1563290093
Pwipwi
iirc, hash_map is at top level

1563290336
mq32
fengb, that's one thing that annoyed me a lot and prevents me from using stuff like Rust/dotnet Core

1563290369
mq32
you have a language and a really thin std library

1563290390
mq32
and then you download like 50 packages into

1563290441
Pwipwi
yay python stdlib

1563290582
Pwipwi
andrewrk is there any reason why zig won't accept arrays as slice parameters ?

1563290592
Pwipwi
maybe doing a [0..] under the hood ?

1563290613
Pwipwi
I find myself creating static arrays a lot, just to take their [0..] as parameter

1563290684
fengb
mq32: pioneered by npm :P

1563290686
Pwipwi
oh nevermind, I can do it with const

1563290714
fengb
But more seriously, it allows each library to iterate on its own instead of depending on core releases

1563290735
mq32
yeah, that's true

1563290795
mq32
but i think there's a path between "npm" and ".NET" thickness of stdlib

1563291823
halosghost
that's quite a wide gap there

1563292755
companion_cube
rust's stdlib seems a pretty decent size to me

1563292767
companion_cube
it's bigger than C++'s but doesn't try to include stuff like http

1563292998
fengb
I think Python is a great counter example. There was urllib, urllib2 both in core and neither was well supported

1563293027
fengb
Sometimes the batteries get super stale but they also can't be fixed due to breaking changes

1563293099
Tetralux
Is it sometimes?

1563293102
Tetralux
Or is it always?

1563293110
Tetralux
Seems more likely always to me.

1563293122
companion_cube
rust includes basic traits and types to help the ecosystem agree on them, which I think is healthy

1563293139
Tetralux
Does that not limit you?

1563293141
fengb
I suppose Java still includes the Vector class :P

1563293234
halosghost
I think providing things like traits/interfaces in the std lib is a great idea so that programmers can standardize on those interfaces and the implementations can be easily pluggable

1563293246
halosghost
best example I can give would be the mistake that Haskell made with STring

1563293250
halosghost
s/Tring/tring/

1563293290
halosghost
would have been dramatically better if String were a typeclass (read: interface, trait) instead of a bare type

1563293305
halosghost
that specific example isn't really applicable to Zig, but I hope the spirit makes sense

1563293347
companion_cube
also things like std::future for rust, they're agreeing on it so async/await can be stabilized

1563293367
gonz_
I dunno, an `IsString` type class is still very usable in the end.

1563293384
gonz_
Regardless of having the base type

1563293413
halosghost
gonz_: If you're disagreeing with me, I don't understand what part you're disagreeing with :)

1563293450
gonz_
Having the base type didn't somehow exclude having the `IsString` type class which people can implement

1563293546
halosghost
for sure

1563293589
halosghost
but that was added on later

1563293620
halosghost
rather, if String (or IsString, whatever) had been in the prelude from the beginning, then that standardization could have happened a lot sooner

1563293625
companion_cube
in rust, even the initial (de)serialization stuff is deprecated and universally replaced by serde

1563293631
companion_cube
which is de facto standard

1563300203
andrewrk
Pwipwi, a slice is a reference; an array is a value. zig won't implicitly make reference unless it's safe (such as for static constants)

1563300332
andrewrk
there will need to be community efforts to help organize zig packages

1563300352
andrewrk
zig's decentralized model takes burden from the zig project itself and puts it on the community

1563300400
andrewrk
we will need third party package discovery services, third party curating, and community lead decisions on what packages are considered "standard"

1563301508
darithorn
just learn from npm's mistakes. i swear i hear almost every day about some npm package being compromised

1563302151
fengb
npm's problem exists because it's a centralized repo without any community guidance

1563302178
andrewrk
zig packages won't be capable of being compromised, users of packages lock exact versions with hashes

1563302181
fengb
I think at the very least, we should have some "core" that's trustworthy

1563302213
andrewrk
of course, when you update to a new version of a package, you are trusting the new code. so skip reading code diffs at your own risk, depending on how much you trust someone

1563302471
fengb
andrewrk: do you foresee something like Debian's packages? Where there's an actual official repository where things can get merged if well maintained and trusted

1563302587
andrewrk
I think that would be a great third party project

1563302644
andrewrk
I could see the zig project "blessing" one or more of these third party project with an official statement saying that the zig project considers it trustworthy and meeting quality standards

1563302707
THFKA4
as long as it plays nicely with nixos

1563302731
THFKA4
also, i think zig is broken since 0.4 on guix because it runs something out of the build output directory or something

1563302739
companion_cube
maybe the blessing could be pgp signatures of releases?

1563302740
THFKA4
in case you care lol

1563302801
andrewrk
THFKA4, happy to help if you can write up an issue with some more details

1563302886
THFKA4
already uninstalled it, sorry. i'll try it again in a VM someday

1563302941
fgenesis
since we're asking about weird systems, any plans for XP support? (as long as it "works"...)

1563303002
andrewrk
THFKA4, if guix is your system, then I'd be more motivated to get it working. in general, however, I think effort is better spent on the language and other core concerns at this time. broadening the set of supported targets is a later stage effort

1563303075
andrewrk
currently zig's policy is to support windows versions still supported by microsoft. that means the lowest supported windows is Windows 7, which you can see on

1563303097
fgenesis
yea i've seen that and got a little sad :D

1563303121
andrewrk
what's your windows xp use case?

1563303125
fgenesis
because i'm wondering how far it might be possible to backport

1563303131
fgenesis
oh, a lot. everyday use kinda

1563303143
andrewrk
you use windows xp as your main operating system?

1563303149
fgenesis
i like having a finished, stable system that's not broken by random updates anymore

1563303157
fgenesis
on my secondary dev machine, yes

1563303185
fgenesis
it thinks it's a POS system so it did get updated until recently

1563303192
andrewrk
interesting

1563303210
fgenesis
plus i need it to supply software to my C64

1563303246
fgenesis
needs this weird kernel driver that works super well on XP and bit-bangs stuff out the LPT port to make the commodore floppy drive actually work on modern systems

1563303300
andrewrk
I doubt that zig's policy on minimum windows versions is going to change. but we have been moving closer to using NtDll for more API which as I understand my help that use case

1563303308
andrewrk
I haven't filed that issue yet

1563303319
andrewrk
also zig's lazy analysis helps the use case a lot

1563303331
andrewrk
because if you don't use a feature, then you don't depend on it

1563303361
fgenesis
NtDll is going to fail hard once i try compiling for w98, then =)

1563303384
fgenesis
aaactually KernelEx might work, but not sure

1563303401
andrewrk
a fork of zig lowering the minimum windows version would be reasonably straightforward

1563303420
andrewrk
I need to keep the scope of this project under control

1563303432
andrewrk
I don't want to be working on a programming language for the rest of my life, I want to be building stuff with it, goddammit

1563303442
fgenesis
i'm more curious about where LLVM draws the line

1563303459
andrewrk
afaik LLVM does not have the concept of windows versions

1563303464
fgenesis
yes, and then annoying users come along and demand Win3.11 support :o)

1563303486
companion_cube
with 💵 hopefully

1563303501
very-mediocre
andrewrk: i think you'll be in a safe situation if at least 1 major corporation adopts zig for a critical app of some kind

1563303531
andrewrk
I still want enough "grass roots" sponsors though, so that said corporation can't jerk me around

1563303556
very-mediocre
yeah i just mean in terms of credibility to keep the project going even if you'd like to retire, or not work on it so much

1563303566
andrewrk
I see

1563303575
very-mediocre
even hated corporations have cred, like facebook

1563303599
very-mediocre
everyone hates facebook, but they produce tons of open source stuff and everyone says "oh facebook is backing this project"

1563303601
companion_cube
easy, just convince Linus to use Zig in the kernel from now on 🙃

1563303617
fengb
I wonder if he'll curse our Zig like he does C++

1563303619
companion_cube
very-mediocre: technically, FB are good; but to users they're bad

1563303623
fengb
s/our/out/

1563303634
very-mediocre
I'll have to disagree with you there but anyway that's a moot point

1563303639
andrewrk
I think that zig wolud be a great fit for the linux kernel, and linus would be unreasonably skeptical about it

1563303658
very-mediocre
Linus had become one of those "code of conduct" cultists recently

1563303668
fengb
FB open source is surprisingly everywhere, e.g. they're the current maintainers of jemalloc

1563303675
companion_cube
otoh if some people use Zig for hardware drivers…

1563303681
companion_cube
where C is king but also really bad

1563303684
andrewrk
let's not get into a code of conduct argument please. that's controversial and off topic

1563303692
very-mediocre
sure i don't meant to get into it much more than that

1563303699
very-mediocre
just saying he's very uncharacteristic now

1563303705
andrewrk
yeah don't even mention it, it's off topic bait

1563303705
very-mediocre
hard to predict how he'd react

1563303710
very-mediocre
noted

1563303744
companion_cube
I don't think linux would adopt a language driven by llvm, though

1563303750
andrewrk
anyway there's a really good reason to be skeptical about zig and that is about its lack of maturity

1563303790
Tetralux
Yeah - just the frequency of running into wierd compiler bugs is enough to dismiss it pretty easily for some people.

1563303797
andrewrk
the llvm monoculture is also a reasonable objection, but that's also related to maturity given that's recognized that we'll need more backends than LLVM provides and an official language specification

1563303821
very-mediocre
LLVM hasn't hurt Rust much I think

1563303829
companion_cube
yeah, personnally I think I'd consider Zig a safe bet for real projects when it gets a gcc frontend

1563303837
companion_cube
(after 1.0 and after a spec exists)

1563303846
andrewrk
so there are those good reasons to be skeptical. but I really think it holds up to scrutiny beyond that

1563303849
fgenesis
oh, there are plans for that?

1563303858
companion_cube
very-mediocre: some people dismiss rust because it has only one compiler

1563303871
andrewrk
companion_cube, what about that c++ one?

1563303892
very-mediocre
Rust does have Firefox backing it though, that's huge. I wonder what Zig's killer app could be

1563303901
companion_cube
it's partial, afaik, it doesn't do the borrow checking

1563303905
fgenesis
which of the many, slightly broken c++ compilers?

1563303909
companion_cube
it's mostly there for independent bootstrapping I think

1563303914
andrewrk
very-mediocre, guess_number.exe. (just kidding)

1563303918
very-mediocre
haha

1563303932
very-mediocre
this is a very consolidated space right now

1563303933
companion_cube
what if systemd adopted Zig? ;-)

1563303946
very-mediocre
connections seem to trump merit

1563303950
fgenesis
pearls on pigs

1563304026
andrewrk
I do think that we'll start to see more complicated and impressive zig projects once the community can start depending on each other's code

1563304052
andrewrk
and then consequently the fact that the stage1 compiler doesn't have all the planned performance improvements of self-hosted will become painful

1563304056
Tetralux
..And once there are fewer compiler bugs :')

1563304079
very-mediocre
maybe the most immediate most mainstream use case is web server software, that attracts tons of people and they tend to get pretty entrenched

1563304095
companion_cube
I wonder if the end result compiler would be comparatively "simpler" (or as simple) than Go

1563304101
companion_cube
since it's something people apparently love about Go

1563304105
andrewrk
Tetralux, yeah. the main difference with self-hosted isn't that it will be written in zig, although that will help - the main difference will be that the requirements are fixed...

1563304118
andrewrk
zig stage1 compiler has had its premises yanked out from underneath it so many times

1563304140
companion_cube
another weird question: could Zig bootstrap from a wasm image?

1563304154
companion_cube
(ocaml bootstraps from a bytecode version of its compiler + the C interpreter, for reference)

1563304160
Tetralux
.. meaning that there is more motivation to--slash, is easier to---fix bugs in it?

1563304168
andrewrk
bootstrapping means using source only. a wasm image is not source

1563304200
andrewrk
Tetralux, I'm saying that it's a lot easier to write bug-free code when the requirements are fixed

1563304252
andrewrk
companion_cube, have you seen the bootstrapping issue?

1563304256
andrewrk


1563304310
companion_cube
andrewrk: but you depend on a C++ compiler then

1563304335
Sahnvour
in what timeframe do you see zig hitting beta stage (almost 1.0 stage2, etc.) ? 2-3 years ?

1563304369
andrewrk
Sahnvour, yes

1563304402
andrewrk
it feels like the issues are never-ending, but in reality there are only a handful of major proposals left

1563304418
andrewrk
and once the language stabilizes all the sudden there won't be

1563304455
Sahnvour
I don't think major proposals will eventually stop but I get your point

1563304497
Tetralux
andrewrk: Hmmm. That's not so clear-a-correlation to me. And yeah - there's always new bugs xD

1563304511
Tetralux
But yeah, the waterfall will prob subside a bit over time.

1563304529
andrewrk
Sahnvour, oh, I mean my own proposals, sorry :)

1563304540
andrewrk
at some point zig will be closed for proposals

1563304566
very-mediocre
golang has ~4600 open issues

1563304570
bheads
then the zig ISO standard will be formed

1563304577
bheads
the MS will extend it

1563304648
very-mediocre
I still think without a killer app things may go in a D-like direction

1563304700
Sahnvour
andrewrk: that's a bold claim, I can't think of a language reaching maturity early on and never updating, even C does

1563304705
very-mediocre
I know pandering sucks but it'd be nice if zig focused on excelling in 1 area for a while just to attract ppl

1563304779
andrewrk
Sahnvour, there will be updates for sure. for example we have to keep up with LLVM/Clang versions, and update the standard library for new operating system stuff. maybe even add a new operating system

1563304801
andrewrk
major language changes, on the other hand, the plan is to finish the language and then leave it alone

1563304831
emekankurumeh[m]
so zig will stay 1.*.*?

1563304837
andrewrk
IMO javascript got worse with ES6

1563304860
very-mediocre
ES6 added Promises though, way better than "then"

1563304867
very-mediocre
ES7 or 8 was async/await

1563304893
very-mediocre
ES5 is pretty miserable imho

1563304897
Sahnvour
I understand, but it's pretty inevitable people get annoyed at some quirks that weren't discovered early enough, and sometimes they might even be right about it :p

1563304956
andrewrk
Sahnvour,  the plan is to fix quirks and design flaws, and I'm willing to bump major versions to do that (I have some ideas so that packages can specify the zig version to make this not break everything)

1563304965
andrewrk
but I don't expect to add new features

1563305026
emekankurumeh[m]
imho that's a bit of a bummer but i can see why you would want to do that

1563305043
companion_cube
C barely evolved in the last 20 years, indeed

1563305060
companion_cube
hopefully, starting now, we could get a language that doesn't need to evolve much either

1563305073
andrewrk
that's been the plan all along, I'm sorry if I didn't make that clear

1563305075
companion_cube
(except for stuff like compiling to CUDA or whatever future architecture will be invented)

1563305104
andrewrk
let's make sure it's a great language before 1.0 then shall we?

1563305120
companion_cube
:D

1563305181
very-mediocre
there is some appeal to it not having tons of radical changes

1563305194
very-mediocre
C++ priotizes backwards compat and it creates a massive amount of cruft

1563305200
very-mediocre
and other languages break too much

1563305223
very-mediocre
python2->3 was a huge mess

1563305224
Sahnvour
about that, the optimizer is bothering me by outlining every function every time they get more than 1 call, even if inlining it at some points would be a huuuge win

1563305236
companion_cube
question is: what new

1563305249
companion_cube
async/await is fairly new, for example, but everyone wants it somehow

1563305300
very-mediocre
btw andrewrk: what would

1563305326
companion_cube
his music player! :D

1563305473
very-mediocre
no need to answer if you find this line of inquiry inappropriate, no pressure. But I thought it might give some insight on the language.

1563305567
andrewrk
very-mediocre,

1563305587
andrewrk
if you look at my github repos I have quite a lot of projects

1563305638
very-mediocre
great, thanks. I find this really insightful, I should have asked earlier.

1563305992
andrewrk
other projects I've done in the past that would have been better in zig: json-like configuration parser, libsoundio, all the games listed on andrewkelley.me (most are playable in the browser), a game engine for rapid prototyping, statically recompiling nes games to native executables, static website generator, using genetic algorithm to evolve brainfuck code, minecrat bot API framework

1563306004
Sahnvour
I'm looking forward to gamedev with zig so much ...

1563306046
andrewrk
we're getting there. as of a couple days ago

1563306158
very-mediocre
all very cool

1563306182
very-mediocre
the most insightful thing imho is your C++ code

1563306209
very-mediocre
it might be fair to say it wants to be zig code

1563306236
Sahnvour
nice

1563306273
very-mediocre
seriously C++ codebases can be so awful, check out his code in Genesis though

1563306277
companion_cube
I forgot, is anything planned for type parameter inference? so one could use ArrayList without specifying the type explicitly

1563306281
Sahnvour
although I would wait for our linker/hot reload to consider it really serious

1563306313
andrewrk
very-mediocre, genesis does not link libc++

1563306321
andrewrk
turns out if you avoid most C++ features you don't even need that

1563306340
andrewrk
Sahnvour, ah yes that's a big deal

1563306362
very-mediocre
yeah, I've written a few C++ projects and they came out like just classes and procedural glue code and not much more

1563306363
Sahnvour
I would also really like to work on them but time is lacking unfortunately

1563306452
Sahnvour
now that I've used Live++ I would hardly consider working without this on a game if that's my main activity

1563306650
very-mediocre
gamedev is so like the rockstar of the programming world

1563306689
THFKA4
zig dorf fortress when

1563306706
Sahnvour
very-mediocre: and like rockstars it's mostly about the image

1563306730
very-mediocre
maybe so, I genuinely love games though. I've made 4 and released 0.

1563306789
very-mediocre
if i have time in the distant future i'd think about making a zig-godot binding

1563306906
very-mediocre
i am out, i'm absurdly burned out. Thank you all for the discussion.

1563307028
fengb
I'm actually curious what pro game devs think about Zig. The only ones I've spoken to are pretty opinionated like Jon Blow

1563307077
mq32
it really depends

1563307086
mq32
there are the engine guys who really want 150% control

1563307096
mq32
and then there are the guys who only make game logic

1563307102
mq32
they want maximum abstraction

1563307215
THFKA4
i think "ziggurat" would be a pretty sweet name for a zig package repo

1563307220
THFKA4
just wanted to share

1563307239
companion_cube
:D

1563307295
THFKA4
the .dev is only $2400/yr

1563307319
Sahnvour
i'm doing engine and no day goes that I don't wish I could use zig instead of C++ ... and I was really into C++ before that :p

1563307349
fengb
I think everyone now agrees C++ sucks. But they all seem to want that 10%

1563307376
mq32
<= actually likes C++17 a lot

1563307382
mq32
if you just ignore all legacy stuff

1563307434
companion_cube
still not as clean as rust, if you're into that level of complexity 🤷

1563307526
mq32
yeah, but i cannot use Rust for my kind of code

1563307535
mq32
low level embedded with rust is just "working against the language"

1563307701
mq32
i've switched hardware platforms for my next project, so i  first have to compile a new LLVM version to build a custom version of Zig against it in order to use zig

1563307719
mq32
xtensa-elf32 is not supported by the mainline LLVM

1563307925
THFKA4
you doing radar or wifi?

1563308015
tghume
Hey so I'm writing a blog post about ways of doing generics that contains a Zig example. I'm wondering how you'd add methods to a generic data structure.

1563308034
andrewrk
tghume, have a look at std/array_list.zig

1563308036
tghume
The example for methods refers to the struct by name in the self parameter of the method like `self: Vec3`

1563308041
tghume
thanks

1563308072
tghume
ah cool a special Self name like Rust

1563308073
mq32
THFKA4: Playing around with my odroid go and some other ESP32 based boards to

1563308075
tgschultz
tghume: short answer based on that: const Self = @This(); in the struct body, then refer to Self

1563308100
tghume
oh thanks almost missed that line and thought Self was special

1563308146
mq32
really good thing in Zig: IF it isn't a keyword or there's an @ in front of it, it ain't special :)

1563308170
tgschultz
andrewrk: I don't think being able to create types and unions with new fields is so bad. Then again, I did create the pseudo-struct so I'm clearly insane.

1563308263
andrewrk
tgschultz, I think you can think of #2907 as a stepping stone to #383. if anything it gets us closer to that

1563308348
tghume
I was just looking at some example metaprogramming use cases for my blog post and some of them required creating structs with dynamic fields

1563308367
tghume
which in Zig would require the fully-featured reify that can create structs

1563308401
tghume
The main real example I have is replicating Swift for Tensorflow's autodifferentiation feature as a library.

1563308420
tghume
You need to be able to automatically create a struct for the gradient that contains all the differentiable fields of the parent struct.

1563308514
tghume
In Zig if it was complete enough I think it would also allow you to implement the feature where you can import C headers as just a non-privileged library that uses libclang.

1563308556
mq32
just a brainfart: with @reify and @embedFile Zig could have a comptime implementation of protobuf

1563308566
andrewrk
yep

1563308610
mq32
and i think it would be great, no more stupid code generators in build scripts… :)

1563308618
mq32
got to go

1563308657
andrewrk
I think for translate-c it is good to have the translated zig AST be in a file somewhere. it helps for 3 things: 1. compile errors 2. debug info 3. caching

1563308665
andrewrk
the same argument coudl be made for protobuf

1563309213
THFKA4
interesting recent talk from the Rust team, you might have seen it already

1563309263
THFKA4
a framework for incremental compilation. basically a very robust cache that will tell you exactly what to recompute on every change

1563309276
THFKA4
this is the code

1563309898
Tetralux
That sounds... very much like a HashMap...

1563309908
Tetralux
Except in a package by itself NodeJS style...

1563309921
Tetralux
And with a few extra things, I presume.

1563309934
Tetralux
Otherwise that would be unadulteratedly ridiculous.

1563309951
Tetralux
Better be a damn good hashmap XD

