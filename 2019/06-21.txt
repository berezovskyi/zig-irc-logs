1561079006
cameris
‚êò/quit

1561085789
andrewrk
I marked #2602 "ready for review" and put up a merge checklist

1561089418
mikdusan1
in copy-elision-3 building libuserland it fails on what looks like unitialized mem for one of the first hash_map created

1561089424
mikdusan1


1561089456
mikdusan1
isi see commit

1561089481
mikdusan1
for "fix zero length array literal casted to slice" but it seems like the mem is still unutialized

1561089550
andrewrk
oh man if you want to help figure this stuff out I'm super excited about that

1561089630
andrewrk
mikdusan1, the trick is going to be creating a small test case that shows the uninitialized memory problem

1561089639
andrewrk
then the IR can be debugged

1561089642
mikdusan1
gotcha. i'll see if i can dupe.

1561089657
mikdusan1
*reduce

1561089673
andrewrk
I'm currently debugging labeled blocks which I just hooked into the result location mechanism

1561089681
emekankurumeh[m]
zig-reduce?

1561089750
andrewrk
yeah I saw that discussion earlier

1561089765
andrewrk
i've been doing zig-reduce manually repeatedly the last few weeks

1561089802
emekankurumeh[m]
if zig was doing gsoc that would be a good project idea

1561089895
mikdusan1
reduction:

1561090290
andrewrk
amazing, thank you

1561090355
mikdusan1
when you mentioned ir you meant zig ir, not llvm-ir correct?

1561090378
andrewrk
correct

1561090402
andrewrk
I can live code solving this problem if you're interested

1561090418
mikdusan1
oh hell yes. i am having trouble even getting ir to not abort.

1561090424
andrewrk
just a sec

1561090521
mikdusan1
(making cup of coffee)

1561090588
andrewrk
ok I'm ready when you are

1561090631
mikdusan1
back. ready

1561090658
andrewrk


1561090665
andrewrk
let me know when you're ready

1561090710
emekankurumeh[m]
this is a exciting

1561090735
andrewrk
mikdusan1, ping me

1561090756
mikdusan1
ping andrewrk

1561090872
mikdusan1
yup i did those overrides

1561091177
mikdusan1
just so i'm not nutz try `[0]{}`

1561091194
mikdusan1
i mean [0]u32{}

1561091636
mikdusan1
is EndExpr new with the result target stuff?

1561091865
fengb
Should this be a parse error? "return and result.ptr;"

1561091895
fengb
Oh there's a stream, ignore me

1561091993
mikdusan1
maybe

1561093093
mikdusan1
awesome thanks andy.

1561093120
andrewrk
pushed, thanks a lot!

1561093135
andrewrk
I'm gonna go to bed

1561093140
mikdusan1
'night.

1561093205
fengb
Good night!

1561096701
marler8997_
getting a pointer from a windows function callback, but zig won't let me ptrCast it "cast increases pointer alignment"...any suggestions?

1561096817
marler8997_
looks like @intToPtr(*Foo, @ptrToInt(ptr)) works, but I'm sure there's a better way

1561097854
emekankurumeh[m]
have you tried `@alignCast`?

1561100530
marler8997_
looks like that just aligns a pointer

1561100539
marler8997_
need to cast from a *u32 to a *Foo

1561100573
marler8997_


1561100595
marler8997_
that's the callback signature, the 3rd parameter `DWORD_PTR dwInstance` is a pointer to a struct

1561100603
marler8997_
so I need to cast it accordingly

1561101941
mikdusan1
marler8997_: are you doing a 32-bit or 64-bit binary?

1561101962
marler8997_
not sure actually

1561102035
marler8997_
dumpbin tells me x64

1561102035
marler8997_
FILE HEADER VALUES

1561102035
marler8997_
8664 machine (x64)

1561102069
mikdusan1
i'm curious at *u32, did a cimport do that automatically or was that hand-crafted?

1561102104
marler8997_
hand-crafted

1561102111
marler8997_
just matched the windows function definition

1561102129
marler8997_
is there another pointer type I could use that would allow me to cast it to pointers with large align types?

1561102182
mikdusan1
i think the issue is "u32". by default zig assumes you align at 4 bytes for that. if it were u64, then it would be 8 bytes. and that would match Foo which is 8 byte align.

1561102197
marler8997_
it's gotta work on both platforms

1561102209
marler8997_
the pointer is already aligned

1561102209
mikdusan1
right. Foo would be 4-byte on 32-bit platforms.

1561102219
marler8997_
but when I get the pointer back in the callback, zig doesn't know it's aligned

1561102232
marler8997_
so how do you recommend I tell it to skip the alignment check

1561102249
mikdusan1
for giggles change *u32 to *usize

1561102272
marler8997_
you don't know how big Foo is

1561102290
marler8997_
it may or may not have the same alignment as a uszie

1561102317
andrewrk
marler8997, alignment errors more likely point to an actual bug rather than needing to cast

1561102333
marler8997_
it's a windows callback function

1561102339
marler8997_


1561102358
marler8997_
stdcallcc fn midiInputCallback(handle: HMIDIIN, msg: u32,

1561102358
marler8997_
instance: *usize, param1: *u32, param2: *u32) void {

1561102380
marler8997_
woops, that was after I changed it, it should be:

1561102381
marler8997_
stdcallcc fn midiInputCallback(handle: HMIDIIN, msg: u32,

1561102381
marler8997_
instance: *u32, param1: *u32, param2: *u32) void {

1561102408
marler8997_
so `instance` is a just a "pass-through" pointer that gets passed to the function where I set the callback

1561102412
marler8997_
and I get it back in the callback

1561102412
andrewrk
whatever alignment it requires you should fulfill it. it's unlikely you need to do any casting fro that to happen

1561102419
marler8997_
I do fullfull it

1561102428
marler8997_
but once I get the pointer back inside the callback, the type information is gone

1561102436
marler8997_
zig no longer knows where that pointer came from

1561102436
andrewrk
these are user-data parameters? better to make them usize rather than *u32

1561102445
marler8997_
yes, user-data parameters

1561102455
marler8997_
It doesn't matter whether it's usize or u32

1561102464
marler8997_
it's not a pointer to either one

1561102464
andrewrk
so you'll necessarily do ptrToInt / intToPtr and that makes sense

1561102480
andrewrk
I'm suggesting to change the extern fn prototype

1561102483
marler8997_
ok, thought I'd check to make sure that was the right way to go

1561102491
marler8997_
sure, but how does that help?

1561102499
marler8997_
it's not a pointer to a u32 or a usize

1561102507
andrewrk
it is a usize though that's exactly what it is

1561102520
marler8997_
it's a pointer provided by the user

1561102523
marler8997_
it could point to anything

1561102527
andrewrk
it doesn't have to be a pointer

1561102529
marler8997_
In my case it points to a struct

1561102536
marler8997_
correct, it also doesn't have to be a pointer

1561102539
andrewrk
it's a usize

1561102542
marler8997_
so long as it fits in a usize

1561102545
marler8997_
oh right

1561102550
marler8997_
you're saying a usize, not *usize

1561102553
andrewrk
right

1561102558
marler8997_
yes that would work as well

1561102572
andrewrk
and the @ptrToInt / @intToPtr that you'll have to is the simplest thing that makes sense in this case

1561102575
marler8997_
maybe a better solution as it sort of signals to the developer that they really need to know what they are doing

1561102584
andrewrk
and the @intToPtr does the align checks etc

1561102595
marler8997_
cool, thanks for the tip

1561102610
marler8997_
note that at some point I'll probably submit these windows functions to zig std library

1561102617
andrewrk
sounds good

1561107745
tdl7rt
andrewrk: any way to have absolute addresses for variables (like --defsym foo=0x40001000)?

1561112908
gamester
andrewrk: timerfd_create in os/linux.zig returns a usize. Is that correct? It does no error handling so I have to check for -1. In C it returns an int, in the kernel it seems to return a long.

1561113445
gamester
okay I can copy what os.zig's epoll_create1 does

1561115172
ace-_
now this may cut against the grain of the zig language, but im interested in knowing if its possible

1561115192
ace-_
using comptime functions, is it possible to make type providers?

1561115228
ace-_
in the sense the zig compiler at compile time, could read in a file and generate types, or make function calls to some server to generate types

1561115303
ace-_
i would try it myself, ive followed zig a bit in the past, but today is the first day im giving it an actual try

1561115328
ace-_
just sayin', it would blow my mind if the answer is yes

1561115439
ace-_
make network* calls to some server.

1561115443
ace-_
a mistype there

1561118861
ace-_
I suppose not, the docs seem pretty clear on the matter:

1561118863
ace-_


1561118904
ace-_
I tried to implement a simple type provider based on reading an input file, but i get an error as expected:

1561118909
ace-_


1561118951
ace-_
darn. i understand the limitation, but that would be the simplest and slickest way of implementing type providers ive seen in any language

1561119151
ace-_
just for inspiration, here is the json type provider in f#:

1561119209
ace-_
it infers the implicit schema of json given as samples to the compiler at compile time. either as const strings, read in from file, or over the network

1561119236
ace-_
many, many other uses

1561119285
ace-_
idris is the only other somewhat popular language that implements type providers as a first class citizen

1561119348
ace-_
haskell and other languages can fake it by generating files before compile time and then just reading them in, its clunky but it works

1561119443
ace-_
there are type providers for csv files, yaml files, sql servers (grabs the schema over the wire)

1561120206
samtebbs
ace-_: Yeah it doesn't look like something that you could do at compile time dynamically

1561120231
samtebbs
But you could create some external tool that would parse the zig source and transform it before compiling, based on some external resource

1561120246
samtebbs
This may be of interest:

1561120354
ace-_
oh, i was just using the source file itself as a temporary placeholder. the input file would usually be something other than zig code

1561120366
ace-_
ill take a look, thanks

1561120421
ace-_
as i said, if this restriction is removed, this would be the most absolutely simple way imaginable to implement type providers

1561120453
ace-_
but who knows? it might just be better to generate zig code from json

1561120467
ace-_
json/csv/yaml/etc

1561120522
sammich
with the external tool that would be sort of like how protobuf and similar things work no?

1561120719
samtebbs
sammich: I didn't know what that was but have looked into it and I guess so

1561120734
samtebbs
If it had a Zig backend then you could certainly use it

1561120891
ace-_
well, from what i understand protoc has tools built in to generate files for popular languages. this would just actually be a lifting of a restriction in zig.

1561120920
ace-_
the nice thing about the F# type providers, is that it works very well with intellisense and you never have to see the ugly files it generates

1561120940
ace-_
i could imagine it working very similarly in zig, but maybe not

1561121152
ace-_
these types are generated at compiletime it plays very nicely with autocompletion and the only thing that is required to generate these complex types and parsers/serializers for those types are just a sampling of the data

1561121221
ace-_
so you never have to look at the ugly complex types, serializers, and parsers it generates, its all done at compile time and exposed by the compiler to the ide

1561121474
ace-_
and the only thing you would have to write (in a hypothetical future zig) would just look like `const TestMsg = JsonProvider("{ 'id' : 1, 'name' :  }")

1561121484
ace-_
oops

1561121493
ace-_
`const TestMsg = JsonProvider("{ 'id' : 1, 'name' : 'john' }")`

1561121530
ace-_
and that would generate the type definition for the TestMsg struct, and the serializer/parser combo to go to and from json

1561121553
ace-_
i think you can do something very similar to this right now in zig

1561121571
ace-_
but however, you cannot read files or open up a socket to some api server to do the same thing

1561121696
ace-_
so instead of the direct sample in the previous example, you can have a csv provider infer the schema of a csv file and then generate the appropriate struct for the rows and the parser/serializer

1561121775
ace-_
would look something like: `const TestCsv = CsvProvider("./some.csv", "\t")` and in this example, its a tab separated file

1561121816
ace-_
now, this may be a little too magical for some people. but zig's comptime system would make this stuff soooo easy to implement

1561121922
ace-_
and in practice it tends to work quite well, especially in exploratory stages

1561121969
ace-_
and since its all done at compile time, its all type safe and (for the most part) zero overhead compared to hand writing

1561125465
gamester
ace-_: @reify

1561131155
tgschultz
you can read files at compile time using @embedFile

1561131178
tgschultz
you are correct though that you can't connect to a server

1561131209
sammich
@embedFile is a nice feature. its a pretty painful experience to do the same in go

1561131242
andrewrk
tdl7rt, yes, make it a global and use @intToPtr

1561131324
andrewrk
gamester, std.os should gain timerfd API which will do the error checking as well as abstract libc/no libc

1561131412
tralamazza
andrewrk: (tdl7rt was temp nick) but then it becomes a pointer no?

1561131433
andrewrk
what's the difference?

1561131454
tralamazza
just the .*. everywhere

1561131495
tralamazza
it should be called the Zig emoji

1561131540
andrewrk
there is another way. you can put the variable in its own section and then in the linker script put that section at whatever address you want

1561131571
tralamazza
yah that's what i meant by section trickery ;)

1561131587
tralamazza
it's fine, just asking because some compilers have that feature

1561131641
andrewrk
I personally would do the pointer thing

1561131773
mmx87
andrewrk, what's your opinion on something like editions ala Rust? Do you know about them?

1561131970
tralamazza
zig build works yay

1561132063
halosghost
:D

1561132349
scientes
hmm, why can't i break on a line number in a zig file

1561132352
scientes
in a zig test

1561132376
scientes
oh I see, its cause i'm using zig test

1561132387
scientes
debugging the wrong binary

1561132588
andrewrk
scientes, you can use --output-dir . to get a predictable binary location

1561132618
tralamazza
in build.zig: exe.setOutputDir(".");

1561132626
andrewrk
mmx87, here's the closest issue open related to that:

1561132650
andrewrk
it's an old issue so take whatever I wrote there skeptically

1561132685
andrewrk
this issue is on my mind but I won't have a formal proposal until closer to 1.0

1561133189
mmx87
Ah, I see, thanks. I think the editions in Rust were a quite good idea and the "versioned" approach to managing multiple versions of a language is quite a good idea to keep the language modern without breaking backwards compatibility.

1561134267
andrewrk
one difference is that I think rust is still open to adding new features to the language (correct me if I'm wrong) but I do envision Zig being "done" at some point

1561134305
andrewrk
of course there will still be work to do such as keeping up with LLVM versions and adding new targets and intrinsics

1561134400
tralamazza
how do you usually debug zig? gdb?

1561134411
andrewrk
yes

1561134423
tralamazza
is lldb a thing?

1561134425
andrewrk
yes

1561134427
andrewrk
and msvc

1561134435
andrewrk
I use lldb on macos, msvc on windows

1561134448
tralamazza
can you have zig expressions inside the debugger?

1561134458
andrewrk
you can have c expressions, which are nearly the same

1561134496
andrewrk
I filed a request to have zig added to gdb but nobody has acted on it yet

1561134505
andrewrk
we need to harass them more

1561134536
tralamazza
i'm using gdb, but if lldb allows me to have zig in it (and it works ofc), i'd switch

1561134603
andrewrk
this is a feature request of lldb/gdb. unlikely to happen until zig becomes much more mainstream

1561134643
andrewrk
c expressions in the debugger are quite close to zig expressions though. gdb/lldb don't care about the difference between . and -> for example

1561134674
andrewrk
gonna close IRC and make more progress on copy elision branch

1561134682
companion_cube
is the syntax already more or less 1.0 in your mind?

1561134829
scientes
companion_cube, parts have stabilized IMHO

1561134832
scientes
but not all of it

1561134863
mmx87
Yeah, I think they're quite open to adding new features. For it to work to be "done" Zig would need to be reasonably flexible to be wrapped for the future. Can that even be realistically done? Let's take async, coroutines or closures as an example. It was quite late when languages implemented it because they saw the value in them at some point and

1561134863
mmx87
only after they were "battle-tested" out by new programming languages. For example closures are quite new in C++. I know they could have been implemented if they language would have been more flexible from the start. But what if I'd like to implement a feature tomorrow that would simplify my code a lot and that relies on something that doesn't exis

1561134863
mmx87
t in Zig?

1561134880
mmx87
*many mainstream languages implemented them

1561134981
companion_cube
it's pretty interesting that rust is implementing async/generators

1561135091
mmx87
I think that's one of the pain points in C, that there's really no way to implement portable coroutines. Though Rust is also kinda in a strange spot because they decided to panic or abort on OOM, instead of returning a result.

1561135159
tralamazza
no portable way? what about that duff's device thingimabob?

1561135171
mmx87
They're currently implementing or have implemented an allocator trait, but the issue with that is that the community who writes new data structures usually implements them by panicking on OOM. It's more of a culture issue than of a language issue though, and I'd imagine that it can't be simply changed.

1561135184
mmx87
tralamazza, that's portable but comes with restrictions.

1561135196
tralamazza
like?

1561135205
mmx87
No local variables and no nested switch usually if you don't rely on computed gotos.

1561135224
tralamazza
yah, use the context thing for local vars

1561135245
tralamazza
nested switches, sure, kinda feel like an edge case though

1561135270
mmx87
Also, they're not really that stackable. How would you do multiple layers? Like if I have a function that yields but calls another function that wants to yield.

1561135273
mmx87
How would you do that?

1561135294
tralamazza
protothreads! that was the name

1561135296
tralamazza
was it?

1561135330
mmx87
Yeah

1561135335
tralamazza
sorry i dont understand your questin

1561135338
tralamazza
question*

1561135695
mmx87
OK, imagine you write a function that downloads a file over HTTP. Now you could yield from that function, but imagine you have another function which handles HTTP connections and that one would yield to remain responsive. I don't think there's an elegant way to solve that in C, without assuming many details about the target architecture. It might b

1561135695
mmx87
e have been quite simple if C would provide a way to save and restore a stack, but last time I checked there's no such way in standard C, maybe because C doesn't assume that a stack is used to implement local variables (just a hypothesis, I'm not sure if they assume the existence of a stack).

1561135729
mmx87
(I think they wouldn't even need to assume the existence of a stack to implement a primitive who "saves the current context.")

1561135951
tralamazza
yup still lost, i spend my days in the low level =P sorry

1561137736
andrewrk
hryx, I hadn't noticed the way you wrote this code before, that's beautiful :)

1561137757
andrewrk
I haven't seen that chaining done before, it looks good

1561137794
andrewrk
I noticed because it broke in the copy elision branch so I'm fixing that now, so also thanks for the test case

1561137827
andrewrk
regarding the coroutines discussion above, zig's coroutines are changing to be nothing more than language-supported syntax for Continuation Passing Style

1561137845
scientes
oh yeah that is cool

1561137848
andrewrk
it's more of a general purpose tool than than people usually think of with the word "coroutines"

1561137851
scientes
|| || ||

1561137888
scientes
andrewrk, how does that differ from longjmp()/setjmp()?

1561137888
andrewrk
the rewrite will remove the tight coupling of coroutines with allocators

1561137927
scientes
that sounds like a good idea

1561137943
companion_cube
mmx87: rust stdlib does fail on OOM, but if you use no-stdlib I think it's your choice

1561137950
scientes
like most of zig, separating out the allocation

1561137959
companion_cube
I think for most user land applications, failing is the simplest thing to do

1561137975
companion_cube
(who wants to check for errors every time they `vec.push(x)`‚Ä¶)

1561137977
scientes
companion_cube, its still difficult, andrew has talked about his before

1561137978
andrewrk
longjmp/setjmp save registers and do some processor magic. CPS style is basically a state machine function with the local variables passed in via a struct parameter

1561138009
tralamazza
composing state machines, that's a pain

1561138024
andrewrk
right, but with language-supported syntax, it becomes pretty painless

1561138028
scientes
andrewrk, can you still have normal local variables, like this:

1561138040
companion_cube
also makes it possible to implement recursive algorithms reliably!

1561138048
scientes
on the co-routine stack

1561138052
andrewrk
the main problem with failing on allocation is when

1561138056
scientes
(which is now explicitely passed around)

1561138062
scientes
but I guess could now be null

1561138065
andrewrk
or if you just have an application which wants to do something different

1561138071
scientes
(and the compiler could even check that it doesn't use stack in that case!)

1561138090
andrewrk
zig is intended to be able to make libraries that have maximum code reuse and best possible behavior / performance

1561138113
scientes
it is already succeeding massively at that (on a prototype basis)

1561138126
tralamazza
I am here for the explicit nature of the language

1561138147
andrewrk
scientes, call it a "frame" rather than "stack" because "stack" implies multiple frames

1561138173
scientes
andrewrk, oh yes, you never have more than one frame when switching co-routines

1561138176
mmx87
>mmx87: rust stdlib does fail on OOM, but if you use no-stdlib I think it's your choice

1561138176
mmx87
Yeah, I know. But it has more to do that there are quite a lot of good data structures which panic on OOM. It doesn't make sense to basically limit their scope of usability.

1561138193
mmx87
The problem is more that Rust is also intended to be a system programming language.

1561138208
mmx87
Imagine you work on a RTOS and you want to use these sleek data structures.

1561138210
companion_cube
in which case you'll probably rewrite your own libs, I think

1561138221
andrewrk
right - but in zig you wouldn't have to do that

1561138223
companion_cube
(which is what you'd do in C anyway)

1561138232
scientes
mmx87, not really, you just can't continue on OOM

1561138249
andrewrk
and importantly - zig libraries will also be usable and you won't have to rewrite those either

1561138251
scientes
so you have to unwind and try again with differn't settings

1561138256
scientes
git fails miserably at this

1561138286
companion_cube
(tbh I'm on an OS where OOM doesn't exist at all)

1561138287
andrewrk
without overcommit, OOM is quite a recoverable error, when APIs are designed with failure in mind

1561138300
mmx87
But that's bad engineering IMO. There are some cases where you should write your own, but having battle-tested general data structures is a good thing. I'd imagine many errors in C are related to that in C the programmer implements all the data structures from sratch.

1561138317
scientes
and linux should be able to send a SIGBUS instead of killing when you writing to a overcommit page

1561138349
scientes
however the program's next syscall would have to be a munmap or it would be killed

1561138372
scientes
yeah that still might be hard to do....

1561138374
andrewrk
perhaps, but as an application developer it would be incredibly difficult to manage failure in that way. the time you need to know if it worked or not is when you ask for the memory

1561138394
mmx87
I think that's one of the advantages that Zig has over Rust currently. It doesn't have the cultural baggage of Rust where most people are fine with panicking on OOM.

1561138437
scientes
andrewrk, depends, it would give you the address of the fault, and it could be handled, but certainly a non-trivial problem

1561138442
mmx87
Otherwise it's a pretty well-designed language overall.

1561138444
andrewrk
I agree that cultural norms are important. Here it is "sure we have bugs, but they're all fixable by design" vs "some bugs we will never be able to fix"

1561138445
companion_cube
for most applications I still don't see what you could do.

1561138448
tralamazza
rust needs a rewrite, smaller (again), call it redox

1561138451
companion_cube
like in ripgrep, what to do in case of OOM?

1561138469
andrewrk
in zig culture, bugs are human mistakes, not design limitations

1561138476
mmx87
No, imagine Libreoffice or something like that, even normal programs should often be able to handle OOMs.

1561138492
scientes
companion_cube, regular expression have O(1) memory usage

1561138499
mmx87
Imagine you just crash and don't save the document. If an error is returned you might be able to save the document before exiting.

1561138510
mmx87
That's a reasonable thing to do IMO.

1561138517
companion_cube
depends how you implement them, and you need to keep the captured groups sometimes

1561138522
scientes
companion_cube, that is why they are called regular

1561138533
companion_cube
mmx87: that's the wrong design, you should have a log as in a DB if you want to be resilient

1561138539
companion_cube
no one uses actual regular expressions

1561138543
scientes
companion_cube, you can just store pointers, and let the data page out

1561138544
andrewrk
failure matters when there is more than one operation happening, and failure in one operation should not affect failure in another one

1561138555
andrewrk
*recovering from failure matters

1561138557
scientes
companion_cube, yes they do, that is exactly why RE2 was written

1561138565
scientes
and hyperscan

1561138582
companion_cube
really? so they don't have capture groups or similar things? :o

1561138582
andrewrk
for example in a web server, you would not want to crash on OOM. you would want to fail a single request with "500: internal server error" and then complete the other requests successfully

1561138598
scientes
companion_cube, you can store pointers to the start and end of the capture group, its still O(1) memory

1561138622
companion_cube
that implies you have the string in memory though.

1561138631
scientes
companion_cube, or offsets into a file

1561138632
andrewrk
well O(N) where N is how many capture groups you have. but that can probably be statically limited to 100 or something

1561138633
tralamazza
overcommit is shifting the problem around afaict

1561138634
scientes
its the same as a pointer

1561138653
scientes
tralamazza, its deferring the problem, which makes sense in some cases

1561138658
scientes
just like a gc

1561138678
andrewrk
overcommit is a step away from a real time capable system

1561138686
scientes
andrewrk, its O(1) for a single regexp

1561138696
scientes
but its O(n^2) to the length of the regexp

1561138712
mmx87
>mmx87: that's the wrong design, you should have a log as in a DB if you want to be resilient

1561138712
mmx87
Even if you save it periodically I don't think that it's just fine to crash on OOM. The right behaviour is the leave the choice to the programmer on what to do on OOM. Everything else is just limiting the usability of a programming language.

1561138722
scientes
but that O(1) is the definition of regular languages, as defined by Noam Chomsky

1561138759
scientes
O(1) time and space, a finite-state-automata

1561138764
companion_cube
I mean checking a regex against a string is O(n) and constant space‚Ä¶ once you've built the automaton

1561138766
mmx87
I think one of the issues with overcommit has also to do that programmers just write their programs with the assumption that it gets killed anyways under Linux when an OOM occurs.

1561138773
mmx87
Which is quite dangerous.

1561138773
andrewrk
btw I had a memory bug yesterday while debugging code and it used all my memory and entire system froze. had to hard reboot. that's a horrible design, it should have only killed the runaway process

1561138778
scientes
oh yes O(n) time, my bad

1561138779
companion_cube
(which can explode during removal of non determinism)

1561138787
andrewrk
oom killer doesn't even work

1561138799
scientes
yeah oom killer blows

1561138828
companion_cube
I'm using one in userland because of that, yeah

1561138869
andrewrk
alright let's see what lovely regression is next for me in this branch...

1561138879
mmx87
andrewrk, I think the issue under Linux is with the OOM that when the OOM killer gets activated too late when everything is swapping already and then it feels like a "freeze." That's really bad design, one of the annoying things on Linux that it optimistically overcommits.

1561138909
companion_cube
(btw rust has some issues open to turn OOM into panics, which are per-thread and recoverable)

1561138917
tralamazza
maybe it's the mental model programmers have of a computer. closer to the metal, memory is very much finite, allocation is something that may happen. in lisp-land, everything is infinite machine

1561138942
tralamazza
so for me overcommit is bonkers

1561138987
mmx87
Yeah, I know. But they go into the territory why Rust doesn't use exceptions as error handling mechanism. Maybe it's the right thing to do for OOMs, but I feel it makes everything less transparent for the programmer.

1561139007
companion_cube
well OOM is a pretty exceptional condition

1561139014
mmx87
Doing something like unwrap isn't really that much effort.

1561139021
companion_cube
(unless you target microcontrollers, but then just don't try to use fancy libs)

1561139033
tralamazza
exceptions open the flow control can of worms

1561139099
fu5ha
hi! So I'm trying to use cglm (

1561139115
fu5ha
since the function is expecting a c pointer but is receiving a pointer to an array of floats

1561139129
fu5ha
i.e.: main.zig:8:42: error: expected type '[*c]f32', found '*[3]f32'

1561139146
fu5ha
anyone know if there's an ergonomic way to make the compiler happy here?

1561139163
andrewrk
mmx87, I have swap disabled and 8 GiB RAM

1561139223
andrewrk
fu5ha, hmm that certainly looks like a bug - missing implicit cast

1561139251
mmx87
I wish they would solve that problem realistically. But as it's mostly used on servers I'm not sure if they care that much. You can usually start the OOM manually with the sysrq sequence when you have it enabled. Never failed me.

1561139289
andrewrk
fu5ha, I don't see an issue, I'm going to open one for you

1561139300
fu5ha
andrewrk, ah, thought it seemed like it should be able to implicitly cast. What would I do to explicitly cast it here properly? And thanks!

1561139304
andrewrk
is this master branch btw?

1561139313
companion_cube
on a server you probably want to die and be restarted by systemd

1561139321
andrewrk
fu5ha, you can workaround with

1561139353
fu5ha
andrewrk, it's latest version from homebrew

1561139476
andrewrk
fu5ha, thanks. here's an issue you can subscribe to:

1561139507
fu5ha
awesome thanks!

1561139507
andrewrk
this is a "contributor friendly" issue - should be reasonably straightforward to look at other examples of casts and add this one

1561139520
fu5ha
Cool, I'll take a look and see if I can figure it out :)

1561139533
andrewrk
no pressure, of course. I'll try to make sure it's done in this release cycle

1561139603
gamester
noice, I've been using ptr casts for that

1561140200
fu5ha
I have this function

1561140223
fu5ha
seems like that function should be able to be comptime-evaluated to me?

1561141916
fu5ha
andrewrk, any chance you could point me to the relevant area of the code where the implicit casts are/should be implemented?

1561142782
fu5ha
also as far as the comptime thing, I figured it out

1561142790
fu5ha
just needed to figure out where to put the comptime keyword :p

1561143049
scientes
i'd like to make it an annonymous enum

1561143051
scientes
.comptime

1561143076
scientes
instead of a reserved word

1561143101
scientes
.volatile too

1561143381
fu5ha
think i might have found another bug x)

1561143434
andrewrk
It might be possible to improve zig so that when using a comptime var, any expression which uses it is implicitly evaluated in a comptime context

1561143434
scientes
not that difficult right now

1561143451
fu5ha
so when trying to cImport cglm, I get this error:

1561143461
fu5ha
no idea where the `pub const m = 4;` is coming from though

1561143516
andrewrk
Looks like a translate-c issue where it's not dealing with name collisions

1561143577
Tetralux
>  when using a comptime var, any expression which uses it is implicitly evaluated in a comptime context

1561143581
Tetralux
That does seem useful.

1561143625
andrewrk
Really the only difference in a comptime context is that function calls are invoked

1561143756
Tetralux
Meaning, using a comptime var in a func call doesn't work, unless you mark the call as comptime?

1561143792
Tetralux
In which case yeah, unless I'm missing something interesting, you prob always would want that call to be comptime too eh.

1561143952
fu5ha
also andrewrk, for the implicit-cast thing from earlier, someone on discord had the idea of doing array[0..].ptr, which also seems to work as a workaround for now and is less ugly than using @ptrCast everywhere :)

1561144031
andrewrk
That's a little better but it's still a workaround. The issue will be fixex

1561144037
andrewrk
*fixed

1561144049
fu5ha
indeed ^_^

1561145628
fu5ha
is there a way for me to use cglm directly as a C lib rather than using translate-c for now?

1561145755
andrewrk
fu5ha, you can do an offline translate-c and then patch up the output zig code and commit that to your repo

1561145768
fu5ha
ah, that's a good idea

1561145774
andrewrk
e.g. you can just copy that file that it listed in the compile error

1561145799
fu5ha
right

1561145799
andrewrk
someday that workaround won't be necessary, but there are a lot of TODOs in translate-c today

1561145807
fu5ha
:thumbsup:

1561151446
fu5ha
if I made a type like `const vec2 = [2]f32;` then how can I express a that an argument to a function should be a constant of this type? I tried `fn blah(a: const vec2)` and `fn blah(const a: vec2)` but neither compile

1561151527
emekankurumeh[m]
all arrays are const unless stored as a var

1561151569
emekankurumeh[m]
i.e. [2]const f32 is invalid

1561152987
mikdusan1
is it possible due to aliasing, that zig statements might eventually get re-ordered?

1561153014
daurnimator
mikdusan1: could you rephrase the question?

1561153085
mikdusan1
in ArenaAllocator.deinit() there is `it = node.next;` and next stmt `self.child_allocator.free(node.data);` frees node

1561153109
mikdusan1
i'm trying to debug something on copy-elision-3 and for the life of me cannot figure out why `it = node.next` is segfaulting.

1561153131
mikdusan1
currently following hint: if i disable the free, i can actually build zig.exe

1561153320
mikdusan1
i can provide a reduction. one sec.

1561153552
mikdusan1
reduced:

1561153612
mikdusan1
basically alloc anything on arena and deinit segfaults

1561153867
emekankurumeh[m]
can you try deiniting manually without the defer?

1561153922
mikdusan1
emekankurumeh[m]: still faults

1561153923
emekankurumeh[m]
nvm

1561154274
scientes
do enums have any guaranteed order?

1561154310
scientes
because they shouldn't

1561155081
Tetralux
you mean the order that they are listed in the typeinfo I'm guessing

1561155465
scientes
the order they are in the source file

1561155476
scientes
in C this is defined and aplications depend on it

1561155759
andrewrk
a decent chunk of std lib tests passing in result loc branch :)

1561155807
andrewrk
mikdusan1, aliasing / moving memory loads/stores around is not something that happens in debug builds

1561155828
andrewrk
I was about to look at that arena allocator test failure, do you have any clues so far?

1561155855
andrewrk
ah you have a reduction, taking a look

1561155868
mikdusan1
yes just force arena to deinit at least 1 allocation

1561155873
andrewrk
I'm going to try to reduce it further

1561155897
andrewrk
it's probably invalid llvm ir code generated

1561155931
andrewrk
I mean, valid llvm ir but something incorrect, like not initializing a variable

1561155976
andrewrk
scientes, I think that's worth discussing in a proposal

1561156000
andrewrk
I think that is not yet stabilized as far as language spec goes. the stage1 compiler will do them in order

1561156030
scientes
yeah better than a specification is just to have debug mode make them random

1561156048
andrewrk
right - debug mode would do that if we decided in the lang spec that the order is not defined

1561156060
andrewrk
so the first step is figuring out how it's supposed to work

1561156083
andrewrk
there is no lang spec yet, but I mean, making a decision to eventually write down in the spec

1561156161
scientes
Its also hard to support enums as flags (which people do in C) without adding ugly footgun UB

1561156182
andrewrk
mikdusan1,  a hint is that this is a regression. it works in master and it should probably work exactly the same way. so if you can observe a difference between master and this branch that can narrow in on the issue

1561156191
scientes
or too much semantic analysis

1561156215
andrewrk
enums as flags doesn't make sense to me, it's not the correct type

1561156250
andrewrk
packed struct with u1's would make more sense to me. if we had the struct equivalent of enum literals that would be reasonable I think

1561156252
scientes
yeah you can just do a struct with some bits reserved

1561156257
andrewrk
yeah and we have defaults now

1561156283
scientes
and specific enum values

1561156284
andrewrk
then you @bitCast it to a u32 or whatever. in theory it should generate the same code

1561156296
scientes
or union it to u32

1561156355
tgschultz
but can you or the structs together?

1561156374
scientes
a struct inside a union

1561156388
tgschultz
an extern union you mean

1561156392
scientes
yes

1561156470
tgschultz
still wouldn't allow `const x = A|B|C|D;` though, you may as well just use consts.

1561156502
scientes
oh yes

1561156517
scientes
@enumToInt() | cnst

1561156532
scientes
translate-c needs this

1561156559
scientes
ability to lower enums to ints

1561156631
tgschultz
I suppose one could just implement that as a member func, and it could look like this: `const x = Bitfields.combine(.A,.B,.C,.D);` `if(bitfields.has(.C)) @panic();`

1561156733
tgschultz
also allowing distinct int types would make it kind of a non-issue too.

1561156774
andrewrk
yeah distinct int types would better model the code than enums

1561156789
andrewrk
I think that bugs with flags are pretty rare though

1561156797
andrewrk
I'm not sure even anything needs to be done

1561156806
mikdusan1
andrewrk: ok, i have enough to keep going myself on this; new hint `it = node.next` actually

1561156838
andrewrk
mikdusan1, nice, ok I'll look for a different bug to work on then

1561157078
Sahnvour
just a thought: pure random enum values makes for non deterministic builds, and also hinders the ability to do incremental recompilation

1561157118
andrewrk
debug builds are allowed to be nondeterministic but the other ones are deterministic

1561157136
andrewrk
precisely to help with incremental recompilation

1561157198
Sahnvour
does release-safe count for debug in this case ?

1561157208
andrewrk
no, that one is required to be deterministic

1561157237
andrewrk
debug mode is the only one optimized for compilation speed

1561157254
Tetralux
> "debug builds are allowed to be nondeterministic"

1561157256
Tetralux
That doesn't sound very good.

1561157267
fu5ha
so how would i go about modifying an array that is a member variable of a struct

1561157271
Sahnvour
feels weird to have debug builds, partly intended for automatic testing, being non deterministic

1561157276
Tetralux
Surely if you're debugging, you want anything

1561157279
fu5ha
like struct { pub a: [2]f32; }

1561157360
andrewrk
Tetralux, Sahnvour - I can see how that could be an issue

1561157387
Sahnvour
I'm not sure you're implying that, but I doubt we have to sacrifice determinism for speed of compilation

1561157418
andrewrk
consider incremental linking: the idea is to leave extra space in case functions grow or shrink

1561157428
andrewrk
this is a form of nondeterminism

1561157438
andrewrk
msvc linker does this

1561157464
andrewrk
likewise you could leave extra space in structs in case fields are added or removed

1561157481
andrewrk
this is also how hot code swapping would work - it's necessarily nondeterministic

1561157532
Sahnvour
I think for incremental linking it generates functions that are just proxies with a call instruction that gets patched, but I get your point

1561157549
Sahnvour
however you can still disable it if you want to stay deterministic in this case

1561157564
andrewrk
yeah I think that use case is valid - you have a bug and you want to reproduce it in debug mode

1561157601
andrewrk
I think it might just be all fine if "randomness" is deterministicly seeded

1561157620
Sahnvour
yes, this is totally acceptable

1561157633
andrewrk
yeah that's the plan

1561157671
Sahnvour
good then, if you can at least get/set the seed, everything is reproducible

1561157687
Tetralux
Personally, I'd be fairly strongly inclined to not have any randomness anywhere near my builds xD

1561157689
emekankurumeh[m]
sort of like fuzzing, but built into the compiler?

1561157741
emekankurumeh[m]
fu5ha have you tried assigning an instance of the struct and modifying that?

1561157839
andrewrk
Sahnvour, except if you were to, e.g. make a function much bigger and then make it smaller again, you'd get a different build than before

1561157878
Sahnvour
assuming there is some pseudo randomness in the compilation, this probably means you need to have the whole test suite run two times, one with a fixed seed, and one with a new seed at every run

1561157911
andrewrk
why's that?

1561157919
fu5ha
@emekankurmeh[m], yes, this is within a method, i.e. something like this

1561157942
fu5ha
'method'

1561157956
Sahnvour
because otherwise it could happen that previously undiscovered bug pop up on totally irrelevant changes for example

1561157994
andrewrk
ah I see. yeah I see emekankurumeh[m]'s point now, it's a lot like fuzzing

1561157999
Sahnvour
having a static baseline helps you identify where it comes from

1561158011
andrewrk
the baseline would be a clean build

1561158039
andrewrk
it's more to do with the fact that debug builds are stateful in order to go faster

1561158077
Tetralux
Is there a switch to make everything from scratch?

1561158087
Tetralux
Also I'm not sure they

1561158091
andrewrk
Tetralux, we're talking about vaporware - zig does not do any of this stuff yet

1561158104
andrewrk
zig master branch builds are stateless in all modes

1561158114
Tetralux
Okay gotcha xD

1561158134
andrewrk
Tetralux, that's true. maybe stateless can be an option. (it would always be on for non-debug builds)

1561158140
Sahnvour
in my previous job we had automatic tests that had non deterministic failures, and it was a pain in the arse :D

1561158151
andrewrk
noted

1561158190
andrewrk
I think this might be worth writing up in an issue. I hadn't considered that "stateless vs stateful builds" were different concepts than caching

1561158201
andrewrk
because you can still do some caching with stateless builds

1561158215
andrewrk
but stateful builds let you aggressively cache more

1561158252
Sahnvour
can you give an example of what you think of by stateful/less during compilation ?

1561158288
andrewrk
stateless would mean that if you have the same input you get the same output. deterministic. LLD does that kind of linking

1561158357
andrewrk
stateful would keep track of struct padding, existing executable section sizes & space for functions to grow and shrink, so that less work would have to be redone on subsequent builds

1561158366
Sahnvour
ok, so state that outlives the compilation process, typically zig-cache ?

1561158391
andrewrk
zig-cache as it stands is "stateless"

1561158407
andrewrk
because we do the cache hash stuff to find out if the output would be different

1561158435
andrewrk
but yes stateful would be state that outlives the compilation process, and also affects the output of subsequent builds

1561158527
Sahnvour
right, so I feel like [non-]deterministic would be a better fit, since caching data structures to speed-up does not necessarily introduce a difference in the output. but I understand

1561158547
andrewrk
that makes sense, and I agree that's a better word for it

1561158589
andrewrk
this is documented btw:

1561158612
fu5ha
I feel like I'm either missing something simple or am trying to go down a path that is impossible, but is there a way to make something like this work `for (self.a[0..2]) |v, i| v += o.a[i]` where self.a is a `[2]f32`?

1561158636
andrewrk
fu5ha, you're trying to modify the element yes?

1561158639
fu5ha
yep

1561158644
Sahnvour
fu5ha: try *v to modify the elements

1561158658
Tetralux
|v*, i|

1561158664
Tetralux
*v

1561158677
andrewrk


1561158724
andrewrk
variable bindings are like parameters by default: they might be a reference or a value but they act like a value

1561158756
fu5ha
doesnt work because I still get a `*const f32`

1561158757
fu5ha
er wait

1561158760
fu5ha
maybe I need to not slice it

1561158765
Sahnvour
andrewrk: indeed, I remember reading this now. I'd still like to insist one last time that whenever determinism can be preserved, we should strive for it :)

1561158791
andrewrk
Sahnvour, thanks, I'll write up an issue for this at some point, I think you have raised some important points here

1561158804
Tetralux
+1

1561158815
andrewrk
feel free to start the issue if I don't get to it soon

1561158846
andrewrk
fu5ha, your `self` pointer is probably const. which means self.a is const. which means v is const

1561158875
fu5ha
ah. so I guess I can 'rebind' self as var?

1561158955
andrewrk
fu5ha, I found your code link above.         pub inline fn plus_ip(self: Vec2(T), o: *Vec2(T)) Vec2(T) {

1561158964
andrewrk
this will let you mutate `o`

1561158976
fu5ha
aha, ok

1561158979
fu5ha
thanks :D

1561158987
andrewrk
btw you should delete all those inlines probably

1561159020
andrewrk
if you're doing it for perf reasons, you are actually tying the optimizer's hands down by doing that

1561159032
andrewrk
trust the optimizer's inliner, it's really good

1561159086
andrewrk
maybe I should rename that keyword to `forceinline` so that people think twice

1561159101
andrewrk
everyone will come to the issue tracker to complain about it, and discover the docs for why they don't need it

1561159133
Tetralux
and everyone will use it anyway because they won't trust the optimizer xD

1561159177
andrewrk
inline is the programmer's good luck charm

1561159229
fu5ha
Haha ok, will do :)

1561159246
Tetralux
andrewrk, I think it's because in C, it's just a hint, and people want determinism... and because funcs that are two lines long seem good to inline.

1561159254
Tetralux


1561159529
emekankurumeh[m]
does zig always pass by reference for function arguments?

1561159554
andrewrk


1561159607
AlexMax
I've actually had to forceinline code somewhat recently.

1561159636
andrewrk
AlexMax, interesting, what for?

1561159672
AlexMax
I'm looking it up, maybe I got rid of it...

1561159757
AlexMax
that's bizarre, I could've sworn at some point I had some bitmap blitting code that had some inline bits

1561159791
AlexMax
oh well, guess not...

1561159821
AlexMax
only things I have left in this tree are vector struct "constructors"

1561159826
Tetralux
Zig doesn't have noinline does it?

1561159835
AlexMax
and I merely inline them, not force them

1561159856
Sahnvour
Tetralux: there is @noInlineCall

1561159869
Tetralux


1561159875
Tetralux
Is there... @inlineCall...

1561159882
andrewrk


1561159891
Sahnvour
yup, there is

1561159909
andrewrk
all the builtin functions are documented:

1561159934
AlexMax
however, I have noodled around with doom source ports, and I do see forceinline used quite a bit

1561159957
AlexMax


1561159958
Tetralux
Sahnvour, EXCELLENT.

1561159978
Tetralux
andrewrk, Also yes - fair point xP

1561159979
AlexMax
16 hits for __forceinline in one source file

1561159982
andrewrk
AlexMax, doom came out in 1993. compilers have come a long way since then

1561159993
AlexMax
andrewrk: This is a modern port that has active maintainers

1561160000
andrewrk
ah

1561160030
AlexMax
I also see two functions that contain inline assembly

1561160031
andrewrk
well fair enough. if you bench the perf and then try inline and it improves something, fine

1561160062
Sahnvour
andrewrk: something to mention in the determinism issue just occurred to me: there's a higher level of determinism that is highly desirable (and more involved), execution determinism. Not only the output is exactly the same, but the compiler does the exact same trace. Really useful for debugging.

1561160098
andrewrk
Sahnvour, I agree - it would be difficult to debug issues with multithreading on

1561160172
Sahnvour
re __forceinline: nowadays that's mostly cargo cult I guess

1561160180
fengb
Does doom really need optimization? Are they running it on a toaster?

1561160224
Tetralux
The classic response: "You'd be surprised."

1561160246
AlexMax
fengb: Doom's software renderer is

1561160287
Tetralux
Plus, you'd probably do that even if that wasn't the case. Gotta meet them 7ms time quotas man

1561160306
AlexMax
There's also some overdraw done for sprites and two-sided transparent walls.

1561160326
fengb
It makes sense in 1992... but the engine been extended in ways that require more handtuning?

1561160334
AlexMax
At 320x240, it's fine.  At HD resolutions, you start running into trouble even on somewhat modern systems.

1561160343
fengb
Then again, I hand tune a bunch of really silly things so who am I to judge

1561160347
fengb
Ah

1561160462
fengb
Serious question: how does C do struct padding? I can create a "struct { uint32_t foo:8 }" and it comes out to be 4 bytes. Where do the 24 extra bits go?

1561160534
Sahnvour
is it because of uint32_t's required alignment of 4 ?

1561160569
fengb
Seems like it. But I can't find a reference in the spec

1561160586
fengb
"An implementation may allocate any addressable storage unit large enough to hold a bit- field. (and later) There may be unnamed padding at the end of a structure or union."

1561160592
fengb
Yay undefined behavior...

1561160642
AlexMax
fengb:

1561160703
AlexMax
Sunder MAP10: The Hag's Finger.  39fps at 1920x1200.  If I turn around, I get into the hundreds.

1561160767
fengb
And __forceinline means really inline, unlike the inline keyword?

1561160823
AlexMax
Correct.  inline is merely a suggestion.  Do modern C compilers even pay attention to `inline`?

1561161292
xcko
just built zig 0.4.0 on aarch64 alpine 3.10 (musl libc) and I can't replicate

