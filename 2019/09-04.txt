1567555379
andrewrk
curtisf, nice! that's an important abstraction

1567555401
andrewrk
Aransentin, neat, I'm following the project now

1567555611
Aransentin
Thanks! :)  Ideally I'd want it to log stuff like DNS/HTTP/TLS SNI etc. and then dump a big pcap when something suspicious happens

1567555660
Aransentin
I think it's pretty neat that with comptime I can have the program configuration as a zig file itself, and then streamline large parts of the program if the user doesn't need e.g. IPv6

1567555729
andrewrk
:)

1567555806
curtisf
Is there a way to compile a zig file (tests and all), but not actually run it, for the purpose of getting compiler errors? I've been thinking about hacking together something for the vscode plugin in advance of having a proper language server

1567555903
andrewrk
curtisf, zig test foo.zig --test-cmd true

1567555914
andrewrk
this calls /usr/bin/true instead of the test binary

1567555948
andrewrk
to reference a function without calling it: comptime {  _ = func; }

1567555957
andrewrk
this will cause it to be analyzed

1567555961
andrewrk
if it's not covered by a test

1567556204
curtisf
perfect, thanks

1567556395
marler8997_1
truncate doesn't seem to allow signed/unsigned conversion

1567556427
marler8997_1
so how would I convert between signed/unsigned and make sure any overflow is detected in releaseFast?

1567556469
andrewrk
@intCast is how you convert integers, preserving the mathematical numerical value

1567556490
andrewrk
if you want safety on in release fast mode, use @setRuntimeSafety.

1567556499
marler8997_1
but overflow isn't detected with intCast in releaseFast

1567556525
andrewrk
release fast turns off overflow detection. that's what you're asking for. if you want safety on in a particular scope, however, use @setRuntimeSafety

1567556525
marler8997_1
I want my code to detect overflow whether or not it is compiled with releaseFast

1567556561
andrewrk
if you want to detect overflow globally, then you don't want release fast. you want release safe

1567556567
marler8997_1
you're saying that's not possible?

1567556599
marler8997_1
if truncate supported conversion between signed and unsigned then it would be possible

1567556634
andrewrk
are you looking for std.math.cast?

1567556646
marler8997_1
checking...

1567556709
marler8997_1
that has the same problem

1567556716
marler8997_1
overflow isn't detected with releaseFast

1567556734
marler8997_1
wait...maybe...

1567556927
andrewrk
are you talking about safety or not?

1567556997
marler8997_1
actually it looks like it does work

1567557142
andrewrk
ok but what are you trying to do? it's unclear whether "detect" means you want your application logic to use this information, or if you mean that you want safety checks to catch undefined behavior

1567557216
marler8997_1
I'd like my application to fail on overflow with a well-defined error, rather than going into undefined behavior

1567557226
marler8997_1
I don't want any undefined behavior

1567557391
andrewrk
It's still not clear. Are you looking to introduce safety-checks, to prevent undefined behavior, or are you looking to actually handle overflow as a possible logical path of your application?

1567557411
marler8997_1
safety-checks to prevent undefined behavior

1567557425
marler8997_1
of course, I'd like an API that allows both

1567557432
andrewrk
OK. in this case you want

1567557449
marler8997_1
but I want well-defined behavior even with releaseFast

1567557465
marler8997_1
@intCast is undefined behavior in releaseFast correct?

1567557465
andrewrk
that's not how release-fast is defined

1567557506
andrewrk
however you can selectively choose a different mode with @setRuntimeSafety on a per-scope basis

1567557727
marler8997_1
Are you're saying that my application shouldn't get to choose how to handle overflows when it is compiled with ReleaseFast?  All overflow checking should be undefined in releaseFast no matter what?

1567557789
andrewrk
I'm just telling you what release-safe does, and what release-fast does, and you're choosing which one to use

1567558068
marler8997_1
Hmmm...I'll have to think on that one a bit...

1567558630
marler8997_1
Thanks for finishing the fix for the segfault issue, just built latest and now I can build my audio application again!

1567558823
andrewrk
glad to hear it, sorry for the delay in fixing it

1567558865
marler8997_1
no problem, I saw you were doing alot of work in that area and figured this change would take a bit to get in

1567560488
ntgg
I want to have a function defined only if the arch is wasm, how would I do that?

1567560576
andrewrk
when you say defined, do you mean exported?

1567560581
ntgg
yeah

1567560598
andrewrk
have a look at this example:

1567560726
ntgg
super easy, thank you!

1567561802
andrewrk
marler8997, nice work on the @Type builtin. I gave you a first round of review comments

1567562959
shritesh
I think the talk went good today. Most people (almost everyone an EE) loved the built in testing and cross compilation. I think we need to provide linker scripts for well known boards/architectures/embedded devices (maybe after the package manager). The videos is up at

1567563178
andrewrk
shritesh, nice!

1567563342
curtisf
is there any possible way to coerce zig into output a range for an error and not a single column?

1567563358
andrewrk
curtisf, stage2 does that

1567563371
andrewrk
stage1 doesn't have the capability currently

1567563375
curtisf
ah, okay

1567564812
stratact
How does one specify the dynamic linker in build.zig

1567565192
andrewrk
stratact, that option is not wired up yet

1567565208
andrewrk
that's a contributor friendly issue if you want to have a shot at it. Otherwise I can have that for you tomorrow

1567566600
stratact
andrewrk: I would love to help however I'm still too new for doing any real contributing upstream. There is also the possibility that option might not be what I'm looking for to solve a problem I'm facing. I would like to some advice or help with my problem if you can spare some time?

1567566619
andrewrk
yeah, sure, what's your use case?

1567566671
stratact
I'm trying to call a function from the X11/Xlib library which is causing my zig program to segfault

1567566712
stratact
I want to get the list of Window IDs from the list of _NET_CLIENT_LIST windows from my X11 instance

1567566785
stratact
Should I show you a paste of the main.zig?

1567566806
stratact
It's a small program, it's all there is.

1567567110
andrewrk
sure. what does this have to do with a dynamic linker?

1567567193
stratact
My thoughts were that the dynamic linker might find some missing parts to the linkage of the program to prevent it from seg faulting.

1567567220
stratact
It's a wild guess/assumption.

1567567575
stratact
andrewrk:

1567567637
andrewrk
ok. I think that's a dead end, better to explore other paths first

1567567648
andrewrk
do you have an output of the segfault?

1567567675
stratact
I do, but it doesn't share any useful info. I'll share a paste anyway

1567567746
stratact


1567567912
andrewrk
stratact, ahh, on freebsd we don't have segfault handlers set up yet. the next step here will be to run your application with a debugger

1567567937
andrewrk
for example: gdb /usr/home/stratact/Projects/Zig/window_list/zig-cache/o/KIE_hb777bYIRBHVw48sj38zA4bf5mBg7eirkvMGvQufEQpXTLnFggtuSE6ikn5Q/window_list

1567567948
andrewrk
(gdb) run

1567567957
andrewrk
gdb will catch the segfault, and then you can use `bt` to look at a stack trace

1567567989
stratact
Ah, gotcha, I'll try that

1567568051
andrewrk
you can also inspect variables and all sorts of other useful things

1567568105
stratact
Here is the stack trace:

1567568832
stratact
andrewrk: I suppose I'll try this on a Linux system (and probably migrate back to one). GDB doesn't seem to be as friendly on FreeBSD, especially since I can't step into that function before it segfaults

1567568890
stratact
It seems to jump into some linker magic right before calling that function

1567568935
daurnimator
stratact: btw, use `const` where you can instead of `var` :)

1567568936
andrewrk
main.zig:14 there's where the segfault is happening

1567568975
andrewrk
so that's the XGetWindowProperty call. notice it's happening inside XGetWindowProperty ()

1567568999
daurnimator
stratact: you need to pass pointers to XGetWindowProperty, not undefined integers :P

1567569013
andrewrk
which means you probably passed some invalid memory (perhaps null or undefined?) to the function

1567569029
daurnimator
`int XGetWindowProperty(Display *display, Window w, Atom property, long long_offset, long long_length, Bool delete, Atom req_type, Atom *actual_type_return, int *actual_format_return, unsigned long *nitems_return, unsigned long *bytes_after_return, unsigned char **prop_return)`

1567569033
andrewrk
daurnimator, oh, there's an issue for not allowing implicit casts of integers to C pointers

1567569059
andrewrk


1567569095
stratact
daurnimator: I've tried passing both pointers to the values and the values themselves and I got the same results

1567569103
daurnimator
stratact: so you need to do e.g. `&atomType, &form, &len, &remain, &list);` instead

1567569135
daurnimator
infact `list` there should be an array of chars, you currently just have a single char

1567569448
stratact
daurnimator: hahaha, you're suggestion helped, thanks. :) Well `list` needed to be [*c][*c]u8 according to the zig compiler, so I changed list from `u8` to `[*][*]u8` and did @ptrCast([*c][*c]u8, list)` for the last argument.

1567569457
stratact
*your

1567569524
andrewrk
that is planned to be a compile error with

1567569536
andrewrk
you never need to explicitly cast anything to a C pointer

1567569551
daurnimator
andrewrk: I just tried locally to do it. ` error: expected type '[*c][*c]u8', found '**u8'`

1567569568
andrewrk
does it have a hint?

1567569582
daurnimator
`note: pointer type child '*u8' cannot cast into pointer type child '[*c]u8'` `note: mutable '[*c]u8' allows illegal null values stored to type '*u8'`

1567569616
andrewrk
it's a good hint

1567569621
daurnimator
ah I see

1567569627
stratact
Oh?

1567569640
daurnimator
stratact: try `var list: ?*u8 = undefined`

1567569650
stratact
Will do

1567569711
stratact
daurnimator: no issues with that :)

1567569751
andrewrk
this is why we need #2984. it's too easy to give up on proper types without a little nudge

1567569776
daurnimator
andrewrk: lucky I asked in here and got pointed at the note; I was about to post to 2984 and say there was something we couldn't do ;)

1567569865
daurnimator
stratact:

1567569953
daurnimator
stratact: btw, isn't new code meant to use XCB rather than xlib?

1567570091
stratact
daurnimator: Thank you for the redone code, I appreciate it. Regarding XCB and Xlib, I'm not doing anything sophistated like making a new Window Manager. I'm trying to get info from the xserver to feed into a FVWM module

1567570146
stratact
I dunno if XCB has the capability to get Window IDs?

1567570185
shachaf
daurnimator: Aren't you still required to use Xlib for anything that uses GLX?

1567570362
stratact
Looks like there is a GLX API for XCB:

1567570432
stratact
Although it's still in "development"

1567570539
daurnimator
shachaf:

1567570693
stratact
daurnimator: thank you again

1567571088
stratact
So now I need to cast the `list` to a `*xlib.Window` type

1567571188
marler8997
how do I run the compile_errors.zig test?

1567571325
andrewrk
marler8997, have a look at ./zig build --help

1567571334
marler8997
thx, just found it :)

1567571355
andrewrk
also

1567571432
daurnimator
stratact: you can probably just make it a `?[*]xlib.Window` in the first place.

1567571483
daurnimator
stratact: also I would create a slice with the result: `const windows = (list orelse return error.WindowNotAvailable)[0..len];`

1567571993
stratact
daurnimator: gotcha, thanks

1567573309
marler8997
andrewrk: trying to address your comment about detecting changes in size/ptrlen enums...I'm thinking we could assert somewhere that the builtin Size values are what we expect...is there an init script somewhere I could do that in?

1567573855
daurnimator


1567584147
nitram91
andrewrk how many assumptions can the elf module make ? For example if it's being compiled for a 64bit, little endian target, can the we assume we will only be opening 64bit little endian elf files ?

1567584166
nitram91
stacktraces would still work that way and the code would be much cleaner

1567584185
nitram91
pretty much the endianess and the architecture would be known at compile time

1567584298
mq32
nitram91, for what is the module?

1567584315
mq32
use in the zig compiler? generic purpose ELF parser?

1567584325
nitram91
module was the wrong word

1567584352
nitram91
I mean the Elf object in the standard library (std/elf.zig)

1567584369
nitram91
afaik it's used for the stack traces

1567584415
mq32
i don't think its reasonable to compile it so it only can speak elf partially

1567584442
mq32
you would have to create another ELF parser thing as soon as you want to use it for

1567584471
nitram91
well it can speak elf properly, but only for the architecture it was compiled for, if you compile it for some other architecture, it will be able to speak that one

1567584476
nitram91
yeah, that's the issue

1567584838
ovalseven8
Question: Why did Zig decide not to be memory-safe like Rust?

1567584868
nitram91
mq32 and it's a weird use case when you compile for X architecture with Y endianess  but you try to work with elf files of a different endianess/architecture

1567584871
mq32
ovalseven8: mostly because it requires "hidden control flow" and that's a no-go in zig

1567584885
mq32
nitram91: why that?

1567584901
mq32
imagine you compile objdump for x86_64, but want to dump a PPC-ELF file ;)

1567584908
nitram91
linkers aren't that weird use case, dynamic linkers aren't that weird use case, debuggers aren't that weird use case

1567584917
nitram91
objdump is a example

1567584922
nitram91
readelf too actually

1567584935
mq32
everything "developing cross platform stuff"

1567584962
mq32
and as i'm doign a lot of embedded coding, most of my stuff is working with foreign-platform elf files

1567584995
ovalseven8
mq32, I am too much a newbie to understand language design but memory bugs are so common in kernels that I think it's worth it fixing this bug class

1567584997
nitram91
yeah but for example, a debugger will be compiled for each architecture it's needed (gdb-x86_64, gdb-mips, gdb-arm, etc...)

1567585088
mq32
nitram91, yes, but it nots for the target platform

1567585105
mq32
which means: my debugger is compiled for x86_64, but debugs ARMv7 code

1567585129
mq32
(both are little endian in this example, but i could also work on PPC for example)

1567585132
nitram91
don't you have a separate toolchain ?

1567585139
mq32
i use clang

1567585146
mq32
so: no :D

1567585185
nitram91
ow nice

1567585188
mq32
ovalseven8: It's not

1567585233
nitram91
definitely harder, and to do some of the kernel stuff you will need unsafe memory, which will break the point of rust

1567585246
ovalseven8
mq32, Another question: Kotlin has null-safety through types like "String" and "String?" with compile-time checks for null. Why does Zig not use this approach?

1567585259
mq32
it does

1567585267
mq32
zig pointers cannot be "NULL"

1567585277
mq32
(except for allownull pointers, but that's a special case)

1567585305
mq32
and nitram91: your question was still: compile for platform X and load elf for platform Y

1567585311
mq32
and that's the purpose of cross-tools

1567585360
nitram91
yes, what I meant is that for example if I compile my dynamic linker to load 64bit LE librairies, I don't expect it to load another architecture

1567585379
mq32
yeah that's true

1567585383
nitram91
and making that assumption would've allowed the Elf library to use mmap

1567585389
nitram91
instead of streams/readers

1567585394
nitram91
and be much much more efficient

1567585396
nitram91
and elegent

1567585398
mq32
but for general purpose you should not do that

1567585410
mq32
you can do both, actually :D

1567585416
nitram91
???

1567585418
nitram91
how ?

1567585421
mq32
two code paths

1567585428
mq32
but it's not that elegant

1567585450
nitram91
(I'm not gonna like I'm a bit narrow minded as my use case for zig so far is only writing a dynamic linker)

1567585527
nitram91
yeah but you would choose the path at compile time ? either compile super cross-platform code but slower or not cross-platform code but faster

1567585570
mq32
yes, that's true

1567585576
mq32
it would be a neat option to have

1567585589
mq32
"fast, but restricted to my platform" vs. "generic, but a tad slower"

1567585617
nitram91
it's when I see code like this

1567585644
nitram91
*reading the file for every call to the function

1567603177
samtebbs
I just found out about this:

1567603181
samtebbs
Last minute mascot idea?

1567603206
samtebbs
Maybe there would be some trademark issues :p

1567603224
fengb
Fair use for parody

1567603271
fengb
So we’ll have to make it really derpy

1567603294
samtebbs
Done:

1567603714
samtebbs
Has anyone ever explored the possibility of customising the style used by zig fmt

1567603970
fengb
No customizations

1567604029
samtebbs
fengb: How come?

1567604031
Aransentin
I kinda like that all zig code looks the same. That way formatting never gets in the way when reading other peoples code.

1567604076
fengb
Same reason as go fmt. When it’s one standard, nobody is happy. Thus everyone is happy

1567604081
companion_cube
I feel like samtebbs wants tabs

1567604165
samtebbs
companion_cube: Haha that used to be my nickname at uni. I've seen the light since then though

1567604189
companion_cube
yep, it's my nick :p

1567604191
samtebbs
I'm not a fan of some aspects of the style, such as commas after every struct member

1567604203
companion_cube
trailing commas ♥

1567604210
fengb
Options split the community and lead to formatting wars

1567604233
fengb
I hated go format for about a week

1567604248
fengb
Like straight up almost quit the language

1567604270
gonz_
Giving people the opportunity for personal style is a massive mistake, yes.

1567604278
fengb
But... everybody’s code looks the same and there’s no style dispute anywhere in the ecosystem

1567604281
gonz_
A needless one that doesn't need exploration.

1567604292
samtebbs
trailing commas don't make sense to me #changemymind

1567604300
fengb
And I’ve probably wasted hundreds of hours on formatting by now so I’m happy to never worry about it

1567604303
companion_cube
they make edition easier and are more uniform

1567604312
gonz_
samtebbs: One common but IMO weak argument is slightly nicer git diffs.

1567604354
companion_cube
I always use terminators rather than separators, if the language allows it

1567604355
fengb
I kinda want a different struct field definition. It looks really weird starting with identifier and ending with a comma

1567604361
gonz_
The point isn't to like the formatting anyway, it's to accept it and move on to more important things.

1567604377
companion_cube
(but then I'd want the syntax to be more rust like, so…)

1567604398
fengb
I can’t read Rust for the life of me

1567604459
samtebbs
gonz_: I don't agree. Formatting is important when it comes to reading code, which you have to do a lot of when fixing bugs

1567604459
gonz_
Rust can get pretty noisy in the worst case. There was a particularly offensive type signature someone pasted from Facebook's HHVM parser.

1567604479
fengb
Formatting is irrelevant if it’s good enough and consistent

1567604491
gonz_
samtebbs: This is offset entirely by the uniformity of the chosen formatting regardless of whether or not someone likes it.

1567604507
fengb
It may not be perfect in your eyes, but it’s something I don’t have to convince you anymore

1567604519
fengb
Cause we’re already fighting over trailing commas, we clearly don’t agree

1567604525
gonz_
And let's be real; it's not usually a question of readability, it's a question of personal minor preference.

1567604530
fengb
Auto formatter is the great normalizer

1567604568
fengb
I don’t agree with all of zig’s formatting decisions, but I’m much happier having them already made

1567604653
samtebbs
That's true. As long as the standard style isn't absurd (which zig's isn't) then one can get used to it

1567604654
gonz_
I feel exactly the same way. I'd rather it always wrapped at something like 100 width or whatever as well, but I also would never suggest that it conditionally does with some flag, because each step of configuration is just needless differences in code bases.

1567604663
samtebbs
I can't say the same for the GCC style though...

1567604672
Snektron
i was just about to say that

1567604685
Snektron
every time i see anything made by gnu, i almost have to cry

1567604695
Snektron
the libstdc++ headers top it all off though

1567604701
Snektron
indentation is literally random

1567604751
samtebbs
I feel ya :p I had to suffer it for the first six months of my internship

1567604792
samtebbs
So I'm trying to agree upon a code style for a project with a friend and one current idea is to just go with what's mandated by zig fmt as some common ground

1567604800
samtebbs
and to be standardised with the rest of the community

1567604810
fengb
The real reason HURD was never ready: code formatting

1567604937
Snektron
the one thing i really disagree about with most standardized formatters is aligning values

1567604943
Snektron
the rest i cant care about

1567605044
andrewrk
marler8997, I'll take #3111 from here

1567605067
samtebbs
gonz_: That's a good point when it comes to git diffs

1567605102
fengb
I actually liked Go's alignment :(

1567605134
gonz_
samtebbs: I dunno, I think it's weaker than people make it out to be, but it

1567605138
Snektron
am i right when saying that stdcallcc is the standard c calling convention?

1567605191
Snektron
or should i export with 'extern' instead?

1567605208
samtebbs
Snektron: Isn't it architecture-dependent?

1567605216
samtebbs
e.g. it's the aapcs for Arm

1567605281
Snektron
Just need the standard calling convetion for c on the target platform

1567605282
andrewrk
Snektron, no, extern is the C calling convention. "stdcall" is a different thing. Related:

1567605310
Snektron
ah, thanks

1567605331
companion_cube
gonz_: the noise is more because of extreme genericity

1567605361
companion_cube
the expression syntax is, imho, almost perfect

1567605400
gonz_
companion_cube: In part I think the most offensive examples are a combination of bad choices on the part of the writer and also a lot of mini tokens being chosen.

1567605408
gonz_


1567605454
companion_cube
well ok, lifetimes can get messy

1567605464
companion_cube
also, pfiu, quanfication in F

1567605464
gonz_
In all of this, with some reflection, you become acutely aware of how good a choice `dyn` as a token was in comparison to all the rest of the mini tokens in that type signature.

1567605465
Snektron
naming isn't really helping there either. 'x' and 'NS' aren't really descriptive

1567605479
gonz_
Snektron: That's what I meant by some of the fault being the writer, yeah.

1567605480
companion_cube
but the body is pretty cool, look at the match

1567605480
Snektron
At least its not lisp made with c++ templates

1567605513
companion_cube
I really mean the expression syntax (including mandatory braces, let, match, blocks returning values…)

1567605551
gonz_
I really don't mind Rust syntax on the whole and it certainly would never be something I would cite as a reason for not using the language.

1567605580
companion_cube
I think zig could learn from it ;)

1567605585
gonz_
I have a few syntax preferences and they're about as far as you can come from zig, but zig is probably my favorite language at the moment.

1567605629
Snektron
I get frustrated by not being allowed to do pointer hacks

1567605659
companion_cube
in zig?

1567605992
Snektron
in rust

1567606168
samtebbs
Snektron: hence Zig ;)

1567606186
companion_cube
Snektron: hmm, you can?! just use unsafe

1567606383
FireFox317
andrewrk: Regarding #2867 and the comment you made, could you explain a bit more what the ambiguity is and what the compile error should be?

1567606462
Snektron
companion_cube: i'm aware

1567606478
Snektron
i feel more like i'm being imposed to write in a certain way due to the whole safety thing

1567606520
Snektron
suddently you have to copy or allocate data to keep it safe

1567606536
andrewrk
FireFox317, yes, I'm saying that enum literals should only implicit cast to the

1567606547
fengb


1567606558
fengb
I can't understand any of this code :/

1567606569
companion_cube
Snektron: oh well

1567606588
andrewrk
FireFox317, const T = enum { Foo } | error{ Foo}; var x: T = .Foo; // ambiguity

1567606633
andrewrk
FireFox317, const T = error{Foo}!enum{Foo}; var x: T = .Foo; // ambiguity (fixed)

1567606704
shritesh
fengb, If it helps "lifetimes are just types on a different (temporal) axis". It clicked for me once it was explained as such. But I do agree there's a TON of visual noise there.

1567606744
fengb
I should sit down and learn Rust. My last attempt ended in failure

1567606762
andrewrk
I think I can actually read this

1567606817
andrewrk
the actual logic is pretty straigthforward, although I don't know what &*next does

1567606857
shritesh
I worked with Rust for a year. But interfacing with c functions (callbacks) was a major pain.

1567606894
companion_cube
andrewrk: &*next typically derefs (a smart pointer) and re-takes a reference

1567606906
andrewrk
companion_cube, what does that accomplish?

1567606925
companion_cube
if you have a Box<T>, you can get a &T locally

1567606933
companion_cube
which might be what a lot of your functions take

1567606940
andrewrk
hmm ok

1567606947
companion_cube
(also works for String -> &str, Vec<T> -> &[T], etc.)

1567607011
FireFox317
andrewrk, So if I understand correctly the last example (ambiguity (fixed)) should be a compile error, because it is not clear whether it should implicitly cast to the error or the enum?

1567607055
andrewrk
FireFox317, I'm using this as an example, to justify a language-wide rule, that enum literals do not ever cast to error sets (and transitively to error unions)

1567607100
andrewrk
I believe your PR is good, it just does *too much*, implementing this extra thing that I don't want to be implemented

1567607161
andrewrk
FireFox317,

1567607253
Snektron
andrewrk: does const PythonError = error {TailTooLong}; const e: PythonError = .TailTooLong; work?

1567607277
Snektron
Otherwise i can't see enum literals casting into E!T ever causing an ambiguity error

1567607296
andrewrk
Snektron, no that's not supposed to work either

1567607334
andrewrk
how would you resolve the code example I gave above?

1567607356
Snektron
And enum{A} | error{B} doesn't work either right?

1567607370
andrewrk
FireFox317, to be clear: enum literals should cast to error unions, but only to the payload type, not the error set type

1567607398
andrewrk
Snektron, that was a typo. the next line has a fixed example

1567607468
Snektron
var x: T = error.Foo; and var x: T = .Foo;

1567607504
FireFox317
Yeah i think I got it. In that example you gave, it should work and implicitly cast to the enum (payload) and as you said never to the error set type.

1567607605
Snektron
Is there even a way to transform an error set into an enum?

1567607846
andrewrk
FireFox317, yeah

1567607861
andrewrk
Snektron, that's how I'm saying it should work. we're on the same page

1567607895
andrewrk
Snektron, we're discussing

1567607924
Snektron
i see

1567607966
Snektron
Error already don't require their originating error set, so using `error` to designate them is only correct

1567607979
Snektron
else you end up with a c++ like grammer

1567610397
andrewrk
zig has @Type now thanks to marler8997. it only works for some types

1567610971
andrewrk
Snektron, with getgroups syscall, the 32 version is preferred over the non-suffixed version?

1567611011
andrewrk
ok yeah I see in musl, /* fixup legacy 16-bit junk */

1567611229
andrewrk
Snektron, there is only 1 thing left, I'm ready to merge after that

1567611268
Snektron
yeah i just took musl's example for those

1567611348
andrewrk
Snektron,

1567611514
Snektron
oh right, i see what you mean

1567611530
Snektron
I'm not sure exactly how PT_TLS and HWCAPS relate

1567611575
andrewrk
the TLS program header is generated by zig's linker. It won't have one if there are no thread local variables

1567611689
Snektron
Ah

1567611703
Snektron
the HWCAPS is not what the program is compiled with, but like i suspected, what the CPU has

1567611732
Snektron
So that condition is checking if the linux kernel exposes tls hwcaps, regardless of wether the program wants to use it

1567611892
Snektron
sure, i'll move it below there

1567611897
fraktor
I'm trying to compile Zig on Debian Testing, and I'm getting the following error: unable to find llvm-config

1567611922
Snektron
install llvm

1567611932
fraktor
Done

1567611966
fraktor
Oh wait, apt is just dumb about what is was showing before

1567611969
fraktor
I feel stupid

1567612027
andrewrk
Snektron, I think beyond a certain linux version it's guaranteed to have HWCAPS. And our min kernel version supported is 3.16. So I don't think that check needs to be there

1567612089
Snektron
done

1567612138
Snektron
On a side note, isn't there always going to be a TLS section as long as extern thread_local is allowed?

1567612154
andrewrk
only if you use it

1567612179
Snektron
Oh, llvm's doing i suppose

1567612213
andrewrk
it makes sense, one should not have to pay the cost of an unused feature

1567612263
Snektron
i agree, but now its not the same as builtin.is_single_threaded right

1567612275
andrewrk
right

1567612353
andrewrk
there is a sort of missing feature here, which is having a comptime constant that tells whether TLS will be used. unfortunately the decision of whether we need to set up TLS happens at runtime, even though we should know after linking whether we need TLS

1567612382
andrewrk
which means that the code for setting up TLS exists in the binary, even though it will never be called

1567612433
andrewrk
it's not impossible to solve, but it is tricky, considering it would require interacting with the linker in an advanced way

1567612466
andrewrk
a large cost in implementation complexity with a small reward

1567612477
Snektron
that or have a guarantee tls is not needed before linking, which is what you were proposing earlier

1567612489
andrewrk
oh yeah. that would be much more reasonable

1567615991
andrewrk
thanks to FireFox317, enum literals now work with ?T and E!T types

1567620654
Tetralux
andrewrk: .. where T is an enum?

1567620703
andrewrk
or a tagged union with a void field type for that tag value

1567620867
Tetralux
So for a return type of ?T, where T is enum, you may `return .SomeEnumValue` and it'll work now?

1567621741
bgiannan
Can i serialize a slice with io.Serializer?

1567621752
bgiannan
namely a []u8

1567621797
bgiannan
reading io.zig it seems serialize will serialize each element of an iterable, but how do i deserialize it? since i don't know the length of it then

1567621846
bgiannan
i could just put manually the length before it i guess

1567623166
andrewrk
Snektron, you've pushed Zig from Tier 3 to Tier 2 arm32 support :)

1567623197
andrewrk
on linux, at least

1567623313
andrewrk
I don't think ARM macOS is a thing, I'm going to mark that as N/A

1567624164
fengb
Watch Apple announce their next Macbook :P

1567624241
shritesh
Has anyone tried running zig on iOS?

1567624335
companion_cube
book apple annouce their next macwatch

1567624372
fengb
You can't compile an iOS executable without Xcode so it's probably a non-starter

1567624418
fengb
Although... RubyMotion somehow leverages Xcode to compile Ruby down. I wonder how they do it

1567624474
shritesh
It's been done in Rust and looks like we should be able to too

1567624528
fengb
`pub extern fn rust_hello_world`

1567624538
fengb
It looks like it's just exporting a C compatible symbol?

1567624547
shritesh
Yeah.

1567624616
bgiannan
is there already a proposal for function argument default values?

1567624652
Sahnvour
bgiannan: status quo is to use struct with default values and pass that to the function

1567624720
bgiannan
yes but don't you lose the function's signatures in error messages?

1567624773
fengb
It's been rejected

1567624791
bgiannan
do you have a link to the discussion?

1567624834
fengb


1567624841
bgiannan
thx

1567624843
fengb


1567624947
andrewrk
with

1567625013
bgiannan
fair enough

1567625111
companion_cube
so it's the builder pattern, in a sense

1567625245
andrewrk
might even remove struct literal syntax, and rely on this:  Foo(.{.field = value})

1567625269
andrewrk
as a var decl it looks like: var foo: Foo = .{.field1 = value1, field2 = value2};

1567625296
bgiannan
do you mean i can already do that or are you considering implementing it?

1567625304
andrewrk
it's planned:

1567625349
bgiannan
great!

1567626252
andrewrk
Here's a nice resource for anyone to read before proposing anything to do with strings or unicode:

1567626377
companion_cube
is there an issue on the design of iterators?

1567626416
mahmudov
is there any basic socket examples at zig for newbies

1567626451
mahmudov
i want to do some test with nc

1567626465
mahmudov
tests*

1567626541
andrewrk
mahmudov, not yet. I'm actively working towards such an example

1567626568
andrewrk
I'm splitting between that, and bug fixing / PR merging

1567626587
mahmudov
ok, thnks andrewrk

1567626644
mahmudov
just curious can we use C libraries in zig code?

1567626683
marler8997_1
andrewrk: maybe for now the Slice function shouldn't support 'one size' pointers?

1567626696
marler8997_1
the *[]T   or   *[N]T cases seem confusing

1567626736
andrewrk
mahmudov,

1567626813
andrewrk
marler8997, what is this function supposed to do? do you have an example use case?

1567626854
marler8997_1
In general, it's used in generic code to convert pointer types

1567626888
marler8997_1
For example, say you have a generic type that accepts a pointer...maybe you want to write functions inside that type that take the slice variation of the pointer type

1567626909
andrewrk
isn't this just @typeOf(x[0..])  and @typeOf(x.ptr)?

1567626984
marler8997_1
maybe...

1567627020
marler8997_1
does that work with just the type as well?

1567627034
andrewrk
if the purpose isn't clear, std lib is not the right place for it, just leave it in your project

1567627053
marler8997_1
of course, I think that's why we're discussing it correct?

1567627056
marler8997_1


1567627082
marler8997_1
How would you get the Slice type with just the type?  Not a variable with of the type

1567627086
andrewrk
I don't think Slice and ArrayPointer are good names for this, the name isn't descriptive enough

1567627112
marler8997_1
fine with me

1567627248
stratact
If I want to return a pointer from within a function, which allocator should I use?

1567627288
stratact
Just want to "box" it, so I can send it out without having it dangling

1567627359
Tetralux
You should pass an allocator to the function and use it to allocate memory.

1567627363
Tetralux
That's the general advice.

1567627379
Tetralux
The idea being that the allocation is explicit to the caller.

1567627401
Tetralux
Oh - sorry - read that wrong.

1567627403
Tetralux


1567627436
Tetralux
You mean, "which one from the stdlib?" or just which one in general?

1567627489
stratact
the former I believe

1567627513
stratact
I'm not writing a library, it's a small app

1567627526
Tetralux
Basically, it depends on how you're using the value and how often you're doing it.

1567627533
marler8997_1
andrewrk: what do you think about the iterators branch I sent you?  I think it demonstrates a couple use cases, of course this isn't exhaustive

1567627575
Tetralux
If you're doing it all the time, or if it's just one thing, I'd consider you pass in a pointer to the function which writes the result and then returns bool or something to say that it did it.

1567627589
Tetralux
But for something more quick and dirty, ArenaAllocator will do.

1567627624
Tetralux
If you want to put a little more time in, then figuring out a way to use a FixedBufferAllocator could be handy for something like that too though.

1567627640
Tetralux
Especially if it's being done in a loop.

1567627657
Tetralux
Like, "every frame, do this thing and give me an answer".

1567627678
Tetralux
Though, I'd have to see the code to know if you even need to allocate.

1567627694
Tetralux
Returning a struct instance may well be a better idea.

1567627732
stratact
I'll share you a paste of my code

1567627752
Tetralux


1567627855
stratact
I think passing a pointer to the function would be probably be the best solution for me though but here is the function

1567627905
Tetralux
What's the pointer you were wanting to return?

1567627938
stratact
`propertyValue`

1567627944
stratact
typed `?[*]u8`

1567627985
fengb
It's a double pointer?

1567628015
Tetralux
I actually think you're doing it right already: just return it, since it gets set the thing you want by XGetWindowProperty, I imagine.

1567628025
Tetralux
So it's just a value - just as if it was a usize or w/e.

1567628077
Tetralux
I'm not sure what memory XGetWindowProperty sets it to point to though...

1567628102
Tetralux
It doesn't take an allocator, so I'm not sure where the memory's coming from.

1567628109
stratact
It's part of the X11 C library, so I dunno :)

1567628165
Tetralux
Anyhow, point being, it effectively returns to you a pointer to the property's value - I assume - and so you can just return that straight-up from your function.

1567628172
Tetralux
Or

1567628197
Tetralux
If you know what kind of thing it points to, maybe think of a way to cast it to *PropertyValueType

1567628202
Tetralux
etc.

1567628222
stratact
I gotcha, thanks for the advice Tetralux

1567628264
Tetralux
o7

1567628281
Tetralux
Is xlib just an alias to c.x11 or something?

1567628289
Tetralux
I'm curious to look at the source for that function.

1567628349
stratact
`xlib` is this: const xlib = @cImport(@cInclude("X11/Xlib.h"));

1567628359
Tetralux
Okay, gotcha.

1567628371
Tetralux
I'll fish for a sec and see if I can find it.

1567628379
stratact
Awesome, much appreciated

1567628562
Tetralux
Yeah - I think it calls malloc or something.

1567628574
Tetralux
It mentions "To free the resulting data, use XFree"

1567628587
stratact
Ah I see

1567628591
Tetralux
There might be a XAlloc or something that it does though.

1567628600
Tetralux
Though this is C, so it prob mallocs in the end xD

1567628622
stratact
So no need for an allocator :)

1567628663
Tetralux
It's kinda wierd you can't ask it for how much space you need to store the value, and then give it a buffer for it to write into...

1567628673
marler8997_1
out of curiosity, what made you decide to use x11 instead of xcb?

1567628680
fengb
It's the C style :P

1567628702
fengb
How does memory management work? rtfm!

1567628755
stratact
marler8997_1: I chose it because there were plenty of examples of what I need to do written in it out there

1567628800
marler8997_1
fair enough, was just wondering as I've seen both and am curious what would make people choose one over another

1567628823
stratact
marler8997_1: if I were writing a Window Manager, I'd probably got out of my way to use XCB

1567628844
marler8997_1
or you could use neither :)

1567628875
stratact
hehe

1567628916
marler8997_1
I like learning protocols like this and have starting creating a new X library for Zig...but have been finding that the language is missing things that is making it alot more difficult at the moment

1567628918
Tetralux
FYI, XGetWindowProperty; the pointer it sets is basically just a slice of bytes; the length being `remain` in your code.

1567628936
Tetralux
So you could do `return propertyValue[0..remain]` IIUC.

1567628966
Tetralux
The data is formatted into either a slice of u8, u16, or u32, as indicated by `form`.

1567628979
Tetralux
But I'm guessing it's just a string?

1567629004
Tetralux
Depending on what you then do with this information, it's probably simplest to indeed, just return a slice.

1567629017
Tetralux
Esp since you literally have the length information.

1567629047
Tetralux
And you can just pass slice.ptr to XFree when you're done with it.

1567629067
stratact
Tetralux: Awesome, I'll give that a shot

1567629087
stratact
marler8997_1: I hope your new X library in Zig works out eventualy

1567629128
marler8997_1
yeah me too, we'll see

1567629131
Tetralux


1567629198
gonz_
marler8997_1: Which things?

1567629590
Snektron
Im guessing mostly stdlib features

1567630160
marler8997_1
mostly meta-programming capabilities

1567630175
marler8997_1
like being able to set the return type to "var"

1567630221
marler8997_1
andrew just merged the @Type builtin so that helps alot

1567630251
marler8997_1
I think I've been very spoiled with D with it's meta-programming capabilities, Zig's just not quite there yet

1567630348
gonz_
You might simply be asking for a

1567630379
marler8997_1
you think so?

1567630410
gonz_
Lots of people are, more or less. Some ask for C++, some ask for Rust, some ask for D, etc.

1567630412
marler8997_1
I can do many things with Zig today?  There just seemd to be a few holes that I'm hoping will be filled

1567630419
Snektron
What would return type var do

1567630436
Snektron
Return a value of any type?

1567630440
marler8997_1
any type that is determined at compile-time

1567630452
marler8997_1
good for generic functions that can return many kinds of types

1567630466
gonz_
marler8997_1: Yes, you can do many things with zig even though it has very few features. Let's keep it that way. :)

1567630480
Snektron
Ah, you want auto

1567630485
marler8997_1
right

1567630528
marler8997_1
most cases you don't need or want auto, but when you start getting into meta-programming it really becomes necessary

1567630538
Snektron
gonz_: gotta find a fine line between go and c++

1567630565
marler8997_1
yeah Zig is taking the right approach of being careful about what features it integrates

1567630580
Snektron
But you can always hack around it at the moment

1567630589
Snektron
Return a type with a member

1567630598
marler8997_1
and some of the features I would have thought it needed it doesn't actually need anymore because it was able to solve the problem another way

1567630700
marler8997_1
In any case I think zig will eventually solve these problems one way or another...it's just a matter of when and how

1567630714
gonz_
That seems like the general case (about solving it *another way*)

1567630737
marler8997_1
perfect example is zig's generics vs templates

1567630787
marler8997_1
rather than bolt a new feature onto the language, it was able to extend existing semantics and achieve the same power as a template system

1567631048
gonz_
Many "things that need solving" are not actually things that need solving as well.

1567631104
gonz_
You never actually need private fields, for example.

1567631127
marler8997_1
sure, not having private fields would not be a deal breaker for me

1567631130
gonz_
Yet some people feel that's something you do need for familiarity.

1567631134
marler8997_1
not being able to write generic re-usable code is

1567631160
fengb
Go squeaks by with even worse generics >_>

1567631201
companion_cube
gonz_: not for familiarity, for safety

1567631230
gonz_
marler8997_1: There are degrees to that. A lot of C programmers would argue you don't need that at all. Is it actually needed? Familiarity plays a part here.

1567631249
gonz_
companion_cube: It really doesn't do much for safety.

1567631253
companion_cube
"needed" is a bit meaningless, everyone will say "what I have is enough"

1567631262
companion_cube
gonz_: well it helps not shooting yourself in the foot

1567631270
companion_cube
by using something meant to not be used directly

1567631293
marler8997_1
yes many people are satisfied with the status quo...if I was one of those people I wouldn't be using Zig

1567631355
companion_cube
Go might become usable if they implement their generics proposal

1567631367
gonz_
companion_cube: There are obvious ways of accomplishing that. They don't require private fields. Tons of features help you not shoot yourself in the foot, yet they're not present in Zig. I think that's for the most part fine.

1567631382
companion_cube
you mean @opaque ?

1567631390
gonz_
No.

1567631404
gonz_
You don't need any new feature at all to not modify "private" fields.

1567631431
companion_cube
I mean if you define a type and don't want users to fiddle with its internals

1567631432
fengb
I've had more problems working around "private" bugs than private actually helping out

1567631435
gonz_
And maybe if someone does, let's treat them like an adult?

1567631449
gonz_
Play stupid games, win stupid prizes

1567631459
companion_cube
so why have types at all?

1567631485
gonz_
Are you actually equating types with private fields in terms of importance?

1567631486
fengb
And Go is fine. It's not ideal and lack of generics sucks but it's pretty usable in general

1567631512
companion_cube
gonz_: I mean that it serves the same purpose: make APIs that are more robust and less error prone

1567631519
gonz_
Put an underscore or two before a field name, leave a comment that people shouldn't mess with it. If they do, tell them they're probably messing it up.

1567631522
companion_cube
I'd be using C++ if I trusted myself with never making mistakes

1567631523
gonz_
This isn't some big issue.

1567631538
gonz_
"More robust". When was the last time you saw an issue that amounted to this?

1567631559
fengb
Hiding design doesn't make it better. Documenting the API is a boon, but sealing off internals isn't really productive

1567631569
companion_cube
I don't, because I write very defensively :D

1567631576
gonz_
I find it ridiculous that people are spending any time debugging these things at all.

1567631587
companion_cube
my OCaml code is full of private types, private aliases, and such things

1567631593
companion_cube
because it removes debugging time

1567631608
fengb
If your code is perfect... good for you

1567631613
gonz_
And that's fine. My Haskell code is full of type classes, type level lists, etc., but I would never argue for them in Zig.

1567631621
companion_cube
ugh, no, it's not perfect, it just helps me avoiding mistakes

1567631628
fengb
I can't always fix upstream, and I always find a weird bug

1567631636
fengb
And if it's private, I can't work around it at all

1567631639
Tetralux
Yeah I'd tend to hesitate to have private fields...

1567631663
Tetralux
IME, it feels good to say "I'll make this one private because I don't need it outside" or whatever

1567631668
Tetralux
It feels good to write that stuff.

1567631675
gonz_
Just because peoples' favorite languages have things doesn't mean zig has to and not everyone has to be a language designer just because the community is small.

1567631679
Tetralux
Like how you write `public:` in C++ structs.

1567631688
companion_cube
gonz_: of course not

1567631700
companion_cube
but that's not an argument against a feature either

1567631710
Tetralux
I would consider that if the bug you're making is that you need to have private fields...

1567631714
companion_cube
people's favorite languages have iterators, and Zig can have them too

1567631717
Tetralux
Then you need to program in a more data-oriented way.

1567631724
gonz_
There's always an obvious argument against every feature: Let's see if we can

1567631738
companion_cube
you can say that of basically everything

1567631752
gonz_
Yes, but private fields is pretty obvious that you can simply *not add*.

1567631775
companion_cube
why have private functions,then?

1567631775
marler8997_1
python doesn't have private fields either

1567631779
companion_cube
you can simply not add them

1567631801
companion_cube
why have const? you can simply not mutate it

1567631819
gonz_
companion_cube: What's going on with these odd equivalencies? Private functions serve a very real function; to make some task in a single file more managable by splitting up the logic.

1567631821
marler8997_1
true, maybe we should remove private methods and const??? :)

1567631824
gonz_
Private fields don't.

1567631836
fengb
You can't modify a function so it's not the same

1567631847
fengb
But if the data is wrong... well now I can't fix it because it's private

1567631852
gonz_
These insane comparisons

1567631853
marler8997_1
can't you do that with public functions as well?

1567631858
companion_cube
^

1567631874
companion_cube
private fields allow you to have some fields that you know won't be touched outside

1567631880
companion_cube
same way private functions won't be called from outside

1567631891
companion_cube
such fields can include cached computations, for example

1567631908
fengb
And if the cache scheme is broken? Because it often is

1567631927
gonz_
And you would accomplish the exact same thing by underscoring it

1567631936
companion_cube
fengb: then it's a bug

1567631942
fengb
Yes it's a bug

1567631942
marler8997_1
but what's the reason for private functions then?

1567631946
fengb
But I can't always fix it upstream

1567631948
fengb
That's my point

1567631966
companion_cube
sounds like you're fucked

1567631978
companion_cube
what if you have to call a function that's bugged? are you going to edit its code?

1567631998
fengb
... or I can work around it if it isn't private

1567632001
fengb
But now I have to throw away the library completely

1567632011
gonz_
Meh, private functions aren't strictly needed either, honestly. They're much more valuable as an organizational tool than private fields, though.

1567632043
companion_cube
I agree, it doesn't mean they're obviously useful and private fields, obviously useless, as you seem to imply

1567632051
marler8997_1
you think so? private fields allow you to hide details about your type so that you can change them without breaking compatibility....seems like the same reason for private functions

1567632052
companion_cube
it's more nuanced than that

1567632082
fengb
marler8997_1: public fields can be solved with documentation. Private doesn't have to imply hidden, just unstable

1567632091
companion_cube
again, same with function :D

1567632103
marler8997_1
fengb: ?

1567632131
marler8997_1
oh wait

1567632137
fengb
I like private == not part of the api. It's the private == cannot touch that I'm not fond of

1567632140
marler8997_1
you're saying private doesn't have to mean you can't use it

1567632148
fengb
Yeah, thar be dragons

1567632165
mikdusan
interesting

1567632200
gonz_
Also known as underscored fields

1567632204
marler8997_1
that would be interesting...private fields are implemented by not documenting them :)

1567632219
mikdusan
and a compiler option to emit diagnostics if using dragons when you're not an authorized slayer

1567632240
marler8997_1
at least, not using triple slash document comments :)

1567632272
marler8997_1
seems a bit silly at first but I like it...ship it :)

1567632293
companion_cube
gonz_: then remove private functions and just underscore them :/

1567632293
fengb
With private functions... I don't really care because I can't really fix the bug anyway. It's not like I can force the state to be correct

1567632321
marler8997_1
yeah it sounded like gonz_ would be ok with that

1567632323
gonz_
companion_cube: It'd be far from a dealbreaker. We have a smart compiler that does dead code elimination anyway.

1567632333
marler8997_1
it's what python does...so there's precedent

1567632335
companion_cube
yep, so that should be removed :D

1567632343
gonz_
The better point in all of this is: We are where we are at the moment. A growing feature set is generally a failure, let's try not to fail more.

1567632351
companion_cube
marler8997_1: in terms of design, I'd tend to do the opposite of python, generally speaking

1567632364
Snektron
I wouldn't take python as example of good language design tbh

1567632373
marler8997_1
lol...I really like python for the space it operates in

1567632408
marler8997_1
This is a pretty interesting one to watch about python:

1567632408
marler8997_1
Search

1567632408
marler8997_1


1567632408
marler8997_1
1

1567632408
marler8997_1
55:05 / 1:01:41

1567632408
marler8997_1
Python as C++’s Limiting Case)

1567632425
companion_cube
I dislike almost all of python's design choices :/

1567632438
Snektron
init is such an ugly way to designate special functions

1567632444
companion_cube
poor scoping, statement instead of expressions, whitespace significant, no typing, no good lambdas…

1567632452
gonz_
companion_cube: Just because we have features doesn't mean we should be careless in adding more. Even if they have some "This is almost like that..." thing in there already.

1567632453
marler8997_1
lol

1567632457
Snektron
Same with underscores on private fields, though thats more convention i guess

1567632486
fengb
Python is a bad ML yes :P

1567632491
marler8997_1
gonz_ I don't think anyone thinks we should be careless in adding features, you're sounding condescending

1567632518
companion_cube
fengb: right? :D

1567632526
companion_cube
and they're trying to add mypy but it's a bit, hum, tough

1567632531
fengb
Java has "private" which isn't really private, but it's really asinine to get access

1567632531
marler8997_1
bad ML?

1567632543
gonz_
companion_cube: OCaml; no type classes, no higher-kinded types, no custom operators, no forward references without ugly hacky methods

1567632551
fengb
C++ has "private" that's defined publicly and kills ABI compatibility

1567632557
marler8997_1
you could get access to c++ private fields as well

1567632571
gonz_
companion_cube: We can do this with any language and bake in as many blub things and familiarities as we can fit as well.

1567632574
companion_cube
gonz_: well, it removed a lot of useless features ;)

1567632592
companion_cube
I know, I just really dislke python, because I can't write anything significant in it

1567632609
fengb
marler8997_1: all the features companion_cube mentioned are things from an ML language, like OCaml or Haskell

1567632615
Snektron
marler8997_1: you  can even do that in a defined manner

1567632617
fengb
Like baked in as core design

1567632627
marler8997_1
I think python has its place

1567632636
Snektron


1567632638
Snektron
Behold

1567632645
companion_cube
fengb: note that something like Elixir doesn't disgust me

1567632649
companion_cube
(despite the lack of types)

1567632659
companion_cube
I think statements suck, is all

1567632663
gonz_
This shows that you haven't used it

1567632678
marler8997_1
the video I sent explains why it has statements

1567632688
fengb
I like statements :/

1567632699
companion_cube
yet you like Zig? 🤔

1567632721
gonz_
Expressions over statements all day every day.

1567632724
Snektron
Bold statement

1567632729
marler8997_1
zig doesn't have statements?

1567632738
fengb
if() is a statement

1567632749
Snektron
Everything is a statement

1567632773
fengb
I guess if() can also be an expression. So it has both in one!

1567632790
companion_cube
if it's an expression it's not a statement :p

1567632800
fengb
if () {} is a statement

1567632807
companion_cube
heh, too bad

1567632808
fengb
const foo = if() ; is an expression

1567632817
companion_cube
in rust it's an expression returning ()

1567632827
companion_cube
but of course you can separate expressions with `;`

1567632864
gonz_
In the regent family of languages it's a SYNTAX ERROR

1567632878
gonz_
Why do you not have `else`!?

1567632884
gonz_
What insolence

1567632902
fengb
Oops you're right, the expression version needs else

1567632906
marler8997_1
well here's the reason python uses statements:

1567632909
companion_cube
unless it returns ()

1567632952
companion_cube
marler8997_1: you can have `a = b` be an expression returning ()

1567632984
marler8997_1
you can?

1567632987
marler8997_1
well then this guys just wrong

1567632994
companion_cube
I mean, that's a valid design decision

1567633010
companion_cube
having it return b is a bit weird tbh

1567633025
marler8997_1
oh right, this guy is saying python doesn't do that because state mutation should be at the top level of the block

1567633060
fengb
But... a = b = c

1567633066
fengb
Transitive that equality

1567633071
fengb
Er... assignment

1567633136
companion_cube
marler8997_1: right, as in `d = {1:2}; x = d.pop(1)`

1567633142
companion_cube
clearly I'm mutating d at the toplevel…

1567633181
companion_cube
(so, in rust, I just checked: `a=b` is an expression returning () indeed)

1567633196
marler8997_1
yeah if I remember right, everything in rust is an expression

1567633334
gonz_
Expressions over statements are a good example of where cutting away something (statements) actually opens up way more, while still being simpler.

1567633387
companion_cube
yep

1567633398
companion_cube
I'd say the same about sum types, but well :shrug:

1567633448
gonz_
companion_cube: As in?

1567633561
torque
guido stepped down as python bdfl because of the huge shitstorm over python 3.8 adding assignment expression syntax

1567633634
torque
Apparently assignment being an expression is very controversial

1567633656
companion_cube
gonz_: algebraic datatypes if you prefer

1567633688
torque
ideas have a tendency to gain a lot of inertia

1567633724
gonz_
companion_cube: Yeah, but what exactly do you mean that you'd want to do with them or some other feature (which)? Are we talking some ideal pure version of what a sum type is; variants, etc.?

1567633746
gonz_
I didn't quite understand the "the same" part of what you said.

1567633760
companion_cube
it's the same in that it's incredibly useful and it simplifies the language

1567633770
gonz_
Aha. Yeah, I agree.

1567633773
companion_cube
(yes, variants in addition to structs)

1567633784
gonz_
It's such a boon to design.

1567633811
Tetralux
Do I want to know why assignment syntax being expressions is useful to anyone?

1567633853
marler8997_1


1567633853
gonz_
companion_cube: I ask because sometimes it seems someone has some platonic ideal of what a sum type is and they hate some other version of it that I can't tell why it's different.

1567633865
marler8997_1
They give some examples and rationale for why you may want assignment expressions

1567633866
fengb
A lot of iterators can be solved using assignment expressions

1567633870
gonz_
You never know who's one of those.

1567633932
fengb
I wonder if Python would have benefited from matching block syntax: if (foo) |match|

1567633956
companion_cube
I mean, I'm a ML programmer at heart, so sum types are my bread and butter (as are expressions obviously)

1567633959
companion_cube
so of course I hate python

1567633967
companion_cube
(although the scoping is objectively bad)

1567633986
marler8997_1
I dont' think so...since it doesn't really have a compile-time type system to accomodate

1567634020
marler8997_1
meh...functions have scopes.  If you want a scope you can use a function

1567634054
fengb
The Javascript way? :P

1567634068
gonz_
Few languages annoy me enough to hate them. I used to be very into Python, but it was mostly a reaction to coming out of a 7 year C++ binge and Python felt so simple in comparison.

1567634090
fengb
C++ binge? How are you coping?

1567634096
companion_cube
marler8997_1: lua, erlang, have good scoping

1567634097
gonz_
But I agree with whoever it was that said "It's good for what it does" before.

1567634099
marler8997_1
yeah like I say I think python has a place

1567634123
companion_cube
I did write a 50 lines script yesterday, using mypy

1567634125
companion_cube
ugh

1567634135
marler8997_1
lua is pretty simple, I haven't done much coding in it but I would think it has pros/cons with python

1567634192
marler8997_1
python's simplicity makes for alot of libraries...it's got very low friction so you can get things done quick

1567634209
fengb
Python used to be simple...

1567634222
marler8997_1
ah....not anymore?

1567634224
gonz_
fengb: There is only one language I actually have a visceral reaction to when I see it. I haven't written more than 20 or so lines of C++ since maybe 2007/2008.

1567634233
gonz_
fengb: That's how I'm coping :D

1567634237
marler8997_1
lol

1567634238
companion_cube
lua is simpler and cleaner than python

1567634245
companion_cube
too bad its community is much smaller

1567634245
marler8997_1
yeah?

1567634254
fengb
I agree with simpler :P

1567634268
marler8997_1
should I be using lua instead of python for my scripting needs?

1567634271
companion_cube
cleaner, because it has good scoping with `local` :p

1567634277
companion_cube
and also faster, obviously

1567634277
fengb
I'm not a big fan of Lua syntax, but its semantics are much nicer

1567634316
marler8997_1
I would guess it doesn't have as many libraries

1567634361
companion_cube
clearly not

1567634372
companion_cube
python's only strength is the ecosystem

1567634376
companion_cube
and it's a big strength

1567634411
marler8997_1
"the ecosystem"...reminds me of Apple products

1567634454
ntgg
python is very easy for at least small things, it's not only the ecosystem

1567634512
marler8997_1
sure but I think he was saying that's it's only strength over something like lua

1567634522
companion_cube
I mean sure, dictionaries remove a lot of friction for small things

1567634524
companion_cube
yes.

1567634562
marler8997_1
I'll have to spend some time with lua and see for myself

1567634595
ntgg
lua takes far more effort than python, at least for me.

1567634614
ntgg
I have done significantly more lua dev than python dev too

1567634639
marler8997_1
would love to see some resources comparing the two

1567634661
marler8997_1
what's some reasons for preferring python over lua?

1567634675
gonz_
lua, Python and Ruby seem like mostly the same-ish language to me, where you can pick an arbitrary favorite and move on.

1567634692
companion_cube
python has nice comprehensions, I must say

1567634711
companion_cube
(it's one of the rare nice things in it, and it's in the expression part :p)

1567634722
marler8997_1
comprehensions?

1567634735
gonz_
You can give a reason like "Well, I like that this one chose to model everything with some kind of table variant thingy and extended that concept really well", but do you really have to have a reason for preferring something so much like the others?

1567634763
fengb
I prefer the Python ecosystem to Ruby

1567634771
fengb
Rubyists love to pretend they're DSL authors

1567634806
gonz_
marler8997_1: List comprehensions, `for x in, where some condition holds for x, bla`

1567634824
companion_cube
marler8997_1: [x+2 for x in whatev if x>0]

1567634841
ntgg
python has a lot more stuff included then lua, lua is a very

1567634850
marler8997_1
oh right...I've seen that one but haven't really groked it yet

1567635010
ntgg
Lua is better for embedding, but you need to do so many things in lua to get to the productivity of python, even without it's ecosystem

1567635044
companion_cube
without its ecosystem and stdlib, even?

1567635484
ntgg
I would say so, the language itself does much more for you compared to lua

1567635666
companion_cube
what do you have in mind? apart from comprehensions and `with`, I don't really see where python shines

1567636086
companion_cube
ah, guess there's async too now

1567636717
ntgg
arrays are much easier to work with in python

1567636722
ntgg
and strings

1567637091
marler8997_1
I like how python has both arrays an tuples, and the only real difference is that you can't modify tuples

1567637119
marler8997_1
I should clarify that the "like" was sarcasm

1567637170
companion_cube
well then you can put tuples in sets!

1567637203
marler8997_1
I suppose

1567637262
companion_cube
(same with frozenset)

1567638008
Tetralux
Q: Does the stdlib support atomic pointers?

1567638043
Tetralux
i.e: A pointer, where the address it points to can be updated atomically.

1567638100
Tetralux
Or is the idea that you have an atomic usize and update it the way you're meant to do that?

1567638176
Tetralux
For clarity, I mean, you have a pointer, you change it to point at something else - only atomically.

1567639111
fengb
Tuples are supposed to be position dependent. Python does a lousy job teaching the difference but they are different in important ways

1567639160
fengb
In languages without proper tuples, you end up reinventing it poorly

1567639186
fengb
Tuples or position aware structs

1567639771
gonz_


1567639792
gonz_
It seems pretty big, though. Does anyone have any experience with something similar and knows where the complexity might come from?

1567639802
gonz_
307k lines of C

1567639832
gonz_
~235.5k LoC, actually, sorry.

1567639863
gonz_
But still, this seems beefy for what is just the library interface for vim, no?

1567639959
fengb
I can’t imagine a purely functional API would be straightforward in C >_>

1567640006
gonz_
It's made for interop with OCaml as far as I understand

1567640036
fengb
I get it. It just doesn’t sound too pleasant

1567640148
fengb
Onivim sounds interesting. I’ve always wanted an IDE built off vim

1567640255
gonz_
They had an electron version before and honestly it was acceptable in performance and the design was pretty good.

1567640281
gonz_
But they switched to this native library based on OCaml so the performance is bound to be much better now.

1567640298
gonz_
OniVim2 is in paid beta atm. I bought it but I haven't sat down with it yet.

1567640399
fengb
How does wee_alloc get under 1kb? I’m not sure I can get zee_alloc below 2 :/

1567640465
gonz_
This "pure" API takes a ton of `file_buffer*` where that struct also has a ton of clearly impure things.

1567640474
gonz_
I probably wouldn't stress that part so much.

1567640535
gonz_
Wasn't GitHub supposed to get a bunch of "go to definition" features and stuff or is that just for Ruby and those languages?

1567640611
gonz_
No, I'm mistaken.

1567640647
shritesh
fengb: It's wasm-gc and wasm-opt after doing a release build. You might want to check those out

1567640732
fengb
Those don’t really do much with my output

1567640756
fengb
Maybe I should get the latest

