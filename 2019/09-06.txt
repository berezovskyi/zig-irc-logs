1567728007
shachaf
I'm still a bit uncertain about the auto-async-await, it seems like a big thing to make implicit in a language that doesn't do function overloading.

1567728014
shachaf
But I'll see how it works out. :-)

1567728119
Snektron
mq32: remember that @Vector should not be used as a mathematical vector!

1567728166
Snektron
Its easy to confuse the two

1567728233
Snektron
Its much more efficient to calculate the same  vector dot product for 4 different vectors than to use the dot product intrinsic for example

1567728297
Snektron
LLVM's autovectorization is quite efficient from what i've seen in C, so i think theres a good chance you wont be able get an improvement at all

1567728316
Snektron
That is assumed autovectorization works with Zig

1567733297
andrewrk
it does, same as clang

1567735687
andrewrk
fengb, it looks like the await / for loop "Instruction does not dominate all uses" issues are my next blockers for the async/await proof-of-concept

1567736068
andrewrk
I'm gonna start the late-night stream in about 15 minutes

1567736298
andrewrk


1567737193
fengb
Sweet. The workarounds are fine but it looks intimidating when stumbling upon

1567741139
redj
hey andrewrk, I just missed the live stream... just caught q&a over and have a good night... are you posting the recording to youtube right away?

1567741148
andrewrk
redj, yes, it's uploading

1567741161
redj
very nice, will watch tonight :)

1567741170
andrewrk
I think the demo went well even though I was clearly a bit tired

1567741198
redj
andrewrk: great job on the streams btw... I like the status update "format" ...

1567741238
andrewrk
I did a live demo with spawning a thread to resume an async function (I've never tried that before) and it worked first try

1567741255
redj
andrewrk: what's the status of networking for the vvery emminent 0.5.0 release?

1567741272
andrewrk
redj, practically non-existent

1567741275
redj
first try -- that's always awesome! :)

1567741303
andrewrk
redj, but I do expect to be ready to start working on networking very soon

1567741307
redj
andrew any kind of rpc planned in the language or std lib?

1567741315
andrewrk
probably not

1567741345
redj
any discussion on that? or why not?

1567741364
andrewrk
that's the kind of thing that works just fine as a third party package

1567741422
redj
ah, understood... do you think it would have a "native" feel as such?

1567741451
andrewrk
I'm not sure that concept applies to zig packages. even the "builtin" module you have to import the same way as you would a third party package

1567741453
redj
I mean would it feel like a natural extension to the language

1567741485
redj
right, and that's a good thing

1567741510
redj
I really need to start experimenting with the language... I've only compiled from source a couple of times...

1567741542
andrewrk
there are also binaries of master branch available on ziglang.org/download

1567741622
redj
I know but I chose to start from source since I do want to understand the compiler maybe...

1567741640
andrewrk
good :)

1567741868
fengb
incompatible types: '[*]u8' and '?*c_void'

1567741872
fengb
Missing an implicit cast?

1567741936
fengb
Hmm there's something weird with the peer resolution here

1567742743
redj
andrewrk: #2377 mentions 'stable event-based I/O' but #3063 doesn't... neither does the 0.5.0 milestone... I'm guessing there's no issue for that specifically. will that make it into the release?

1567743415
andrewrk
redj, stream video is up:

1567743424
andrewrk
it might be a few minutes before the HD version becomes available

1567743566
redj
awesome -- zig creator guy :)

1567743613
andrewrk
I think some early proof of concept version of event-based I/O will be in the release, but not stable

1567753599
Yardanico


1567753685
Yardanico
JS has 7976744, Python 4063862, C 1222969, Rust 105186, Nim 3429, V 32

1567754004
Yardanico
Not that bad considering that Zig first appeared in 2015 and Nim in 2008

1567754807
bgiannan
I think zig is way to young to start comparing its usage to other languages

1567755236
gonz_
I agree with that entirely, but I think accidentally it also tries to say "We need/want people to make things" and I also agree with that.

1567755267
gonz_
As a metric for some attribute of goodness of a language it's pretty meaningless, though.

1567755461
mq32
i think Zig/andrew is doing the right right now

1567755500
mq32
defining and refining language semantics instead of implementing a load of features/libraries that will lock the language in place (like web server, REST clients, …)

1567755524
mq32
that was one thing that bugged me about V the most

1567755538
Yardanico
is there a way to read a runtime-decided number of bytes from a stream?

1567755546
Yardanico
or I should use while loop and readByte?

1567755553
bgiannan
btw if you guys were not aware: i'm rewriting my game

1567755556
mq32
"wait, you tell me your language isn't even finished yet, but you already have UI, graphics acceleration, networking and all that stuff done?"

1567755618
mq32
it just feels like the focus is set wrong

1567755647
gonz_
bgiannan: Cool! What does the source situation look like?

1567755648
Yardanico
(btw I like io.InStream in Zig, it's actually better than streams module in Nim because it has more flexibility and natively supports different endianness)

1567755677
bgiannan
gonz_, the source situation?

1567755693
mq32
yeah, endianess is imho an important thing in I/O everyone tends to ignore

1567755709
gonz_
bgiannan: Are you doing any source distribution, partial or otherwise? Will you be making zig utility code available in the process?

1567755711
Yardanico
well Nim has it, but it's in a different module so you first have to read a byte or a int and then switch the endianness of it

1567755786
Yardanico
hmm, so can I create a []u8 variable with size known at runtime?

1567755808
Yardanico
[len]u8 where len is a runtime-defined var doesn't work (well, as expected)

1567755838
gonz_
Yardanico: `array[0..]`should create a slice

1567755857
gonz_
This should have a runtime known size

1567755871
Yardanico
gonz_: I need to pre-allocate a variable of a certain size so I could read a UTF8 string from a binary file into that variable

1567755877
Yardanico
will a slice work in this case?

1567755917
bgiannan
gonz_, if i end up writing anything general enough i'll extract those i open source projetcs yes

1567755925
bgiannan
in*

1567756033
mq32
Yardanico: var backing_buffer = [1]u8{0} ** 256; var data = backing_buffer[0..len]; readsome(data);

1567756036
gonz_
Yardanico:  `var buf: [8]u8 = undefined`

1567756051
Yardanico
gonz_: thanks, but I need a runtime-defined size :) mq32 thanks, I'll try

1567756055
gonz_
Yardanico: `@compileLog(@type(buf[0..]));` will be `[]u8`

1567756060
mq32
or you can use an allocator for data with no unknown upper bounder

1567756064
mq32
got to go

1567756119
gonz_
If we are talking "I can't ever create this without a runtime known size", `allocator.alloc(T, count)` will do the trick

1567756166
Yardanico
mq32: yeah, that did the trick, because I know that the string size will not be bigger than that anyway

1567756718
Yardanico
wait, so Zig automatically emits Valgrind data to debug binaries so I can check them with valgrind? that's cool

1567757635
Yardanico
I'm still amazed by the size of Zig-built binaries in release-fast mode after stripping them  by the way :)

1567758659
Yardanico
How do I pass a []u8 variable to a C function which expects to have a [*c][*c]u8 ?

1567758667
Yardanico
(unsigned char ** outData in C)

1567758821
samtebbs
Yardanico: Seems to me that you want to pass the address of the array

1567758844
Yardanico
samtebbs: yeah, this is a function from a C library for LZMA compression/decompressing

1567758879
Yardanico
I need to pass file format (lzip in that case), input array and size (it works with &in_data[0] and lenght of it), output array and size (it will write to these two)

1567758918
Yardanico
Zig made this definition for that function: "pub extern fn simpleDecompress(format: elzma_file_format, inData: [*c]const u8, inLen: usize, outData: [*c]([*c]u8), outLen: [*c]usize) c_int;"

1567759136
gonz_
I just created

1567759151
gonz_
If anyone wants to try it out and see if it's useful for them

1567759179
samtebbs
Yardanico: Does passing the address of your outData array work?

1567759187
gonz_
I still haven't even really discovered the basics of making something like this available as a package, so any pointers there are welcome.

1567759235
samtebbs
gonz_: Not sure how we should do it before we have a package manager

1567759246
gonz_
Using deps via `git clone` is pretty bleh if you don't set up rules for these specific repositories to be cloned with `LF` endings

1567759269
gonz_
And in this case is doubly relevant because obviously if you're using win32 you're on Windows and it defaults to cloning with `CRLF`

1567759278
Yardanico
samtebbs: how do I do this? I currently have "var out_data: []u8 = undefined;" and tried to pass it as "&out_data[0]" to the C function but it didn't work

1567759300
Yardanico
if I pass "&out_data" it says "error: expected type '[*c][*c]u8', found '*[]u8'"

1567759375
mikdusan
maybe something like this? `var p1: [][*]u8 = undefined; decompress(..., @ptrCast([*c][*c]u8, p1.ptr), p1.len);`

1567759534
Yardanico
hmm, it seems to go further, now ldd can't find the symbol from that lib (it's in C source code with headers), how do I tell Zig to compile the C lib from source code?

1567759543
Yardanico
I currently have @cInclude for headers of that lib

1567759561
Yardanico
I do zig run --library c test.zig -isystem "$PWD"   right now

1567759667
mikdusan
well if you want to compile an entire C lib, you probably don't want to issue commands on CLI for it. Zig's analogue to makefiles is `build.zig` and the `zig build` command to run it

1567759682
mikdusan
in there you can tell zig to compile additional .c files

1567759803
mikdusan
i made a small command-line tool a while back that builds a .zig main, and then adds 3 .c files

1567759806
mikdusan


1567759873
mikdusan
fair warning build.zig is not documented yet. and look to zig tree `std/build.zig` to see the API

1567760024
Yardanico
mikdusan: well I know that there's no documentation for build, because I already look quite a lot in the src for the stdlib modules :) although that way I learn the language a bit faster

1567760123
gonz_
samtebbs: I've included a tiny bit of how I'm using the package in one of my projects in the README, but I'm not sure `addPackagePath` is what people have been using at the moment.

1567760158
gonz_
It works, obviously.

1567760455
Yardanico
can I somehow use addCSourceFile for all files in a directory?

1567760500
Yardanico
ah nvm

1567760653
Yardanico
I really think that there should be a way to just specify something like addCSourceFile("src/*.c", ...)

1567760664
Yardanico
but I'm fine with an array and a for loop

1567760670
mikdusan
if you

1567760827
Yardanico
yay it compiled

1567761010
Yardanico
but it seems that the way I passed my out array is still wrong :D

1567761158
mq32
gonz_, is that just a raw conversion of the windows.h file?

1567761215
gonz_
Yes

1567761226
gonz_
With every deficiency that incurs

1567761250
mq32
ah okay

1567761260
gonz_
I also haven't tested it in any other circumstance than the one I have on my two Windows machines

1567761270
mq32


1567761277
mq32
what would be cool is something like

1567761285
gonz_
My first version of this had meticulously translated, hand-written bindings

1567761291
mq32
const user32 = @import("win32/user32");

1567761294
gonz_
Then I realized I'm doing a ton of work for nothing

1567761307
gonz_
That was the idea from the beginning, actually

1567761327
mq32
ah yeah

1567761331
gonz_
But technically it doesn't serve any purpose other than self-documentation

1567761338
gonz_
Because we only import what we use

1567761355
mq32
yeah, but it also makes clear what windows library actually provides this functions :)

1567761364
mq32
maybe it's possible to only extract the function definitions and match them against the exports from the libraries

1567761366
gonz_
So if the user knows where something comes from, they don't really need to care. It would be nice to have the split because it makes knowing what to link much easier.

1567761373
mq32
so splitting up windows.h into subfiles would be possible

1567761377
Yardanico
Damn even with that easylzma lib (a wrapper for 7z C lib) compiled in the  after stripping the release-fast binary it's only 96kb

1567761384
Yardanico
although I linked with the C library :)

1567761401
gonz_
Yardanico: <3

1567761446
gonz_
mq32: Yeah, I haven't experimented much with this. I was happy enough that I could actually extract it like this and re-use it without referring to my specific include folders

1567761456
gonz_
(more than for the generation)

1567761505
gonz_
I'm curious how many things change from version to version. The only way to really practically find out is from someone using something that apparently did change, I guess.

1567761556
mikdusan
Yardanico: is your outData still borked? i think my understanding was backwards

1567761561
Yardanico
mikdusan: yeah

1567761566
mikdusan
k give me a sec

1567761651
gonz_
mq32: The long-term plan is still to have a zig interface where it's warranted, probably in the top-level of that module or in some other module, that accomplishes common things in a more zig-like way.

1567761700
gonz_
But it also turns out that writing win32 apps in zig the way you'd write win32 apps usually is also not terrible

1567761789
Yardanico
mikdusan: I think I fixed it

1567761819
Yardanico
1st of all I had an error in my code: I use lzip format instead of lzma, and then I used "@ptrCast([*c][*c]u8, &out_data.ptr)" for out_data and it worked

1567761856
Yardanico
now the C lib correctly decompresses the LZMA data in the memory

1567761918
Yardanico


1567761952
mq32
how's the plan about networking right now? is there something in Zig/std already?

1567762114
samtebbs
Yardanico: nice one :)

1567762118
samtebbs
What IDE is that btw?

1567762151
Yardanico
VSCode with zig-lsp (simple Language Server  implementation with some parser/lexer checks, although the parser part is a bit outdated and sometimes shows "problems" on correct Zig code)

1567762165
Yardanico
well, open-source build of VSCode from Arch repos

1567762182
Yardanico


1567762307
mikdusan
i think this might be pretty clean: `var outData: []u8 = undefined; simpleDecompress(..., @ptrCast([*c][*c]u8, &outData.ptr), &outData.len);`

1567762365
Yardanico
mikdusan: yeah, I also got it working with this (see previous messages) :P thanks a lot for helping ( didn't know that I had to use ptrCast here)

1567762392
mikdusan
took me a bit to realize the c-api was simply setting a ptr & len; which magicaly is what a zig slice is :)

1567762513
mikdusan
any compiler internal gurus lurking? i'm looking for any info on Extended-Basic-Blocks vs. Basic-Blocks pros/cons of each

1567762548
samtebbs
mq32: It was waiting for async/await to be merged which was done recently, not sure if anything is blocking it now

1567762557
samtebbs
mq32:

1567762571
samtebbs
mikdusan: What's an extended basic block?

1567762629
mikdusan
apparently a grouping of basic blocks. the first BB can be entered from anywhere. the rest are entered only from within group. (if i understand correctly)

1567762633
mq32
samtebbs: I'm thinking about implementing a "reliable udp" library (or at least something like that)

1567762646
mq32
and before i start in C++, i'd like to give Zig a shot here

1567762652
mikdusan
i first heard about it in some Rust blog where they were talking about switching to EBB then ditched the idea

1567762676
mikdusan
and also heard about it for the Mill CPU Architecture... it uses EBB as well.

1567762703
daurnimator
mq32: I have intentions for networking stuff....

1567762717
daurnimator
mq32: are you targetting linux/posix/windows?

1567762729
mq32
i am targetting "generic message passing platform"§

1567762779
daurnimator
?

1567762782
mq32
:D

1567762793
mq32
serial port, udp, tcp, raw wifi, bluetooth, ...

1567762803
mq32
anything that can transmit some kind of packet

1567762807
Yardanico
hmm, now a question about enums, how do I convert an integer to a set (or array) of enum values? maybe there's something already in stdlib for that?

1567762825
daurnimator
mq32: oooo. I have huge plans for that to :)

1567762829
Yardanico
for example if 64 is DoubleTime and 8 is Hidden, and the value is 72, I want to get an array of DoubleTime, Hidden

1567762833
daurnimator
mq32: https://ȱ.com :)

1567762857
daurnimator
Yardanico: that should like bit flags; not an enum

1567762861
Yardanico
ah, right

1567762866
daurnimator
s/should/sounds/

1567762867
gonz_
Yardanico: You can use packed structs with 1 bit fields to/from this.

1567763006
mq32
daurnimator, sounds like a big project!

1567763079
daurnimator
mq32: yep. I've also got bits implemented in zig :)

1567763134
mq32
cool

1567763153
mq32
my project "group" right now is kinda same level of crazy, but very different :D

1567763293
samtebbs
mikdusan: Sounds like that would be useful for loops where you should only enter the initial basic block

1567763421
mikdusan
i found a blurb suggesting it "some local optimizations such as instruction scheduling are more effective when done in EBB"

1567763594
mq32
daurnimator, samtebbs: i assume i can access standard socket() io, right?

1567763612
daurnimator
mq32: yeah.... sort of. it's not very nice

1567763635
daurnimator


1567770068
mq32
daurnimator: how do you want to design end-to-end encryption in ȱ?

1567770086
mq32
in terms of key-ex between my own devices or similar

1567770157
daurnimator
mq32: you share your 'master secret key' between devices by inviting your other devices to a channel that is for that purpose

1567770334
mq32
this sounds reasonable

1567773053
fengb
3 hour optimization session: -100 bytes. 5 minutes of updating to C spec: +100 bytes. Le sigh

1567774730
bgiannan
Is there a way to tell `zig test myfile.zig` to not run test of imported files inside `myfile.zig`?

1567774817
daurnimator
bgiannan: --test-filter ?

1567774850
bgiannan
`zig test --test-filter myfile.zig`?

1567774952
daurnimator
bgiannan: no it is a filter on the test names

1567774982
daurnimator
`zig test myfile.zig --test-filter myfile`

1567775002
bgiannan
oh should i maybe prefix all my test names with something?

1567775023
bgiannan
what do you mean by test name actually?

1567775037
bgiannan
test "testname" {...} <- this?

1567775040
daurnimator
yep

1567775059
bgiannan
this is weird to want to filter on this

1567775087
daurnimator
do I recall that an @import prefixes the module name onto the test names?

1567775119
gonz_
Is this test behavior limited to current project? Because I've never had tests from imported files run automatically AFAIK.

1567775125
bgiannan
yes i would have though zig had some auto-naming conventions like it does for types

1567775139
gonz_
And obviously I use the standard library, which has tests.

1567775155
gonz_
Or is it present only in newer versions?

1567775165
bgiannan
gonz_, you do @import("std") and not @import("./std.zig") which maybe the difference

1567775214
gonz_
Recursive testing without having asked for it seems very unintuitive.

1567775226
bgiannan
my thought exactly

1567775249
bgiannan
but i guess you could do `zig test main.zig` and run all your tests that way?

1567775477
gonz_
Yeah, I dunno. I think running all tests is a job for globbing or a flag being passed.

1567775561
gonz_
Or just `zig build test`

1567775602
gonz_
As for filtering on test names it's what I've usually seen in other environments

1567775613
gonz_
Regex filtering on test names is very useful in certain circumstances

1567775975
bgiannan
i would have expected `zig test` without a file name to run all tests and `zig test myfile.zig` to run only the tests of myfile.zig

1567776024
gonz_
I think that's probably what people are used to, at least.

1567776064
samtebbs
Has anyone ever gotten `/home/samteb01/repos/zig/build/lib/zig/std/time.zig:62:15: error: container 'std.os' has no member called 'timespec'

1567776076
samtebbs
var ts: os.timespec = undefined;` when doing `const time = std.time.timestamp();`?

1567776106
samtebbs
Oh wait maybe it's because I'm targeting freestanding

1567776165
samtebbs
For some reason I thought it would be evaluated on the host computer at build time so I could embed a "This software was built on date x" in a boot message

1567776273
fengb
Maybe anything that references OS should have a friendlier error message

1567776286
fengb
"Freestanding has no OS. Your code is bad and you should feel bad."

1567776338
samtebbs
:(

1567776365
samtebbs
I'm sure I saw a PR that added an "Unsupported OS" compile error

1567776383
fengb
Yeah that was just for referencing fd_t

1567776396
samtebbs
Oh ok

1567776400
fengb
Maybe I could disable all of OS?

1567776419
samtebbs
Makes sense to me

1567776422
fengb
I'm not sure what that'd impact but it might be worth a shot

1567776456
samtebbs
Oh your PR's been open for a month now

1567776849
fengb
Well it can be improved :P

1567776922
fengb
Braindump: we should have a special path for freestanding that errors out with "Freestanding cannot use OS code", as wells the current "unimplemented" path

1567777045
samtebbs
+1

1567777144
fengb
I'm also surprised at the comptime thing. Is it not possible to run things in the compilation host?

1567777596
samtebbs
So it doesn't find the time code

1567777688
mq32
samtebbs, fengb:

1567777712
Snektron


1567777715
mq32
could be inserted here:

1567777721
Snektron
I think that should be a compile error

1567777731
Snektron
I think the root is caused by usingnamespace here

1567777734
fengb
Yep exactly. More of a design change question than anything

1567777760
fengb
I'm a little afraid we have random references to OS, but this will prevent that going forwards

1567777769
mq32
comptime is just awesome stuff ♥

1567777810
fengb
I actually had a different change but I think doing this makes a lot more sense

1567777838
fengb
Add 2 branches to the OS switch: else => "unimplemented", .freestanding => "never will be implemented"

1567777911
mq32
fengb, Snektron: i don't think this is the right position to add the check

1567777922
Tetralux
I feel like not allowing functions that call into os to run at compile time when cross compiling is a bug..

1567777934
mq32
as zig is lazy, this error will only trigger when you try to use functions from those bit files

1567777956
Snektron
Yes, but its caused by that

1567777966
Snektron
Thats where timespec should be imported

1567777977
mq32
yes, but it would solve only for timespec

1567777981
mq32
but OS has more features

1567777985
mq32
like std.os.argv

1567778006
Snektron
That would be imported in the same place

1567778015
Snektron
Anyway, i feel like Zig should have a timespec structure thats not dependent on OS

1567778062
Snektron
The question is how you would want to implement stuff like argv

1567778072
fengb
Having a compile error should uncover some accidental OS dependencies. It's a bit too easy to accidentally reference something in there atm

1567778086
Snektron
You could always implement a "null" argv iterator

1567778102
Snektron
But im not sure if thats feasable for everything

1567778111
Snektron
And if you really want that

1567778156
mq32
which would then still be available on freestanding ;)

1567778156
mq32
imho the right point is std.zig where os is defined

1567778156
mq32
and as soon as you access std.os it should error for freestanding

1567778156
mq32
Tetralux: i think it's a design decision whether to allow this or not

1567778156
mq32
it could allow some crazy stuff, but it would break reproducible builds

1567778156
mq32
and makes building a zig project dependent of place of compilation

1567778156
mq32
(because why not play a song while building the project)

1567778156
mq32
=> compiling on my computer maybe wouldn't work, because i don't have SDL2_mixer installed

1567778183
mq32
argv was also just an example

1567778197
mq32
os.getrandom is another thing again

1567778230
mq32
you don't want any of these on freestanding

1567778322
mq32
look at my godbolt link from above. imho that would be the right solution (preventing access to std.os completly)

1567778389
fengb
Don't need a labelled block. Just assign to the if ;)

1567779319
samtebbs
+1 for preventing std.os entirely

1567779595
fengb


1567779701
fengb
I see 3 places where it kinda makes sense to put it: in std.zig (which breaks the current pattern of simple imports), in os.zig (which doesn't have a good home since the existing switch is hidden behind libc), or in os/bits.zig (which has a good place but located awkwardly within the file structure)

1567780514
mq32
fengb, i still don't think about if as an expression but a statement :D

1567780910
Yardanico
so I'm home again, starting questions again - how do I convert/cast a byte to a bool?

1567780927
Yardanico
wel by byte I mean u7

1567780930
Yardanico
u8 *

1567780954
Tetralux
intToBool?

1567780960
Tetralux
@intToBool*

1567780967
Tetralux
I forget if that exists or not.

1567781001
Tetralux
var b: bool = if(n == 0) false else true; -- that'd work too.

1567781004
mq32
Yardanico: "var my_bool = (my_byte != 0);"

1567781009
Yardanico
mq32: well ok

1567781014
Tetralux
Ah yes

1567781016
Tetralux
Or that xD

1567781021
mq32
Tetralux: LUL

1567781037
Tetralux
Don't look at me. xP

1567781056
Tetralux
We probably should have @intToBool though.

1567781062
Tetralux
Probably save a few bugs.

1567781101
mq32
i would not do that

1567781117
mq32
how should the semantic of that function look like?

1567781123
mq32
"accept only 0, 1 or panic?"

1567781131
mq32
"everything not 0 is true?"

1567781141
Tetralux
That last one was my first idea.

1567781149
mq32
"test for the LSB, if that is 0, the value is false"

1567781155
mq32
"everything that is not 1 is false"

1567781167
Tetralux
Nah - I'd make it just say "if it's zero, its false else true."

1567781167
mq32
i have seen

1567781172
Tetralux
That way it's actually useful.

1567781185
Tetralux
Otherwise, why not just write != 0.

1567781191
mq32
but i can express that with less code and more semanticly document by doing (value != 0)

1567781198
Tetralux
The whole point is that you don't have to think about zero or not.

1567781219
mq32
but it's a good point to think about that

1567781229
mq32
i have code here that converts an ascii char to boolean

1567781234
mq32
everything not '0' is true :D

1567781240
Tetralux
xD

1567781245
mq32
which is definitly not what i want :D

1567781276
Tetralux
You want 0 or 1 and nothing else?

1567781292
Tetralux
Only, (value != 0) === (everything not 0 is true)

1567781330
Yardanico
is there a pure Zig alternative to something like scanf?

1567781357
Tetralux
parseInt, parseUnsigned?

1567781363
Tetralux
I think that's in std.fmt.

1567781376
mq32
Tetralux: in that code i'd actually want to be '1' true, '0' false and everything else an error

1567781395
Yardanico
I mean I want to parse a string like with entries like "w | x | y | z", and these entries are separated by commas

1567781419
mq32
just search for commas :)

1567781423
Tetralux
mq32: In that case, I'd either use a switch/if-else.

1567781423
Yardanico
ah I guess I can use a simple while loop

1567781451
Tetralux
:s/either use/use

1567781494
mq32
Tetralux: yeah

1567781848
andrewrk
bgiannan, Settlers of the Deep looks fun

1567781985
andrewrk
gonz_, you don't need exe.linkSystemLibrary for windows DLL calls, as long as all the extern functions have extern "kernel32" etc in them

1567782036
Tetralux
That's because kernel32 is always linked?

1567782044
samtebbs
So I've resorted to adding a build option with the timestamp so I can print when the build was made. All I need to do now is figure out how to format the timestamp to a date string

1567782048
samtebbs
Pointers welcome

1567782121
andrewrk
Yardanico, you can probably further reduce release build size by using --strip if you don't care about debug info

1567782122
Tetralux
Did you know that the UK was on BST+1 for several years during WWII?

1567782133
mq32
samtebbs: (void*)0xB8000 // this one helps you print the text

1567782133
Yardanico
andrewrk: doesn't the "strip -s" do the same?

1567782168
andrewrk
no; --strip to zig becomes a comptime const value that the std lib observes and avoids wasting binary size for e.g. stack trace code knowing the info won't be available

1567782174
Yardanico
ah, ok

1567782188
andrewrk
--strip is kinda like "heads up, I plan to strip"

1567782215
andrewrk
Tetralux, no, zig auto generates .def files on windows for dlls when you use extern "foo"

1567782231
andrewrk
this is one major strategy used for cross compiling

1567782271
gonz_
andrewrk: The generated code would have to be modified in that case. I guess a neat regex could do it.

1567782319
gonz_
andrewrk: But are you saying this also applies to f.e. `user32`, `gdi32`, etc.?"

1567782351
andrewrk
gonz_, yes, sadly, .h files do not contain this information. yes it applies to any DLL that you expect to exist in the target environment

1567782386
andrewrk
my suggestion for your project would be to do `pub usingnamespace std.os.windows` and then augment it with additional definitions

1567782390
gonz_
Mhm, yeah, I mean mostly that now it'll be very hard without some kind of external list (this seems surprisingly hard to come by in a neat format) used for modification

1567782439
andrewrk
getting them from windows.h is a good start, but if you're going through the trouble of having an entire repo dedicated to it, might as well open the possibility up to improve the APIs, IMO

1567782456
gonz_
Yeah, the idea is to have better APIs in the top level module

1567782463
gonz_
or more "zig-like" APIs

1567782476
gonz_
And have a backing module fully available to use `c`/`lean_and_mean`

1567782486
gonz_
Because someone's going to want to use something you haven't sorted out yet.

1567782559
gonz_
My first version of this had manual bindings + zig interface stuff, but I decided to scrap that approach entirely and see what would need adding by leaning much more heavily on this generated code.

1567782579
gonz_
So once you know what feels annoying and painful, you know what you should add in the top-level.

1567782618
gonz_
But this is mostly hypothetical as well; I have no idea how much drive and time I will have for sitting down and working with win32 going forward.

1567782645
mq32
oh gonz_, btw:

1567782653
mq32
maybe this is some help :)

1567782666
gonz_
Ooh, this is neat

1567782731
mq32
afaik it's not fully complete, but includes the most needed APIs

1567782905
samtebbs
mq32: That looks like the framebuffer address to me :p

1567782945
mq32
samtebbs: correct!

1567782947
mq32
VGA segment

1567783048
samtebbs
Yeah I have printing all wrapped up. Is there any date formatting support in the stdlib?

1567783177
mq32
andrewrk: how much work would it be to convert the Zig AST into a "list of declarations"?

1567783204
andrewrk
that's what it already is

1567783216
andrewrk
you have a root node and then a list of declarations

1567783216
mq32
ah i meant some export function

1567783226
mq32
would be a helpful step towards documentation. not autogenerated documentation, but something that tells us: "hey, this stuff exists in the codebase"

1567783977
Tetralux
Surely you'd know it was in your codebase because you-know... you read the source every once in a while xD

1567784081
samtebbs
Not everyone knows everything about a codebase

1567784084
samtebbs
Zig for example

1567784157
gonz_
Some code bases are older than most of the people in this channel. :D

1567784238
samtebbs
andrewrk: When I asked why my run step in build.zig also built the kernel, you explained that it's because the run step uses addArtifactArg. That makes sense.

1567784254
samtebbs
What doesn't make sense is why it's being rebuilt when it's already in the zig-cache dir

1567784275
andrewrk
There's that stale issue bot we were complaining about the other day:

1567784277
samtebbs
Surely if an artifact is in the cache and the sources haven't changed then it shouldn't be rebuilt

1567784321
Tetralux
samtebbs: What if the artifact depends on other source that you did change?

1567784335
Tetralux
Much like object files.

1567784337
andrewrk
samtebbs, the build system doesn't cache yet, other than relying on enabling the caching that the zig compiler itself supports

1567784352
andrewrk
so, for example, build steps that are system commands will always be run

1567784363
andrewrk
there's an issue open for that

1567784408
mq32
Tetralux, my idea was more to throw such code at std ;)

1567784410
mq32
so i have a list what is included in std and so samtebbs could have his question answered faster

1567784419
mq32
got to go (and had a bad timeout :( )

1567784419
samtebbs
Tetralux: I can build then run and run once again while doing nothing in between and it still rebuilds so I don't think it's because something else has changed

1567784420
mq32
laters!

1567784430
samtebbs
mq32: See ya

1567784443
samtebbs
andrewrk: I see, caching in the build system would be cool

1567784444
Tetralux
mq32: o/

1567784449
andrewrk
samtebbs, yes, it's planned

1567784481
Tetralux
Only the installation step is cached currently?

1567784998
samtebbs
andrewrk: Is it something that can be tackled now or is it blocked? It sounds like an interesting thing to work on

1567785051
andrewrk
it's not blocked, but it is an inherently difficult problem, pull requests would be welcome but also under deep scrutiny

1567785125
andrewrk
well, it might be blocked by re-implementing the cache system from stage1 c++ to zig

1567785160
Tetralux
Does stage2 build again yet?

1567785179
andrewrk
I think we could potentially remove caching in zig0 and rely on a zig implementation of the "cache hash" system

1567785281
Tetralux
So long as I can use the cache on Windows x)

1567785294
Tetralux
I'm not sure I can build self-hosted on Windows.

1567785309
Tetralux
Though, I haven't tried it in a while.

1567785642
Yardanico
why can I be getting an OutOfMemory error when trying to append an element to an ArrayList?

1567785667
Yardanico
I have 5GB RAM free on my PC (and 4GB swap free)

1567785707
andrewrk
what allocator are you using?

1567785720
Yardanico
std.debug.global_allocator

1567785742
andrewrk
there are admittedly few docs but there is at least this, in front of that allocator: /// This should only be used in temporary test programs.

1567785761
Yardanico
are there any other general-purpose allocators which I can use?

1567785780
andrewrk
I've one under construction that's not ready for std lib yet:

1567785807
andrewrk
if you're writing a CLI application, or a short-lived program, I recommend following this pattern:

1567785817
andrewrk
if you're linking libc, std.heap.c_allocator is a good choice

1567785859
andrewrk
oh, I've documented this

1567785862
andrewrk


1567785925
Yardanico
oh, "Are you linking libc? In this case, std.heap.c_allocator is likely the right choice, at least for your main allocator."

1567786111
companion_cube
is std.heap.direct_allocator one that just requests pages from the OS?

1567786147
andrewrk
yes

1567786158
andrewrk
it's good as a backing allocator

1567786165
companion_cube
nice.

1567786180
companion_cube
(I asked because I was seeing it in the arena allocator, indeed)

1567786284
daurnimator
direct_allocator is also useful in that it requires no userland state

1567786308
daurnimator
so useful for "the world is upside down" situations

1567786328
companion_cube
std.heap.survival_mode_allocator

1567786334
daurnimator
+ it means you can observe all your allocations via strace by looking for mmap/munmap

1567786393
Tetralux
... and also wastes a bunch of memory xP

1567786405
daurnimator
Tetralux: when debugging that doesn't matter :P

1567786423
Tetralux
For a short lived program. Probably.

1567786425
Tetralux
I guess.

1567786512
companion_cube
I guess if you mostly allocate a few vectors/hashmap with a large initial size, it's good

1567786547
daurnimator
companion_cube: not really IMO

1567786577
fengb
You could use zee_alloc :P

1567786587
Tetralux
I mean, if you make a bucketarray allocator thingy and then always use that for any heap allocated thing, and then immediately resize to a reasonable number... then sure.

1567786589
daurnimator
the other situation the direct allocator is useful is if you are going to go and modify page attributes with e.g. mprotect.

1567786593
fengb
(Don't use it. It's not designed for lots of allocations)

1567786652
companion_cube
daurnimator: oh that's super nice. So a library for storing sensitive data in memory, could have a custom allocator on top of that, that always protects the pages (like, noswap and all)?

1567786717
Tetralux
I mean... how often you gonna do that?

1567786736
daurnimator
companion_cube: yeah. you'd be able to use things like MADV_DONTFORK and MADV_DONTDUMP without much worry

1567786737
companion_cube
well if you write crypto stuff it could be a good practice

1567786752
companion_cube
if it's part of the allocator it's simpler, I assume

1567786765
daurnimator
Tetralux: most programs... e.g. to protect random number state getting cloned into worker processes.

1567786765
Tetralux
Which is why you'd probably write your own allocator.

1567786789
Tetralux
daurnimator: Most of your programs do stuff like that?

1567786804
daurnimator
Tetralux: I can't think of many programs I write that don't need random numbers at some point...

1567786846
Tetralux
Doesn't that mean a syscall every time you want a random number?

1567786854
Tetralux
Two in fact

1567786889
Tetralux
One to unprotect, one to protect

1567786889
daurnimator
Tetralux: no

1567786889
Tetralux
And then there's a race as well.

1567786902
daurnimator
Tetralux: you only need to seed with kernel-provided randomness once per thread/process.

1567786919
daurnimator
Tetralux: the key is to know when you've been cloned() so that you can reinitialise from kernel randomness

1567786942
shritesh
andrewrk: If there was a way to extract the ret val from a frame as an optional ptr, life would be so much easier :D

1567786961
Tetralux
Wait - the thread needs to know if it's cloned?

1567786990
Tetralux
Also - you use mprotect to protect the seed after initialization and only read it once from it's owning thread in order to init the rng.

1567786995
andrewrk
shritesh, in this case would you be using .? or actually need to check?

1567786997
Tetralux
Is that what you're saying? xD

1567787016
andrewrk
shritesh, related:

1567787072
andrewrk
shritesh, because if you would be using .? then this case is solved by

1567787088
daurnimator
Tetralux: see this post + read this HN thread:

1567787158
shritesh
andrewrk: I want to errdefer right after an async call for cleanup without building an implicit state machine with conditional checks

1567787246
andrewrk
shritesh, 3164 is the one to subscribe to for that

1567787254
shritesh
andrewrk: Yep. Looks like it

1567787324
andrewrk
shritesh, I had that example with cancel fully working - but I ended up backing out of it because I wasn't able to solve canceling non-async functions

1567787384
andrewrk
it's still on the table. but status quo works, and doesn't prevent that from a future possibility

1567788746
andrewrk
oh nice, scientes's talk is listed first on

1567788804
scientes
yes

1567789038
fengb
Curious: what's the problem with Rust SIMD?

1567789057
scientes
fengb, the portable version was removed

1567789076
scientes
it existed in rust, and then was removed, no idea why

1567789095
companion_cube
I thought simd intrinsics were stabilized in rust?

1567789110
scientes


1567789114
scientes
> Deprecated since 1.3.0

1567789114
scientes
: use the external simd crate instead

1567789166
scientes
and then

1567789217
scientes


1567789221
scientes
which have no portable simd

1567789235
companion_cube
I see, there's intrinsics but only platform specific

1567789239
companion_cube
I think there are libs for that though

1567789245
scientes
that isn't possible

1567789249
scientes
you have to use the llvm bindings

1567789253
scientes
so it has to be part of rust

1567789269
companion_cube


1567789293
scientes
but that is just sse3 sse4 avx

1567789306
scientes
>  and produce SSE2, SSE41, and AVX2 versions of the function.

1567789317
scientes
he is just wasting his timme

1567789318
andrewrk
scientes, I could see zig shipping with libmvec

1567789335
andrewrk
it only makes sense

1567789348
scientes
well libmvec is targetting the glibc ABI for now

1567789390
scientes
that way zig stability isn't important either

1567789404
andrewrk
the point though is that you should be able to do math stuff on vectors

1567789453
scientes
well yeah. we are already calling the llvm intrinsics, and eventually those will call libmvec

1567789468
andrewrk
ok well that's a pretty good evidence that we need to ship libmvec

1567791052
mq32
hey again

1567791062
mq32
andrewrk: what is the section .ARM.exidx for?

1567791791
andrewrk
mq32, I don't know

1567791801
mq32
hm

1567791809
mq32
zig/llvm requires this section when building for ARM

1567791822
andrewrk
what's in it?

1567791885
mq32
stackoverflow says, it contains unwinding information

1567791936
mq32
hm

1567791960
mq32
it looks like i'm kinda "blocking" on the function literal syntax

1567792008
mq32
looks like it's still possible to continue, but it will be very messy :D

1567792015
andrewrk
mq32, you're not blocking on function literal syntax

1567792037
mq32
what flags can i attach to functions?

1567792053
andrewrk
function literal syntax is just syntax sugar for `struct { fn f() void{} }.f`

1567792059
mq32
yeah

1567792070
mq32
i'll go with that

1567792117
mq32
how can i put stuff into sections and enforce emission?

1567792546
andrewrk
linksection

1567792565
andrewrk


1567792655
mq32
does this enforce symbol emission?

1567792682
mq32
because my application entry point is in .rodata, not in .code :D

1567792682
andrewrk
the way to force emission is with export keyword or @export builtin

1567792686
mq32
.text

1567792692
andrewrk
you can also use a linker script

1567792714
mq32
yeah i already have one

1567792726
mq32
okay, next error

1567792737
mq32
error: pointer type 'nakedcc fn() void' does not allow address zero

1567792771
mq32
hm

1567792784
mq32
maybe i can work around that with packed unions

1567792816
andrewrk
mq32, just put a ? in front of it

1567792822
andrewrk
?nakedcc fn() void

1567792828
mq32
ah

1567792846
andrewrk
nakedcc is advanced, what are you doing with that?

1567792935
shritesh
So TinyGO has an awesome linking/flashing support for microcontrollers (

1567792946
mq32
andrewrk: the microcontroller demo :)

1567792968
mq32
bootstrapping an LPC1786

1567792975
andrewrk
mq32, sounds right, carry on :)

1567792982
Yardanico
shritesh: only if LLVM supports architecture for that device I think

1567792998
mq32
shritesh: llvm actually supports Arduino target already :D

1567793001
mq32
it's AVR

1567793014
shritesh
Yes it does. But linking/flashing is still a pain

1567793025
andrewrk
AVR is an experimental target in LLVM. That makes it Tier 4 in zig. I do enable AVR on the ziglang.org downloads though

1567793028
Yardanico
mq32: too sad they didn't yet merge the xtensa changes

1567793040
mq32
i think that will happen some time

1567793064
mq32
i don't have my arduino stuff at home but i'll try to get an AVR blinky running when i get the time :D

1567793069
Yardanico
yeah, also I hope they'll add esp8266 support without waiting too much after their initial work gets merged (it only has esp32 support)

1567793137
andrewrk
shritesh, I'm not sure exactly what that's doing, but that's the kind of thing I envision as a third party package that would be a "build dependency" once we have the package manager

1567793155
mq32
zig build flash

1567793156
mq32
nice :D

1567793157
andrewrk
so you'd still be able to flash in 1 command: `zig build flash` or whatever

1567793162
andrewrk
:)

1567793163
shritesh
Nice

1567793166
mq32
btw

1567793168
mq32
i killed the compiler

1567793313
andrewrk
welcome to the club

1567793342
mq32


1567793359
mq32
should i make an issue for that?

1567793416
andrewrk
yes please. a link to the gist is fine

1567793463
andrewrk
if you find that assert in a backtrace and change it to ir_assert or src_assert it will tell you where in your zig source code the issue is coming from

1567793592
mq32
hm

1567793601
mq32
i think i should start to compile my own zig compiler now :D

1567793795
mq32
okay, i found the culprit

1567793802
companion_cube
this edge ain't bleeding enough yet

1567793805
mq32
it's the union over function pointer and number :D

1567793824
Yardanico
wow, I can actually find places where I forgot to free stuff I allocated with valgrind

1567793836
mq32
Yardanico, yeah valgrind is great

1567793842
Yardanico
and with magical "exe.valgrind_support = true;" I can even see source code lines

1567793851
Yardanico
(their index I mean)

1567793869
Yardanico
for me (who almost never used languages with manual memory management before) that's pretty cool

1567794043
andrewrk
Yardanico, valgrind_support = true is on by default in debug builds

1567794084
andrewrk
valgrind gives you this in C as well. but there is one thing that zig's valgrind integration gives you right now that's unmatched - which is if you assign something to undefined when you're done with it

1567794102
andrewrk
huh, I really should show this off on ziglang.org home page

1567794256
mq32
hm, damn

1567794273
mq32
i think i have to solve this different…

1567794298
Yardanico
:D " definitely lost: 373,603 bytes in 1 blocks" (calling C function leaks memory :D), gonna solve that, it's pretty fun to fix memory leaks

1567794326
andrewrk
Yardanico, std.heap.c_allocator integrates well with valgrind. don't forget to use --leak-check=full

1567794333
Yardanico
andrewrk: yeah I'm using that

1567794394
andrewrk
the tooling for native applications is unmatched

1567794397
Yardanico
So I figured out I should add alloc.free even for variables which aren't allocated with alloc.alloc :D

1567794401
Yardanico
" All heap blocks were freed -- no leaks are possible" :P

1567794443
Yardanico
(well that variable is a special case since it's used as a variable which the C  function uses to write the resulting string buffer into)

1567794452
mq32
andrewrk, can i somehow create interrupt handlers with zig?

1567794463
mq32
right now i use inline assembler, but GCC knows an attribute for that

1567794483
andrewrk
mq32, what's stopping you?

1567794516
mq32
boilerplate code :D

1567794526
mq32
every interrupt handler requires inline assembler

1567794550
andrewrk
what's stopping you from doing it without inline assembly

1567794601
mq32
how do i annotate that the function is an interrupt handler?

1567794614
mq32
i don't think we have interruptcc?

1567794630
andrewrk
it's a calling convention?

1567794634
mq32
kinda

1567794645
Tetralux
"Kinda." xD

1567794652
mq32


1567794756
Tetralux
Typical

1567794764
Tetralux
Godbolt doesn't tell you what bic or bx does

1567794765
Tetralux
But mov

1567794768
Tetralux
.. that everyone knows

1567794771
Tetralux
No problem.

1567794774
mq32
bx is  branch

1567794791
andrewrk
clang emits that attribute as arm_aapcscc

1567794797
andrewrk


1567794808
Tetralux
I'm guessing bx is the ret of arm.

1567794854
mq32
branch lr

1567794857
mq32
branch link register

1567794862
mq32
lr contains the return address

1567794892
Tetralux
Ah, I see. So it's literally just "return to the return address (that was set up by callq I assume)

1567794929
andrewrk
arm_aapcscc: "ARM Architecture Procedure Calling Standard calling convention (aka EABI). Soft float variant"

1567794981
andrewrk
my proposal for this would be to implement the planned

1567795129
Yardanico
BTW, about asking about scanf  - in the end I used a different simple approach -

1567795317
andrewrk
std.mem.tokenize and std.mem.separate are useful for parsing

1567795391
Yardanico
oh, I didn't know these were a thing :D also, asking about memory management - should I always have a deinit function for my struct if it has some memory which needs to be freed, or I can just write "defer mystruct.field.deinit();" in init function?

1567795406
Tetralux
Yardanico: You know that won't work for floats like 4.0 right?

1567795409
Yardanico
because for now these both work, but I don't know if the latter is considered good or bad

1567795415
andrewrk
if your data looks like "w | x | y | z" you could use `var it = std.mem.tokenize(data, " |"); while (it.next()) |item| {}`

1567795431
andrewrk
IMO get rid of the spaces and just use 1 byte delimiter

1567795438
Yardanico
Tetralux: isDigit is not from ascii, it's my function and defined as "return (ch >= '0' and ch <= '9') or ch == '-' or ch == '.';"

1567795496
Tetralux
Ah Good xD

1567795498
Yardanico
andrewrk: yeah actually in the file these are stored without any spaces, I tried to find by looking for "scanf" in zig repo, but didn't find mem.tokenize thing

1567795533
Tetralux
I honestly find it hard to get tokenize to work in my head for some reaosn

1567795540
andrewrk
use std.mem.separate if you want "a||b" to return 3 items instead of 2

1567795552
Tetralux
If it was split, it'd make more sense xD

1567795595
andrewrk
separate is going to get renamed to split, tokenize is a good name

1567795617
Tetralux
Wait - so what's the third item from seperate?

1567795626
Tetralux
"a", "||", "b" ?

1567795645
Tetralux
Only if so, tokenize does what split does in every other language I've used.

1567795754
Tetralux
Oh wait - you mean it'd be: "a", "", "b" - in which case yeah - that makes more sense.

1567795831
Yardanico
Wow I tried "while (it.next()) |item|: (current_var += 1){" and that syntax actually worked

1567795892
andrewrk
it's a pretty decent language when the compiler doesn't crash, eh?

1567795932
Yardanico
andrewrk: it's a good sign where people can intuitively write syntax  which actually works and they've never seen it in examples before :P

1567795939
Yardanico
s/where/when

1567795967
Yardanico
I mean, firstly I tried to place :(current_var += 1) before |item|, but that didn't work and worked on the second attempt

1567795981
andrewrk
there's a good reason for that, item is in scope

1567796013
andrewrk
while (node.next) |child| : (node = child) {}

1567796881
andrewrk
I wonder if it would be possible to make calling conventions a userland concept. Define them at comptime

1567796941
andrewrk
then arm_aacpscc would be implemented in the std lib

1567797038
mq32
andrewrk, my approach was to create function decorations in userland

1567797060
mq32
by taking a nakedcc function as an argument and returning that function with prefix, @inlineCall, postfix

1567797145
mq32
also: most of my hackery wasn't even necessary :)

1567797177
mq32


1567797368
knebulae
@andrewrk: that would be huge

1567797371
Yardanico
how can I create a stream (IoStream or BufferedIoStream, or maybe I should use SliceIoStream)? from a []u8?

1567797429
andrewrk
Yardanico, std.io.SliceOutStream std.io.SliceInStream

1567797448
andrewrk
buffering would be redundant

1567797719
mq32
andrewrk: is an array packed by default?

1567797748
andrewrk
no

1567797770
mq32
can i enforce this?

1567797790
andrewrk
no, zig doesn't have packed arrays. I think they could be proposed though

1567797809
mq32
hm

1567797825
mq32
okay, i have to work around that :D

1567797833
andrewrk
you'll have to make a byte aligned array, and then ptr cast sections to a packed struct

1567797853
andrewrk
or make a byte aligned packed struct and use that as the array element

1567797866
mq32
yeah i already have a packed struct

1567797870
mq32
and want to make that an array

1567797880
andrewrk
if it's byte aligned then you can just put it in an array and it will work correctly

1567797904
andrewrk
e.g. if your packed struct has u4, u4, that's byte aligned. u4, u3, not byte aligned

1567797942
mq32
the struct is only some u32s

1567797946
mq32
pub var gpio = @intToPtr(*[5] volatile GPIO, 0x2009C000);

1567797964
mq32
(volatile may be wrong still)

1567797967
andrewrk
why do you think you need a packed array?

1567797991
mq32
because i create an HAL layer of the microcontroller registers

1567798013
andrewrk
I see. This will work fine - packed structs have 1 byte alignment, and so there will be no padding between them inside arrays

1567798028
mq32
okay perfect

1567798051
andrewrk
packed array would be like if you wanted @sizeOf([8]u1) == 1

1567798161
mq32
aaand another one :D

1567798162
mq32
unreachable: /deps/zig/src/ir.cpp:const_ptr_pointee_unchecked:250

1567798304
andrewrk
you have to be careful with packed structs. they need another round of work done on them

1567798322
andrewrk
after

1567798333
mq32
yeah but i need a defined memory layout :D

1567798364
andrewrk
oh, this has to do with a hard coded address

1567798372
andrewrk
this is probbaly an easy fix

1567798411
andrewrk
just need to look up the stack a couple frames and there's likely a missing check for ConstPtrSpecialHardCodedAddr

1567800455
Tetralux
What's a good way of debugging an infinite loop in a test?

1567800495
andrewrk
run it with gdb. hit ctrl+c

1567800514
Tetralux
I don't know which test.exe it is though. :)

1567800657
Tetralux
OOO

1567800661
Tetralux
I just figured it out

1567800689
Tetralux
zig.exe was hanging because I made the caching folder a symlink to a directory in temp that did not exist.

1567800713
Tetralux
And it hung instead of reporting the error that it was trying to.

1567800912
Yardanico
wow fmt.parseFloat takes about 50% of runtime when trying to benchmark my replay parsing lib :P

1567800927
Yardanico
that's a bit strange since nim's float parsing function only uses like 7% of runtime

1567800973
andrewrk
just checking are you using --release-fast

1567801024
Yardanico
andrewrk: zig build -Drelease-fast , yeah

1567801053
andrewrk
you also need exe.setBuildMode in there for each executable

1567801079
Yardanico
well I only have one executable

1567801178
andrewrk
what float parsing algorithm does nim use? looks like zig's current implementation is based on

1567801236
Yardanico


1567801312
andrewrk
looks like there are some other reasons the std lib parseFloat isn't its final form, there are some limitations listed there as well

1567802164
fengb
Worthwhile to port the nim code as a test

1567802843
andrewrk
the next thing I'm interested in as far as parseFloat goes is one that solves the problems - round trip accuracy, supports all the rounding modes, handling denormals, etc

1567802869
andrewrk
and then after that is thoroughly covered by test cases, I'd be interested in an implementation that improves perf

1567803229
Sahnvour
isn't the new ryu algorithm what we'd want to use in the end ?

1567803354
andrewrk
for rendering

1567803928
Snektron
Hm

1567803946
Snektron
I might replace the rpi with an arduino for the project i had zig in mind for

1567803953
mq32
andrewrk, regarding the last error i had: should i file an issue or did you fix it already? :D

1567803955
Snektron
Now that will be a fun experiment

1567803991
andrewrk
Snektron, AVR is tier 4

1567804051
andrewrk
not to discourage you, just so you know what you're up against

1567804130
Snektron
Yes i saw it, i'll probably take a quick stab at it and see where i will get

1567804162
Snektron
I assume clang's avr backend is pretty solid, and according to godbolt it can compile code for it without some crypting internal clang error

1567804192
mq32
Snektron, most interesting part is the bootstrap as well

1567804199
Snektron
Although its another "emit random symbols a random library should provide"

1567804206
mq32
AVR uses a boot jump table for interrupts

1567804222
Snektron
Hmm

1567804226
mq32
(so the table is built from jump instructions, not pointers)

1567804234
mq32
this may require some inline assembler

1567804245
Snektron
Nothing that seems impossible

1567804262
mq32
yep

1567804280
mq32
i got blocked for today, too lazy to rewrite my code that the compiler won't crash anymore :D

1567804281
Snektron
Anything to avoid the horrible processing ide am i right

1567804311
Snektron
I might actually use the project in an uni project

1567804328
Snektron
Saves me thinking of something else

1567804361
Snektron
Anyway, andrewrk, did you see the question about off_t, before i stupidly closed and reopened the issue

1567804691
Yardanico
fengb: well I got about from 11ms to 6ms in one iteration after using Nim's float parsing algorhitm which is faster than Nim parsing the same stuff (it got 9ms per iteration)

1567804714
Yardanico
when I had 11ms per iteration in Zig the fmt.parseFloat was about 45% of runtime

1567804759
Yardanico
now nim's float parser is about 9% of runtime (75% of runtime is now is actually used by LZMA decompression function from the C library :D)

1567804954
Yardanico
oh wow, I found an LZMA implementation in Zig on github, gonna also try that

1567805169
Tetralux
Yardanico: This is ten times faster than std.fmt.parseFloat:

1567805182
Tetralux
Only does basic floats though.

1567805192
Tetralux
(i.e: no scientific notation, etc.)

1567805279
mq32
return -nan(T)

1567805281
mq32
nice D:

1567805299
Tetralux
(I didn't check that part works yet) xD

1567805313
mq32
i think -nan is the same as nan

1567805331
mq32
the more interesting question is about signaling and silent nan

1567805343
Yardanico
Tetralux: for some reason on my machine your implementation is only about 60ns faster than fmt

1567805360
kristoff_it
Tetralux: I might steal that for my redis client. Redis has a simplified float type without scientific notation etc.

1567805365
kristoff_it
:)

1567805400
Tetralux
Yardanico: On mine, as measured by that program, std.fmt.parseFloat is 245ns, that parseFloat is more like 12ns.

1567805410
Yardanico
Tetralux: wow, why is that

1567805410
Tetralux
kristoff_it: Please do :p

1567805423
Yardanico
I build with --release-fast

1567805431
Tetralux
Yardanico: Likewise.

1567805489
Yardanico
Tetralux: maybe you have a more modern CPU so LLVM optimizies the binary to use some newer instructions?

1567805501
Tetralux
I have a 7700K.

1567805510
Yardanico
well I have i5-4460 :)

1567805633
Tetralux
Question: Is s = s[1..] legal for []const u8?

1567805641
Tetralux
Only it gives me a segfault.

1567805665
Tetralux
And I was under the impression that it's the elems that are constant.

1567805676
Tetralux
s is also a fn arg though.

1567805679
Yardanico
Tetralux: also for benchmarking there's a cool lib -

1567805690
fengb
Function args are always const

1567805703
Yardanico
it's for simple benchmarks but shows time per one iteration and you can customize number of them

1567805713
Tetralux
fengb: Compiler bug then; should give compiler error.

1567805726
fengb
But it shouldn’t seg fault

1567805755
fengb
So the s should be equivalent to `const s: []const u8`

1567805768
kristoff_it
average time: 18.8941849609375 ns

1567805769
kristoff_it
average time: 322.6269822265625 ns

1567805782
kristoff_it
from a rmbp 15

1567805801
Yardanico
whyy it's so slow for me hmm

1567805818
mq32
Yardanico, what do you mean by "slow"?

1567805824
mq32
taking 45% time?

1567805851
Yardanico
mq32: I'm talking about Tetralux's implementation, for me it's only like 17% faster :)

1567805876
shankar
hello

1567805876
Tetralux
And for it's like.... 10x.... 1000% faster? xD

1567805884
Tetralux
shankar: /me waves.

1567805887
Yardanico
maybe there's some kind of bottleneck in my system or something is wrongly configured

1567805927
kristoff_it
so now I crosscompiled it for linux and run it in docker, and... I'm still waiting for the first message to print

1567805931
mq32
perf stat may help!

1567805961
mq32
so you can compare cycle count, IPC, cache miss values and so on

1567805964
mq32
that may explain a lot

1567805999
mikdusan
Tetralux: is rhs value of s a zero-length slice?

1567806071
Tetralux
Nope

1567806090
Tetralux
s is more than two chars.

1567806243
mikdusan
maybe storage behind s went missing. anyhow i can't reproduce with just that alone.

1567807072
Tetralux
Okay. I also made it error if you give it too many digits, since that gives you garbage otherwise.

1567807082
Tetralux
I'll also note that the stdlib just gives you the garbage.

1567807090
Tetralux
(Paste updated.)

1567807110
Tetralux
kristoff_it: Might be interested in that ;p

1567807143
kristoff_it
Tetralux: noted, thanks!

1567807151
Tetralux
o7

1567807938
Tetralux
(Adds some clarity comments to the paste.)

1567808636
kristoff_it
Tetralux: thanks, I've saved it, I'll take a look more in detail once I understand a weird segfault that involves buffered in/out streams

1567808695
kristoff_it
Without a bufstream, everything works ok. With bufstreams, in debug mode, everything works ok. With bufstreams + release-safe/fast, I get a crash

1567808799
kristoff_it
the crash is related somehow to the length of the message I'm sending (so that makes me think it's memory corruption), but everything seems normal when inspecting the variable in gdb

1567808811
mikdusan
kristoff_it: paste code that creates and uses bufstream

1567808855
kristoff_it


1567808880
kristoff_it
this is where I instantiate everything

1567808928
kristoff_it
I remember that I must make sure to keep around the actual struct and not just the interface, I already made that mistake with rand in the past

1567808944
kristoff_it
so I'm storing basically everything in the struct

1567808978
mikdusan
`new.bufin = ... &new.in.stream;`

1567808981
mikdusan
and new.bufout

1567809004
mikdusan
by creating new as local inside initIp4 it's not using copy-elision.

1567809021
mikdusan
thus new is copied on return and those pointers become bogus

1567809046
kristoff_it
uhh ok

1567809049
mikdusan
set it up so your final line is `return Self{ .... };`

1567809059
kristoff_it
ok I'll try, thanks

1567809069
Yardanico
does anyone here know how to create a build.zig such that I'll be able to link a dynamic (.so) library with my binary?

1567809070
mikdusan
oh wait.

1567809082
Yardanico
it currently says "liblibrouter: linker needs 1 or more objects to link" and I don't know why is that

1567809088
mikdusan
we don't have syntax for you to self-ref a return value yet.

1567809107
mikdusan
so after Init(), set new.bufin and new.bufout

1567809111
Yardanico
build.zig looks something like that rn

1567809119
Yardanico
liblibrouter is liblibrouter.so

1567809351
Yardanico
However it works if I compile it with this command "zig run src/main.zig --library c --library src/liblibrouter.so --library-path /home/dian/projects/zigrs/src/"

1567809483
kristoff_it
mikdusan: sorry I'm not sure I follow what you're saying. I re-wrote the function with a final return Self {...} and now I don't get any crash. I updated the Gist with the new version.

1567809497
mikdusan
can u pastie the update

1567809513
mikdusan
ah got it

1567809636
mikdusan
i really wish we had `@result()` for this

1567809661
mikdusan
or even `@Self()` :)

1567809743
kristoff_it
mikdusan: I think you were onto something. The small test passes, but I have a more complex routine and that still crashes.

1567809753
mikdusan
just prepping a diff

1567810000
kristoff_it
I think I get it: this isn't fine either because I can't instantiate the bufs independently and only after place them in the struct. they need to be created directly in there, right?

1567810241
mikdusan
commented.

1567810308
mikdusan
i don't know what to call this... but it's a curiously recurring zig allocate-before-init pattern :)

1567810345
kristoff_it
ah wow ok in retrospect that's definitely the way to create everything directly in the right place

1567810355
kristoff_it
thank you very much, I'll try it now.

1567810366
mikdusan
i have a few typos there. but i'm almost sure this is the issue

1567810657
kristoff_it
mikdusan: perfect. everything works now, and I've even discovered a bug with .close() (I forgot to save the file descriptor in the struct) thank you very much!!

1567810676
mikdusan
👍

1567810707
fengb
Oh... I think you copied the socket streams and that broke the interface pointer

1567810723
mikdusan
yup

1567810726
kristoff_it
yeah, same thing that I did with the xoroshiro rand generator

1567810757
kristoff_it
this stuff actually the only annoying thing that I'm hitting regularly with zig

1567810825
mikdusan
kristoff_it: with this it would be possible to access call-site storage inside the init function:

1567810827
mikdusan


1567810934
mikdusan
so for one possibility is for a new builtin like `@result()` from inside fn body gives the correct pointer

1567811192
kristoff_it
that would make sense. also an error when a copy happens to something that should not be copied. If I encountered a flurry of "you're copying stuff that should not be copied" I would have eventually solved it, probably

1567811314
mikdusan
local stack address escape analysis is something that's been mentioned before and would make great for diagnostics. it likely wouldn't get

