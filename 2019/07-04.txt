1562199110
daurnimator
scientes: W^X is fine and a good thing. WX should be blocked.

1562199135
scientes
iOS doesn't allow either

1562199157
scientes
and Linux uses WX

1562199203
daurnimator
s/uses/allows/

1562199216
scientes
I mean the kernel

1562199252
scientes
it uses WX to hot patch hot patch the kernel

1562199259
scientes
with debug/trace code

1562199290
scientes
but yes, you can turn that off

1562206519
darithorn
are stack traces working in FreeBSD?

1562206641
andrewrk
I believe they were at one point, but stack traces currently have no regression tests on any platform

1562206664
andrewrk
zig's dwarf info code is not sophisticated enough to handle optimized builds yet

1562206728
darithorn
i get a partial stack trace (i forgot what you named it) but at the end of it I get a "Unable to dump stack trace: FileNotFound"

1562206784
andrewrk
maybe the source file for the code that's calling into your zig code cannot be found

1562206801
andrewrk
e.g. the libc source code for the system

1562206835
darithorn
hm i didn't think about that. i'll make sure the source is installed

1562206985
darithorn
it does mention "/usr/src/lib/csu/amd64/crt1.c" before saying it's unable to dump so maybe that is what's wrong

1562207000
darithorn
and i checked and that file doesn't exist

1562207255
andrewrk
the rest of the stack trace is probably not interesting

1562207259
andrewrk
that's the code that calls main()

1562207279
darithorn
yeah

1562207295
andrewrk
it's no big deal that it can't complete, the whole point is just to help you debug

1562207366
darithorn
yeah it normally wouldn't be a problem for me but it's "zig build" that's failing

1562207403
andrewrk
oh, look higher up, just like the most relevant stack frames are at the top, the most interesting error is at the top

1562207434
andrewrk


1562207898
darithorn
the top most just says "std.debug.warn("exec failed")" from std/build.zig line 779

1562207917
andrewrk
there should be something else above that

1562207997
via
is there any way to use lto with a c library built with gcc (and -flto) and a c library built with zig? when i try, the resulting binary actually just has a 0-sized program segment

1562208104
scientes
> <andrewrk> zig's dwarf info code is not sophisticated enough to handle optimized builds yet

1562208116
scientes
ahh that's why its failing when it tries to debug stage1 for me

1562208126
scientes
(probably)

1562208178
darithorn
this is the entire thing

1562208209
andrewrk
scientes, yes

1562208229
andrewrk
if you're interested in improving std/debug.zig it might be fun. dwarf is a standard with a PDF explaining everything

1562208262
scientes
that's why you had to remove that abort() from my patch

1562208268
andrewrk
right

1562208282
daurnimator
"fun" "dwarf"

1562208295
daurnimator
dwarf contains a full turing complete VM

1562208305
scientes
I actually feel debugging native code is a much better experience than interpreters/JITs

1562208305
daurnimator
you can do a

1562208323
scientes
the problem with making a new interpreter or JIT is that you have to write that stuff all over again

1562208354
andrewrk
via, I believe this is the first time this use case has been brought up, trying to do LTO across zig and non-zig code

1562208369
andrewrk
probably should be an issue. I can foresee a lot of potential problems with it

1562208406
scientes
yeah that doesn't sound like a very good idea

1562208435
scientes
not that it isn't possible

1562208438
scientes
it just sounds scary

1562208438
daurnimator
scientes: what?

1562208480
scientes
The C ABI really isn't that bad if you know what it is when you write to it

1562208505
daurnimator
scientes: I'm not sure what your comment is in reference to

1562208510
scientes
or maybe I misunderatnd what LTO is

1562208568
daurnimator
scientes: LTO is link time optimization. you emit your object files with all sorts of extra data to tell the LTO what it is allowed/not allowed to do

1562208587
scientes
is it the same thing as profile guided optimizations

1562208600
scientes
and its still just a sub-set, it isn't -fprofile=full

1562208602
daurnimator
and then when your objects are linked together to form e.g. an executable, the LTO is able to e.g. inline a function across object file boundaries

1562208630
daurnimator
scientes: profile guided optimization is usually about finding which branches/code paths are common and recompiling with hints to make the branch predictor happy

1562208635
via
for my project its been pretty helpful, i can have all these little functions like disable_interrupts, and nest it in wrapper functions and nest it deep, but it still bubbles up as just the single assembly instruction to disable interrupts

1562208641
via
rather than 4 branches and returns

1562208652
scientes
yeah but LTO is a funny term that brings many differn't things together

1562208661
daurnimator
scientes: not really

1562208670
daurnimator
LTO is optimization passes that happen at link time

1562208675
daurnimator
as oppose to compile time

1562208677
scientes
but its not the same as making all functions "static", that is -fprofile=full

1562208680
via
i would also call it whole program optimization

1562208693
via
automatic inlining across object file boundaries

1562208693
scientes
via, but it isn't that

1562208699
via
i mean, it does do that

1562208699
scientes
it doesn't analyze

1562208707
scientes
only a subset that is deemed to get the most benifit

1562208740
scientes
so its really just a set of optimizations that only can be done on the whole program

1562208742
daurnimator
isn't that exactly what optimization does?

1562208743
via
the compiler heuristics are still used to determine what should be optimized, sure, but it does do it across object file boundaries

1562208759
andrewrk
via, if your code is pure zig then it has whole program optimization because it only makes 1 object file

1562208765
scientes
so it would make alot more sense to know what those  opitmizations are

1562208769
daurnimator
"it only optimizes what is worth optimizing" -> well yeah; what else did you expect?

1562208777
scientes
i.e. 1) inlining, 2) profile branch prediction scheduling

1562208786
andrewrk
scientes, PGO is an entirely separate thing

1562208789
scientes
3) function splitting

1562208789
via
andrewrk: yeah, but as i learned this morning i can't directly use libopencm3 in zig

1562208795
via
yeah, i feel like you're confusing a bunch of things

1562208813
scientes
there could also be a LTO register allocator

1562208816
scientes
but there isn't

1562208822
scientes
I am doing a project right now that could use that

1562208861
scientes
where you unroll a outer loop into an inner loop to maximize OOO multi-issue

1562208883
scientes
but that is quite specialist, so probably should just be done by hand

1562208893
daurnimator
why does this make it scary/"not a very good idea"

1562208903
via
i, and i think most others, use whole program optimization to just mean across object boundaries

1562208927
via
which yeah, uses some extra info in object files which i guess is mostly compiler/linker specific

1562208998
scientes
it might actually work quite well with zig

1562209005
scientes
as zig would be doing all the compiling

1562209017
via
it does dead code elimination, automatic inlining ... and at least in my project, produces pretty significant performance gains due to the lack of branching

1562209021
daurnimator
via: so LTO with GCC works by adding GIMPLE bytecode to the objects

1562209030
scientes
what is scary is when you take a stable ABI from a shared library, and suddenly don't actually use it

1562209046
daurnimator
via: I would not expect GIMPLE in those objects to be useable by lld

1562209054
via
yeah, i figured lld couldn't use it

1562209055
scientes
because you are pretending that function is static and doesn't follow the C ABI anymore

1562209067
daurnimator
via: but at the same time, I would have expected lld to be oblivious to them; and end up just not doing LTO. rather than a 0KB output

1562209075
via
scientes: this is a static library i'm linking into a static freestanding executable

1562209088
via
daurnimator: yeah, it does seem like a weird results, i expected that too

1562209110
scientes
if its made to be static, I can see that you would want all the performance you could get

1562209110
daurnimator
via: my first thought is that maybe lld doesn't know the entry point(s), and ended up garbage collecting

1562209120
scientes
and then it would make plenty sense

1562209127
daurnimator
scientes: you're mixing

1562209163
scientes
well I see the terms, but rarely do they actually describe the transforms

1562209185
via
that was my thought too, that maybe i need to make sure that my entry point is kept -- i know if i were using lto just with libopencm3 and a bare c file with no entrypoint, everything would get eliminated as dead code

1562209201
via
but since it own't work anyway, i'll just not use lto and see how bad the hit is nowadays

1562209203
scientes
and they aren't concepts, C is a as-is language, so as long as the program runs as-is it is fine

1562209213
scientes
the question is what ABI/APIs you implement

1562209239
daurnimator
via: so first thing I'd so is to just swap to compile libopencm3 with clang instead of GCC

1562209293
via
yeah, i can try that

1562209314
via
though i need a clang arm cross compiler first

1562209328
daurnimator
via: hint: zig is one

1562209341
scientes
^^^^

1562209342
daurnimator
via: `zig cc` <-- is built in clang cross compiler

1562209359
via
can i just use CC='zig cc' with an existing makefile based c project?

1562209364
daurnimator
yep

1562209379
scientes
and it can build like 15 differn't architectures

1562209383
daurnimator
though for a cross compiler you might need -target or similar

1562209448
scientes
if it only supports gcc cross-compilers that is

1562209510
scientes
you can just do CC="zig cc -target arm-non-eabi" however

1562209532
darithorn
i found what was causing the issue. i had a recursive data structure

1562209573
via
yeah, though now i need to figure out how to make clang build with hard float for this arch, and lto. which i can do, but i might call it a night and do it in the morning

1562209584
andrewrk
`zig cc` won't provide libc and compiler_rt though. but you can use `zig build-exe --c-source [flags] foo.c` to do that

1562209616
andrewrk
you probably want musleabihf

1562209618
via
compiler-rt might be needed for a few things, and libopenc3 is pretty big, i don't know if i can build the whole project that way

1562209629
via
why would i need to link in musl?

1562209642
via
maybe i misunderstand

1562209644
andrewrk
you don't but that will at least communicate that "hard float" is part of the target

1562209647
scientes
via, that is the abi, you don't have to use a libc

1562209655
via
oh, ok

1562209692
andrewrk
libopenc3 will be a good candidate to port to the zig package manager. then it'll be real easy to cross compile using it, whether with C or Zig

1562209693
scientes
(and if you don't the glibc and musl variants are the same)

1562209718
via
one remaining piece of output t odeal with is this: /usr/include/stdint.h:26:10: fatal error: 'bits/libc-header-start.h' file not found

1562209727
via
not sure why its using what looks like my system stdint.h

1562209761
via
and yeah, maybe unobvious, but i'm a huge fan of libopencm3, and i really would love to move past C to something else for a lot of what i'm doing

1562209783
scientes
via, you actually probably want musleabi, i don't think that has a FPU

1562209799
via
my chip has an fpu

1562209807
scientes
oh, then musleabihf

1562209833
via
and i use the crap out of it :p

1562209847
scientes
do any of those have NEON?

1562209873
via
don't think so, its just a cortex-m4f (stm32f407)

1562209916
andrewrk
the package manager is still vaporware at the moment, but you could bundle libopenc3 source into your project and build it with zig build system. that will auto cache it, and cross compile it, and supply compiler_rt to it

1562209918
via
project is a engine control system (ignition and fueling), fwiw, open source, currently in C, evaluating porting to zig

1562209932
scientes
add they created Helium for doing SIMD on low-end chips

1562209941
scientes
cause neon is too bulky

1562209948
andrewrk
you can see an example of mixing C and Zig code here:

1562209953
via
yeah, i bundle it now, and this morning was building it as a static lib and linking to it -- and that does work

1562209966
via
though it wasn't being built by zig

1562209977
andrewrk
I only mention building it with zig because zig will cross compile it for you

1562210000
via
yeah, that would be nice, though it might take a lot of work to get that working

1562210041
via
i'll play around with it in th emorning, i'm much more of a 7am-10pm east coast person

1562210049
via
thanks for the help

1562210060
andrewrk
np see you later

1562210108
scientes
ooo helium has scater-gather

1562210612
daurnimator
andrewrk: nice, #1717 now accepted :)

1562210621
daurnimator
andrewrk: so what is the next thing you're working on?

1562210833
andrewrk
bugs & PRs for a bit

1562210917
andrewrk
coroutine rewrite branch is also in progress:

1562210985
scientes
yeah i saw that when i fetched origin

1562211083
scientes
#1717 is so beautifully written-up

1562211373
hryx
holy shit

1562211417
hryx
very exciting about #1717 !

1562211488
hryx
(and thanks scientes)

1562212164
emekankurumeh[m]
i don't quite know how i feel about that proposal

1562215616
andrewrk
"switch army knife"

1562224415
emekankurumeh[m]
we have comptime to force compile time execution but is there a way to force runtime execution?

1562224688
daurnimator
emekankurumeh[m]: why would you want to?

1562224726
daurnimator
emekankurumeh[m]: and it doesn't entirely make sense... usually there are many subexpressions that do get run at comptime

1562224727
emekankurumeh[m]
i'm trying to write a lazy opengl loader (ie functions are only loaded when called)

1562224764
daurnimator
dlopen?

1562224821
emekankurumeh[m]
so i was thinking i could have the functions defined as `const fn_name = dlopen(opengl_dll, "fn_name");`

1562224836
emekankurumeh[m]
^psuedocode

1562224883
emekankurumeh[m]
and when the function is called that would be the dlopen would be done at runtime

1562224928
emekankurumeh[m]
but now i'm thinking i could do this in a much simpler way

1562225308
daurnimator
emekankurumeh[m]: you get functions from dlsym, not dlopenm

1562225433
emekankurumeh[m]
I know, that's what I meant in part by pseudocode

1562234035
very-mediocre
the new (i think?) default values for struct members can be such a huge ergonomics improvement

1562234185
very-mediocre
after just a few more kinks get ironed out this is going to be a very pleasant language to work in

1562235174
samtebbs
very-mediocre: That's what I've been saying to everyone at work :D

1562237516
ntgg
Is there a way to conditionally have a function in a struct?

1562237629
ntgg
something like ```fn Foo(comptime size: usize) type { return struct { data: [size]u32, if (size > 0) { fn first(self: Foo) u32 { data[0] } } } }```

1562237636
samtebbs
I can't think of a nice way, but I can give you a less-nice way

1562237801
samtebbs
ntgg:

1562237909
ntgg
Thank you! looks a little hacky, do you know if something like what I have is planned in the future?

1562239136
very-mediocre
Has this ever been considered for zig?

1562239168
very-mediocre
it'd help eliminate a very, very common and annoying pattern

1562239264
nifker
very-mediocre: Not sure about the differences but - isnt that quite the same as

1562239285
very-mediocre
No, try is for userland-defined error sets

1562239301
Tetralux
very-mediocre: You mean like x.?

1562239310
very-mediocre
`.?` means `orelse unreachable`

1562239330
very-mediocre
so your program dies at runtime if a chained property is null

1562239330
Tetralux
.. Whereas you mean "orelse null"

1562239339
very-mediocre
Yes, `orelse null` but chainable

1562239370
very-mediocre
Take `someone.something.something_else.value`, if any of those is optional you have to unwrap it separately before chaining it

1562239385
very-mediocre
that all adds up

1562239402
very-mediocre
whereas I'd like the entire expression to evaluate to null if at least 1 of the chained values is null

1562239411
very-mediocre
someone?.something?.something_else?.value

1562240520
very-mediocre
I just found myself writing this abomination: std.debug.warn("-- {}\n", if (root_node.nodes) |nodes| if (nodes[1].symbol) |sym| ([_]u8{@intCast(u8, sym.val)}) else null else null);

1562241051
very-mediocre
would be much better if you could do `std.debug.warn("-- {}\n", if (root_node.nodes?[1].symbol?.val) |val| ([_]u8{@intCast(u8, val)})[0..] else null);`

1562241776
samtebbs
very-mediocre: That's an interesting idea, what syntax would you propose?

1562241816
very-mediocre
`someone?.something?.something_else?.value`

1562241873
samtebbs
IMO that's too similar to .?

1562241934
very-mediocre
.? could be deprecated and you'd just do something like `someone?.something?.something_else?.value orelse unreachable`

1562241935
samtebbs
Could do `something.!value` but that can be confused with the exclamation mark used in error returns

1562241956
very-mediocre
admittedly it's not the same

1562241959
very-mediocre
hmm

1562242033
samtebbs
Does `null orelse unreachable` evaluate to `unreachable`? If so that would do the same thing

1562242057
very-mediocre
same outcome but you lose granularity about which expression triggered the `orelse unreachable`

1562242093
very-mediocre
eh, that's very narrow though, I would argue in favor of deprecating .? after all

1562242106
mikdusan
or `a?.b?.value` for optional chainging, and `a!.b!.value` for unwrap chaining and deprecate `.?`

1562242191
very-mediocre
I like that

1562242227
very-mediocre
fyi. what I've been doing is sneaking in some spare time to write some serious zig code, and I keep feeling the lack of this pattern

1562242255
Flaminator
Do you have many optionals in your code?

1562242259
very-mediocre
yes

1562242284
very-mediocre
situations like when you're dealing with nodes that may or may not have child nodes

1562242304
scientes
C# has that (i've never used C#, just heard about that feature)

1562242393
mikdusan
hmm mind for grammar right now error unions use `!` which might be a conflict. eg. tons of `Error!void` use in std so a suffix `!` for unwrap operator might have grammar conflicts

1562242419
scientes
! is always exceptional

1562242422
scientes
*also

1562242540
scientes
I would like to keep the . in the syntax

1562242586
samtebbs
mikdusan: That was my reservation too

1562242612
samtebbs
`.&`?

1562242619
scientes
ewww

1562242634
very-mediocre
scientes? what benefit does the . provide?

1562242637
scientes
& already has two uses (three in C)

1562242642
scientes
its a method

1562242650
scientes
it makes it clear it isn't part of the symbol

1562242653
very-mediocre
(i accidentally just optional'd scientes' name)

1562242667
scientes
in ruby its custom to use ? as part of symbols that return bool

1562242707
mikdusan
so dumb question. why can't analysis figure `.*` to deref a pointer, and `.*` to unwrap ?

1562242720
scientes
it can

1562242734
mikdusan
and then that frees up .? for optional null check.

1562242749
scientes
but it would require some re-writing which we already need to do element extraction from vectors vector[3]

1562242749
very-mediocre
? as a suffix is currently an invalid character for a symbol anyway, I don't see the importance of the .

1562242785
scientes
yeah but people learning the language don't know that

1562242789
very-mediocre
likewise ! as a suffix isn't currently allowed, so it's distinct from error sets

1562242817
very-mediocre
scientes: i dunno, almost all other languages use the prefix and I have to say it looks really natural and readable (

1562242821
very-mediocre
suffix*

1562242850
scientes
oh i see .& might be reasonable

1562242860
scientes
actually its weird, because its actually a dereference

1562242865
scientes
and you are taking the address

1562242890
mikdusan
i like `.*` for deref/unwrap, and `?` for optional chaining, the latter esp because other langs have popularized it

1562242908
scientes
yes, but with a .

1562242911
scientes
.* and .?

1562242946
scientes
which would make .* unsafe and .? safe

1562242949
very-mediocre
mikdusan: + it works as a counterpart to ? prefix denoting an optional. The current ? prefix communicates you know in advance it can be null, while a hypothetical ? suffix communicates a query about whether it's null

1562242975
scientes
oh yes the consistancy is nice

1562242997
mikdusan
very-mediocre: yeah if given choice `?` more of a null query to me, than an unwrap operation

1562243021
very-mediocre
it's a query with an implied "orelse (entire expression) is null"

1562243039
scientes
but the difference between .* and .? is similar to . and -> in C and most languges have dropped that because in most code you don't give a shit which is which

1562243071
very-mediocre
I like -> because I like to remember I'm using a pointer

1562243073
scientes
(and now C++ has that with references)

1562243083
scientes
yeah but with zig pointers they are both safe

1562243100
scientes
and c++ reference are the same thing

1562243124
scientes
i prefer without c++ because i spend so much time recompining my code to fix them all

1562243140
scientes
but yeah it does make the data structure a little clearer

1562243359
very-mediocre
I think it isn't inconsistent to have .* and ? (without the .), the former is accesses something through an indirection, while the latter doesn't represent an access

1562243387
scientes
scala does it with the .

1562243394
scientes
val name = article.?.author.?.name : @ ?

1562243409
scientes
oh its a library

1562243424
Flaminator
Imo having to get null in a round about way is a good thing.

1562243445
scientes
yeah, what if you want to do a differen't thing with null at each level of dereference?

1562243461
scientes
this sort of thing is only common is certain specific situations

1562243466
very-mediocre
then you can always use the verbose status-quo style

1562243513
mikdusan
scientes: sure, json and petty much anything with recursive maps benefits from optional chaining

1562243522
mq32
scientes: I only know the "?." operator from C#, but i used it a whole lot of times

1562243532
mq32
most common use case in c# was something like

1562243546
mq32
var x = obj?.a ?? sane_default;

1562243564
mq32
where ?? is the equivalent to the "orelse" operator of Zig

1562243574
scientes
we use that have ??

1562243577
scientes
orelse is better

1562243597
mq32
i'm also a fan of more verbose operators

1562243603
scientes
Like perl is almost incomprehensible if you aren't familiar with it

1562243610
mq32
i'm even using "and" "or" and "not" in C++

1562243611
scientes
using English when the English is clear is good

1562243619
scientes
mq32, with a macro?

1562243625
mq32
nah, it's actually builtin!

1562243631
Flaminator
Pretty sure and or and not are build in.

1562243638
mq32
C++ has the iso646 operator set builtin

1562243644
scientes
oh weird

1562243649
scientes
do you have to use some header for that?

1562243658
mq32
Flaminator: it is. But not in Microsoft C++ except you have a "PLEASE CONFORM WITH STANDARD" compiler flag set

1562243660
mq32
nope

1562243663
very-mediocre
re:verbosity: for that reason .? can be replaced with `orelse unreachable`, if anything this kind of assertion-ish scenario might be too important to use a shorthand

1562243672
scientes
well I use C

1562243676
mq32


1562243684
mq32
in C you have to, it's iso646.hj

1562243685
Flaminator
I think most operators have an alternative. xor/or/and and their _eq brothers.

1562243687
scientes
so if it isn't available in C I am not really itnerested

1562243691
scientes
oh cool it is

1562243695
scientes
yeah i'll probably use that then

1562243718
scientes
oh yeah I think dpkg uses that

1562243730
mq32
has somebody already made a request to change && || and ^ in Zig to the literal versions?

1562243774
Flaminator
Pretty sure && and || are not valid operators.

1562243811
fengb
|| is error set merges. && is invalid atm

1562243819
mq32
ah wait

1562243834
scientes
no, the binary operators are much rarer than the bool operators

1562243838
mq32
i messed up, Zig has "and" and "or", but no "not", instead it has the C version

1562243840
scientes
so I think they should stay same as C

1562243854
scientes
but that is my opinion

1562243860
mq32
sorry 'bout that

1562243867
scientes
but yeah && and || in C are ugly

1562243892
mq32
but on the topic of the syntax of the safe navigation stuff:

1562243922
mq32
i prefer the "?." syntax over ".?" because it reads more "logical" (in terms of "left to right")

1562243986
fengb
I prefer `.x` because it seems to be a decent standard for postfix operators

1562244034
scientes
ekkk, use a valid symbol?

1562244045
scientes
I think that is a bad idea

1562244059
very-mediocre
.* is an indirection, it evaluates to what the pointer points to (access operation). The proposed ? does not evaluate to the result of accessing an indirection, so the . seems unintuitive.

1562244086
very-mediocre
something? evaluates to something or null, not the "contents of" something

1562244099
fengb
Contents of null unwrap

1562244137
very-mediocre
in the chain example the unwrapped value doesn't get exposed

1562244156
samtebbs
very-mediocre: But having `something?` by itself makes no sense

1562244179
samtebbs
it expands to `if (something == null) null else something`

1562244189
samtebbs
Which is just `something`

1562244208
very-mediocre
Zig doesn't let you use an optional for safety reasons

1562244217
samtebbs
It only make sense when you're accessing the contents of that something, hence why you'd need to add the `.`

1562244226
very-mediocre
ok, sure, but the main point is chaining

1562244238
very-mediocre
i see your reasoning wrt. it being an access

1562244283
very-mediocre
but it's still not quite an unwrap

1562244293
very-mediocre
something.? might be null, i wouldn't call that an unwrap

1562244325
very-mediocre
or rather i wouldn't call that a `capture` if we're going to be accurate

1562244331
very-mediocre
so it wouldn't be an access

1562244342
very-mediocre
ahh, too theoretical.

1562244356
samtebbs
Yeah the only way to unwrap that I've encountered is `if (something) |something_unwrapped|`

1562244434
very-mediocre
I think the theory is futile, there's no objective answer. I find it intuitive to read `something?` in a certain way, I guess other people find `something.?` more intuitive. Either way I think that's ultimately moot. :)

1562244454
fengb
I'm just offering consistent postfix syntax >_>

1562244501
very-mediocre
I understand, but it depends on how you read it. I don't read it as a "true" indirection the same way a pointer dereference is/

1562244568
fengb
.* was added for disambiguity, not necessarily for access

1562244579
very-mediocre
anyway the . discussion is premature, the question is, do you folks think this is worth a proposal?

1562244606
fengb
Of course... we don't have a ? infix operator but I would kinda like all postfix operators to have the same parsing technique

1562244633
mikdusan
very-mediocre: i think we need an optional chaining solution. yes.

1562244744
very-mediocre
fengb: Maybe controversial, but I don't think "postfix" is a general concept that the language design ought to conform to.

1562244793
fengb
I don't understand what you mean. foo? is a postfix operator already

1562244793
very-mediocre
you say postfix, I say access operator (tomato, tom-ah-to)

1562244806
fengb
The ? is postfix by parsing

1562244824
very-mediocre
Yes it's a suffix, but I don't see that as a useful way of categorizing things

1562244848
very-mediocre
and i don't see consistency in that regard as a goal, insofar as .* would require .? and not ?.

1562244849
fengb
Language grammar should be simple... and Zig has made many decisions to err on simplicity

1562244851
mq32
fengb, i think very-mediocre thinks of "postfix operator" in terms of usage, not grammar: "i++" would be postfix, "i.j" would be infix/access

1562244907
fengb
Infix is i * j

1562244965
samtebbs
Postfix is just the position in the parsing term, nothing to do with semantics

1562244997
mikdusan
waat i thought you guys were talking about an email server this whole time

1562245033
very-mediocre
it's too theoretical if you ask me

1562245066
samtebbs
very-mediocre: But yeah open up a proposal and let's have this discssion in an issue, where it can be formatted and recorded nicely

1562245076
very-mediocre
imho the final outcome is what counts most, except if it's prohibitive to implement in the parser

1562245092
very-mediocre
I'll do a short writeup soon and float both syntax options

1562245170
very-mediocre
for whoever wants to delve into the theory:

1562245174
very-mediocre


1562245193
Flaminator
I atleast think it's best to have it something like ".{sign}" like it is now with ".*" and ".?".

1562245218
very-mediocre
this . seems quite divisive :)

1562245242
very-mediocre
reminds me of several months back when .{.member=1} was in a proposal

1562245245
very-mediocre
i dub that the nipple operator

1562245256
very-mediocre
(not a fan)

1562245288
fengb
Not a fan of nipples?

1562245297
very-mediocre
not in programming languages :)

1562245306
samtebbs
lel

1562245685
scientes
nipple operator

1562245813
very-mediocre
I was more focused on the chainable optionals operator, I didn't note any consensus on an unwrapping operator, shall I just leave that out?

1562245895
mq32
what would be the unwrapping operator? "ignore that this optional may be null and just do what i say?"

1562245958
fengb
Oh we already have the `.?` operator

1562245981
fengb
`a.?` equivalent to `a orelse unreachable`

1562245985
Flaminator
Yes the .? operator is basicly value orelse unreachable.

1562246010
very-mediocre
it would be deprecated, and mostly replaced by `something?.value orelse unreachable`

1562246024
very-mediocre
and imho i prefer a more verbose "orelse unreachable" than a shorthand for it, but that's just me

1562246055
very-mediocre
mq32: good question, I've thought of it a certain way but I'm not sure I'm aligned with what mikdusan was talking about

1562246104
mikdusan
i was suggesting that since we already have `.*` to deref pointer and that's likely not going anywhere,

1562246191
mikdusan
that compiler could be enhanced to allow `.*` to be used

1562246257
very-mediocre
I assumed it would work on errors -> `catch unreachable`

1562246264
mikdusan
thus freeing up `.?` in the case that is used for optional chaining. or in the case just `?` is used for optional chaining, removing `.?` for unwrap makes things clearer

1562249162
kristoff_it
Hi all, I posted

1562249296
kristoff_it
I have very dumb questions in my mind such as "are streaming parsers worth it if you have to call the function on every single input character?" or "will I incur in any bad performance problem if I set off trying to keep the parsing logic completely separate from the networking code?"

1562249403
very-mediocre
This guide is great:

1562249420
very-mediocre
re: 1st question

1562249576
Tetralux
I don't quite know what you mean by "called on every character" -- you'd probably more take a slice of bytes---a 'chunk' of newly read data from the stream, and then process it as much as you can.

1562249596
Tetralux
You wouldn't call it on a per character basis.

1562249603
Tetralux
You'd call it on a per-chunk basis.

1562249619
Tetralux
But maybe I'm missing some nuance here.

1562249998
very-mediocre1
Wrote the proposal btw:

1562250821
via
figured i'd report back, building the library with clang using -O3 and -flto did allow zig to automatically inline functions from the lib

1562251047
via


1562251118
via
vs this:

1562251251
via
though even if i just have one call to toggle_blink, zig doesn't seem to want to inline it even with release-fast, but meh, this is still pretty great

1562252322
andrewrk
kristoff_it, I think those are good questions, and even experts in this community would need to write code and benchmark it to find out the answers

1562252365
kristoff_it
very-mediocre: thanks I'll check the link out

1562252480
kristoff_it
Tetralux: check this out for example

1562252558
kristoff_it
andrewrk: thanks, I imagine getting everything precisely right is non-trivial and probably use-case specific, I'm mostly interested in common practices so that I don't endup rediscovering fire after burning myself multiple tiems

1562252570
andrewrk
streaming where possible is certainly common practice

1562259884
marler8997_
Why are function parameters always const?

1562259940
hryx
marler8997_: I asked that once in an issue and got a good response, let me find the link for you

1562259964
hryx
here you go

1562260039
marler8997_
> If you need a mutable parameter, var foo = param; is an easy, reasonable way to get it, that comes at no performance cost.

1562260048
marler8997_
no performance cost?

1562260105
andrewrk
if zig were to introduce mutable parameters, it would have  to secretly generate `var foo = param;` to make them work

1562260129
marler8997_
is that an LLVM-ism?

1562260185
marler8997_
does that result in 2 copies?  one copy from the caller and one copy inside the call?

1562260229
andrewrk
for scalar types such as integers and floats, the concept of a "copy" doesn't make sense

1562260251
marler8997_
one MOV from the caller to the function frame, and one MOV from the function frame to a local variable

1562260263
scientes
frame?

1562260268
scientes
you usually pass in variables

1562260275
scientes
*pass in registers

1562260289
marler8997_
depends on the ABI, but the question still applies

1562260308
marler8997_
why force the user to have to move the data twice?

1562260316
scientes
marler8997_, LLVM is SSA

1562260326
scientes
so it doesn't know what variables even are

1562260348
scientes
so as andrew says, it doesn't really a concept of copying them

1562260357
andrewrk
there's no data being moved twice, unless you actually want a copy of an aggregate type. if you don't want a copy of an aggregate type, don't make a copy

1562260371
marler8997_
I am using an aggregate type

1562260394
andrewrk
then pass it as immutable, in which case there is no copy, or pass a mutable pointer if you want to mutate it

1562260404
marler8997_
I need to be able to modify it

1562260409
marler8997_
but I don't want to modify the caller's copy

1562260415
andrewrk
so you want a copy

1562260417
andrewrk
make a copy

1562260424
marler8997_
but isn't the parameter already a copy?

1562260427
andrewrk
no

1562260431
marler8997_
oh?

1562260446
andrewrk


1562260448
marler8997_
that's what I'm not understanding

1562260635
scientes
marler8997_, also if it is only 16 bytes its probably getting passed in registers in which case the copy is quite cheap

1562260660
scientes
actually i think that works up to 32 bytes in general

1562260675
scientes
"homogenous aggregates"

1562260686
scientes
but that's only when calling C

1562260687
marler8997_
but it says "no performance cost"

1562260691
marler8997_
yet it's still doing 2 copies

1562260705
marler8997_
if the parameter is able to be mutable, then wouldn't you have one less copy?

1562260709
scientes
marler8997_, do you have a godbolt paste to show?

1562260710
marler8997_
if you needed to modify it?

1562260714
marler8997_
I'm working on one

1562260753
andrewrk
note that the docs I linked are for zig functions, not C ABI functions

1562260788
scientes
yeah i realized i was kinda spreading confusion about the diff.

1562260805
scientes
zig functions are basically the same as "static" in C

1562260903
marler8997_
hmmm interesting

1562260909
marler8997_
so it got passed by reference

1562260928
marler8997_


1562261027
scientes
no you can paste from godbolt

1562261238
scientes
I just spend like 3 hours debugging a showed variable in C

1562261242
scientes
*shadowed

1562261292
marler8997_


1562261300
scientes
and there was no compiler warning

1562261433
scientes
your debug statements will change the behavior of a function like that

1562261460
marler8997_
because I'm taking the address of the data?

1562261504
scientes
yeah if you turn on optimizations it inlins the function

1562261517
andrewrk
marler8997_'s example shows pointer addresses to show whether or not copies occur and it's notable whether they happen in debug builds

1562261520
scientes
so clearly the answer is just "you need to turn on optimizations if you are going to complain about optimization problems"

1562261535
scientes
oh i see

1562261536
andrewrk
scientes is incorrectly assuming that we want to look at optimized release builds for this example

1562261562
marler8997_
not complaining about optimization, I'm asking why parameters are alwayas immutable

1562261577
marler8997_
it sounds like the reason is because parameters aren't necessarily a copy

1562261595
marler8997_
I'm just use to C, so this is very different

1562261619
scientes
the static analyzer could still figure that out, even in C. But I think it prevents a footgun , you can always just copy out of the parameter

1562261648
andrewrk
marler8997_, you can use e.g.  "{*}" and `&tpInMain` and it will print pointer format

1562261677
andrewrk
so: &tpInMain = TwoPointers@7ffede378050 \n &tpInFoo = TwoPointers@7ffede378050 \n &tpCopyInFoo = TwoPointers@7ffede378030

1562261691
andrewrk
this backs up what I said earlier: the only copy is the one you make

1562261696
marler8997_
yeah

1562261733
andrewrk
for C ABI functions, one would have to rely on the optimizer to elide the copy

1562261765
marler8997_
are extern C function parameters also forced const?

1562261819
andrewrk
yes

1562261842
scientes
It means that you can always access the parameters that were passed

1562261849
marler8997_
hmmm, I think ideally those would be treated differently

1562261855
scientes
which eliminates stress for the programmer

1562261857
marler8997_
but probably not a big deal

1562261883
marler8997_
since it would be fairly rare

1562261907
scientes
what I do if I want to change it is call the parameter _foo, and then assign it to foo

1562261946
scientes
auto with auto typing it works pretty well

1562262022
marler8997_
one thing that's confusing is that the type of the parameter looks mutable even though it's const

1562262038
marler8997_
what if you required the function to declare it as const?

1562262058
scientes
just set it const

1562262104
marler8997_
sure, but what about the use case I talked about.  It's still const even if you don't include const

1562262117
scientes
no it isn't

1562262121
scientes
because you can assign it to a var

1562262140
scientes
oh wait, that isn't right

1562262166
andrewrk
marler8997_, it's consistent with all the other capture variables

1562262173
andrewrk
for (array) |item, i| {}

1562262188
marler8997_
that one doesn't have a type

1562262228
scientes
everything has a type

1562262239
mikdusan
he means lexically

1562262246
marler8997_
it doesn't have an explicit type like a function does

1562262249
scientes
oh yes

1562262280
scientes
the point is that you can always use the parameters as they were passed, those never get shadowed

1562262290
andrewrk
that's correct, currently true everywhere

1562262333
marler8997_
that's irrelevant to my point, I'm talking about putting const on the parameter type now

1562262352
marler8997_
not making the parameter mutable

1562262362
scientes
it has an effect if it is a slice or pointer to const data

1562262402
marler8997_
hmmmm, I'm still learning these new semantics, you can't specify (const u8) in a function parameter

1562262412
marler8997_
so you can't even do what I'm proposing anyway

1562262539
marler8997_
D handles const completely differenty.  It's always a type modifier.  Whereas in zig, it's a type-modifier when you're talking about pointers and arrays, but it's also associated with other things such as whether it's a parameter/loop variable

1562262563
marler8997_
I should say "head const" is handled differently

1562262565
scientes
thats because there is "var" and "const"

1562262577
marler8997_
well D has that too, but it modifies the type

1562262590
marler8997_
const foo = 0;  (typeof foo is (const int))

1562262606
scientes
actually const comptime_int

1562262608
marler8997_
in zig, it doesn't modify the type

1562262617
marler8997_
that example was in D, not Zig

1562262617
andrewrk
`const int` doesn't make sense, but `*const int` does

1562262639
marler8997_
can you elaborate on that one andrew?

1562262640
andrewrk
mutability describes locations, not types

1562262660
marler8997_
sure, but the type could reflect the mutability of it's location as well

1562262675
andrewrk
it doesn't make sense that a type knows its location

1562262689
marler8997_
why not?

1562262786
marler8997_
if you think about it, you can put any information you want into a type, of course whether or not you should is another question

1562262814
marler8997_
you could have the type know it's location, who owns it, whether it's a pointer that ends with a null value, etc

1562262822
hryx
if type information were to include location, wouldn't every single variable have a different type?

1562262841
marler8997_
yeah that would be the extreme side of it, that each value has it's own type

1562262875
marler8997_
but we weren't saying it would include it's location, just that it's location could modify the type

1562262895
marler8997_
andrew doesn't think that makes sense and I'd like to understand why that is

1562262979
marler8997_
it looks like in Zig, head-const is determine by the variables location, and tail-const is stored in the type

1562263077
marler8997_
I'm not sure whether that's a good or bad choice, just trying to understand the reasoning

1562263852
mikdusan
is `zig --help` missing text for `--override-lib-dir` to limit help noise, or is it bonafide oops missing?

1562263888
andrewrk
oops missing

1562264029
marler8997_
I'm thinking about the consequences of not including head-const in the type, one use case that comes up is struct members

1562264038
marler8997_
is there a way in zig to declare a struct member as head-const?

1562264086
andrewrk
there is not

1562264106
marler8997_
any research/discussion on that?

1562264124
marler8997_
I've read that making things "const" reduces strain on the developer and the argument has been used for other features

1562264130
andrewrk
I'm not aware of any open issues

1562264179
marler8997_
from what I'm gathering at the moment, whether or not a type is head-const can usually be inferred from it's location, so including it in the type would be redundant

1562264211
marler8997_
however, in the case of struct members, since there's not way currently to declare a member as head-const, the type could be used in this case to declare whether or not it's head const

1562264230
marler8997_
but of course, there could be other ways, just saying that this is a case where having it in the type would not be redundant

1562264268
very-mediocre
hryx: re: proposed ? suffix in #2816 -> it rhymes with the existing ? prefix that defines optionals in the first place [

1562264304
very-mediocre
erroneous ] at the end of that url

1562264508
hryx
if George Lucas says it's a good idea then it must be. case closed!

1562264510
marler8997_
still thinking on this...if we look at the function parameter case, head-const could be used to make parameters mutable/const without needing copy the parameter into a local variable.  The compiler would essentially generate the "var fooVar = fooParam" when the parameter is declared as mutable

1562264557
marler8997_
So in that case, head-const and non-head-const parameters would have different semantic meaning, thus not redundant in that case either

1562265455
very-mediocre
has anyone here worked on deflate? I'd be interested in sharing notes

1562265999
hryx
very-mediocre: is your deflate project on github? you should totally link to it from one of the issues

1562266024
hryx
specifically

1562266054
very-mediocre
It's extremely un-presentable tbh

1562266092
hryx
I know the feeling

1562266104
very-mediocre
I have extremely limited time, in 3 days I'm going to receive a 6-month project ;|

1562266113
hryx
still, maybe if you offer it as a very WIP experiment and invite comments, it came make progress

1562266122
hryx
oh dang

1562266127
very-mediocre
Will consider.

1562266153
very-mediocre
I'm a bit stuck on Huffman coding, which is not that complicated but I wasted too much time on the RFC which is ambiguous

1562266189
very-mediocre
There's a lot of "unsaid" stuff - like pruning the hashtable that's used during Lz77 search

1562266216
very-mediocre
i figured if it's always a fixed 32kb, may as well do a LRU memory pool, which I've now done

1562266221
very-mediocre
tl;dr: it's a huge mess

1562266264
very-mediocre
The "learning" reference zlib implementation is inflate (decoding), which is much easier than encoding

1562266497
emekankurumeh[m]
you're writing it from the spec?

1562266507
emekankurumeh[m]
why not port an existing implementation?

1562266534
emekankurumeh[m]
like miniz

1562266546
very-mediocre
Mark Adler is going around telling people to learn using puff.c which is inflate

1562266551
very-mediocre
zlib deflate is unreadable

1562266570
very-mediocre
also I never intended to go very far with this, I was toying around

1562266598
very-mediocre
now I figure may as well, but my time is shrinking... Alas.

1562266635
emekankurumeh[m]
i know the feeling

1562266685
emekankurumeh[m]
andrewrk:  when making install the defaut step should the default prefix be changed?

1562266728
andrewrk
emekankurumeh[m], I'm working on this now btw, about to push

1562266752
emekankurumeh[m]
darn, i was too

1562266753
andrewrk
I'm thinking to make the default prefix be zig-cache

1562266784
andrewrk
emekankurumeh[m], what do you think about

1562266796
andrewrk
should we simply not call msvc abort()

1562267001
hryx
emekankurumeh[m] / very-mediocre: What do you think about porting DEFLATE from the Go stdlib?

1562267010
hryx
not sure how well it would work since it makes heavy use of interfaces

1562267080
very-mediocre
well I'm sort of at the last big hurdle. Planning to read this article carefully:

1562267146
very-mediocre
if you'd like a peek at the horror of this wip, here you are:

1562267163
very-mediocre
everything Huffman is broken

1562267199
very-mediocre
each time i context-switch i go back to "how does everything work together again?"

1562267364
very-mediocre
bonus: the Huffman tree which encodes all of the deflate alphabet then gets Huffman encoded itself

1562268934
andrewrk
ok now zig build has install as the default step. There should no longer be any reason to use setOutputDir.

1562269012
emekankurumeh[m]
is there fcntl syscall in the stdlib?

1562269098
andrewrk
I believe fcntl is not very portable

1562269126
andrewrk
meaning, better to special case calls to it rather than try to abstract around it

1562269151
emekankurumeh[m]
link to libc?

1562269406
emekankurumeh[m]
andrewrk: how is this valid isn't a copy made when self is returned?

1562270236
andrewrk
emekankurumeh[m]: I changed Builder to get heap allocated

1562270570
marler8997_
just ran my "downloadlatest" script and noticed there was a new update....are updates to ziglan.org/download automatically pushed once a day or are they manual or both?

1562270587
mikdusan
every ci build

1562270591
emekankurumeh[m]
it's part of the ci script

1562270597
marler8997_
ah thanks

1562270606
emekankurumeh[m]
when it passes successfully after a merge

1562270650
nifker
why am I not allowed to use tabs in zig source code?

1562270713
marler8997_


1562270847
hryx
nifker: the decision to make tabs illegal was discussed here

1562270849
andrewrk
all whitespace conversation is off topic here. take it to

1562270875
hryx
I'll add this to the FAQ since it still comes up from time to time

1562270890
mikdusan
lawl i was just editing wiki.i but go ahead hryx.

1562270909
andrewrk
sounds good hryx

1562270915
hryx
oh haha! in sync mikdusan

1562271612
hryx
mikdusan: lemme know if you feel this covers it well enough

1562271798
mikdusan
hryx: maybe add link to #663 which discusses other ascii control codes, which is mentioned in

1562271893
mikdusan
oh you already have #663

1562271916
hryx
ah, yep

1562271935
mikdusan
👍

1562271999
mikdusan
when is zig going to support `var a = 10 ÷ 4;` :)

1562272090
hryx
gahaha

1562272234
marler8997_
well that was an interesting 15 minutest reading through the whitespace discussion.  It surprises me how passionate people get about such trivial things

1562272259
emekankurumeh[m]
andrewrk: i'm writing some blocking networking stuff for the stdlib, is it okay if i break std/event/*?

1562272545
Flaminator
Yeah the whitespace preference(tabs vs spaces and \r\n vs \n) is something that will never really get solved if a language doesn't force something and allows both.

1562272798
marler8997_
I think the discussion is fine, but I don't like seeing people get so riled up.  I don't know why but us humans can get very passionate about things that really don't matter.  Wish I knew why.

1562273370
Flaminator
And that is the reason why, people have different things they think that matter and things that don't matter.

1562273418
hryx
twitch stream today?

1562273424
Flaminator
andrewrk will there be any twitch streams today?

1562273443
andrewrk
ah, yes I'm planning on doing that. wow it is almost 5pm already

1562273454
andrewrk
damn was hoping to finish up this patch

1562273487
andrewrk
I'll do a stream in 1hr10min

1562273519
andrewrk
I don't even know what timezone I live in anymore. I've been saying EST but I found out yesterday that is off by one hour

1562273544
scientes
lol

1562273557
hryx
daylight savings? wobbly earth orbit?

1562273565
scientes
lots of leap seconds

1562273566
Flaminator
That is why I never use CET(current CEST because of daylight saving time) but always just use UTC+01:00/UTC+02:00.

1562273582
andrewrk
apparently your time zone changes, when daylight savings time happens. rather than your timezone adjusting its time

1562275177
samtebbs
I'm taking a look at

1562275240
samtebbs
I've tried using types_match_const_cast_only on wanted_type.data.pointer.child_type and actual_type.data.pointer.child_type but they don't seem to match

1562275257
andrewrk
you're on the right track

1562275327
samtebbs
Ok :)

1562275392
samtebbs
Am I using the right function and variables?

1562275501
andrewrk
I'm not sure, I can take a look after the stream

1562275530
samtebbs
Thanks, I'll probably be asleep by then but will check tomorrow!

1562275746
hryx
while waiting for eyes on the translate-c PR I'm starting on #2129 (support for u{xxx} characters)

1562275758
hryx
seems like a reasonably small-scoped project

1562276302
hryx
oh no, looks like zig test doesn't operate on a directory?

1562276376
andrewrk
hryx, that's one of the consequences of lazy analysis

1562276426
hryx
oh I see -- is it related to needing to specify a single root file?

1562276476
scientes
hryx, are you working from my work on #2129?

1562276478
hryx
BTW I have come to appreciate and enjoy the root file concept and its consequences. originally I didn't get it but I like it now

1562276496
scientes
I think my work was pretty good, and should be a good starting point

1562276502
scientes
but it is a bit disorganized

1562276509
hryx
scientes: I'm not - are there gotchas I should be looking out for?

1562276546
andrewrk
hryx, yes it is

1562276765
andrewrk
look at the nice changes to README.md

1562276818
scientes
hryx, perhaps I should just take some time and get my patch ready for re-submission

1562276834
scientes
or rather patch series, as there are many parts to that bug

1562277054
hryx
andrewrk: boy do I love seeing some red in diffs

1562277079
scientes
nice feature too

1562277107
andrewrk
scientes, nice, I'd look forward to some of your older patches that I closed, but you know, submitted in a way that makes it easier for me to merge

1562277117
hryx
scientes: I know you put some work into it and I don't wanna step on your toes. but do let me know if you intend to resubmit so that I can more properly direct my energy

1562277140
scientes
well that is why I feel I sound take the time

1562277145
andrewrk
hmm, considering experimenting with playing some chill music during this stream

1562277148
scientes
because your time could be better spent on other things

1562277174
scientes
andrewrk, and you were right for closing them

1562277205
andrewrk
I didn't like doing it though, it feels bad to reject people's code

1562277218
scientes
that is your job

1562277219
hryx
andrewrk: let me know if you need recommendations for creepy ambient music. unless you didn't mean THAT chill

1562277224
scientes
or rather, role

1562277250
scientes
Grek Kroah Hartman has spoken about this quite a bit

1562277256
scientes
and gives good advice

1562277630
andrewrk
streaming now

1562277633
hryx
scientes: your original patch looks good, why didn't you just remove all the stuff that doesn't have to do with #2129? Things like unicode validation, the #2097 fixes, etc.

1562277734
scientes
well they do kind all belong together

1562277739
scientes
i plan to submit them as a patch SERIES

1562277746
scientes
but plenty of that stuff does not

1562279633
emekankurumeh[m]
does zig fmt strip excess whitespace?

1562279658
hryx
emekankurumeh[m]: it should do so already, yeah

1562280144
marler8997_
So is [*c]u8 supposed to be the latest version of [*]null u8?

1562280178
fengb
No, [*c] means ambiguous whether it's * or [*]

1562280184
fengb
We don't have [*]null yet

1562280196
marler8997_
oh...interesting

1562280203
hryx
marler8997_: [*c] should only be generated from translate-c, not written by hand

1562280216
fengb
It's mostly for translating C because all pointers are kinda arrays

1562281416
samtebbs
andrewrk: I figured the casting thing out in the end, I just had to add to one of the checks already there

