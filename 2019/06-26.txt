1561510644
zxrf
i'm freeing a pointer with allocator.free after converting it to a slice

1561510667
zxrf
this is a pointer to heap-allocated memory of type [*]u8

1561510748
zxrf
when converting it to a slice i know the size of the allocation in bytes, but the thing is, any length works e.g. [0 .. 0]

1561510777
tgschultz
Most allocator implementations don't actually care about the size of the allocation

1561510786
zxrf
it "works" even if i use [0..0] instead of [0..length]

1561510821
tgschultz
wehn it comes to freeing them I mean, only the base pointer is usually required to know what to free

1561510841
zxrf
ah i see, but doesn't allocator.free take a slice?

1561510897
zxrf
so it doesn't matter what the length of the slice is?

1561510903
tgschultz
yes, in case it

1561510938
tgschultz
Actually... that's probably not true now that I say it out loud

1561510964
tgschultz
I thin in systems that use mmap you'll memory leak if you do that, only freeing the first page

1561511200
zxrf
so the correct way to do it would be to convert to a [0..length] slice and then calling free?

1561511266
tgschultz
yeah, the correct way is to free the whole original allocation. If you want to only free part of it you're looking at realloc or shrink

1561511313
zxrf
ok, thanks tgschultz

1561512667
fengb
Allocators that follow C conventions (realloc / free) need to be able to find recreate the original sizing without an explicit reference

1561512890
fengb
"extern structs cannot contain fields of type 'u4'"

1561512895
fengb
Can't generate bitfields?

1561515718
hryx
What's the best way to convert a clang::APSInt to a zig math.big.Int? Is it correct to just copy the APSInt "raw data" to the []Limbs?

1561516089
scientes
hryx, actually yeah they both use 64-bit limbs

1561516110
scientes
not sure how the sign works

1561516137
scientes
but i don't think that is a good idea

1561516191
hryx
According to the comments it's discouraged

1561516375
fengb
I abused C bitflags a bit too much. It's really starting to hurt :(

1561517214
tgschultz
fengb is your extern struct packed?

1561517326
fengb
Yes, but it doesn't seem like Zig can translate to or from bitflags yet

1561517343
fengb
I took a look at translating and there's oodles of underspecced edge cases

1561517362
tgschultz
huh. Well, deserialize can do it.

1561517376
tgschultz
but it would be making a copy.

1561517377
fengb
Yeah, I just need to hide the definitions

1561517405
fengb
So C can deal with it, and Zig can separately deal with it. Until I gut the C code anyway

1561522610
curtisf
What does the error `control flow attempts to use compile-time variable at runtime` indicate? It's singling out the `<` in `if (list.count() < field.min_take_count) {` where the rhs is a comptime `usize` inside a `inline for` loop

1561522910
andrewrk
curtisf, it means you have a runtime branch and in one or more of the branches you load or store to a comptime variable

1561522928
andrewrk
since the compiler doesn't know if the branch will be taken, the variable's value cannot be determined

1561522987
curtisf
hmm how should I be writing this? There's other branches in this inline loop that need to be resolved at comptime but this one I want to be done at runtime

1561523322
curtisf
I think what I want is for this comptime expression to be treated as an integer literal (so e.g. it's the same as `if (list.count() < 4)`). Is there a way to do that?

1561523497
curtisf
hmmm extracting it into a `var` out of the condition fixed it... I'm confused

1561523663
curtisf
andrewrk: would you be able to explain why `var c = list.count() < field.min_take_count; if (c) {......` is OK but `if (list.count() < field.min_take_count) ......` is rejected?

1561523707
andrewrk
probably a bug

1561523776
curtisf
do you think the right thing is that they are both rejected or both accepted?

1561523805
andrewrk
I'd need to see a more complete example

1561523810
andrewrk
but I'm about to go to bed

1561523820
curtisf
Ok, I'll try to reduce it later

1561523835
andrewrk
thanks. those reductions are very helpful

1561537428
mingyangyin
hi, what is the function of parsergen in the Zig code base?

1561544236
komu
andrewrk I've been struggling to find the right words to describe my problem with todays music and tv shows. Until today when I read

1561544325
komu
andrewrk When/if you re-write the music player in zig, have a paid tier because I want you to take my money

1561548240
tiehuis
hryx: i can add an import/export set of routines to the Int that will help with that specific use case

1561548254
tiehuis
something like this from gmp:

1561548310
tiehuis
you can still do it manually now, since APInt does seem to support approriate functions for getting specific words

1561548339
tiehuis
its just a bit of work and the limb sizes only match on 64-bit etc so there are some edge cases to consider

1561552461
gonz_
andrewrk: Given zig's focus on readability over writability, do you think there might be a reason in the future to do an overhaul of needless abbreviation in the standard library? Things like "buf" are pointless, usually.

1561552497
Tetralux
So long as we don't become Java, sure.

1561552512
Tetralux
Because then I'd hate you. With the passion of a thousand blue suns.

1561552523
Tetralux
And that would not be good xD

1561552539
gonz_
andrewrk: I'm not just asking for the bike shedding factor, by the way. I code mainly by voice and when a language has a culture of abbreviating everything, i.e. C it becomes much harder to actually write it. I would argue the savings are pretty small for everyone else also.

1561552677
Tetralux
Does "code by voice" mean you say it out loud - or out loud in your head? Only, 'Buf' (buff) is a bad example of that isn't it? :)

1561552764
gonz_
Tetralux: I use dictation software and plug-in infrastructure for that software to code, I don't touch the keyboard (I do this with a microphone, obviously). Everything I've written in this channel has been dictated.

1561552814
gonz_
`buf` is a problem, as are things like `msg`.

1561552845
gonz_
In general, everything that's not a natural word is going to provide issues.

1561552960
gonz_
`msgBuf` == "Made sun gust ship bat urge fine"

1561552987
gonz_
`message_buffer` == "Snake message buffer"

1561553048
BitPuffin
shouldn't std.ArrayList have some way to get a ptr to an element in it other than converting to a slice and indexing it and taking its address?

1561553945
Tetralux
BitPuffin: l.ptr() + n

1561553952
Tetralux
gonz_: Oh cool.

1561553967
Tetralux
gonz_: That does make sense.

1561553987
BitPuffin
I meant more as a standard part of the interface Tetralux

1561554003
BitPuffin
so you could do list.ptrAt(i)

1561554006
BitPuffin
or something like that

1561554017
Tetralux
There should prob be smartness in there where "message buff" searches for symbols, finds msgBuf and then completes that. :3

1561554025
Tetralux
BitPuffin: I gotcha.

1561554043
Tetralux
gonz_: But yeah - I can see how that could be painful.

1561554073
gonz_
"Smartness" rarely works. I basically just speak vim.

1561554132
gonz_
`ptr` is another classic.

1561554357
gonz_
`p` really is no worse than `ptr` if you want short names. But short names are really only good in the short term, they're not for production code and other long-lived things.

1561554398
gonz_
Local names obviously can be very short, but in those cases `p` is probably what you want to use anyway.

1561554596
gonz_
In general I think the attachment people have to unnatural abbreviations is usually a historical accident.

1561554654
gonz_
I'm sure someone will manage to be offended by the suggestion that it's needless.

1561555506
Tetralux
gonz_: You'd probably like Jonathon Blow's code then. He doesn't abbreviate much :D

1561555676
fengb
I wish Jai was public. It looks quite awesome from the vague video snippets

1561556086
fengb
Random question: did Go invent the term "slice" for fat array pointer?

1561556301
mmx87
><gonz_> `p` really is no worse than `ptr` if you want short names. But short names are really only good in the short term, they're not for production code and other long-lived things.

1561556302
mmx87
It is, p could also stand for something else, while most people are aware what ptr should mean. I think you're currently arguing for your specific use case mostly.

1561556446
gonz_
Given the premise that short names are local, it's not very likely to be many other things. Probably you're not doing yourself any favors by having other things in scope that could be `p` anyway.

1561556505
gonz_
Also, I would argue that writing `pointer` is not very hard, certainly not much harder than `ptr`.

1561556507
fengb
`p` is harder to scan since it's vaguely similar to `i` and `j`

1561556568
fengb
I like `p` as a prefix, but standalone it looks weird

1561556596
gonz_
You're not trying to save hard drive space or anything like that. There's no upside to having a long-lived API that uses, for example, `ptr`.

1561556622
mmx87
gonz_, have you considered the line length? If we would spell out anything than that would make lines very long, like in Java.

1561556641
gonz_
`ptrAt` is a pretty horrible choice. `pointerAt` would've obviously better.

1561556668
gonz_
Boo-hoo, my lines are so long…

1561556673
gonz_
Really?

1561556713
fengb
... I don't see anything wrong with ptrAt

1561556748
gonz_
Saving 4 letters, for what?

1561556758
mmx87
Yeah, really. Not only one function, but other functions also. You need to see it as a whole if you spell out anything then it usually makes the lines very long.

1561556820
mmx87
Let's say you write a DNS server? Would you spell out DomainNameSystem? OK, that might be different because it's different from shortening a word, but it still would be annoying for your with voice software.

1561556851
fengb
`standard.input_output.printFormatted`

1561556861
gonz_
I think people are little bit too attached to some of these things. No, common abbreviations are not difficult: DNS, API, HTML, HTTP…

1561556881
gonz_
Don't presume to know what's difficult or not.

1561556940
gonz_
Get some perspective as well, maybe the way the people have been writing C is not actually the best way to formulate things.

1561556962
samtebbs
"be excellent to each other"

1561557081
gonz_
There was at one point a reason to use short names and odd abbreviations, but that's not really relevant anymore. Invoking Java as an argument for these things is pretty garbage.

1561557179
companion_cube
short names can be easier to read, too

1561557182
mmx87
No, it's a fair argument. Because everything is often spelled out. Why do you think Java as an example is invalid? I know Java is overly verbose where it doesn't need to, but still all lines would be longer, which can sometimes be painful if you need to have multiple windows of code open.

1561557193
companion_cube
(it's not just in C culture, also in functional languages, btw)

1561557334
gonz_
I'm not going to disagree that it's everywhere, but particularly unnatural abbreviations are more common in certain languages. The way certain people defend them is certainly tied to historical C-isms.

1561557460
mmx87
I don't think there's any argument that would convince you that they might not be as bad as you make them out to be. You're arguing from the standpoint that these short names are inherently flawed.

1561557563
gonz_
In most contexts, yes.

1561557594
gonz_
I think they're vastly overused for the savings that they do actually provide in terms of big picture.

1561557646
gonz_
I think they're an objectively bad choice in terms of public, long-lived API.

1561557740
BitPuffin
I said ptrAt because we already have .ptr on slices ¯_(ツ)_/¯

1561557781
gonz_
More than anything I think the argument for them is usually based entirely on historical accidents and familiarity. The argument in functional languages that provide enough abstraction where you can't actually name something something specific is precisely that. This usually does not apply to lower-level languages.

1561557946
gonz_
With that said I'll try to be less and agonistic about this, because obviously I have a completely different viewpoint than most people here.

1561557958
gonz_
*antagonistic

1561558233
samtebbs
In the end you can't please everyone. It seems that most people are fine with short names and that, combined with the typing ease and line length savings, makes them fine.

1561558305
samtebbs
For everything in existence there's going to be a group of people (however big or small) that oppose it, but the important thing is to go with the preference of the majority.

1561558436
halosghost
not to prolongue this conversation that I just walked into, but I would suggest that going with the majority isn't always the right call

1561558456
halosghost
for the particular subject matter, I can't speak to it as I missed out on the conversation

1561558612
BitPuffin
I mean on a standard library or language level I think it doesn't hurt to work towards being accomodating towards people who might for whatever reason be excluded or inhibited by a design decision because of disabilites or what not.

1561558626
mmx87
halosghost, there are IRC logs:

1561558653
gonz_
I think it might be immaterial in the long run, since you're always going to be dealing with C and all of that. I don't think that there is a good reason for new language to actually inherit these things.

1561558671
halosghost
mmx87: thanks

1561558675
gonz_
But now I regret even bringing it up anyway

1561558731
halosghost
a bit slow to load, that page :)

1561558748
BitPuffin
that said if an abbreviation is common enough it could be the case that the right place to address this problem is in the dictation software. but I don't know enough about how hard it is to make them  recognize a codeword or whatever for ptr ("putter"?)

1561558876
gonz_
BitPuffin: Many things are possible here: you could add an abbreviation command that allows you to say "abbreviate [word]" and have those set up. I would destress the importance of the dictation software, perhaps, and instead emphasized that maybe some of this is actually not needed anyway.

1561558976
gonz_
Anyway, I'm not going to comment more on it because I doubt that this would actually be something that can be changed for this generation.

1561558985
BitPuffin
okay so if we set aside the dictation problems

1561559000
BitPuffin
I agree that it's not strictly needed to say ptr instead of pointer

1561559019
BitPuffin
but I pretty much pick which one seems better even if it's just a tiny amount

1561559119
BitPuffin
ptr is also one of those that often glues itself onto some other longer word

1561560714
andrewrk
I do think that once zig has better IDE integration, it will make sense for names of things to be longer in general

1561560809
andrewrk
IDE integration should in theory help a lot with voice commands because it limits the set of things you could possibly want to type, thus making it easier (and more discrete) what the programmer wants to input

1561560970
gonz_
IDE integration does help, yes, but to be honest I think that one helps equally with the odd abbreviations.

1561561072
gonz_
What I mean is I think that one is an equally strong argument for three letter abbreviations that only save a few characters.

1561561170
andrewrk
I agree with you that more explicit names are in general preferable. I see IDE integration as a way that abbrevations matter less because of auto completion, thus enabling longer and better names

1561561312
fengb
Is there a clean way of shutting off tagged union checks? In my critical path I want to just use the raw value directly, but I want to be able to switch on a tag

1561561603
fengb
Oh it just works. I thought I needed a packed union as well but I didn't

1561562793
andrewrk
fengb, those accesses are safety-checked too, so if you access the wrong field in a safe build mode you'll get a panic

1561562813
andrewrk
you can disable all safety checks in a given block with @setRuntimeSafety

1561563079
fengb
Yep I see it. That's actually really helpful since I

1561563111
zxrf
gonz_: what do you think of short variable names like "i" in short loops? i guess that's the only place they might seem appropriate

1561563143
fengb
For some reason I had assumed the compiler would be more anal and force me to check

1561563189
andrewrk
fengb, that's been proposed but I resisted it

1561563205
scientes
zxrf, you just can't resuse them

1561563218
scientes
in the same scope

1561563232
gonz_
The smaller the scope, the more appropriate short names are, in my opinion. I think most people agree, though.

1561563289
gonz_
Something that is globally available isn't something that I would want to have a short name and/or have too many abbreviations and it.

1561563780
zxrf
gonz_: that makes sense. your perspective on this was very enlightening for some reason, thank you

1561564358
gonz_
I would add that how generic something is also makes a difference: `mapM f m` is simultaneously good and bad; `mapM` is globally available (if imported) so should probably be `mapMonad` but `f` is fine to use here because it's a completely generic function over all monads, etc.

1561564402
gonz_
(and `f` & `m` are also locally scoped)

1561566269
zie
are there docs for the standard library somewhere?

1561566553
hryx
zie: not yet but planned for next release. for now your best bet is to look through the sources in std/

1561566573
zie
hryx that's what I started doing :)

1561569553
andrewrk
scientes, interesting, that error that gcc 9 points out, is precisely defeating the safety I tried to introduce

1561569570
andrewrk
fine, I won't use c++ features, they only seem to cause problems

1561569588
scientes
that's how i feel about C++

1561569604
Tetralux
People still use C++ features? xD

1561569636
andrewrk
all I did was delete the copy construction and assignment operator so you couldn't accidentally use ConstExprValue wrong

1561569703
Tetralux
Yeah - I tried compiling the branch earlier and ran into that.

1561569722
Tetralux
By "use it wrong",  what do you mean?

1561569763
Tetralux
.. that you shouldn't copy one that's already been set up by the system?

1561569789
Tetralux
.. or indeed, accidentally by using '='?

1561569843
andrewrk
right

1561570063
Tetralux
Is that because data is stored by value within the struct, and this value is the only one that should exist for a particular thing?

1561570068
Tetralux
Something like that?

1561570086
andrewrk
wow, I just discovered that you can jump to another line in gdb

1561570092
andrewrk
that's useful

1561570095
scientes
the main problem i have with C++ is that there is this huge learning curve

1561570102
scientes
and I can't rationalize it

1561570112
scientes
because C++ seems full of strange edge cases and bugs

1561570137
Tetralux
Oh absolutely.

1561570141
scientes
like when you use operator overloading you don't get the same operator precedence rules

1561570143
scientes
which is super weird

1561570146
Tetralux
If I ever program  in C++

1561570149
scientes
and makes me distrust the whole language

1561570160
Tetralux
I only thing I use is fn overloading and auto.

1561570169
Tetralux
If I can at all avoid it.

1561570170
scientes
zig has auto

1561570187
Tetralux
This is a good thing.

1561570203
scientes
like I was writing a patch for llvm because i thought something was a linked list, and the llvm documentation said it was a linked list

1561570207
scientes
and then i realized it was just an array

1561570210
scientes
fuck me

1561570216
Tetralux
Although, I must say, having to state the type can be handy instead of having to look it up.

1561570230
scientes
and even Chris, the author of LLVM, said my idea was a good idea.....

1561570243
scientes
if the author can't keep track of the data structures.....

1561570272
Tetralux
How the hell does a linked list and an array become so hard to tell which one is being used? xD

1561570293
scientes
well all the APIs for operands in LLVM use it like a linked list

1561570297
scientes
but its a damn array

1561570316
daurnimator
gonz_: how do you about slices having .ptr and .len. I don't think I'd want them to be any longer (.pointer and .length) as they are so common to use as part of a call: `if (someFunction(a.ptr, b.ptr) < a.len) .....`

1561570346
daurnimator
gonz_: likewise zig uses 'fn' instead of 'function'

1561570356
scientes
that comes from go

1561570362
scientes
which initially has it "function"

1561570379
scientes
or well, its pretty simple

1561570387
Tetralux
Oh yeah - meant to say this earlier - but if I had to dictate what I was writing, I'd REQUIRE the ability to set up abbreviations.

1561570387
scientes
fn is great

1561570403
scientes
Tetralux, no, macros are not a good idea

1561570424
scientes
but you have full control over your namespace

1561570466
daurnimator
scientes: ehhh; coming from lua I don't mind writing out 'function'

1561570471
scientes
I think what zig has now (that the namespace type was removed) is beautiful

1561570506
Tetralux
I like that each file is it's own namespace.

1561570508
andrewrk
the main reason for `fn` being short is that it's a keyword in function types

1561570509
daurnimator
the main time it gets annoying is inline closures: `sort(t, function(x,y) return x < y end)`

1561570524
andrewrk
nice we said the same thing

1561570538
Tetralux
But it is quite irritating how you can't tell what namespace the code inside a file belongs to without tracing it from top-down.

1561570560
scientes
but a static analyzer could do that

1561570566
scientes
i think the way it is done is good

1561570573
Tetralux
Indeed - but I don't believe I should need one to know xD

1561570580
scientes
agreed

1561570588
Tetralux
Well - I don't "need" one

1561570591
scientes
that's why in the std lib we always use them under their given name

1561570595
Tetralux
I can go through the files and figure it out

1561570598
Tetralux
But you get my point

1561570604
daurnimator
'fn' is a good short choice because 'fn' doesn't tend to appear as a sequence in any english words

1561570626
scientes
because it needs a vowel

1561570635
scientes
maybe finnish

1561570637
daurnimator
which means that greping for 'fn' is 99.9% of the time only going to return function definitions

1561570652
Tetralux
daurnimator: That

1561570654
gonz_
I have plenty of voice macros set up specifically for zig (I say "all your base are belong to us" and it's activated). That's not so much the issue as promoting an ecosystem where these kind of things are everywhere. You can't set up macros for every tiny thing. I have macros for the base syntax of zig and that's pretty much it.

1561570692
scientes
gonz_, i agree that a static analyzer should not be required, i do 99% with git grep (which is faster than grep)

1561570697
scientes
and find | grep

1561570712
Tetralux
Personally, if I needed to dictate, I'd want to just teach it how to recognise and activate things. Like,  if I open a zig file, know that I wanna enable the zig macros.

1561570713
gonz_
I also have voice macros that apply to many languages, but have specific implementations in each language, like saying "exported function" which in zig outputs "pub fn ..."

1561570713
Tetralux
AND

1561570720
Tetralux
I would NOT want to set them up manually.

1561570730
daurnimator
gonz_: not 'export fn'... ?

1561570750
hryx
tiehuis: Thanks for addressing my big.Int question, I didn't see that. I'll give it a shot tonight

1561570759
daurnimator
gonz_: shouldn't `pub fn` be "public function"?

1561570800
gonz_
I suppose it should be, yes. The point is that they're a known set of things that each language does differently.

1561570807
Tetralux
This is true.

1561570822
Tetralux
Like - maybe I'd type out some code, or open a code example

1561570841
Tetralux
And be able to easily teach it - "Hey - this is what an if-statement looks like - make that a macro."

1561570848
Tetralux
I wouldn't probably do it by saying that.

1561570849
gonz_
Tetralux: I think you should probably try this before you have set opinions on it. It's extreme hard to set something up that is robust and the more complex you make it the less stable it's going to be.

1561570863
Tetralux
Oh - I have tried to use dictation before.

1561570870
Tetralux
I wanted to strangle it pretty quickly.

1561570880
Tetralux
I'm more thinking out loud. x)

1561570885
Tetralux
I

1561570898
Tetralux
And it won't ever be if someone doesn't imagine it being.

1561570910
Tetralux
Long way of saying, "aim high."

1561570912
scientes
I couldn't imagine doing that

1561570913
triplefox
happened to see this discussion and i could weigh in with some of my notes on symbol length when i tested using lengths of two, three, and four characters for everything...

1561570940
scientes
it would be like talking to a very dumb child

1561570941
triplefox
at two, you get a lot of collisions. at three you don't, but you can't read the full word most of the time. four or more you usually can

1561570973
daurnimator


1561570983
gonz_
scientes: It's actually surprisingly easy and pretty precise. It helps if you can just speak vim.

1561571004
scientes
but you still have to be precise

1561571008
scientes
and I just don't work that way

1561571019
gonz_
daurnimator: That's the one people usually see and they it's the one I saw before I started doing this.

1561571056
Tetralux
gonz_: Also, I don't have

1561571059
gonz_
scientes: Well, I didn't want to do this. I woke up one day and my hands hurt basically immediately when I started typing.

1561571137
Tetralux
If anything I just said came off badly, I apologise - wasn't meant as such.

1561571251
daurnimator
gonz_: I had that too once. I took a week long break from typing and swapped to using an ergodox at work: I have been okay since.... as long as I don't use a normal keyboard for long

1561571582
oats
I love my ergodox

1561571609
oats
Been on the lookout for a nice compact ergonomic keyboard I can use on the go

1561571625
gonz_
No offense taken or perceived.

1561571625
gonz_
Even though I never wanted to start doing it I can actually say that it's not the blocker that I thought it would be and I probably will continue doing it pretty much forever. Once you get really into a language you set up the basics and you're pretty much up and running with some reasonable level of efficacy.

1561571626
gonz_
daurnimator: With regards to ptr and len I'm not really sure. They're not your usual identifiers and like you said they show up a lot. Doing the same thing with things that show up drastically less isn't the same to me. I should probably just bite the bullet and set up "pointer" to automatically output "ptr".

1561571627
oats
I like the look of the Atreus, but I worry it has too few keys

1561571643
oats
The Planck is super cool, but it's backlogged and not as ergonomic

1561571669
gonz_
Yeah, I also have ErgoDox (EZ)

1561571696
daurnimator
oats: I think the key thing for me was reducing use of my pinky and "scrunched" movements: having ctrl and windows key on the thumb is the main benefit

1561571722
oats
Yeah, extra thumb keys are great

1561571724
daurnimator
also that I can pick my own "width"

1561571735
daurnimator
A planck doesn't do either of those things: I don't consider it an ergonomic keyboard at al

1561571765
oats
I think a split Planck would be pretty ideal for me, but that's a bigger project

1561571917
triplefox
i got this folding keyboard for travel use - i actually kind of like the fixed split on it but i wouldn't really call it ergonomic

1561572347
companion_cube


1561572410
companion_cube
(I'm still sad about the syntax for blocks returning expressions, so weird)

1561572424
companion_cube
blocks returning values*

1561572461
daurnimator
companion_cube: yeah I always mix up blk: vs :blk

1561572502
companion_cube
should just be `{foo; bar; value}`, shorter, more readable, more intuitive. but well, not C-like enough I guess.

1561572503
Tetralux
AH-HA!

1561572503
Tetralux


1561572508
daurnimator
An IIFE might be a good alternative once we get function expressions

1561572524
andrewrk
companion_cube, it used to be that way and changed

1561572532
companion_cube
I know, we've discussed that already.

1561572558
companion_cube
I'm just not sure why I like almost all the design choices in Zig except this one

1561572561
daurnimator
const foo = (fn()mytype { return ..... })()

1561572571
companion_cube
what is this, javascript?

1561572598
companion_cube
(it kind of blew my mind that people say JS is basically a functional language, when it's so not expression oriented)

1561572617
daurnimator
companion_cube: I like that 'return' always means "return from current function". so if I want 'return' to work in a block.... you need a function :)

1561572634
companion_cube
I'd rather not have return at all, except for functions, yeah

1561572674
companion_cube
the break syntax is useful in 1% of the cases where you want a block to return an expression, and have shortcut cases in the middle; otherwise it's a lot of overhda

1561572676
companion_cube
overhead

1561572830
companion_cube
I think I'd just like zig's syntax to be a bit closer to rust's…

1561572935
daurnimator
companion_cube: modern rust often looks like line noise to me. I prefer far fewer symbols and more keywords

1561572951
companion_cube
I don't think rust has more symbols than Zig

1561572973
companion_cube
but anyway I'm thinking of the expression syntax for blocks, and the if/while mandatory braces

1561572996
Tetralux
I don't like mandatory braces.

1561573002
Tetralux
I like single if guard ifs :p

1561573005
Tetralux
single-line

1561573024
daurnimator
andrewrk: oh that reminds me. did you see my request the other day about a 'do while'?

1561573030
companion_cube
if's just `goto fail` waiting to happen, and you have to wrap the test in ()

1561573044
companion_cube
so it's not even longer to have `if a { … }` instead of `if (a) …`

1561573088
companion_cube
and it's easier to go from `if a {b} else {c}` to `if a {print; b} else {c}` when the if returns an expression

1561573092
companion_cube
returns a value*

1561573123
companion_cube
(I use daily a language with non mandatory braces and it's the worst part of the syntax)

1561573136
daurnimator


1561573140
Tetralux
I can understand that.

1561573180
Tetralux
I find enclosing conditions with () easier to read, but like being able to omit them.

1561573194
Tetralux
Especially when testing for flags.

1561573209
companion_cube
it's like match/switch, you always want `{}` afterwards anyway

1561573217
Tetralux
Or really any '!(expr)'

1561573221
Tetralux
And yeah.

1561573236
Tetralux
I just very often do `if bad_thing  return`

1561573249
Tetralux
I don't like indentation.

1561573254
Tetralux
I want as little as possible.

1561573258
companion_cube
you could still have `if bad_thing { return }` :)

1561573472
daurnimator
Tetralux: you still need something between the condition and the block. Lua has `then`: `if bad_thing then return`

1561573521
fengb
I think mandatory zig fmt fixes most (all?) of the problems with no braces

1561573525
Tetralux
companion_cube: You could - but I don't like how it looks. Though it helps if they are the same exact height as letters.

1561573556
Tetralux
daurnimator: Nope. Jai has 'then', but it's optional and I've never seen him run into a problem with not using it.

1561573562
Tetralux
He just leaves two spaces instead.

1561573568
Tetralux
`if bad_thing  return;`

1561573574
Tetralux
Which I find quite pleasing to read.

1561573610
companion_cube
fengb: would still be simpler if the syntax itself was failproof

1561573652
torque
I don't think one man coding in his own language on live streams is a good model for making syntax design choices

1561573662
torque
brackets remove ambiguity

1561573667
companion_cube
^

1561573691
companion_cube
(and the label syntax for returning from blocks just adds boilerplate and confusion, imho)

1561573735
daurnimator
Tetralux: if foo(bar())()

1561573928
Tetralux
torque: This is true. Though, so would having `if bad_thing do return;`

1561573965
companion_cube
something to be mindful of is that Zig's syntax should be easy to write parsers for

1561573977
companion_cube
which is an explicit design point in rust (and go)

1561574007
mmx87
Isn't Rust quite complicated already?

1561574021
companion_cube
not that complicated, and the syntax is pretty unambiguous

1561574028
companion_cube
(the typechecker would be complicated to write, for sure)

1561574047
fengb
I personally can't parse Rust code >_>

1561574067
companion_cube
really? what's tripping you up?

1561574100
mmx87
Rust is quite nice, but I feel it's almost becoming a second C++.

1561574139
Tetralux
I'm not sure what "easy to write parsers for" means.

1561574144
Tetralux
Speed?

1561574151
Tetralux
Ambiguity?

1561574153
Tetralux
Only

1561574153
companion_cube
can be parsed by yacc and the likes without hacks

1561574167
companion_cube
lack of ambiguity, and speed, go together anyway

1561574181
Tetralux
I'm not sure that being parsable by yacc is a positive thing xD

1561574185
companion_cube
if you are context free and with a lookahead of 1, you can write a fast parser

1561574193
fengb


1561574224
Tetralux
I mean, Jai parses all it's files in a 100,000 line game in about 25ms.

1561574226
Tetralux
IIRC.

1561574245
Tetralux
So that logic seems flawed. 'Less I be missing sometihng.

1561574255
companion_cube
maybe jai has a simple syntax then?

1561574266
andrewrk
jai is vaporware

1561574284
fengb
Just like V? :P

1561574292
mmx87
I really dislike the generics syntax.

1561574304
companion_cube
(and I do mean that even a pretty naive rust parser using yacc or similar generators, would be reasonably fast without needing tons of optimizations)

1561574315
Tetralux
mmx87: I love the generic syntax xD

1561574316
mmx87
Functions that return types like in Zig is one step in the right direction.

1561574337
companion_cube
andrewrk: the talk is great, but you're a bit dismissive of academia :/

1561574354
mmx87
Now, Zig should just become a bit more uniform.

1561574359
mmx87
Like declaring functions.

1561574359
andrewrk
companion_cube, I'll concede that

1561574374
andrewrk
it's a weakness and a strength

1561574378
BitPuffin
which talk

1561574378
mmx87
It should basically the same as declaring const variables.

1561574389
companion_cube
it's not all great, but there's good stuff to be found about dependent types and staged programming

1561574408
daurnimator
mmx87:

1561574412
Tetralux
companion_cube: It uses Thing :: Value or Thing: Type = Value;  for all it's declarations... and has no parens around conditions and non-mandatory braces around blocks xD

1561574434
companion_cube
eeeeek

1561574435
mmx87
Yeah, I know I saw that already , daurnimator.

1561574440
andrewrk
I'm still considering `let` instead of `const`

1561574442
companion_cube
well then I guess it's an implementation-defined syntax

1561574444
Tetralux
andrewrk: RE Jai being vaporware - true. Though, at least we've seen it run.

1561574458
mmx87
I think one of the strengths of hardcore functional languages is that mostly everything is uniform.

1561574460
companion_cube
`let` would be great

1561574477
andrewrk
sure I mean jai is certainly intruiging, but until the source is available, I have no interest in it

1561574477
daurnimator
andrewrk: `let` in most languages is the mutable form

1561574481
BitPuffin
jai probably won't remain vaporware for long

1561574487
BitPuffin
they're shipping closed beta already no?

1561574488
companion_cube
daurnimator: only in JS…

1561574498
Tetralux
BitPuffin: I hope not!

1561574525
andrewrk
daurnimator, that is counter to my understanding, can you give examples?

1561574538
Tetralux
Always a chance of nothing happening, but.. my senses doubt it, considering he's making a game in it etc. We'll see though.

1561574552
Tetralux
Also yeah - I thought 'let' was const form.

1561574618
companion_cube
in all functioanl languages that have it, `let` is immutable; in rust too; only JS retrofitted it to be a well scoped `var`

1561574653
BitPuffin
Tetralux: I personally hope they are releasing closed beta

1561574654
mmx87
Toe be fair, almost anything in functional languages is immutable by default.

1561574660
andrewrk
guess what time it is now?

1561574668
companion_cube
time to leave IRC? :p

1561574678
andrewrk
it's time to give me links to your projects if you have tests, so I can check for regressions for you with copy-elision-3 branch

1561574685
andrewrk
all tests passing on all OS's

1561574690
fengb
:o

1561574692
Tetralux
OH MY WORD YES.

1561574697
Tetralux
THIS SHOULD BE GOOD.

1561574705
Tetralux
OR ATROCIOUSLY HILARIOUS.

1561574723
halosghost
andrewrk: :D

1561574747
andrewrk
I'll start with tiehuis's response here:

1561574753
daurnimator
andrewrk: javascript, BASIC.

1561574800
fengb
andrewrk: did we resolve needing to explicitly copy iterated values? Is that just going to be a mild footgun for now?

1561574812
andrewrk
mild footgun for now

1561574871
daurnimator
andrewrk: in javascript: `var` is a new mutable variable of function scope; `let` is a new mutable variable of lexical scope; `const` is a new non-mutable variable of lexical scope.

1561574902
companion_cube
but only because they botched `var` initially, really

1561574903
Tetralux
daurnimator: My brain hurts just trying to understand that.

1561574904
andrewrk
that decision is due to legacy baggage of var

1561574929
andrewrk
rust has `let` as immutable

1561574934
mmx87
I think JS is a good example of how to not design a language, lol.

1561574944
andrewrk
haskell has let

1561574949
companion_cube
ML and OCaml, too

1561574966
andrewrk
js is a notable example but I don't think it's prescriptive

1561574985
Tetralux
Does 'let' obviously imply 'const' beyond assosication with functional languages, and Rust, of all things? xD

1561575002
fengb
'let' is also constant in Swift

1561575013
andrewrk
it's pretty easy to understand, if you do it wrong you get a compile error. it's not going to cause confusion

1561575016
companion_cube
`let` is mostly found in languages inspired from functional langs, so… :D

1561575043
Tetralux
One less char to type I suppose.

1561575050
Tetralux
And I'd find it much easier to type than const.

1561575056
mmx87
I think most functional languages use let, because of how it's usually used in mathematics.

1561575058
Tetralux
Well - "much" is maybe stretching a little there

1561575060
Tetralux
But regardless.

1561575062
Tetralux
Still easier.

1561575077
fengb
I'd get slightly irked coming from JS... but I already have to deal with different `const` semantics

1561575089
Tetralux
I'd prefer let=const than let=immutable.

1561575093
Tetralux
So yes.

1561575098
andrewrk
it's intended to address that many people I have noticed use `var` when they don't need to. this is especially problematic in zig because `const` stuff can be comptime but var stuff cannot

1561575099
daurnimator
I like the zig status quo.

1561575106
companion_cube
D uses `immutable` 😱

1561575150
Tetralux
I universally use var under any circumstance unless it's top-level or specifically wanting to be const.

1561575168
daurnimator
Tetralux: in JS?

1561575174
Tetralux
In Zig xD

1561575179
daurnimator
Tetralux: ah. don't :P

1561575186
fengb
const makes your program run faster

1561575194
daurnimator
in zig you should use `const` unless you need to mutate the variable

1561575201
Tetralux
Which is why I use them for things that like.. constants.

1561575207
Tetralux
But I never use immutable variables.

1561575213
companion_cube
so use `let` for immutable, `let mutable` otherwise, so the easy path is the safe one ;)

1561575229
daurnimator
fengb: in zig? not really. in JS? no it actually makes your program slower :(

1561575232
Tetralux
I'd rather the other way. Because I'd never type 'let' by itself then xD

1561575328
Tetralux
I use constants for things that are constant. Like PI. Obviously. But for stack vars. Nope, always mutable.

1561575361
fengb
We'd do smashingcase for that: `letmutable`

1561575364
mmx87
I think it's a good design choice to make everything immutable by default, like Rust.

1561575364
Tetralux
But I don't esp like using loads of stack vars so it balances a bit.

1561575392
daurnimator
mmx87: function arguments already are

1561575400
Tetralux
The machine is mutable - my variables are mutable - I am mutable. ;)

1561575405
daurnimator
but I wouldn't want mutable creation to be longer in zig unless we get e.g. better iterator support

1561575434
companion_cube
so `var` and `let` would be perfect since they have the same length

1561575439
daurnimator
`letmutatable i = usize(0); while (i < 42) : (i+=1)` is far too ugly

1561575456
daurnimator
companion_cube: I actually think that's a bad thing.

1561575460
Tetralux
I'd honestly rather that the compiler just said "Okay. Do they write this variable again after assigning it? No? Then I'll make it const."

1561575468
companion_cube
going back to value-returning-blocks: shorter syntax means it's easier to initialize `let x = { y; z};` instead of `var x; y; x=z`

1561575473
daurnimator
companion_cube: I like that they are different lengths: it makes it so the difference is obvious when you vertically scan code

1561575494
companion_cube
Tetralux: immutable by default is a safety feature

1561575501
companion_cube
not a helping-the-compiler feature

1561575523
mmx87
let mut i = usize(0); while (i < 42) : (i+=1)

1561575525
Tetralux
I was thinking more of a "helping speed and code size" feature - but yes - people consider it a safety thing too.

1561575525
daurnimator
`var x; let y; var z;` is hard to see that y is different; vs `var x; const y; var z` the different length makes it more obvious

1561575570
Tetralux
I don't like thinking of loads of different names for the same thing after each mutation.

1561575590
Tetralux
I like just saying, var ptr = thing; if (cond) ptr += 1; return ptr;

1561575597
Tetralux
.. trash example, but you get the point.

1561575609
companion_cube
of course var is still useful

1561575621
Tetralux
Very. Hence why I almost always use it.

1561575622
companion_cube
but many times, you only assign once

1561575636
mmx87
One common pattern in Rust is shadowing the variable, at least I saw that multiple times.

1561575638
companion_cube
like in swap: `const tmp = x; x=y; y=tmp`

1561575651
companion_cube
making `tmp` a var means you could change it by mistake

1561575653
Tetralux
mmx87: One of the few pattern I like from it.

1561575666
Tetralux
mmx87: I love the ability to shadow an optional with it.

1561575668
companion_cube
(another influence from ML)

1561575673
mmx87
Yeah, it's pretty nice. Especially if an object can be in multiple states.

1561575674
mmx87
Like a file.

1561575680
mmx87
It can be open, or closed.

1561575714
Tetralux
companion_cube: See - that's an example where I

1561575716
mmx87
It's also integrates well into the rust type system.

1561575733
companion_cube
Tetralux: well that's because you have bad habits ;) ;)

1561575740
halosghost
this is kind of apropos of nothing

1561575759
companion_cube
(I'm joking, but the goal of `let` in rust is indeed to make immutable the default)

1561575773
Tetralux
..which I part of why I stopped using Rust :p

1561575787
halosghost
but, the way pony deals with swaps is kind of fascinating; (x = y) returns the value of x before assignment

1561575798
halosghost
meaning that, in pony, swap is just: a = b = a

1561575808
companion_cube
ugh, such magic

1561575810
halosghost
lol

1561575899
Tetralux
companion_cube: Like - right kind of idea; wrong effort. Thinking about what variables I'd make mutable and which I wouldn't would stop me using the language, I suspect.

1561575911
Tetralux
..If it was immut by def that is.

1561575920
companion_cube
that's pretty strong

1561575942
Tetralux
In Rust, I found myself wanting to write "let mut" for EVERY var

1561575953
companion_cube
that's definitely a code smell in rust

1561575953
Tetralux
And then go back and remove the "mut" for the things I didn't change.

1561575961
companion_cube
it means you don't use expressions nearly enough :p

1561575964
Tetralux
Just to avoid having to think about it.

1561575996
Tetralux
It is quite possible it was due to inexperience, indeed.

1561576007
Tetralux
But Rust is too big-idea for me to really like it.

1561576025
Tetralux
So, having to learn about intracacies like that... meh.

1561576048
companion_cube
I'd kind of expect good Zig to look similar, except more explicit and without borrow checker?

1561576058
Tetralux
Def without the checker.

1561576070
companion_cube
but still, initialization with expression beat re-assignment imho

1561576085
Tetralux
I'm not sure I can agree on that one. x)

1561576107
Tetralux
Partly because of excess indentation, partly because of 'break blk'.

1561576113
mmx87
Zig's current syntax feels a lot lighter than Rust's.

1561576119
companion_cube
which is why `break blk` irks me so much

1561576123
Tetralux
Partly because if-guards read better to me.

1561576142
Tetralux
And partly because situations where I might use expression to set a var, I'd just have a local fn and call it.

1561576147
Tetralux
..except I cannot do that in Zig.

1561576150
Tetralux
:^)

1561576154
companion_cube
mmx87: if you don't use high level abstractions in rust, the syntax is pretty similar…

1561576175
companion_cube
Tetralux: are you really that used to JS ? :D

1561576183
Tetralux
xD

1561576188
fengb
Most nowadays JS uses const

1561576190
Tetralux
More Odin actually. ;)

1561576203
companion_cube
fengb: except you can't have block expressions 🙄

1561576239
mmx87
Well, you'd almost certainly use high level abstractions in Rust though.

1561576256
mmx87
Something like Result for example.

1561576259
companion_cube
declaring/implementing traits is ugly; the rest is pretty concise

1561576274
companion_cube
ah well. not longer than Zig if you use `x?`

1561576301
Tetralux
Why use a higher-level abstraction when you don't need to

1561576322
mmx87
The syntax is pretty good still.

1561576342
mmx87
Because they're zero-cost and usually you should use them.

1561576360
fengb
companion_cube: sure you can, (() => ())() :P

1561576363
mmx87
For example things like Result are much better than out pointer parameters.

1561576370
companion_cube
fengb: that's so ugly :/

1561576393
Tetralux
mmx87: I hope that's satire xP

1561576417
BitPuffin
andrewrk: I don't have tests but you could run it and see if it works (just a space invaders clone)

1561576417
Tetralux
I'd rather multiple-return than Result.

1561576429
BitPuffin
lmk if you want

1561576431
Tetralux
The headaches I got dealing with that ***.

1561576438
mmx87
Lol

1561576448
mmx87
There's nothing wrong with Results.

1561576456
mmx87
And in Rust they're pretty ergonomic.

1561576464
andrewrk
BitPuffin: thanks. Link?

1561576471
Tetralux
mmx87: I found the whole unwrapping business flat-out confusing and leading to nothing more than loads of indents.

1561576472
companion_cube
zig's error set is more ergonomic when it comes to merging, though

1561576480
Tetralux
I like Zig's errors much better.

1561576490
fengb
I prefer multiple returns, but I'd much rather result than out pointer

1561576492
Tetralux
But would STILL likes multi-return.

1561576495
companion_cube
Tetralux: `x?` you mean? not too bad when it comes to indentation

1561576514
mmx87
Yeah, that's missing in Rust.

1561576526
Tetralux
Also in Zig.

1561576526
companion_cube
there are tuples…

1561576541
companion_cube
`let (x,y) = f();` there you go

1561576554
BitPuffin
andrewrk:

1561576557
BitPuffin
zig build selfie

1561576561
Tetralux
I don't think they had that when I was trying it.

1561576568
andrewrk
Got it

1561576574
companion_cube
rust has had tuples since forever

1561576579
mmx87
I think the biggest pain is that you need to implement a few traits if you want to use your error type conscisely.

1561576609
companion_cube
yep, that's not optimal

1561576613
Tetralux
companion_cube: It's possible I just got bogged down looking at the docs, trying to figure out how best I'd architect getting rid of all the optionals / results and getting to the things I wanted xD

1561576630
companion_cube
you could just use `match`…

1561576635
Tetralux
INDENTS.

1561576638
companion_cube
I mean, optionals are results are there for a reason

1561576643
companion_cube
does your screen have 16 columns?

1561576646
BitPuffin
I guess there is a minor thing with tests in puffy/src/capped_array_list.zig

1561576734
Tetralux
Maybe Zig just makes it more obvious that an error is handled differently, whereas in Zig, Result is just a struct.

1561576738
Tetralux
If you see what I mean.

1561576742
companion_cube
an enum*

1561576751
Tetralux
That's worse xD

1561576765
companion_cube
well no, it must be an enum since there are two distinct cases

1561576769
mmx87
Yeah

1561576770
Tetralux
Indeed.

1561576772
mikdusan2
andrewrk: i guess we have our answer: CI VM probably 4GB

1561576776
companion_cube
Go does it wrong with its 2 return values

1561576789
fengb
Go's error handling has a lot wrong

1561576794
fengb
Not capturing stack traces...

1561576802
Tetralux
Honestly, I like the simplicity of understanding Go's multi-return has.

1561576803
mmx87
Go is like a worse C with safety features and some nice syntactic sugar.

1561576807
Tetralux
It's immediately obvious.

1561576808
companion_cube
Tetralux: simple, and wrong.

1561576812
Tetralux
No complicated stuff.

1561576812
fengb
Single error returns being thrown away

1561576848
Tetralux
I like simplicity.

1561576854
Tetralux
No hidden stuff.

1561576859
Tetralux
And emphasis where it means something.

1561576860
companion_cube
result is not hidden -_-

1561576873
Tetralux
I'd rather Zig's way than Rust's with errors.

1561576873
mmx87
Result is pretty easy when you tried it for a bit.

1561576888
Tetralux
It's just more obvious.

1561576891
companion_cube
Zig's way is pretty similar to rust's result, but baked in

1561576893
Tetralux
And feels more ergonomic.

1561576898
mmx87
It forces you to think what you do wit the result.

1561576908
companion_cube
Tetralux: do you indent with 8 spaces?

1561576916
mmx87
I'm not sure if something like Result woiuld improve Zig.

1561576917
Tetralux
You can also do run(...) catch ...

1561576925
Tetralux
Which prob helps a lot.

1561576936
Tetralux
companion_cube: I do not.

1561576946
companion_cube
then I'm not sure why you're so scared of indentation :3

1561576964
Tetralux
It reads better to me to have as little movement to right as possible.

1561576970
mmx87
4 spaces > everything else

1561576976
Tetralux
Possibly because I don't wanna judge which indent is which.

1561576983
Tetralux
If there's <3, it's pretty trivial.

1561576990
mmx87
Seeing indent is easy.

1561576996
Tetralux
Not for me ^.^

1561577002
mmx87
You should try to program a week in Lisp.

1561577003
Tetralux
Not when you have like 5.

1561577004
companion_cube
heh, don't look at my code then :D

1561577008
mmx87
It basically forces you to focus on indent.

1561577021
fengb
The only additional thing I wish Zig error handling had is capturing context

1561577041
andrewrk
there's a proposal open for that which I am considering

1561577044
Tetralux
fengb: Isn't that exceptions at that point?

1561577078
fengb
Without magical throws

1561577103
Tetralux
I think Zig just does a better job at communicating what it's error stuff is all about and what mental model to use for control flow.

1561577110
companion_cube
so I have code with 10 levels of indent, can't find more in this codebase ;)

1561577114
Tetralux
Whereas in Rust it just felt like a swamp that I was trying to swim through.

1561577114
mmx87
It depends on how you define context.

1561577136
fengb
Honestly, most grievances of exceptions are the hidden control flow. And most "fixes" are reimplementing exceptions in a weird, half-baked way

1561577137
Tetralux
companion_cube: I'm curious what that code is doing.

1561577157
Tetralux
fengb: I'd rather just multiple-return with an error enum.

1561577162
fengb
Go is probably the worst offender

1561577163
scientes
how is @import("builtin") generated?

1561577175
companion_cube
a bunch of algorithmic stuff. It's just in a language with lots of expressions

1561577181
andrewrk
scientes, there's a function in codegen.cpp

1561577195
andrewrk
define_builtin_compile_vars

1561577206
Tetralux
companion_cube: I'm curious - what do you think is the one syntactic thing that would reduce those indents in that case.

1561577218
companion_cube
absolutely nothing

1561577221
Tetralux
Like - being able to shadow a previous optional that wasn't null?

1561577235
companion_cube
I mean, if it were C, I'd have to replace a 20 lines function with 300 lines

1561577251
Tetralux
Or is just literally just if (x) { thing(); if (y) { thing2() .. etc?

1561577256
companion_cube
(because it's nested matches and higher-order functions and stuff like that, it could be more shallow if I named more stuff)

1561577271
Tetralux
companion_cube: You mean...

1561577273
Tetralux
Like...

1561577277
Tetralux
LOCAL FNS?

1561577281
Tetralux
:^)

1561577318
companion_cube


1561577323
companion_cube
local functions, but anonymous

1561577342
companion_cube
there's like one level which could be removed if `match` wasn't so braindead

1561577371
Tetralux
The fact you have THAT many indents with indent-2 is already too much for me xD

1561577378
Tetralux
Although, that does look better than Rust.

1561577380
Tetralux
So

1561577381
Tetralux
There's that.

1561577405
companion_cube
it'd look quite similar in rust, except with 4 spaces

1561577457
Tetralux
Hence worse XD

1561577519
Tetralux
Also I MIGHT have to steal your colors by the way x)

1561577533
companion_cube
wombat256mod for vim

1561577545
mmx87
Usually handling results doesn't change the indentation level.

1561577559
mmx87
If you just want to bubble them up you write result?

1561577605
mmx87
Also, Rust has the if let syntax.

1561577685
Tetralux
For me, Rust has too much friction for me to use it for daily coding.

1561577705
Tetralux
I just want to get to a compiling program as quick as possible and write in the hackiest way.

1561577713
Tetralux
So I can figure out what I want and how I want to do it

1561577720
Tetralux
Only to then rewrite it better later.

1561577730
Tetralux
(If necessary.)

1561577736
Tetralux
OR

1561577746
companion_cube
so why don't you write C? :p

1561577750
Tetralux
Is just easy to write stuff that isn't very hacky.

1561577755
Tetralux
Because...

1561577757
Tetralux
That...

1561577757
companion_cube
(or D, actually)

1561577758
Tetralux
Just..

1561577760
Tetralux
OH

1561577765
Tetralux
D doesn't have struct inheritance.

1561577769
Tetralux
Only classes.

1561577774
Tetralux
AND A GC.

1561577788
Tetralux
I'm not figuring out how to turn that off reliably. x)

1561577791
Tetralux
Can you even?

1561577793
companion_cube
@nogc

1561577803
Tetralux
I don't want it in my program. Period.

1561577805
Tetralux
No GC.

1561577806
Tetralux
NOPE.

1561577809
Tetralux
NADDAH.

1561577831
Tetralux
I'd rather write my own that I know what tradeoffs it makes and when xD

1561577846
Tetralux
And if I'm doing that I'd rather just not have it.

1561577865
Tetralux
Plus it's not that hard to manage it myself.

1561577881
mmx87
A GC is fine if your programming language isn't a system programming language and you just write stuff quickly.

1561577893
Tetralux
There is SOME truth to that.

1561577895
Tetralux
Except that

1561577903
mmx87
Though a GC can be very horrible.

1561577904
Tetralux
It takes so little effort to manage it myself

1561577906
mmx87
See Java on phones.

1561577908
mmx87
Lol

1561577910
Tetralux
That I really don't care enough.

1561577913
mmx87
Now they need 10GB of RAM.

1561577919
mmx87
That's insane.

1561577920
Tetralux
"Solve problems I care about." - You know?

1561577937
companion_cube
so you never have any memory issue? hat off

1561577939
Tetralux
Yeah - I might have to write an OS specifically to replace Android but that can run Android apps or something.

1561577965
Tetralux
I have more with GCs than without xD

1561577990
Tetralux
Plus they're slower to close my program.

1561577991
companion_cube
that's kind of surprising

1561578004
Tetralux
Because they're busy releasing everything that the OS is gonna dump anyway.

1561578050
companion_cube
you can always call `exit(0);` at the end ;)

1561578063
Tetralux
I COULD just not have one xD

1561578105
Tetralux
Also - when I say "I have more than without" - maybe that's exaggarating a little bit ;P

1561578129
Tetralux
But I want to have control over those things by code that I know what it's doing.

1561578181
Tetralux
With a GC, you can still read nullptrs. And a general purpose allocator does the same job as a GC really.

1561578194
Tetralux
Like - The tradeoff just isn't worth it.

1561578210
Tetralux
All that code, for something that one call to malloc, or one arena allocator or whatever could handle just fine.

1561578285
Tetralux
And it could stop my world.

1561578286
companion_cube
(some GC'd languages don't have null pointers…)

1561578302
Cadey
eh

1561578321
Cadey
different tools do different things

1561578342
mmx87
Null pointers have nothing to do with GC TBH.

1561578343
Cadey
i find a GC is better for a lot of my usual programming style because i fire and forget memory allocations

1561578351
mmx87
They're still useful even if you have a GC.

1561578372
Cadey
having a way to represent nothing vs zero is useful in certain cases

1561578373
Tetralux
mmx87: Eh, maybe not.

1561578384
companion_cube
Cadey: Option<T>

1561578391
Tetralux
Cadey: For fire and forget, I'd just malloc anyway.

1561578396
Cadey
companion_cube: my point stands still

1561578414
mmx87
Tetralux, please don't design my next programming language :P

1561578415
Tetralux
Or allocate a bunch of blocks and be done with it. Like how ArenaAllocator does it maybe.

1561578435
Tetralux
mmx87: #StreamOfConsciousness. ;p

1561578463
halosghost
upon reaching the realization that having a safe memory allocator is enough to make use-after-free and double-free into bugs instead of vulnerabilities, I was pretty much sold on the idea that GC should just go away

1561578493
halosghost
plus, `defer` makes “manual” memory management so much simpler

1561578497
Tetralux
halosghost: THERE! That's basically what I was trying to say. x'D

1561578502
Tetralux
Sometimes...

1561578505
Tetralux
Sometimes I feel stupid.

1561578521
companion_cube
how safe can the memory allocator be? would it never reuse a memory slot ever?

1561578532
halosghost
anyone who says malloc/free is “manual” probably hasn't interacted with mmap

1561578541
scientes
all tests passing on linux !

1561578545
Tetralux
companion_cube: Virtual memory.

1561578559
Tetralux
128TB is a lot to use.

1561578560
halosghost
companion_cube: all it needs to do is make sure that once a bit of memory has been allocated for a particular type, that it is only ever used for that type again (for the duration of the execution)

1561578563
halosghost
companion_cube: that's actually it

1561578580
companion_cube
ok, that's reasonably safer indeed

1561578597
companion_cube
(you need it to be tied to a typed language, not C, though)

1561578624
halosghost
C would be fine so long as you're remembering the types and caring about them more than older standards did

1561578638
halosghost
but yeah, a more powerful type system would make that better

1561578640
companion_cube
not sure how you'd do that without any form of generics

1561578643
daurnimator
halosghost: doesn't really work if you have a union member

1561578649
andrewrk
scientes, there's a crash in the behavior tests in release safe mode

1561578697
halosghost
daurnimator: sure it would; it'd just be tagged with the union type

1561578727
halosghost
so, any of the types that allow access to that region of memory would be valid for future allocations

1561578755
halosghost
(I should also mention that “just” is a four-letter word and though what I'm talking about above isn't tremendously difficult, none of it is trivial)

1561578780
halosghost
(though, I would argue implementing a type-safe memory allocator is likely simpler than implementing a GC that performs reasonably well)

1561578983
halosghost
companion_cube: as for without-generics, it could probably be done with some macro magic and _Generic

1561578990
halosghost
though, that wouldn't exactly be pleasant

1561579002
halosghost
it'd certainly be much more pleasant if you had access to something like Zig's @typeInfo

1561579026
Tetralux
If I was gonna write a type-based allocator, def in a lang with typeInfo.

1561579037
Tetralux
Not even attempting that otherwise.

1561579072
companion_cube
especially since you could already do some decisions at comptime based on the type's size, yeah

1561579108
halosghost
but yeah, with use-after-free and double-free demoted to bugs, you could enable range checks on array access (or use some wide-pointer tricks to guarantee safe array access), and you have the vast majority of memory safety errors handled

1561579113
halosghost
no-gc needed

1561579115
halosghost
:)

1561579283
halosghost
personally, I like the wide-pointer tricks because they're backwards-compatible and incredibly compact

1561579432
halosghost
I wish wide-pointers had much wider support

1561579433
halosghost
):

1561579663
companion_cube
having more defensive allocators sounds awesome for security sensitive applications

1561579827
fengb
I'm really happy that Zig supports custom allocators as a design goal

1561580249
halosghost
indeed

1561580281
zie
what would also be really awesome for security sensitive apps is a way to easily check variable assignments for custom constraints..

1561580318
zie
like the postgresql CHECK keyword for example.

1561580378
halosghost
not to pick a fight (because postgres is one of the most standard-philic of the SQL engines), but check constraints are part of standard SQL :)

1561580389
halosghost
and yes, smart constructors are very cool

1561580405
halosghost
some really high-level languages (like Haskell) have them

1561580417
halosghost
I'm not aware of any lower-level languages that have smart constructors

1561580438
zie
halosghost :) indeed.  Well Haskell has Liquid Types, which mostly does that.

1561580442
halosghost
unless you count OOP languages where you can do almost anything in teh constructor

1561580466
halosghost
zie: oh, I didn't even mean Liquid; I just meant plain old smart constructors

1561580471
zie
but as far as I'm aware, it's not integrated or part of the language.

1561580475
zie
halosghost oh?

1561580485
halosghost
zie: it's up to the type implementer to leverage it

1561580504
companion_cube
isn't it the case of any language that has reasonable type abstraction?

1561580534
halosghost
roughly, the way it works is that you don't export the regular data constructors, just the smart constructor functions; i.e., you can only make a new thing via the function that does checks to verify that you're doing sane things

1561580545
halosghost
companion_cube: I guess it depends on how you categorize that :)

1561580572
Tetralux
That just sounds like a constructor fn to me :)

1561580577
companion_cube
if you can force a type to be constructed only via certain functions

1561580609
halosghost
companion_cube: you mostly can in Haskell anyway :)

1561580616
halosghost
Tetralux: I suppose

1561580618
companion_cube
and in OCaml

1561580632
halosghost
companion_cube: cool :)

1561580636
halosghost
I've been meaning to learn ocaml

1561580639
companion_cube
(you can make a type definition readable by all, but constructible only via functions from the same module)

1561580646
companion_cube
it's extremely useful

1561580649
halosghost
I believe it

1561580656
zie
halosghost

1561580659
companion_cube
also pattern matching is amazing

1561580667
halosghost
companion_cube: yes

1561580689
halosghost
zie: right

1561580752
halosghost
doesn't look like it

1561580758
halosghost
not sure it'd be helpful in Zig anyway :)

1561580783
andrewrk
async/await futures are linear, and that's not planned to change

1561580789
andrewrk
but the concept is not exposed to userland

1561580792
zie
"This check will be carried out at runtime, once, when the value is built." -Haskell, which severely limits the checks, unless you always do immutable types.

1561580844
halosghost
andrewrk: linear as in “use only once”?

1561580866
halosghost


1561583629
andrewrk
scientes, I think this one is going to pass

1561583842
halosghost
:D

1561584098
dimenus
andrewrk: do you prefer support on patreon or do you have another method as well?

1561584167
andrewrk
for now patreon is all I have. in the near future I hope to use github sponsors, and more in the future I hope to have started a non-profit org

1561584204
companion_cube
do you have any plans for after 1.0?

1561584212
companion_cube
(like, concurrent implementations)

1561584272
andrewrk
then I want to make a bunch of cool stuff! programming, instead of meta-programming

1561584319
companion_cube
😁

1561584380
andrewrk
I might do a game, or pick back up my digital audio workstation

1561584383
THFKA4
hope you get into the github beta to get those sweet sweet matching bucks

1561584493
andrewrk
long term plan is to potentially make the non profit org do some consulting, and contract people to do zig coding

1561584515
andrewrk
I'd love to be able to pay people to work on zig stuff

1561584521
companion_cube
any dreams of standardization?

1561584534
andrewrk
you mean besides a language specification?

1561584540
andrewrk
(which is planned)

1561584564
daurnimator
zie: there's a proposal around  (in a comment that I can't find) that makes it so that arguments/types can be declared as `somefunc` where somefunc is a function that takes a type and returns a bool

1561584637
companion_cube
like an ISO standard, somewhere in the future

1561584648
zie
daurnimator the closest I found is:

1561584649
companion_cube
(but sure, first it needs a spec and several implems anyway, including one in gcc)

1561584946
mikdusan2
daurnimator: this one?

1561585156
andrewrk
mikdusan2, thanks for all your help with copy-elision-3 branch

1561585160
andrewrk
it's ready to merge now

1561585168
andrewrk
I'm going to try BitPuffin's game real quick

1561585395
andrewrk
hmm what library has xcursor in it

1561585455
andrewrk
nvm found it

1561585504
mikdusan2
andrewrk: nice! 3rd-time is the charm.

1561585620
dimenus
is it possible to pass a define to translate-c?

1561585737
andrewrk
dimenus,

1561585754
andrewrk
oh you mean to the command line?

1561585760
andrewrk
your input file is a c or h file right? put the define at the top in there

1561585846
dimenus
yes, I mean the command line. Thanks!

1561585942
andrewrk
BitPuffin, oh my god this game is demented

1561585951
andrewrk
I'm horrified

1561585978
companion_cube
horrifyingly good?

1561586578
andrewrk
here is some gameplay:

1561586679
companion_cube
seems like the binding of Isaac :D

1561586715
andrewrk
once all the zig tests passed, this branch has survived everything I've thrown at it

1561586745
daurnimator
mikdusan2: yep that's it! zie:

1561586785
Sahnvour
yay for copy ellision

1561586858
zie
daurnimator +1 thanks

1561587233
emekankurumeh[m]
andrewrk: are you going to update the stdlib to take advantage of copy elision?

1561587251
andrewrk
emekankurumeh[m], not yet. that'll need parts 2 & 3

1561587256
emekankurumeh[m]
or will that be in separate PR's

1561587266
andrewrk
the next part of the plan is the coroutine rewrite, which can now take advantage of the new Result Location Semantics

1561587306
emekankurumeh[m]
I mean like taking a pointer in a constructor

1561587332
marijnfs__
lol that game

1561587538
emekankurumeh[m]
for example will this not be a problem anymore?

1561587583
andrewrk
emekankurumeh[m], that's what I mean about parts 2  & 3. in that example, the result is still copied

1561587595
andrewrk
because there is a `var result` - that creates a stack variable

1561587626
andrewrk
and so the `return result` - you can follow the result location: the `return` refers to the non-copying result location. but then the `result` variable gets copied into that result location

1561587630
andrewrk
I'll write this stuff up

1561587674
mikdusan2
i think the "surprise" here is init() stays the same. it's the call site that chooses if it's a stack or heap destination

1561587694
andrewrk
I don't know the order of parts 2 & 3 but part 2 is ability for the return result location to be used throughout the function rather than just in the return expression. and part 3 is unwrapping error unions & optional return types so that the underlying payload is not copied

1561587778
andrewrk
what is about to change is "result location" not "copy elision". Every expression, you can see where the result location flows from outside the expression inwards

1561587792
andrewrk
thejoshwolfe explains it in the original comment on

1561587920
FireFox317
andrewrk: Nice job with the copy ellision branch, I laughed about the video you just posted

1561588070
daurnimator
andrewrk: hit that merge button already ;)

1561588111
andrewrk
but nobody reviewed the code

1561588112
andrewrk
j/k

1561588189
daurnimator
andrewrk: yay

1561588210
daurnimator
> 16 of 19 tasks complete

1561588214
daurnimator
:sweats

1561588234
mikdusan2
make 19 immutable

1561588236
daurnimator
andrewrk: go have a beer

1561588259
daurnimator
andrewrk: and then back to the code mines to merge PRs and then work on #2377 ;)

1561588278
Tetralux
"Houston,  I am ready and waiting to press the button." - Or in my case command line.

1561588279
andrewrk
\o/

1561588301
Tetralux
XD

1561588538
andrewrk
I can't wait to delete all this garbage coroutine code

1561588626
daurnimator
andrewrk: so I'm re-reading #2337 now. I like the @Frame idea. But I'm unsure why calling an function returns the frame. That seems undesireable from a #1778 POV

1561588758
daurnimator
and apparently my spelling/grammar has failed for the day

1561588791
emekankurumeh[m]
+1 for doing a write-up on copy elision

1561588834
emekankurumeh[m]
tbh i'm kinda confused by what "result location means"

1561588939
daurnimator
emekankurumeh[m]: see #2377 for a short explanation

1561588952
daurnimator
> What actually ends up happening is that hi gets a secret pointer parameter which is the address of w and initializes it directly.

1561588973
scientes
I'm going to need to figure out how to actually use the inline assembly if  am to get a number of things done

1561588990
scientes
the error messages are so cryptic and i am not the only one with this problem

1561588997
scientes
tgschultz has the same problem

1561589553
andrewrk
scientes, there's a missing feature to connect the error messages back to zig source

1561589567
andrewrk
it's pretty bad, I wouldn't do any inline asm work debugging without implementing it

1561589599
scientes
oh so llvm gives decent error messages?

1561589611
andrewrk
you're seeing llvm's error message but it's missing context

1561589623
scientes
well yeah i figured so

1561589997
shollrollah951
Tried solving an euler problem with zig:

1561590099
emekankurumeh[m]
daurnimator: that's what I thought but, in the issue I linked to earlier andrewrk said the the result was still copied.

1561591143
rsdimenus
is there a way in zig to specify that a function has a different link name than the one you're using in code? eg glfw

1561591158
rsdimenus
I'd prefer to use glfw.Init() rather than glfw.glfwInit()

1561591748
andrewrk
dimenus, I believe I have a proposal open for this

1561592444
scientes
are you sure we want a @splat() intrinsic?

1561592457
scientes
I am not sure it is a footgun to not have it

1561592468
scientes
well actually it might be

1561592471
andrewrk
scientes, I'll have to refresh my memory to be sure

1561592495
scientes
yeah it would be when you have a function that takes vectors, and it would then implicitely cast from non-vectors

1561592499
scientes
which could be problematic

1561592629
scientes
yeah i think its a good idea

1561592795
andrewrk
emekankurumeh[m],

1561592804
andrewrk
I think this addresses your questions

1561592846
andrewrk
still working on the other part

1561592926
companion_cube
I'm excited by the idea of having custom allocators that would limit available memory

1561592946
companion_cube
so you could give them to a library and be confident that the rest of the program won't get oom'd

