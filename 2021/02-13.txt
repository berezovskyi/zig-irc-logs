1613174415
zags
andrewrk: one GPA for the entire app? This is a long-running server app. I was initially thinking of serving up arenas per request, but not sure what's best.

1613174448
zags
A single GPA can presumably get fragmented over time

1613174473
andrewrk
an arena per request is almost certainly in order

1613174518
zags
and each of those backed by a shared GPA?

1613174543
andrewrk
first I would try a single GPA for everything since it's simpler, but could be interesting to try a pool of GPAs that you would use per request as well

1613174560
zags
alright

1613174583
andrewrk
depending on how you have things set up, you may be able to avoid using locks on the per-request GPA

1613174698
zags
requests will be handled from a thread pool, so I'd need locks for the shared gpa case, which is why having a pool of those sounds like a good suggestion (maybe tie it to the request pool)

1613181695
mikdusan
marler8997: pending rev3:

1613181798
marler8997
reading

1613181817
mikdusan
aah i left 2 fails. lol

1613181836
marler8997
yup just saw em :)

1613181879
mikdusan
fixed

1613181882
marler8997
I like that you're tracking the revision notes

1613181975
marler8997
missing close paren: "    // NEW: propagate error (equivalent to OLD `return error.Bad`"

1613182046
marler8997
the first `afunc` in example.zig is demonstrating the new code with a very uncommon use case, namely, a function that returns an error without triggering a throw

1613182092
marler8997
It might give people a bad impression when they see "return error.bad" and realize it's not triggering an actual error

1613182151
marler8997
we could change afunc to return !void, then show that "return error.Bad" would result in a compile error

1613182183
marler8997
then further down show how you can use errors as values also

1613182296
marler8997
I think you're missing an item in the initial list of changes

1613182302
mikdusan
i think that's the only place where I show that means "return an error _value" . the other cases are "return value-error-union"

1613182306
marler8997
I don't see the new "catch EXPR" being mentioned there

1613182325
mikdusan
`var d = catch doit();`

1613182339
marler8997
I mean in the initial list that currently has 4 items

1613182348
marler8997
after "Primary to this proposal to elevate error flow-control to lexical distinction from regular flow-control:"

1613182352
mikdusan
hmm...

1613182364
mikdusan
the gist:

1613182376
marler8997
looking at this now, I actually think the whole "catch EXPR" is an optional part of the proposal

1613182412
mikdusan
yes I should add it in the 1-6 list somewhere.

1613182417
marler8997
it might be completely orthogonal to everything else

1613182476
mikdusan
well if catch isn't there, not sure how to handle cases where that is currently done in code. ie: can't allow `const x = doit();`

1613182564
marler8997
without the "catch EXPR", wouldn't "const x = doit()" just work like today, where "x" is just an error-union?

1613182574
mikdusan
today we have `const x = doit()` which has 2 cases. the common case: error, you want `const x = try doit()`. the rare case: `const x = doit()` <-- both in context of zig status-quo

1613182637
mikdusan
it works today but I don't want it to work:

1613182639
mikdusan
/ NEW: do not let an error-union

1613182673
marler8997
right I understand the justification, I'm just saying I think it's orthogonal to the other changes

1613182708
marler8997
I mean, you could do everything else in the proposal and not do that, its still an improvement and everything still works

1613182722
marler8997
unless I'm missing something

1613182750
marler8997
if that's the case, we may want to make the separate proposals

1613182753
mikdusan
I did state this but it might not be rich enough "elevate error flow-control to lexical distinction from regular flow-control"

1613182781
marler8997
yeah, it still falls under that umbrella

1613182791
marler8997
so that's a good argument to keep it under this proposal

1613182800
mikdusan
the point infinite monkeys (myself) typing in `const x = doit();` compile. then use x. then get fat error and scratch head. then learn oh that error... need `try doit()`

1613182826
marler8997
right, that's definitely a footgun

1613182850
marler8997
let's make sure we include that footgun somewhere in there, is it in there?

1613182872
mikdusan
i wrote a stage1 mod to trace everytime an error-union is stuffed into a decl. 16 times. for all of zig CI test code on macos platform.

1613182907
marler8997
very nice, that's great data, you immediately catch 16 existing bugs!

1613182944
marler8997
"catch" more bugs with "catch", now we have a slogan! :)

1613182947
mikdusan
they're not bugs. at least the ones I looked over. it's intended usage. but for sure they'd need conversion to `const x = catch doit()`

1613182957
marler8997
oh dang

1613182996
mikdusan
here's an instance

1613182999
mikdusan


1613183043
marler8997
do you think we want to mention this as a path forward to solve #2647 in related proposals?

1613183200
mikdusan
that one I've not fully groked yet. mainly because I'm thinking why aren't people balking... doesn't #2647 mean the error-union is sum-type as fat as the largest subtype? I get that it can get pruned as the errorset coerces down... but it is fat until so

1613183286
mikdusan
I'll give it a better read tonight and see about referencing it. do you have initial thoughts on how 7812 might help 2647 ?

1613183299
marler8997
yeah true, it would have to coerce down properly to be reasonable

1613183332
marler8997
it helps because it provide a lexical way to throw an error without it being an error value

1613183368
mikdusan
I suppose too because result-location-semantics fat is relgated to the stack, and not return-copied-to-stack so there is that

1613183440
mikdusan
it's funny how 1 tiny feature (RLS) opens the door to many things

1613183469
mikdusan
tiny written in italics :P

1613183513
marler8997
if we want to mention it, I would say something like "because this proposal provides a lexical way to throw errors, it could be used to solve #2647"

1613183528
marler8997
I think that's a sign of a great proposal, that is solve many issues

1613183656
mikdusan
ah ok are you referring to `return error{ .InvalidChar = index }` that

1613183668
mikdusan
(just a hot take)

1613183688
marler8997
yup, you got it

1613183781
mikdusan
ok so they are saying it removes need for extra syntax. but it's actually overloading error{} syntax because today it's just error{Thing0,Thing1} like enums. not like anon struct initializers

1613183819
mikdusan
yeah 7812 could help. because `return .{ .field = value };` is totally cleared up too

1613183836
marler8997
yup

1613183873
mikdusan
ok def will reference #2647 .

1613183878
marler8997
in f1

1613183889
marler8997
// [1] `f1()`       error {Overflow,Underflow}

1613183904
marler8997
I think that's supposed to be error.Overflow (in the .Overflow case of the switch)

1613183936
marler8997
we should probably update the comments about the error stack with the new terms clear/push/throw

1613183964
mikdusan
yeah that table i think is going to go in

1613184035
mikdusan
doit() errorset is error{Overflow,Underflow}

1613184092
mikdusan
maybe I need a clearer way to show it. but trying to show the frame with depth on left, and possible errors on right

1613184097
marler8997
the comments for .Overflow and .Underflow are showing different ways of representing the error set of f1()

1613184142
mikdusan
switch (err). 2 possible values right?

1613184165
mikdusan
ugh

1613184168
mikdusan
duh

1613184175
marler8997
lol

1613184216
marler8997
oh and I just realized doit's actual error set is Overflow/Megaflow

1613184231
mikdusan
heheh

1613184296
mikdusan
udpated

1613184309
marler8997
I think we can improve the rationale section for @clearErrorStack

1613184323
mikdusan
does my gist allow you to comment? if so feel free.

1613184352
marler8997
I can make a comment at the bottom I can't see how to make line comments

1613184390
mikdusan
feature not implemented :(

1613184476
marler8997
what was the proposal to clear error stack after catch block?

1613184490
mikdusan


1613184578
mikdusan
the gist suffers from other things too... like a #1923 issue ref won't resolv until it's an issue comment. the gist isn't associated with a repo like issues are.

1613184595
marler8997
this is what I would say:

1613184596
marler8997
We found multiple cases where a programmer may want to clear the error stack at different places or even not at all.  By providing this builtin the programmer is able to have full control of when and to clear the error stack if at all.  Note that this builtin does not prevent other features from also being implemented to clear the error stack such as

1613184607
stilbruch
would this be the palce to ask basic zig questions? I do alot of development with c, and tonight I am giving zig a try

1613184613
daurnimator
stilbruch: sure

1613184667
marler8997
typo "...programmer is able to have full control of when to clear the error stack if at all"

1613184696
stilbruch
okay just making sure. I am creating an init function for a struct that takes in a file. I want to some integers and arrays from a file into integers and arrays in the struct. Zig is not letting me instantiate the struct and then fill in the values later. What would be the idiomatic way to do this?

1613184739
marler8997
stilbruch, can you provide a link to the code?

1613184754
mikdusan
got the paragraph in.

1613184766
marler8997


1613184784
stilbruch
Sure let me put it in pastebin or something

1613184785
mikdusan
{ @panic("tru dat"); }

1613184875
stilbruch


1613184918
marler8997
var cartridge : Cartridge = undefined

1613184933
g-w1
or provide default struct values

1613184935
marler8997
another option is adding default values to your fields

1613184964
marler8997
an yet another option is partial initialization: var cartridge = Cartridge { .magic = undefined, .prg_blocks = 0 };

1613184975
marler8997
in your case, I would set .magic as a default value

1613184977
g-w1
especially if magic is constant, you can just put it in the struct definition itself

1613184996
marler8997
magic: [4]u8 = "\x4e\x45\x53\x1a",

1613185000
stilbruch
Well it's not constant, it can be anything. It just

1613185032
g-w1
then undefined should work the best imo

1613185040
marler8997
^

1613185140
stilbruch
file.read isn't playing nice with my magic array either. Says it needs []u8, not [4]u8. Any way I can cast my array or something?

1613185150
marler8997
prefix with &

1613185167
marler8997
&cartridge.magic

1613185193
g-w1
even in c it would need to be a pointer, but in zig it needs to be a slice (pointer + len)

1613185224
marler8997
yeah, and pointers to arrays (which are "values" in zig) implicitly convert to slices

1613185254
stilbruch
so in c terms magic would be an array (pointer). and file.read wants a slice (pointer to array), which would be like a uint8_t** in c?

1613185258
stilbruch
just making sure I understand

1613185267
marler8997
no

1613185283
stilbruch
well a slice has a length too, so better than uint8_t**

1613185295
daurnimator
stilbruch: C doesn't really have arrays (except for when it does)

1613185297
marler8997
in c terms, a Zig array of 4 bytes is equivalent to struct { char _0; char _1; char _2; char _3};

1613185319
marler8997
a slice is not a pointer to an array

1613185348
daurnimator
stilbruch: btw though, you probably want `file.reader().readBytesNoEof`

1613185373
marler8997
its like a struct like this "struct { char *ptr; size_t len }"

1613185403
marler8997
where ptr is pointing to an "array"

1613185433
marler8997
I quoted "array" because I've overloaded the term here

1613185679
mikdusan
marler8997: added binary table (just after code example)

1613185697
mikdusan
oh bad copy. one moment.

1613185819
mikdusan
k I think it's correct now. note the permutations are same for try/throw

1613185836
marler8997
good, I was about to say something :)

1613185866
stilbruch
okay so i'm reading the magic bytes now. If I want to read a u8 from a file, how would I do that? Is there a good way to cast a u8 to a slice, or pass a pointer like I would in c?

1613185871
marler8997
you should put the try/throw case in the same box, on different lines

1613185873
marler8997
there's a way to do it

1613185889
mikdusan
yeah that should work

1613185946
daurnimator
stilbruch: `file.reader().readByte` ?

1613185961
daurnimator
stilbruch: I'm not sure what you mean by "cast a u8 to a slice"

1613186038
stilbruch
uh I'm bad with the terminology. like in c I would just use "read(fd, &cartridge.prg_blocks, 1)"

1613186040
marler8997
self correction, replace

1613186041
marler8997
"By providing this builtin the programmer is able to have full control of when and to clear the error stack if at all."

1613186047
marler8997
with "By providing this builtin, the programmer has full control over when to clear the error stack, if at all."

1613186133
marler8997
The first sentence "Primary to this proposal..." doesn't sound grammatically correct to me

1613186243
marler8997
what about this? "The primary goal of this proposal is to distinguish error control flow lexically rather than have it be triggerd by values at runtime."

1613186291
marler8997
with this proposal, "return x" never triggers error flow control no matter what the value of x is

1613186339
mikdusan
the first part "at runtime" doesn't sound right

1613186368
marler8997
yeah

1613186379
marler8997
triggered by runtime values?

1613186397
mikdusan
(btw it was supposed to be "primary to this proposal

1613186570
mikdusan
the big thing is ambiguity. by making it lexically distinct, it removes "what does `return doit();` mean. what does `return try doit();` mean and why do they both work and do exactly the same kind of thing. but not just limited to those cases.

1613186608
marler8997
right, now "return x" always returns, never triggers error flow.  Error flow now required either "try" or "throw"

1613186700
mikdusan
the the first part. before:

1613186703
mikdusan
Primary to this proposal is to elevate error flow-control to lexical distinction from regular flow-control:

1613186710
mikdusan
now:

1613186713
mikdusan
The primary goal of this proposal is to distinguish error control-flow from regular flow-control:

1613186720
marler8997
sure

1613186721
marler8997
better

1613186737
marler8997
I think we should include that second sentence to.

1613186757
marler8997
Maybe "With this proposal, "return x" is always regular control flow." ??

1613186811
mikdusan
as part of item #1 or before it

1613186833
marler8997
this definitely makes Zig adhere more to its tenant of "no hidden control flow"

1613186865
marler8997
because before, you wouldn't necessarily know whether "return x" executes errdefers or trigger the caller's catch block

1613186885
marler8997
I dunno, it should be somewhere though :)

1613186966
marler8997
actually ignore me on that

1613186970
marler8997
that's your first bullet

1613186991
marler8997
`return` no longer triggers error flow-control

1613186997
mikdusan
i'm really glad fengb pointed out #2562; while not directly addressing it, #7812's emergent behavior covered that issue. love it when that happens.

1613187066
marler8997
yeah, that one's been bugging me too

1613187497
marler8997
for bullet 2, maybe say "only try and throw trigger error control flow" ??

1613187535
marler8997
or "error flow may now only be triggered by 'try' or 'throw'"?

1613187542
mikdusan
2. only `try` and `throw` effect error flow-control

1613187551
marler8997
ok

1613187565
mikdusan
ah but not entirely true. builtin.

1613187576
marler8997
oh right

1613187610
marler8997
so this bullet is really just introducing "throw" to replace the old "return error"

1613187653
marler8997
"introduce the 'throw' operator to trigger error flow control"

1613187724
mikdusan
s/require/use/  ; and `use throw instead of return when pushing....`

1613187737
marler8997
or we could say "replace the current 'return ERROR' mechanism with 'throw ERROR'"?

1613187811
marler8997
mikdusam that works

1613187920
mikdusan
a slight prob is while i get exactly that point, `return <error>` meaning type `error`, the usage of `return` idiomatically includes `return doit();` which now becomes `return try doit();`

1613188008
mikdusan
2. replace current `return error.BadValue;` with `throw error.BadValue;` when pushing an error onto error-stack and leaving function

1613188018
mikdusan
that's pretty clear?

1613188053
marler8997
sure, I don't think you need to explain what it's doing, but probably doesn't hurt

1613188072
mikdusan
ah yup

1613188081
marler8997
actually if you're going to explain, I would also say it's triggering error flow-control

1613188102
mikdusan
i'm looking at your comment

1613188117
mikdusan
how would the first return be with our proposal

1613188147
marler8997
throw SomeStruct.init(...)

1613188177
mikdusan
but that's a struct-type. to which error does it get associated with?

1613188187
mikdusan
error-enum i mean

1613188197
marler8997
yeah, that's what the proposal is trying to address

1613188240
mikdusan
ok there might be more than 1 thing tho. the `return error{ .WideError = index };` is pretty clear to me

1613188255
mikdusan
but `return error Foo.init(...)` I don't get.

1613188314
marler8997
it means the caller would get an instance of Foo when the catch/switch on the error

1613188320
mikdusan
consider: `error{ One, Two: u32, Three: Foo, Four: Foo }`

1613188327
mikdusan
which enum gets Foo ?

1613188342
mikdusan
s/enum/tag

1613188366
marler8997
oh yeah I see what you're asking

1613188375
mikdusan
i think daur has a similar comment. one sec.

1613188382
marler8997
using a tagged union makes sense there

1613188417
mikdusan
ah n/m. this one is the error type itself so I get it:

1613188423
mikdusan


1613188451
mikdusan
ok right. so I'll pull 2 or 3 of those examples and add them to proposal showing #2647 vs. #7812 syntax

1613188472
marler8997
throw error { .ParseError = .{ .InvalidChar = index } }; ???

1613188509
mikdusan
ParseError is ok... because it's the error!result  of the union.

1613188532
marler8997
oh right

1613188543
mikdusan
this ziggy is tricky tricky

1613188557
marler8997
you're idea of using a normal union got me thinking though

1613188570
stilbruch
I really don't understand what this error means.

1613188574
stilbruch
its around half way down

1613188721
marler8997
mikdusan, you could include examples if you want, just mentioning it could be helpful I think is enough

1613188752
mikdusan
already 3/4 done

1613188763
marler8997
ok

1613188804
marler8997
stilbruch, I don't know that looks weird, maybe your stack trace line number is wrong

1613188850
marler8997
is that a runtime error or compile error?

1613188903
stilbruch
its a compile error

1613188915
marler8997
oh got it

1613188925
marler8997
@intCast(usize, cartridge.prg_blocks)

1613188984
stilbruch
ah okay that makes sense. thanks for the help, I appreciate it

1613189169
mikdusan
marler8997: updated

1613189528
marler8997
reading

1613189627
mikdusan
maybe I should move related-proposals to bottom of doc, but before changelog.

1613189712
marler8997
I think the examples you added at least should be moved to bottom

1613189860
marler8997
maybe we should move bullet 5 to secondary?

1613189948
mikdusan
yup done

1613190018
marler8997
in regards to the first question about using "try error.Foo"

1613190026
mikdusan
ah so for gist I changed the primary "doc" out to be a simple 1-liner. and have been using the comment for iterating this doc. The reason was because the primary in gist is too big a font and irks me. but I think that's where you can make line-comments. lol

1613190083
marler8997
huh?

1613190093
marler8997
is there a new link?

1613190107
mikdusan
no no earlier you mentioned something about not being able to comment on lines

1613190158
mikdusan
and I chalked it up to no feature support in github. It's because gists have like "files" but I put this doc into a comment

1613190171
mikdusan
and it's the files that show diffs

1613190176
marler8997
oh

1613190192
mikdusan
I'll do it the right way next round :P

1613190199
marler8997
got it

1613190216
marler8997
ok, in regards to the first QA question

1613190252
marler8997
let's assume we never added the "throw keyword"

1613190269
marler8997
then I believe that "try error.Foo" would still work the same way, it's not actually an overloaded use of try, is that correct?

1613190302
mikdusan
hmm no I just tried master and it errors out with `expecting error-union got error` or somesuch

1613190304
marler8997
oh wait not, try expects an error union, it doesn't work with just an error value

1613190327
marler8997
I would also mention another point about that

1613190351
marler8997
if we overloaded "try", then it looks like an error may or may not be thrown, you'd have to know the value to know for sure

1613190372
marler8997
by using a different keyword, you immediately know that an error is always being thrown, no matter what the value is

1613190374
mikdusan
oh right. try specifically means maybe throw

1613190379
marler8997
exactly

1613190410
mikdusan
#define MAYBE_THROW try

1613190411
mikdusan
oh busted

1613190413
marler8997
I think that's the main argument for not overloading try

1613190427
marler8997
lol

1613190541
mikdusan
The `try` keyword means "maybe throw" and overloading it to accept expressions of type `error` would change that use meaning to `always throw`.

1613190620
mikdusan
A. The `try` keyword means "maybe throw" and overloading it to accept expressions of type `error` would change that use to mean `always throw`.

1613190623
marler8997
...  This means the semantics of try would depend on the value of the expression after it, its no longer clear what "try x" will do

1613190635
noam
andrewrk: On a more positive note, I think I have an idea on how you can reduce memory usage by at least another five bytes per node.

1613190683
noam
I'm still experimenting with the idea for myself, but basically: instead of lhs/rhs and extra_data, you store an (untagged!) union of nodes and indices

1613190711
noam
every entry contains, instead of lhs and rhs, the number of children nodes. Then, that number of entries following it are indices

1613190851
noam
With n=0, that's 4 fewer bytes (no lhs, no rhs). With n=1, it's the same size. With n=2, you're four bytes higher - but with n=3+, you drop the lhs, start, end, and index into extra_data, and replace it with nkids plus args

1613190874
noam
With a few other changes, the added overhead actually gets dropped, and you get it so that you save bytes for all values of n

1613190883
noam
(changes which are unblocked by this)

1613190932
mikdusan
marler8997: ok updated - MOVED to top of gist (the file). reload gist

1613190978
mikdusan
and now the Q.A. is rendering different. what the.

1613191099
mikdusan
fixed.

1613191509
noam
Writing up proposal now :)

1613191829
marler8997
very nice, one more comment

1613191833
marler8997
bullet 3

1613191863
marler8997
overloading catch isn't really the point, more the mechanism we chose

1613191880
marler8997
the point is more about inadvertently missing errors

1613191888
mikdusan
ah yeah it currently reads as a changelog lool

1613191923
mikdusan
here is how i commented that code:

1613191926
mikdusan
/ NEW: do not let an error-union

1613191962
marler8997
require explicit syntax to capture an error-union as a value?

1613192032
mikdusan
i did want to shy away from "capture" because of the postfix idiom `|err|`

1613192048
mikdusan
but it is qualified as error-union so it is correct

1613192079
marler8997
require error-union values to be caught explicitly?

1613192089
mikdusan
i like your first better

1613192142
marler8997
what case is bullet 4 for?

1613192165
marler8997
is that for "return doit()" must now be "return try doit()"?

1613192178
mikdusan
/ NEW: do not let an error-union

1613192185
mikdusan
`var c = doit();`

1613192197
mikdusan
it's the counterpart to prefix-catch

1613192232
marler8997
so it's saying the same thing, just in a different way?  do we need it then?

1613192247
noam
ifreund: curious in your thoughts on

1613192273
mikdusan
marler8997: yeah correct. this falls in the same boat as more of a changelog

1613192312
mikdusan
updated

1613192342
mikdusan
oh I'll just line-space the related proposals. formatting bork

1613192383
marler8997
looks great

1613192429
mikdusan
one thing about the motivating case for @throwCurrentError_Supercalifragalisticexpialidiosious()

1613192438
mikdusan
can you think of a better case?

1613192494
marler8997
I can't think of one no

1613192517
mikdusan
ok I'll update the actual proposal. this should be good for now.

1613192524
marler8997
cool

1613192557
marler8997
wait

1613192560
marler8997
no more TLDR?

1613192575
mikdusan
heh no. it was pretty much the same thing as code section.

1613192580
marler8997
ah ok

1613193927
marler8997
I think the proposal would be better with a section explaining the problems

1613193937
marler8997
"the problems" meaning, the issues that this proposal is solving

1613193946
marler8997
like the var x = doit() footgun

1613193949
mikdusan
concrete motivations. sounds good.

1613194008
marler8997
the ambiguity of: fn foo() !(error{Bad}) { return error.Bad }

1613194087
mikdusan
tbh right now I'd have to go try that code to see what it does

1613194124
marler8997
yeah me too :)

1613194166
mikdusan
oh wow I did not expect this:

1613194171
mikdusan
error: error is discarded. consider using `try`, `catch`, or `if`

1613194181
mikdusan
`    _ = try doit();`

1613194186
mikdusan
your foo()

1613194284
marler8997
hmmm, that's not what I got actually:

1613194354
mikdusan
yeah now replace that statement with `_ = try foo();`

1613194373
mikdusan
so if you don't ignore it, the answer is: it's a throw

1613194381
marler8997
hmm, that's weird

1613194392
marler8997
it also means there's no way to actually return a value from this function

1613194397
mikdusan
if you ignore it ala `_ =` you get a funky error maybe appearing because it wants attention but for no other good reason :P

1613194425
mikdusan
yes unless you wrap/box it in a struct or something

1613194436
marler8997
yeah it's a really weird mix between how Zig handles error vs values

1613194641
marler8997
I think the stronger issue this solves is that currently you can't tell lexically whether error flow-control is triggered "return x" may or may not

1613194683
marler8997
that's a more general description of the error.Bad example we just looked at

1613194740
marler8997
for the exact same reason we though it was better not to overload try, we are moving the "return" overload

1613194766
mikdusan
"maybe" control-flow

1613194770
mikdusan
err-control-flow

1613194802
mikdusan
so yeah return is currently "maybe error control-flow or regular control-flow"

1613194805
marler8997
today: try = "maybe throw", return = "maybe throw"

1613194819
marler8997
with proposal: try = "maybe throw", return = "no throw", throw = "throw"

1613195044
marler8997
So maybe in the proposal we say something like.  "In Zig the "return" statement is overloaded to return both values and errors with error flow-control.  This proposal simplifies "return" to only handle values, and adds a new "throw" keyword to handle errors.  This has the advantage that one can always immediately tell whether a return/throw statement will return a value or trigger an error."

1613195098
marler8997
Wording could probably be improved, but something like that maybe

1613195307
mikdusan
on that, note #2 can probably be nuked. the 2 big parts are #1 and #3. #2 is a detail of

1613195374
marler8997
yeah, but it's an important detail, maybe important enough to be included in it's own bullet (or mentioned in the first bullet)?

1613195404
mikdusan
either way works for me.

1613197273
andrewrk
noam, n=3+ is very rare, it's better to optimize for n=2

1613213745
ky0ko
i've been thinking the past few days about how i would write a forth implementation in zig, and have come to the conclusion that i have absolutely no clue what that would look like in the slightest. which is a sign to me that i should try and write one

1613219623
ifreund
hmm, you can't use multline string literals with extern, this seems inconsistent

1613219714
ifreund
noam: I think it's cool that you can do that. I don't know it if would yield better performance in the end though. I think andrew's probably right about n=2 being the most common

1613219750
ifreund
someone should totatally collect some actual data on that though, using e.g the std as an example codebase

1613226229
tane
ok it seems like `shrink` => `shrinkAndFree` was done at a lot of places due to do rename, but `shrinkRetainingCapacity` would be the right choice most of the time

1613226379
tane
some of these are up to discussion though, like json.Parser.reset, currently freeing the buffer completely. I'd argue that retaining the capacity would be fine here, because otherwise one could just init a new parser instead of resetting it.

1613232565
noam
ifreund: I didn't contest that tehy're the most common - they have to be more than just more common for it to not be a net gain, they have to be an order of

1613232599
noam
Note also that it optimizes for n in [0,1] more, as well

1613234019
ifreund
noam: I think this needs science

1613234049
noam
For sure!

1613234065
noam
I will note that the more extreme variant I'm using actually wins even at n=2

1613234082
noam
But I also don't think that's a good fit for stage2, so /shrug

1613234113
noam
(It makes use of relative indices, which means you add the index at which the index of a child is found to said index to find the index of the child... that came out more confusing than it really is)

1613234154
ifreund
and so you are limited to math.maxInt(u16) children right?

1613234244
ifreund
we're already limiting file size to math.maxInt(u32) bytes...

1613235411
noam
No, I have a way around that :P

1613235460
noam
I'm using an

1613235477
noam
So mine is affected by node locality instead of node children count

1613235549
ifreund
that does sound funky... I though your compiler was supposed to be simpler :P

1613235734
noam
It is :)

1613235867
justin_smith
ky0ko left, but there are some excellent examples on line of "forth in only N bytes of assembly", surely the zig code would be smaller

1613235892
noam
Then handwritten asm?

1613235894
noam
I doubt it.

1613235916
justin_smith
noam: the code base itself, not the executable size, sorry

1613235927
noam
Ohhhh, okay, no that's my bad

1613235939
noam
I don't think that's a good way to go about it though

1613235956
noam
Porting asm to Zig won't result in high-quality Zig; idiomatic asm and idiomatic zig are diametrically opposed.

1613235996
justin_smith
noam: the reason I suggested it was that it's shocking how small a full forth impl is in assembly (if you are used to what "normal" assembly looks like), but yeah, I wouldn't neccessarly translate it line for line...

1613236012
justin_smith
that's a fair point

1613236028
noam
Yeah, forth is awesoem

1613236031
noam
awesome*

1613236090
justin_smith
it's hard to beat when your main concern is as few bytes in RAM as possible

1613236126
noam
ifreund: you do have a point though, but not for the reason you think -I do think my way remains simpler than stage2, but I think I can make it even simpler in exchange for a relatively minor hit to performacne...

1613236214
noam
Plus, without hard numbers indicating that this is faster, it's entirely reasonable to assume that the arithmetic on lookups would counteract the saved memory vs the 8+4N scheme

1613236247
noam
if the goal was more about CPU than RAM, that would be enough reason on its own

1613236330
noam
ifreund: yeah, I'm probably going to use the 8+4N one instead

1613236359
noam
Even if Andrew is right that it ends up being worse due to a preponderance of n=2 nodes, it's definitely simpler both than the 6+2N scheme and the extra_data scheme

1613236366
noam
Thanks!

1613236504
ifreund
your welcome :D

1613236517
ifreund
*you're

1613236775
ifreund
noam: ok here are some very rough numbers: { 766932, 89277, 264456, 123193 }

1613236786
ifreund
that is n=0,1,2,>2

1613236807
zags
bleargh, how do I debug tests? The test crashes, but if I convert it to main it no longer crashes so I can't debug it haha

1613236807
ifreund
for parsing all of lib/std with the currently ast-memory-layout branch

1613236825
ifreund
zags: when the test crashes it should log the command that was run

1613236838
ifreund
copy and paste that command to your gdb invocation

1613236860
zags
oh i see it logged - no gdb in sight, but i'll do the same with lldb

1613236861
zags
thanks

1613236913
zags
a stable test exe would be nice so I can put it into vscode's task file

1613236956
ifreund
not sure if there's an easy way to do that, maybe -femit-bin=foo works with zig test

1613237040
zags
oh yeah, that solves it!

1613237196
ifreund
andrewrk: looks like we've got ~3x as many n=0 nodes as n=2 nodes... I think noam's proposal is worth considering

1613237235
ifreund
code here:

1613237340
ifreund
I may have made minor errors in the Node.Tag => n mapping, I did it pretty fast

1613238690
zags
Had a hard-to-track-down bug which I partially blame on Zigs nameing of struct declarations :) var counter: u64 = 0; makes it look like it's per instance. I know it's not, but it's kinda easy to mix up. I think a static keyword would make sense.

1613238733
zags
unless of course this is the first time you hear of such a bug haha

1613238744
marler8997
zags, if nothing else changed, that would mean putting static on literally everything because files are also structs

1613238785
zags
implicit structs, so they could be implicitly static?

1613238806
zags
anyway, "var' makes it look like per-instance data

1613238808
marler8997
there was a proposal for that, it got rejected maybe I can find it

1613238854
zags
it totally tripped me up when I was learning zig because the docs do a bad job pointing it out, then i learned it, and i still made a bug

1613238887
zags
not a problem if you're doing zig 100% of the time, but certainly a footgun when jumping between langauges

1613238900
zags
and footguns should be pink :)

1613238937
marler8997
in your case, how did this become a footgun?

1613238963
marler8997
since you access instance/global variables differently, how did you mistake it for an instance variable?

1613239054
zags
marler8997: because the update happens behind accessors

1613239057
marler8997
here is that proposal that I think is what you meant by "implicit static":

1613239058
caolanm
is there an easy way to read the contents of a file at build time and include the data in my binary?

1613239114
zags
marler8997:

1613239115
marler8997
zags, you still have to access then differently

1613239118
zags
it's that type of situation

1613239120
marler8997
inside the struct

1613239136
marler8997
if it was an instance variable, it would be self.x += 1

1613239147
zags
yes, how is that not an easy mistake to make?

1613239169
marler8997
you had to make 2 mistakes there

1613239173
zags
yes

1613239196
zags
it's a total footgun

1613239209
marler8997
I'm sure I've made both mistakes at different points, but I don't think I've ever made both mistakes at the same time

1613239226
zags
having to do "Shared.x +=1" would solve it

1613239230
zags
marler8997: you're better than me

1613239242
marler8997
lol, well that wasn't what I meant

1613239255
marler8997
I was saying it's going to be more rare if you have to make 2 mistakes in concert

1613239257
ugla
caolanm:

1613239271
marler8997
zags, using Shared.x is an interesting idea

1613239298
marler8997
but maybe that is just moving the problem?

1613239304
marler8997
because accessing Shared has the same issue?

1613239305
zags
marler8997: you mean not using self. two places? That's an obvious risk when you write the two functions at the same time. If you make the mistake in the first function, you're likely to make it in the next.

1613239335
zags
Look at the example. var x makes it look like an instance variable due to naming

1613239343
marler8997
I mean, you have to both mistakenly declare the variable as a global instead of a field, and also forget to access it through "self.foo"

1613239345
zags
then you write x +=1 and return x

1613239349
caolanm
ugla: sorry, that's a bit too easy. have you got anything more difficult?

1613239350
caolanm
:P

1613239358
ugla
:D

1613239359
marler8997
so that's 2 mistakes that have to work in concert simultaneously

1613239373
zags
the second mistake easily follows

1613239416
marler8997
sure I can see that opinion, my point was just that it's harder than having to make just one mistake

1613239440
zags
look, if you're in the frame of mind that "var x" makes an instance variable, then I'm kinda making only one mistake

1613239443
zags
I think you can see that

1613239456
marler8997
of course

1613239459
marler8997
that's the first mistake

1613239503
zags
a total non-issue if I was doing zig all day long haha

1613239553
marler8997
yeah I can see how this would be an issue if you're working with other language

1613239564
zags
I see how i'm making two mistakes, but I'm also interned that var means not using self, so ugh

1613239568
marler8997
you're more likely to make both mistakes

1613239581
zags
yeah, and "var" makes it easier to do so

1613239738
zags
marler8997: could you elaborate on why Shared.x moves the problem? If you HAD to use self.x or Shared.x, for fields and decls respectively

1613239774
marler8997
could you make the same mistake with Shared?

1613239868
marler8997
I suppose you would say no because it is "const" instead of "var"? Is that right?

1613239887
zags
not sure, if i'm forced to write TypeName.decl, I won't mistake it for an instance variable

1613239905
zags
hm, it's not const

1613239906
marler8997
But could TypeName also be an instance variable?

1613239920
marler8997
you see what I'm saying, TypeName is also inside struct, everything in Zig is inside a struct

1613239920
zags
That's the enclosing type

1613239944
zags
const Shared = struct { ... Shared.x }

1613239983
zags
My point is, if I'm forced to access decl via enclosing type name, I won't make the mistake

1613239991
zags
unless i'm missing something (quite likely)

1613239992
marler8997
yeah you're right, a type is pretty distinct from a value

1613240015
marler8997
for generic types it would be @This().x

1613240021
zags
right

1613240028
marler8997
it's an interesting idea, I think worth considering

1613240046
marler8997
it would also mean access global variable would be different

1613240057
marler8997
var x: u32 = 0;        fn foo() { @This().x }

1613240061
zags
I'm not nearly confident in the language to write a proposal yet, feel free :D

1613240086
zags
How do you access the global from within a struct function?

1613240124
zags
since @This refers to the innermost type

1613240125
marler8997
not sure what you mean by "struct function"

1613240131
marler8997
oh

1613240134
marler8997
a nested function

1613240148
marler8997
You would have to declare const Self = @This(); at the top of your file

1613240151
noam
ifreund: note also that even just the last two  numbers are enough.

1613240156
noam
264456 vs 123193

1613240162
zags
marler8997: that works, love it

1613240169
noam
My proposal saves

1613240181
zags
explicit and overall awesome and removes my footgun :D

1613240181
noam
and it costs

1613240192
noam
123193 * 13 - 264456

1613240208
noam
That's already >1.3MB

1613240214
marler8997
I don't remember seeing this proposal before, but it's possible it has been proposed, anyone that's lurking know?

1613240260
noam
Hm?

1613240313
noam
Toss in the n=0 and n=1 nodes and that's probably at least 3MB

1613240359
noam
at n=0, we save five bytes - oh yeah, that's 3.5MB just from the terminal nodes.

1613240369
noam
at n=1, we save 3 bytes - that's another 240KB

1613240379
noam
we then lose 300KB to binary nodes

1613240396
noam
and gain another 1.6MB or so from >2-ary node

1613240408
noam
So a rough estimate of 5MB saved?

1613240441
zags
marler8997: Shared.x already works, so I'll use that as an idiom for now, would be nice to have it enforced for sure

1613240468
marler8997
ok, I'm working on a simple proposal

1613240490
zags
awesome, thank you so much

1613240529
justin_smith
in case anyone finds it useful, I made a small function that takes the same args as debug.print, but uses the resulting string to do a formatted failure message (for unit tests I always want to know what the unexpected values actually were)

1613240867
noam
andrewrk: can we get RAM usage numbers for the AST rework, as well, not just CPU? Seems like those would be useful, given that it's gaining performance by lowering RAM

1613241131
marler8997
justin_smith, isn't that what std.debug.panic does?

1613241200
zags
marler8997:

1613241265
justin_smith
marler8997: d'oh, of course that already existed

1613241274
marler8997
lol

1613241323
noam
Ah whoops, my calculation there was a bit off; I was still thinking in terms of the smaller scheme

1613241328
noam
Posting actual numbers in the PR

1613241702
justin_smith
marler8997: OK, it was worth checking out that namespace, std.debug.dumpCurrentStackTrace(@returnAddress()) lets me create a dump that makes my editor jump to the failed test instead of the test failure code

1613241709
justin_smith
huge quality of life improvement there

1613242042
noam
Huh, that estimate was actually pretty accurate ;P

1613242118
noam
We actually lose 0.8MB to binary nodes, not 0.3, and we only gain 90KB from unaries, not 240 - but it's actually 3.8 saved on terminals, not 3.5, and I was rounding anyways :P

1613242134
noam
So yeah, roughly 4.7MB of savings :)

1613243342
zags


1613243354
zags
there's no way to refer to an already initialized anon literal member?

1613243497
ifreund
nope

1613243515
noam
ifreund: would you be able to get those numbers for stage2?

1613243526
noam
Given that I intend to compile stage2 itself, that should be a somewhat more useful guide :)

1613243593
ifreund
noam: { 90868, 55985, 70933, 15572 }

1613243611
ifreund
quite different lol

1613243667
noam
much smaller too ;P

1613243720
noam
let's see... 454K+56K+200K-212K

1613243739
noam
roughly 500K of savings still :)

1613243779
noam
(90868 * 5 + 55985 - 70933 * 3 + 15572 * 13)

1613243807
noam
499962 bytes of savings :)

1613243850
ifreund
and for river cause why not: { 8592, 8046, 8249, 1440 }

1613243887
noam
8592 * 5 + 8046  - 8249 * 3 + 1440 * 13

1613243908
noam
45KiB of savings

1613243971
noam
ifreund: thanks, that's 3 for 3 cases demonstrating that 8 + 4N is at the very least more than good enough for tricarbon :)

1613244055
ifreund
noam: to make sure I understand correctly: tag and main_token are still stored in separate arrays right?

1613244081
noam
Yes

1613244088
ifreund
and kid_count as well I suppose

1613244094
noam
Well... hm.

1613244098
ifreund
and then the nodes array stores the index into these arrays?

1613244113
noam
ifreund: there's actually two separate schemes here :P

1613244121
noam
First is "yes" - this is my proposal for stage2.

1613244127
noam
Second is "no" - this is what I'm doing for tricarbon

1613244135
ifreund
no == no SoA?

1613244138
noam
Yeah

1613244141
noam
... dammit.

1613244143
noam
Correct.

1613244152
ifreund
heh

1613244172
ifreund
why not? no comptime for that sweet MultiArrayList abstraction?

1613244193
noam
Nah, because there's no point

1613244199
noam
Struct of arrays is useful because padding.

1613244207
noam
If you're already u32 aligned anyways...

1613244221
noam
It's also useful for locality, in theory

1613244229
noam
Poke left and right in tokens, for instance, without reading unrelated date

1613244230
noam
data*

1613244242
noam
My solution might be a bit less performant, but it's easier to reason about

1613244267
noam
It's because of the different goals, really

1613244274
noam
Tricarbon's primary practical emphasis is

1613244282
noam
Using a single array is simpler.

1613244307
noam
In theory, I can store the tokens directly in the same array as nodes...

1613244400
marler8997
zags:

1613244592
zags
marler8997: good stuff

1613244802
ifreund
marler8997: I think it needs to affect const decls as well, a const pointer to mutable data is not at all uncommon

1613244823
ifreund
would also be much more consistent

1613244826
noam
ifreund: in theory, I could separate children from nodes?

1613244839
noam
But there's no really good way to  that

1613244840
noam
do

1613244850
marler8997
ifreund, yeah that's a good point, but, that would be a much bigger change

1613244878
noam
ifreund: also, even with this, we're still wasting 4N bytes, technically...

1613244884
marler8997
having to us a type qualifier for every single constant...not so sure about the tradeoff on that one

1613244886
ifreund
marler8997: I don't think the proposal is worth it without applying to const decls as well

1613244887
noam
(because we're storing indices)

1613244911
noam
Clever solutions can definitely reduce it further, but I personally don't want to use them

1613244945
marler8997
Maybe there's a way to tell if a variable has any mutabaility?

1613244981
ifreund
marler8997: even if there was, that sounds too complex IMO

1613245061
noam
ifreund: mind pulling up numbers for zls as the one last test? I think it's probably one of the most widely used zig projects, so it should also be a useful number

1613245112
ifreund
noam: { 10859, 7329, 8338, 2321 }

1613245139
noam
Thansk!

1613245141
noam
Thanks*

1613245250
marler8997
ifreund, I've added a "Varition" section to describe that

1613245302
marler8997
and ifreund, in your variation, what kind of consts do you think should be qualified?

1613245311
marler8997
obviously const Types would not be correct?

1613245408
ifreund
hrm, yeah you're right that does get ugly too

1613245495
marler8997
well, I suppose at some point something has to be unqualified

1613245505
marler8997
technically @This() at the top level is still just a type

1613245540
ifreund
yeah

1613245748
zags
weird, my type has a deinit() which in turn calls arraylist.deinit(), but that fails because when ArrayList calls free->shrinkBytes, resizeFn is suddenly a null pointer

1613246341
ifreund
zags: sounds like you copied your allocator interface out of it's parent struct

1613246365
ifreund
see:

1613246401
zags
oh shit, that's probably it, thanks man

1613246409
zags
another footgun :D

1613246421
ifreund
this one is solved though, just not yet implemented

1613246434
ifreund


1613246439
zags
cool

1613246561
zags
hm, can't say I see where I'm doing the copy, everything is passed by ptr

1613247256
ifreund
noam: I don't see how you get 8+4n. there's tag (1) main_token (4) num_children (4) in the SoA and then in the []u32 one index in to the SoA (4) + n child indexes (4n)

1613247270
ifreund
that's 13+4n, so what am I missing?

1613247273
noam
For stage2, you mean?

1613247277
ifreund
yeah

1613247310
noam
Just from your comment: it drops the "one index"

1613247318
noam
Ahhh, right.

1613247334
zags
ifreund: oh there it is I think?

1613247347
zags
allocator gets copied, &instance.arena.allocator points to something teared off

1613247349
zags
right?

1613247354
ifreund
zags: yep

1613247356
noam
ifreund: Hmm, I think my proposal only works if you stop using a SoA, so it might not be wanted by Zig. /shrug

1613247367
zags
ifreund: dang, so what's the workaround here?

1613247374
noam
There might be a way to match it, but I've already spent enough time thinking about this

1613247424
noam
Though 13+4N is still an improvement over what you have now, to be clear

1613247427
noam
:(

1613247438
noam
Not nearly as big of one, though

1613247456
noam
ifreund: note my original proposal in that thread does say to remove the SoA

1613247467
ifreund
ok, how does that help though?

1613247502
noam
Without the SoA, if you have one giant array of nodes ([]u32, some entries are nodes, some are indices), you don't need an index of the first child

1613247507
noam
The indices are stored immediately after the node

1613247520
ifreund
zags: in that case specifically, I'd just use ArrayListUnmanaged probably

1613247546
zags
nasty, good to see #7769 scheduled for 0.8

1613247556
noam
{root, index_of_child_1, index_of_child_2, ... index_of_child_N, child_1 (terminal), child_2, index_1_of_child_2, child_3 (terminal), child_1_of_child_2 }

1613247557
ifreund
you could also make the signature fn init(self: *@This(), ally: *Allocator) void {}

1613247563
noam
and so on

1613247588
zags
ifreund: yeah, that makes the call sites weird though

1613247629
ifreund
noam: but how you get from child_1 to the tag of child one?

1613247638
noam
ifreund: it's part of it

1613247642
noam
child_1 is the node

1613247648
noam
it's 8 bytes

1613247672
ifreund
so it's not a []u32 then I guess

1613247673
noam
I'm using a u16 for tag, and a u16 for kid_count, with a u32 for token index

1613247684
noam
It is

1613247696
noam
Well, it's u32-aligned, and it's a single contiguous block of memory

1613247705
noam
Entries are either 64-bit nodes, or 32-bit indices

1613247721
ifreund
ok yeah

1613247729
noam
You could keep u8 tag and have u24 for kid_count

1613247740
noam
Though I find it unlikely it would make a practical difference either way

1613247755
zags
ifreund: what's the "Unmanaged" in ArrayListUnmanaged?

1613247768
ifreund
zags: it doesn't store an allocator pointer

1613247789
zags
oh i see, gotcha, gotta pass it

1613247809
noam
Why have both managed and unmanaged?

1613247829
zags
in this case, to avoid the friggin unpinning footgun

1613247866
ifreund
noam: managed can be more convient in some cases, but I'm starting to think that the "unmanaged" api should be the default

1613247980
mikdusan
yeah do-less == default

1613248032
ifreund
the static init is quite nice, and it's certainly the better choice in nested data structures

1613248149
ifreund
noam: 13 + 4n is worse than what have currently, which is just straight 13 for n <=2

1613248163
noam
ifreund: sure, but 13 + 4n still saves 8 bytes for n>2

1613248171
noam
But... no.

1613248190
noam
Yeah, the binary nodes then match the n>2 nodes, and the terminal ones no longer help

1613248220
noam
You can probably figure out a way to improve it further still, at least

1613248239
noam


1613248246
noam
The question is whether you want to

1613248266
ifreund
I just want what's faster, which is a much harder question to answer

1613248276
zags
ifreund: ArrayListUnmanaged solved all my sorrows, thanks a bunch, you saved me a lot of time

1613248287
ifreund
zags: no problem!

1613248308
noam
I might actually use a SoA just for tokens

1613248320
noam
That'll let me get those down to five bytes while maintaining 8+4N nodes

1613248343
noam
But that also means 8-bit tags instead of 16-bit... meh, it's good enough now

1613248638
zags
ifreund: quick follow-up on

1613248751
ifreund
zags: zig currently only guarentees that there is no copy if you return the struct literal directly (i.e. return Foo{ .a = 42 }; )

1613248773
zags
interesting

1613248782
zags
subtlety increased by 95%

1613248826
ifreund
I think there's an accepted proposal to allow getting a pointer to the result location or something like that

1613248868
zags
noice

1613249230
daurnimator
ifreund: I thought it guarnteed no copy in other circumstances too

1613249313
daurnimator


1613249382
ifreund
daurnimator: thanks for the link, that's not implemented yet though afaik

1613249406
daurnimator
ifreund: true

1613251293
andrewrk
ifreund, thanks for crunching the numbers, this is useful data

1613251394
andrewrk
noam, your math is wrong for n=3+. it's 13 + 4*(n - 1)  e.g. 9 + 4n

1613251440
noam
Hm? You have lhs for one child, rhs as index, then start and end, and all the other children

1613251454
noam
9 + 12 (index,start,end) + 4N

1613251472
andrewrk
I see, you are talking about ranges

1613251476
noam
So index into extra_data, plus two indices in extra_data

1613251477
noam
Yeah

1613251510
noam
You could make the extra_data entries slices, effectively

1613251518
noam
Instead of start and end, just have length followed immediately be entries

1613251523
noam
That's 4 bytes shaved off per n>2 node

1613251527
noam
by*

1613251565
noam
That'd still be nearly 500K saved for stdlib full, and 60K for stage2

1613252346
ifreund
that's a neat trick that wouldn't be as invasive of a change

1613252448
andrewrk
I originally looked into having the children just be directly after the parents in the node array, but that was too hard to implement in the parser

1613252467
andrewrk
if there's a middle ground that is reasonable to implement in the parser, I'm for it

1613252537
andrewrk
as for the other proposal, if I understand correctly, it is to remove 4 bytes from node data, and merge it with extra_data

1613252693
noam
andrewrk: actually, it's not

1613252705
noam
It's to remove 8 bytes from extra_data in favor of a different four

1613252741
noam
Currently, you specify start and end. Instead, the start

1613252828
noam
andrewrk: you said you tried having children immediately follow parents in the node array - do you mean indices, or the children themselves?

1613252836
andrewrk
the children themselves

1613252842
noam
Oh okay

1613252850
noam
I'm doing indices, so I was about to ask what the issue was

1613252873
noam
Having the children follow... yeah that sounds awful to implement

1613252888
Gliptic
I've been trying to get that working in other parsers, but seems it always requires either designing the language for it or reparsing things

1613252892
noam
Impossible for me, actually, since my tree is actually able to be cyclic

1613252920
noam
My tree allows a child to have multiple parents, effectively, so that's not at all an option for me

1613252926
noam
There's also the case of, for instance, nested expressions

1613252933
noam
((a) + (b * 3))

1613252960
noam
The 3 there should follow the b - but if that's the case, then the "b*3" cannot properly follow the

1613252981
ifreund
andrewrk: noam's suggestion to replace SubRange is good I think and not very invasive, I think I'll try it tomorrow

1613252981
noam
...in less confusing terms, you can't have a child's nodes follow the child or they'll be mistaken as its siblings

1613252988
noam
:)

1613253007
andrewrk
ifreund, sounds good

1613253242
noam
I'm using 6-byte tokens now, with 8+4N byte nodes :)

1613253242
noam
I like how our ideas are feeding into each other :)

1613253276
ifreund
Here's a (possibly dumb) idea: we could get rid of all the nodes that have no children and a single token by making lhs/rhs and extra_data use i32s, with postive refering to nodes and negative refering to tokens

1613253327
andrewrk
essentially what we're doing here is using a u31 for the index and a bit to determine whether it is token or node index

1613253333
ifreund
yeah

1613253369
andrewrk
given that we have extremely consistent 8:1 source byte to token ratio, and 2:1 token to AST node ratio, I think we can afford that bit

1613253372
ifreund
and I think u31 is fine for the supportted max source bytes juding by the 8:1 bytes:tokens ratio described in parse()

1613253386
ifreund
jinx :P

1613253391
andrewrk
ha!

1613253429
andrewrk
if we want to be really paranoid we could even put a check in after tokenizing to make sure len fits in u31

1613253482
ifreund
yeah, though I don't think that should ever happen in practice

1613253494
noam
Just use a u31?

1613253545
ifreund
the downside to this would be more branchy code

1613253560
andrewrk
I'm interested in bringing this branch to fruition

1613253579
andrewrk
uhh git branch I mean, sorry

1613253581
ifreund
the upside would be potentially large savings on the total number of nodes

1613253606
ifreund
yeah it would be good to have it done, we can always iterate more on the design later

1613253629
andrewrk
even this lhs,rhs thing is progress from master branch

1613253649
andrewrk
I think future improvements will be slightly less invasive for a few reasons

1613256307
marler8997
andrewrk, what can I do to help make progress on issue #6044 and/or my PR #7664

1613256361
marler8997
one thing I think I've realized since is I think #7664 isn't correct because it requires all paths to be resolved to absolute paths first, and I don't think it's doing that

1613256412
g-w1
while we are on the topic of optimising memory use in stage2, a while ago i realized that the src: usize only needed to be src: u32 since the max file size is 2gb or 2**31. is this a good way to save memory in stage2? i feel like if there are a lot if ir.Insts this might help a lot

1613256524
noam
True - that would be 4 bytes per inst

1613256880
ifreund
g-w1: I think that will likely be done when the same approach in #7920 is applied to the ZIR/TZIR

1613256922
g-w1
ok, when that time arises ill leave a comment if i remember

1613259937
andrewrk
g

1613259960
andrewrk
g-w1, I have some other ideas too such as only emitting the source for statements and other special cases

1613259970
andrewrk
often many instructions in a row will have the same source location

1613259990
g-w1
awesome!

1613259995
andrewrk
marler8997, I'll have another look, thanks for the ping

1613260050
andrewrk
I'm behind on all PRs not just yours

