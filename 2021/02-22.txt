1613952665
noam
Amusingly, since Netsurf prepends `NetSurf - ` to the window title, it showed up as "NetSurf - The Modern Packager's Security Nightmare" :P

1613955897
andrewrk
recovery cases fixed; now working on auto rewriting inline fn to callconv(.Inline)

1613956148
g-w1
will these auto-translation things be removed at 1.0?

1613956321
andrewrk
we've already had dozens of auto translations that are gone already; typically we leave them in for 1 release cycle

1613956344
andrewrk
just makes things a bit easier on people who track master branch

1613956510
g-w1
makes sense

1613956881
andrewrk
done. going for a run before deciding my next task

1613956971
andrewrk
41 more test cases to go

1613957091
noam
Enjoy your run :)

1613957900
v0idify
andrewrk, why would it RIP ZLS, would another implementation need to be made?

1613958002
andrewrk
ZLS will be broken until it is updated because it depends on zig's AST API

1613958039
andrewrk
I'm being dramatic. it will require a few days of work, that's all

1613961084
v0idify
is there a magic thing zig will do that will make both program authors and packagers happy? /s but is there something interesting proposed?

1613961481
mikdusan
frankly in my experience packagers aren't ready for bonafide needs of projects when they differ from the general desire to share deps across packages

1613961963
daurnimator
pinning only works for

1613961997
daurnimator
however most applications are a fraction of the size of the libraries they use

1613968674
marler8997
candidate for Zig Zen: "always fails is better than sometimes works"

1613968718
marler8997
something I codified this morning as I tried to analyze some of my programming sensibilities

1613968729
daurnimator
marler8997: ehhhhhhh. that ends up being a recipe for bad portability

1613968733
g-w1
runtime crashes are better than bugs?

1613968750
g-w1
its kind of the same thing

1613968752
marler8997
daurnimator, the opposite actually

1613968755
daurnimator
marler8997: e.g. have a look at the issues around OpenBSD not having a good .openSelfExe

1613968761
marler8997
g-w1, yes, I think it's a more general version of that

1613968769
daurnimator
marler8997: we had to select a "sometimes works" rather than a "robust"

1613968773
g-w1
maybe it should replace it

1613968861
daurnimator


1613968874
daurnimator
though I remember griping in the issue/pull request that added the workaround in the first place

1613968881
marler8997
I like "runtime crashes are better than bugs", these 2 statements might be more different in some ways

1613968950
daurnimator
"comptime errors > runtime crashes > bugs "

1613968955
marler8997
"sometimes works" is where bugs live

1613968974
daurnimator
marler8997: "sometimes works" is the opposite of robust, which is in the language tag line

1613968981
marler8997
exactly

1613969009
marler8997
everyone can agree "sometimes works" is bad

1613969030
marler8997
what I think is insightful is that its better to "always fail" than "sometimes work"

1613969048
daurnimator
marler8997: except when the alternative is doesn't work....

1613969076
marler8997
it's saying, don't release a feature half-baked, either implement it robustly, or don't implement it at all

1613969077
daurnimator
e.g. its better to have stack tracebacks *most of the time*, then never

1613969123
marler8997
daurnimator I would agree with that

1613969133
marler8997
so maybe then the definition of "works" needs modification

1613969275
daurnimator
marler8997: you can also get into tricky definitions of "works" -> e.g. what if something is O(n^2) on one platform and O(1) on another?

1613969292
marler8997
there's some sort of distinction between "partially implemented" and "buggy code that fails catastrophically"

1613969309
andrewrk
@panic("TODO") vs a bug at runtime

1613969342
marler8997
yeah that's a good description

1613969534
marler8997
looking back it looks like it's basically what daurnimator said "runtime crashes > bugs"

1613969591
daurnimator
marler8997: which is the whole philsophy of segfaults

1613969604
marler8997
oh yeah that's true

1613969613
daurnimator
marler8997: exit with "segmentation fault" is better than "run random data as code"

1613969626
daurnimator
its one of the lessons I used to instill in my programming lessons

1613969684
marler8997
Maybe providing examples of our Zig Zen points somewhere would be beneficial

1613969691
marler8997
examples like the one you just mentioned

1613969742
g-w1
it could be in the zig zen section in the docs/langref

1613969780
marler8997
yeah that seems like a good place

1613970251
marler8997
I think my original statement of "sometimes works" was actually supposed to be "has bugs"

1613970305
marler8997
no implementation is better than buggy implementation ?

1613970746
daurnimator
marler8997: could I hear you attempt to apply that rule to

1613970788
siraben
daurnimator: Nix address many problems raised in that article

1613970818
siraben
(the one about package managers)

1613970841
marler8997
I'm not sure how it applies

1613970854
marler8997
OpenBSD doesn't support getting it's own exe, not sure the relation

1613970898
marler8997
maybe the rule would state, it's better to not implement the selExePath feature on OpenBSD unless it can be implemented without bugs?

1613970944
siraben
daurnimator: take for instance the issue of pinning dependencies. In many package managers the dependency specification is purely nominal (by name) and inexact, so anything with the right name and version could satisfy the dependency spec.

1613970971
daurnimator
marler8997: the implementation we have now does have potential bugs: it's a hacky work around. but without it we wouldn't have 1. stack traces on openbsd. 2. be able to distribute binaries.

1613970976
marler8997
yeah the Nix phdthesis mentions that exact issue

1613971007
siraben
right i was about to quote it, hehe

1613971008
siraben
it's actually very readable for a PhD thesis

1613971022
siraben
Nix OTOH uses a hash of the dependency to remove any ambiguity, so a package that depends on GNU Hello 1.0 with patches will be different from a package that depends on GNU Hello without patches

1613971023
daurnimator
siraben: its not though: the whole article is fighting against the trend in package managers (go, rust, recent python, node) of pinning dependencies

1613971039
marler8997
daurnimator, we already clarified that "sometimes works" != "has bugs"

1613971067
marler8997
so having a implementation of selfExePath that works some of time, without bugs, wouldn't apply to the rule

1613971082
daurnimator
marler8997: this isn't a "sometimes works" though: its a "has bugs when used in combination with a few other features that's undectable; and we're sort of just luck we don't use right now"

1613971113
marler8997
oo that's a tricky one

1613971132
marler8997
this one might be an exception to the rule then

1613971196
daurnimator
marler8997: the implementation we use right now for selfExePath on OpenBSD only works if: 1. you are an application not a library. 2. you don't modify arg0. 3. no one has called chroot. 4. no one has moved or replaced the running executable. 5. you haven't modified PATH in the current process..... etc.

1613971226
marler8997
yeah that sounds super ugly, but sometimes ugly is necessary

1613971232
marler8997
unfortunately

1613971247
marler8997
that really leaves us with no choice

1613971367
marler8997
the rule of no implementation > buggy implementation wouldn't apply if 1) a bug-free implementation is impossible and 2) having any implementation at all provides good benefit

1613971385
daurnimator
won't

1613971391
g-w1
why not just @compileError if on openbsd?

1613971408
marler8997
daurnimator, I'm not sure what you mean by "won't everyone say"?

1613971412
daurnimator
g-w1: because it was decided that a buggy implementation is better than none..

1613971414
marler8997
This is just a general guidance when writing code

1613971418
g-w1
ok

1613971434
marler8997
it's saying, if you're about to implement something that you know will have bugs, maybe just @panic() for now and come back to it later

1613971453
daurnimator
marler8997: what's the point of the zig zen if not something to point at when reviewing someone else's code?

1613971480
marler8997
did I say we shouldn't point to it when reviewing code?

1613971521
daurnimator
and I'm sayin that the inevitable reply from the code author

1613971539
marler8997
if it's a partial implementation I would agree

1613971546
marler8997
if it's a buggy implementation, I think I would disagree

1613971580
marler8997
unless again, the other 2 criteria apply

1613971633
marler8997
but I'm glad that you are taking issue with the rule, I think it shows that the rule in and of itself is not obvious

1613971668
marler8997
it's codifies a programming technique that I've learned over the years and I think makes my code better overall

1613971890
siraben
daurnimator: in any case I agree with the article's claim that bundling dependencies is problematic. When upstream tries to be too clever about things usually causes the most headaches

1613971991
daurnimator
siraben: its more about the issues of pinning dependencies (of which bundling is one form)

1613972063
marler8997
If I understand correctly, in the article he said "pinning dependencies" is problematic because it makes updating them more difficult

1613972070
siraben
Why wouldn't pinning dependencies make sense? If you allow slightly different dependencies to be used in a piece of software the results may change

1613972105
marler8997
if that's the case, then this is not an issue for nix, because updating a package in your nixpkgs file updates it for everyone (by default)

1613972116
siraben
Right.

1613972127
siraben
marler8997: but for Rust/Go packages aren't they pinned by the project's lockfile?

1613972150
marler8997
not sure on that one

1613972164
daurnimator
siraben: that's the whole point! if a library the application uses has a bugfix; I have to wait for the application to update its lockfile before I can get the fix

1613972182
siraben
with Nix's Hydra build farm it also lets one build all packages that depend on an updated library and check for regressions

1613972185
daurnimator
when you get to dependency trees 5 layers deep, it can be a decade to get a bugfix

1613972216
marler8997
daurnimator, yeah that's an issue with "lockfile dependencies", but this doesn't apply to nigpkgs

1613972217
daurnimator
or not even a bugfix, a performance fix would have the same problem

1613972231
daurnimator
marler8997: why not?

1613972233
siraben
marler8997: " buildRustPackage requires either the cargoSha256 or the cargoHash attribute which is computed over all crate sources of this package. cargoHash256 is used for traditional Nix SHA-256 hashes, such as the one in the example above. cargoHash should instead be used for SRI hashes. For example: "

1613972239
siraben
it applies to Rust packages for instance

1613972242
marler8997
>  if that's the case, then this is not an issue for nix, because updating a package in your nixpkgs file updates it for everyone (by default)

1613972276
siraben
marler8997: say I update SDL2 in Nixpkgs, then every package that depends on it (directly or transitively) gets a rebuild.

1613972287
siraben
But if a package bundles SDL2 with it, well it doesn't get rebuilt.

1613972302
siraben
Oops wanted to ping daurnimator

1613972356
daurnimator
siraben: how does nix handle a go application like, uh (trying to pick a well known one... chezmoi?) that has a go.mod and go.sum file?

1613972399
daurnimator
siraben:

1613972411
siraben
daurnimator: latest version bump of chezmoi:

1613972412
siraben
vendorSha256 is dependent on chezmoi's lock file

1613972443
siraben
So it's up to chezmoi to update their pinned versions

1613972447
daurnimator
siraben: so does `buildGoModule` ignore go.mod/go.sum?

1613972456
siraben
it uses the go.mod file

1613972463
daurnimator
siraben: right that's the whole problem!

1613972473
siraben
Is the issue that say OpenSSL has a vuln then Go packages won't have that issue resolved?

1613972509
siraben
whereas all the C or C++ packages that explicitly have OpenSSL as as dependency would build against the newer version?

1613972510
siraben
Hm.

1613972513
daurnimator
siraben: imagine e.g. (picking a random dep here) go-vfs 2 has a bugfix (

1613972611
daurnimator
siraben: how do I (as a nix user) make sure i get that bug fix?

1613972638
marler8997
nix package override?

1613972650
siraben
you will have to apply a patch to go.mod and update vendorSha256 accordingly

1613972653
marler8997
and/or, submit a PR to nixpkgs to apply it

1613972656
siraben
via an overlay, say.

1613972714
daurnimator
the end user has to do it? or the package maintainer?

1613972715
siraben
How much of a security concern is this? I understand the threat but how would you actually exploit an insecure dependency of a Go program?

1613972742
daurnimator
siraben: I didn't say security. I said bug fix. hell maybe its a 10x performance improvement.

1613972764
siraben
Shouldn't that be up to upstream?

1613972801
marler8997
I'm not seeing the problem, daurnimator are you saying that package managers should take updates from every single tool/project they reference automatically?

1613972816
siraben
daurnimator: end user could apply the patch immediately while waiting for the change to be merged in Nixpkgs, say.

1613972825
daurnimator
siraben: I don't think so: why would you expect an application to have a release that does nothing but e.g. bump pinned dependencies?

1613972857
daurnimator
not to mention that for a deep depdency tree

1613972864
marler8997
oh we're talking about indirect dependencies, not direct dependencies

1613972875
siraben
It's like you want lockfiles but without the locking part, which is the point

1613972884
daurnimator
no. I

1613972889
marler8997
daurnimator, my guess is it's not using go.mod

1613972895
siraben
But why not? You lose reproducible builds!

1613972941
daurnimator
siraben: not if I build with the same dependencies: which I could select. but default should be newest releases of dependencies

1613973000
daurnimator
also if you're using dynamic linking you wouldn't lose reproducible builds either; but that's beside the point

1613973091
marler8997
If your philosophy is "I always want the latest version of all my dependnecies, even if they have not been verified", then that's just a fundamental difference

1613973115
daurnimator
marler8997: what is "verified"

1613973127
marler8997
in nix land, verified means it has passed CI

1613973146
siraben
then if you build your package now and in 6 months, by following the latest releases you could break your package

1613973189
marler8997
the nixpkgs CI to be specific

1613973207
daurnimator
okay so bringing it back to a nixpkgs context: every go dep should have its own nixpkg

1613973225
siraben
marler8997: in building Python packages for Nixpkgs you have to specify all the python inputs actually, so it would follow the "latest" version (latest in nixpkgs)

1613973226
daurnimator
and then you would depend on that in whatever the way you depend on packages is

1613973274
siraben
I suppose we could make it so that the entirety of all go modules is added as a package set in Nixpkgs and say to hell with lockfiles and make package maintainers to specify them as inputs

1613973275
marler8997
I'm not sure what nixpkgs does with go

1613973305
marler8997
but siraben I believe you're correct about python packages

1613973315
siraben
Looks like we don't have a goPackages set, but we have haskellPackages, python3Packages etc.

1613973323
marler8997
every python package has it's own deriviation, so updating it updates it for everyone

1613973353
siraben
but from a packager POV, doing that for python is more painful than just obtaining the vendorSha256 hash and being done with it.

1613973358
marler8997
I can see nix deciding to just leverage what Go already has, if Go wants to change it, it can change it

1613973378
daurnimator
marler8997: I think Go in particular has made it impractical to do "the right thing"

1613973387
marler8997
right that's kinda what it sounds like

1613973388
daurnimator
and I hope zig doesn't go the same way

1613973393
siraben
I need to try out

1613973418
marler8997
I think if Go had a way to easily configure/override go.mod, then maybe that would be enough?

1613973437
daurnimator
marler8997: I think the pattern of having a lockfile in version control is poisoness

1613973440
daurnimator
*poisonous

1613973451
siraben
marler8997: sounds like it. The only way I think of to override go.mod is to done some sed wizardry

1613973451
daurnimator
attach it to a release some other way

1613973467
marler8997
daurnimator what do you suggest?

1613973487
siraben
daurnimator: I have to disagree. I've had to deal with minor version bumps of dependencies that broke API use, despite being a minor version bump

1613973491
siraben
so necessitates lockfiles

1613973519
siraben
then I run a tool to check for outdated deps and update my version contraints accordingly

1613973522
marler8997
if you have a better solution than lockfiles, that means my build doesn't break I'd love to hear it

1613973560
siraben
e.g.

1613973669
siraben
Maybe it also suffices to have a way to override a dependency of a dependency? Then that would satisfy daurnimator's goal of making sure a program uses the latest version of Y library

1613973700
marler8997
right, overriding go.mod would need to be recursive

1613973734
marler8997
but if Zig encapsulated every go package in a derivation, it could do that

1613973735
siraben
In which case might be impossible to do with Nix because you can only touch the go.mod file really

1613973739
marler8997
sorry, I mean Nix (not Zig)

1613973741
siraben
Yes

1613973778
siraben
the pythonPackages set is probably a prime example of this, since Python packaging is so awful and inexact

1613973809
marler8997
yeah, they could do the same with Go if they were so inclined

1613973819
marler8997
but best not to encourage them to make Go better right? :)

1613973881
marler8997
just leave Go how it is, then we can use this article as a reason not to use Go.  Zig Stonks!

1613973907
siraben
zigPackages package set when?? :P

1613973941
siraben
Unfortunately Nixpkgs' Zig is broken on darwin because we're still using the 10.12 macOS SDK

1613973976
marler8997
is 10.12 one of the versions Apple no longer supports?

1613974007
siraben
it's already EOL'd and 10.13 will be EOL'd soon

1613974028
marler8997
shoot

1613974053
siraben
nvm 10.13 is already EOL'd

1613974054
siraben
we really should update it soon because

1613974057
siraben
> Go 1.16 is the last release that will run on macOS 10.12 Sierra. Go 1.17 will require macOS 10.13 High Sierra or later.

1613981598
noam
siraben: upstreams misusing versioning is not a legitimate reason to subvert the

1613981640
noam
While I largely disagree with the article's stance on static linking, the points on dependency pinning are absolutely correct - as bad as heartbleed was, it'd have been a million times worse if people had pinned the old versions.

1613981662
noam
imagine if a web browser pinned the SSL library they were using

1613981700
noam
I'd bet all the money i've ever conceived of that it would've directly affected tens of thousands of people minimum before it was addressed who would have been unaffected if not for pinning

1613981717
noam
The fact that security implications of other software is less blatant does not mean that they aren't real

1613981746
noam
That said, breaking changes should

1613981750
siraben
So, make it easy to override dependencies of a package?

1613981768
siraben
They never should be, but I've seen enough breakage from minor version bumps.

1613981785
noam
Sure, but is that really

1613981807
noam
Breakage with bad versioning usually means failed builds, which makes the problem obvious and forces people to address it.

1613981821
noam
Dependency pinning

1613981854
noam
Which means people will be silently running insecure software without knowing it

1613981859
siraben
Well, in Nixpkgs everything that declares openssl as a dependency will be rebuilt when openssl is updated. However Go/Rust programs which use lockfiles will not (I think)

1613981868
noam
That's the problem.

1613981877
noam
The former is fine

1613981879
noam
The latter is

1613981886
siraben
Sure, but what's the proposed solution?

1613981889
noam
S

1613981893
noam
"Stop using it."

1613981897
siraben
Dunno how Arch/Debian deals with this

1613981901
noam
Dependency pinning causes far more issues than it solves

1613981916
siraben
FWIW one can also pin the Nixpkgs revision because of its monorepo nature, heh

1613981919
noam
Personally, I'd blacklist any software using it blindly from any repo I ran

1613981932
noam
That's not an improvement lol

1613981949
siraben
nah it was just an example

1613981950
noam
There

1613981973
noam
Fighting upstreams is the Go / Rust model.

1613981993
siraben
I don't think stop using it is an adequate solution

1613982014
noam
Basically, instead of working with upstreams and getting them to stop making breaking changes without bumping major version, Go / Rust projects say "assume all changes are breaking and don't update without explicit action"

1613982018
siraben
Being able to override dependencies sounds much more composable

1613982020
noam
which is 1000x worse.

1613982030
noam
It's a failed attempt to solve a social issue with a technical resolution.

1613982055
noam
The issue that you mention - breaking changes without major version bumps - is not truly a technical issue.

1613982059
noam
It's a *social issue*.

1613982065
siraben
I realize.

1613982075
noam
Technical solutions to social problems always make things worse. 100% of the time.

1613982088
siraben
When updating a lockfile for a Flutter project a package bumped from 1.6.3 to 1.6.4 and broke the build, WTF?

1613982104
noam
(Note: social problems here does not mean problems affecting a society, but problems arising from the interaction of people)

1613982120
noam
(I'm not saying technology can't help with e.g. hunger, but that technology can't solve interpersonal issues)

1613982138
siraben
Maybe a packaging system/programming language should force semantic versioning to be bumped if the public API changes

1613982150
noam
siraben: so you either a) contact upstream and get them to fix it or b) stop using that upstream

1613982162
noam
if you can't trust the upstream to work with you, then why would you use it in the first place?

1613982175
noam
an upstream that is hostile towards you is not one you should rely on

1613982196
siraben
That's the case for a lot of enterprise software unfortunately

1613982253
siraben
and the enterprise solution to this (according to a friend who works in it) by distributing entire VMs is actually pretty common

1613982255
siraben
lol

1613982260
noam
So... break the entire package management ecosystem... to accomodate what is effectively malware? (Software which is hostile towards its users - who are in this case devs)

1613982279
siraben
Who said what's malware?

1613982310
noam
> siraben: so you either a) contact upstream and get them to fix it or b) stop using that upstream

1613982313
noam
> if you can't trust the upstream to work with you, then why would you use it in the first place?

1613982333
noam
If the upstream is acting in ways hostile towards it consumers, then it isn't trustworthy.

1613982372
siraben
There's plenty of situations where upstream is unmodifiable but one cannot do anything about it. So the reaction seems to be to use the exact same dependencies as upstream did in the first place.

1613982373
semarie
"public API changes" is complex. one part is on dev side (size of its struct) but another part could be in OS where it is compiled (if software uses time_t and OS changed time_t from 32bits to 64bits for example)

1613982407
noam
Structure layouts and sizes isn't API, it's ABI.

1613982417
noam
API changes don't break rebuilds

1613982420
semarie
ah yes

1613982427
noam
With API changes, your'e recompiling the library and its dependents

1613982440
noam
The issue would be attempting an ABI change without a rebuild

1613982455
siraben
I don't have a good solution for this, but making entire build graphs explicit and making overrides composable seem like good steps in the right direction

1613982461
siraben
and making dependency specifications exact

1613982467
noam
I disagree - they make things

1613982469
noam
worse*

1613982472
siraben
which part?

1613982475
noam
All of it!

1613982477
noam
because now people have an excuse!

1613982502
siraben
Did you see the discussion before that updating openssl will cause dependants to rebuild?

1613982506
noam
Made a change that broke all your dependents? That's their problem!

1613982517
siraben
> There's plenty of situations where upstream is unmodifiable but one cannot do anything about it. So the reaction seems to be to use the exact same dependencies as upstream did in the first place.

1613982540
noam
yeah, that's awful

1613982547
siraben
It is.

1613982548
noam
That's not just not good, it's actively making things worse

1613982569
noam
Dependency pinning lends justification to it without solving it.

1613982585
noam
Or, in a different perspective, it solves that issue while creating far worse ones.

1613982601
noam
For the sake of exaggerated example, imagine someone pinned Windows XP as a dep.

1613982608
noam
It's been EOL for a while now

1613982640
noam
but unless the author is *active*, there are actual serious security threats to all of your users and your dependents users, recursively up the graph.

1613982671
siraben
IME on large projects with lockfiles, automation is good in making sure dependencies are as up to date as possible.

1613982671
noam
Dependency pinning means that old software continues to *build*, for instance - it doesn't make the old software safe to use.

1613982702
noam
Except now you're wasting a metric fudgeton of energy just to test compatibility.

1613982713
noam
Per project, per update of dependencies.

1613982714
siraben
if the issue is security, how vulnerable is the resulting binary really?

1613982722
noam
Very!

1613982754
siraben
> Dependency pinning means that old software continues to *build*, for instance - it doesn't make the old software safe to use.

1613982754
siraben
yeah, definitely

1613982755
noam
If something depends on, say, libgoffice, and there's a security bug allowing trivial construction of malicious documents, then anyone with an outdated version has a very real problem

1613982770
siraben
even if the application doesn't expose that part of the API?

1613982779
noam
It's not about API!

1613982807
noam
If I use libsvg to open an SVG, and I use an old version with a security bug, and I rarely bother updating my dependencies, now all of my users are at risk when they open SVGs

1613982831
siraben
Yeah

1613982841
noam
(and this isn't purely hypothetical; malicious execution while manipulating complex file formats is probably one of the most common attack vectors)

1613982868
noam
I wrote a library that abstracts libsvg, libpng, etc? Congrats. Now all my dependents are vulnerable too

1613982883
noam
Dependency pinning means that unless

1613982898
siraben
So... override libsvg/libpng until upstream fixes it?

1613982900
noam
All it takes is

1613982907
noam
No, don't pin it in the first place!

1613982919
siraben
yeah overriding is hard/impossible when there's a lockfile

1613982935
noam
instead, make sure that upstreams don't make breaking changes without bumping major versions - and that security fixes get backported

1613982943
noam
Importantly, this reduces the number of people who have to be responsible to

1613982980
noam
If even a single dependency pins an old libsvg version,

1613983028
siraben
I just did a quick search for overriding Rust package dependencies, looks like it's possible

1613983040
noam
Possible doesn't mean it's going to happen

1613983041
siraben
cc marler8997 ^

1613983048
noam
and you still need far more people to be responsible here

1613983062
siraben
well, this is why we have security audits

1613983067
noam
... really.

1613983080
noam
What percent of the packages in, say, Gentoo, do you think have been audited *ever*?

1613983085
noam
I'm willing to bet it's below 1.

1613983088
noam
At *best*.

1613983102
noam
How about in the last year? If it's even 0.1% I'll be shocked.

1613983118
noam
Let's make it more fun. What percent of, say, LibreOffice do you think has been audited?

1613983191
siraben
Well, organizations run security audits of their servers

1613983193
siraben
of course the only real solutions to get people to 1. actually respect semantic versioning and 2. take responsibility

1613983227
noam
Sure, but dependency pinning fights both of those.

1613983238
noam
With dependency pinning, who cares if versioning is wrong? not like anyone's going to expect it to

1613983239
siraben
yes!

1613983248
noam
and who cares about responsibility? It's the user's problem, not upstream's.

1613983289
siraben
It's the user's problem to patch their software?

1613983298
noam
Well - s/user/downstream/

1613983311
noam
If a depends on b, it's not *b*'s problem if it broke; a should have pinned the old version!!

1613983349
noam
The biggest problem with dependency pinning is social, IMO

1613983364
noam
It propagates horrible and harmful ideas on how projects should be interacting

1613983492
noam
If you're making a project which other people depend on, you have a

1613983498
noam
That's not optional.

1613983666
siraben
Though, the article's places a lot of emphasis on eliminating vulns in production systems, I wonder how much it actually occurs in practice

1613983677
siraben
haven't managed prod before so shrug

1613983732
noam
I suspect at least an order of magnitude more often when pinning is involved.

1613983752
noam
Simply because you only need

1613983770
noam
(Whereas without pinning, distros will often patch problems before upstream does)

1613984604
daurnimator
siraben: from experience? it happens a lot

1613984628
daurnimator
and putting on my packager hat... we've essentially declared forfeit for go, rust and node

1613984637
daurnimator
python is barely hanging on

1613984674
siraben
daurnimator: dependency-related vulns in prod happen a lot?

1613984731
daurnimator
siraben: indeed. though real life attackers are few. usually its 7 days hunting down a bug causing an outage that turns out to be fixed in a dependency of a dependency, but pinning hasn't made it up to us yet

1613984763
noam
In other words, the vulns are real and a serious problem but nobody cares (including attackers)?

1613984772
daurnimator
yep

1613984774
noam
I mean, it makes sense

1613984775
siraben
daurnimator: so how long until the pins update all the way?

1613984793
noam
There's probably easier methods of attack - though, as someone concerned with security, that's hardly reassuring

1613984799
daurnimator
siraben: takes between a month and 2 years to make it through each level. cross your fingers that its shallow...

1613984805
siraben
yikes

1613984814
noam
... freaking heck

1613984832
noam
See I've been arguing it's bad but I didn't expect

1613984839
noam
I was thinking a few days to a week per level...

1613984839
siraben
daurnimator: is that a serious problem? or are there other low-hanging fruits to deal with?

1613984908
daurnimator
noam: its worse when its a service.... e.g. there's a bug in a go library that was finally fixed 3 years ago, it finally got incorporated into kuberenetes 1.20 a year or so ago. now we're waiting for amazon EKS to support EKS 1.20... probably 6 months left

1613984945
noam
ffs that's insane!

1613984957
karchnu
that's why we should have pledge(2) and unveil(2) for the linux kernel, too

1613984964
noam
Forget the

1613984972
daurnimator
siraben: its a serious waste of time: spending week after week chasing bugs that have already been fixed... just to figure out which commits to cherry pick

1613984978
noam
karchnu: what are those?

1613984988
daurnimator
noam: they're openbsd's syscall filtering

1613984993
karchnu
noam: security syscalls in the openbsd kernel

1613984994
noam
...huh.

1613985000
siraben
Yeah I've heard of pledge, very nice

1613985007
siraben
didn't know the Linux kernel had it too

1613985009
noam
What does it do? Change syscall behavior?

1613985011
noam
siraben: it doesn't

1613985022
siraben
oh oops, "should have"

1613985023
noam
> that's why [Linux] should have it too

1613985024
siraben
lol

1613985030
daurnimator
noam: you pledge to not use certain syscalls. if you try it kills the process

1613985045
daurnimator
very implementable with existing linux syscall filtering

1613985046
noam
Neat

1613985057
karchnu
and unveil is kinda the same for accessing different paths

1613985082
siraben
daurnimator: does pinning provide more or less benefits than the costs?

1613985095
karchnu
but it doesn't kill your program, just tells you that the path isn't available/doesn't exist

1613985100
siraben
imagine if you unpinned a production service

1613985125
noam
siraben: yeah, imagine being able to update a service within a day of it being fixed upstream instead of three years...

1613985128
noam
What a horrifying concept!

1613985145
siraben
well, it's more complicated than that.

1613985153
noam
Sure, but that's a serious downside

1613985165
noam
For a production service the security issues are actually critical

1613985172
noam
I wouldn't

1613985181
siraben
have you managed a production service before?

1613985190
siraben
I know little about managing prod

1613985211
noam
Depends on how you define production

1613985213
noam
(Read: no)

1613985394
siraben
maybe people here have seen this already:

1613985435
noam
It's on medium, so I'm betting I'll scoff at it. That said,

1613985529
siraben
tldr: some guy hacked into dozens of companies by uploading malicious packages to npm knowing that it'll be downloaded by company's internal projects

1613985925
noam
shocking

1613985955
noam
Why, the very idea that both large corps and NPM / PyPi aren't the epitome of security has me so stunned I'm dying of shock.

1613985984
siraben
you should see the security systems of entire countries :P

1613986006
noam
lol

1613986010
siraben
hospitals/banks, etc.

1613986022
noam
I try not to think about the social security system's password requirements

1613986029
noam
"Must not be > eight characters. No symbols."

1613986032
siraben
what's the requirements?

1613986035
siraben
oh?

1613986038
noam
at a minimum

1613986039
siraben
No way. Seriously?

1613986041
noam
Pretty sure it gets even dumber

1613986094
siraben
minimum password length of 7 characters, consist of both alpha and numeric/alpha-numeric characters (Letters and numbers or special characters), Passwords are case sensitive.

1613986120
noam
Huh, maybe they changed it? (or it's a different site?)

1613986141
siraben
found a screenshot from 3 years ago for "ssa.gov" where the pass needs exactly 8 characters

1613986145
siraben
and is not case sensitive...

1613986164
noam
Ah. That.

1613986171
noam
That's, what.

1613986189
noam
208827064576 possibilities?

1613986201
noam
Only 208B :P

1613986251
siraben
36^8 right?

1613986259
siraben
well it also says needs at least 1 number and 1 letter

1613986265
noam
ah

1613986267
siraben
counting is hard

1613986278
noam
2.8T, then

1613986285
siraben
looks like max len is 20 now

1613986288
noam
A lot, but also...... not really.

1613986550
daurnimator
siraben: IMO pinning provides no benefit, as we take care of that like 3 layers up

1613986559
daurnimator
IMO its all downside

1613986570
siraben
daurnimator: what resolves it 3 layers up?

1613987836
daurnimator
siraben: 1. dockerfiles that hashlock to what they clone. 2. private mirrors that only host the versions we want

1614009314
tnorth
Hey there. Based on a previous discussion here lately, I submitted

1614009451
ikskuh
ah yeah

1614009456
ikskuh
this is a bug in the lazy analysis

1614009465
ikskuh
it happens with different pointer types as well

1614010148
tnorth
ikskuh: is there a workaround?

1614010164
tnorth
ikskuh: a lot of datastructure use this kind of pattern, how is that handled?

1614010249
ikskuh
the problem is the array

1614010256
ikskuh
?*@This() works

1614010261
ikskuh
?*[1]@This() doesn't

1614010467
ifreund
I think ?[]@This() works too

1614010475
ikskuh
yeah, it works for pointers

1614010480
ikskuh
but i think arrays and functions break

1614010836
tnorth
ok, if ?[]@This() works, this should cover all use-cases

1614010887
g-w1
not realy, [2] is different because the memory is in the struct instead of outside

1614010987
dutchie
though a struct containing an array of itself is never going to work

1614011078
g-w1
an optional

1614011106
tnorth
but always a pointer to... their size is always known

1614011149
g-w1
hmm, yeah ah slice does cover all use cases

1614011164
g-w1
but its still a language bug

1614011178
ikskuh
the problem is an implementation bug, not a limitation

1614011218
g-w1
ok yeah not a language bug, but an impl bug

1614011247
ikskuh
language bug would be critical ;)

1614012004
tnorth
Is the issue LLVM-related, or in Zig itself? How much effort would it be to get it fixed?

1614012090
ifreund
it's probably a pretty trivial change if you manage to find where in ir.cpp/analyze.cpp the bug is

1614012133
g-w1
you can just search for depends on itself, there are only 3 occurances

1614012159
ifreund
I doubt anyone is motivated to do it though as the C++ codebase not exactly fun to hack on and will be thrown out as soon as the self hosted compiler is ready

1614012269
tnorth
Ok, then since there is a valid workaround it doesn't make sense

1614019420
ikskuh
heya

1614019424
ikskuh
i need a tad of git help

1614019444
ikskuh
i have a branch that is somewhat outdated and want to bring it up to latest master

1614019454
ikskuh
is it possible without merging?

1614019615
torque
you can rebase it, not sure if that's what you want

1614019624
ikskuh
how do i do that?

1614019655
ikskuh
i only know "git rebase origin/master", but that will probably rebase master on my branch instead of my branch on master

1614019667
noam
ikskuh: `git rebase origin/master` rebases the active branch onto origin/master

1614019680
torque
well, in the simple case, on your old branch, something like `git rebase -i master` which will attempt to rewrite old branch commits on top of current master

1614019700
ikskuh
noam: so just

1614019703
ikskuh
git checkout my_fork_branch

1614019707
ikskuh
git rebase master

1614019707
ikskuh
?

1614019722
noam
yes

1614019727
ikskuh
okay, i'll try

1614019732
noam
well - is your local master branch up to date?

1614019751
noam
Also note that it might not rebase cleanly - in which case it'll stop in the middle for you to resolve conflicts, commit, and run `git rebase --continue`

1614019785
noam
ikskuh:

1614019875
ikskuh
thanks :)

1614021500
v0idify
how many git-*.io sircmpwn has registered xD

1614021591
v0idify
how am I supposed to store a BufferedWriter in a struct?

1614021873
ikskuh
^^

1614021889
ikskuh
v0idify: you have to store the typed writer or make the struct generic

1614022082
ifreund
alternatively don't

1614022086
ifreund
only store the buffer

1614022115
ifreund
or wait nvm, the api doesn't make that nice :/

1614022137
v0idify
ikskuh, should I use @typeOf or..?

1614022173
ikskuh
that's hard to say without more context

1614022428
v0idify
std.io.BufferedReader(4096, std.fs.File.Reader) works

1614023506
v0idify
how do I get an array from a slice?

1614023537
v0idify
mem.copy?

1614023687
ikskuh
slice with comptime known items:

1614023700
ikskuh
var slice: []const u8 = "helllo";

1614023705
ikskuh
var array: [3]u8 = slice[0..3].*;

1614023864
v0idify
if it's not comptime though? it will crash right?

1614023872
v0idify
or.. UB but will crash usually

1614023879
v0idify
i.e not on Fast/Small

1614024243
ifreund
for an array you must know the length at comptime

1614024256
ifreund
otherwise it's not an array

1614024513
v0idify
yes but you said "slice with comptime known items"

1614024518
v0idify
not you*

1614024541
v0idify
std.debug.print("{any}", .{list.items}); // list is an ArrayList, makes CPU usage go to 100% on runtime for some reason

1614024549
Gliptic
it is a slice until you do .*

1614024582
v0idify
nevermind it's not that...

1614024590
v0idify
ok got it, thanks

1614024592
ifreund
v0idify: with comptime known bounds not items

1614024985
ikskuh
i meant slice with comptime known items where "slice" is a verb ^^

1614025003
ikskuh
so yeah. the bounds must be comptime known, the contents of the slice are not

1614028801
ifreund
andrewrk: I'm working on getting comma separated list in their various forms behaving properly in zig fmt by the way

1614028899
andrewrk
I'm shitposting on twi--- working on multi line strings

1614028917
andrewrk
are you doing array rows/columns?

1614028976
ikskuh
current meta for struct field syntax is snake_case, right?

1614028998
ifreund
not yet, first making sure we insert trailing commas and render properly if there are line comments in the list

1614029005
andrewrk
gotcha

1614029043
ifreund
I'm also wondering if there's a way we could unify all the code preforming essentially the same logic to render a comma separated list of things

1614029061
ifreund
the small differences in behavior that are the current status quo annoy me

1614029145
ifreund
that refactor could probably happen after this branch is done though

1614030748
andrewrk
that makes sense to me. I propose we get to a merge point here as soon as possible

1614032655
noam
v0idify: two or three, I think :P

1614032765
ikskuh
andrewrk, time for a little compiler error guessing game?

1614032766
ikskuh
const Foo = struct {};

1614032766
ikskuh
const Bar = struct { name: u32 };

1614032766
ikskuh
var foo: Foo = Bar{ .name = 10 };

1614032770
ikskuh
what error will this yield? :D

1614032775
noam
Hmm.

1614032798
noam
Error: cliched identifiers

1614032798
andrewrk
error: expected Foo, found Bar

1614032807
noam
error: expected Bar, found Foo

1614032814
ikskuh
error: no member named 'name' in struct 'Foo'

1614032824
noam
... lol

1614032827
ikskuh
yep :D

1614032834
andrewrk
let me check how stage2 handles this

1614032844
ikskuh
if you add that field to Foo, it will error out with the expected type mismatch

1614032892
g-w1
stage2 doesn't handle it at all since it has no struct types yet (except for imports) i think

1614032944
andrewrk
error: TODO implement astgen.expr for .StructInitializer

1614032952
andrewrk
the stage2 error message is reasonable ;)

1614032980
ikskuh
haha

1614032994
ikskuh
but yeah, it's a weird and unexpected error message

1614033000
ikskuh
but i don't see reason to fix it in stage1

1614033009
andrewrk
result locations are handled much, much more cleanly in stage2

1614033107
ifreund
andrewrk: why are extern functions fn_proto instead of fn_decl?

1614033184
andrewrk
we can rename the tag if you want, but there is no need to pay the cost of an extra AST node per extern function decl since the body is null

1614033198
ifreund
ah ok

1614033224
ifreund
my main gripe is that firstToken() is broken for fn_proto now, I think I might just make a new tag

1614033233
andrewrk
oh snap sorry about that

1614033241
andrewrk
ah right of course

1614033275
andrewrk
perhaps: extern_decl ?

1614033294
ifreund
yeah that's what I just came up with too :D

1614033299
andrewrk
:D

1614033319
ifreund
though it sounds like it includes extern var decls too, so extern_fn_decl

1614033325
andrewrk
was just thinking the same thing

1614033328
andrewrk
there is a zig fmt test case that expects this syntax to work: export fn foo() void;

1614033341
andrewrk
I think the idea there is to make this a semantic analysis error rather than a parse error

1614033349
andrewrk
it's up to you if you want to keep it that way or make it a parse error

1614033385
ifreund
alright cool

1614033400
ifreund
(took me a minute to realize that was export not extern :D)

1614033779
karchnu
Hello. Just passing by to say that I'm working on the website translation in french.

1614033843
karchnu
Don't hesitate to tell me that someone else is doing it. :) Thanks!

1614034144
ifreund
cool! don't know of anyone else working on it yet

1614034303
karchnu
Nice. B)

1614034401
ifreund
andrewrk: decided extern_fn_proto{_simple,_multi,_one,} wasn't worth it, just fixed firstToken()

1614034428
andrewrk
sounds good

1614034475
ifreund
hmm, the parser doesn't seem to support toplevel doc comments yet. I'll take a look at that then go to bed

1614034541
ifreund
or nevermind, I think this test case is wrong

1614034574
ifreund
container doc comments are only valid at the beginning of the contianer right?

1614034715
andrewrk
you mean this form? //!

1614034720
ifreund
yeah those

1614034736
andrewrk
yeah only allowed to be the first thing at the beginning of a container

1614034753
ifreund
cool, then the parser is fine, just need to add support in zig fmt

1614034850
andrewrk
I'm going through all the multi line string test cases

1614035090
ifreund
nice

1614035187
andrewrk
tfw you uncomment a test case and it already passes from a previous commit :D

1614035218
ifreund
:)

1614035865
andrewrk
ifreund, do you have any clues about the double indenting problem?

1614035879
andrewrk
e.g. the translate-c case we have disabled

1614035922
andrewrk
oh it seems to happen because of the grouped_expression

1614035989
ifreund
hmm, I added the indent stuff for grouped expression to pass some other test case

1614036023
andrewrk
I changed it to match master branch and it fixed the issue

1614036033
andrewrk
but tbh I don't really understand most of the AutoIndentingStream abstractions

1614036090
ifreund
they're if we want comments between tokens to be rendered indented in some cases

1614036102
ifreund
for example in an empty container decl

1614036186
andrewrk
ah I see

1614036599
andrewrk
zig fmt is a good example of software that is easy to understand conceptually but the devil is in the details

1614036606
ifreund
hrm, lastToken() is broken for container decls it seems, I'm not going to get container doc comments finished tonight

1614036623
ifreund
yeah definitely

