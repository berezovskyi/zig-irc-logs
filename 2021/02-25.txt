1614211428
marler8997
andrewrk are you available to discuss tryImport

1614211466
andrewrk
not right now

1614211476
andrewrk
but I would be up for that sometime this week

1614211514
marler8997
well, I think you missed the point on the android example, you said that we would only need to download the android dependency if we need it but that's not the case, build.zig needs the android dependency

1614211529
marler8997
I don't see why you're not getting that

1614211900
v0idify
"drews gonna drew" truth

1614212302
g-w1
andrewrk: while you do the benchmark, could you also commit the formatted results, for consistency?

1614212335
andrewrk
g-w1, no - will do a separate zig fmt commit directly to master branch after this is merged

1614212349
andrewrk
the benchmark is done on already formatted code

1614212367
g-w1
ok, cool, I just like formatted code :)

1614212538
andrewrk
marler8997, I can chat on IRC for a bit

1614212551
marler8997
I left another comment about 8 minutes ago

1614212560
andrewrk
catching up on that...

1614212562
marler8997
did you understand that it was build.zig that has a dependency on Android?

1614212569
marler8997
not just the application code?

1614212609
marler8997
somewhere in build.zig, there is a @import("androidbuild")

1614212638
marler8997
which provides code to let you configure the build to generate an Android APK

1614212773
mikdusan1
psa: llvmorg-12.0.0-rc2 has been tagged

1614212845
noam
...already???

1614212852
noam
Wasn't 11 just a few months ago??

1614212863
noam
... have they picked up the pace of version bumping?

1614213028
mikdusan1
yeah and 11.1.0 just got tagged. apparently zig builds against it but I didn't have a chance to see if that @reduce aarch64 bug is fixed. 12.x apparently fixes it and their release notes even say reduce builtin is no longer experimental

1614213429
andrewrk
oof I didn't get a chance to report regressions yet in rc1

1614213515
watzon
andrewrk: curious, how difficult was it to get arbitrary sized integers working in Zig? I just submitted a proposal to have the same thing done in Crystal (since it uses LLVM as well and it should theoretically be possible), but the maintainers have been struggling just getting i128 working properly.

1614213570
andrewrk
marler8997, let's talk about concrete use cases - so what's the example where we have a build.zig that wants to @import("android_sdk") - what is it doing with that import?

1614213587
marler8997
it's configuring the manifest file, adding application identify, etc

1614213594
marler8997
anything that you need to be able to build and Android APK

1614213622
marler8997
a library with all the stuff in ikskuh's talk in his build.zig file

1614213644
andrewrk
I see, so, for example, that package might provide some binaries that optionally want to get executed during `zig build`

1614213650
marler8997


1614213676
marler8997
it could, but it also could just be providing functions to add data structures to std.buid.Builder

1614213698
mikdusan
so a simple helper even

1614213702
marler8997
right

1614213708
marler8997
another example is bearssl

1614213724
marler8997


1614213743
marler8997
it provides a "linkWithBearSSL" function that adds all the bearssl C sources to the execuatble

1614213781
marler8997
I'd like to use it, but without @tryImport I can't

1614213844
marler8997
the bearssl example is less of a big deal because download that repo is small, but the same concept applies to Big repositories

1614213994
marler8997
by the way andrewrk, I think this is the first time someone has actually asked me a question about this proposal

1614214022
andrewrk
what do you mean?

1614214028
andrewrk
you didn't get any engagement on it before?

1614214039
marler8997
I don't know why some people are immediately passing judgements on this proposal saying things like "I don't like this" when they clearly have not throught about the underlying problem yet

1614214044
marler8997
it's quite frustrating for me to see that behavior

1614214066
andrewrk
yeah that is indeed frustrating

1614214094
andrewrk
unfortunately I think it's one of the phases of getting someone to understand a complex subject - first they deny that it is complex (myself included as guilty of this)

1614214110
marler8997
yeah I think you're right

1614214135
marler8997
this is less of a problem when the problem you're solving is simple

1614214193
marler8997
this one is especially complex because it has so many tendrils in so many other parts of the future of Zig

1614214199
andrewrk
my opinion on this topic is that you're onto a tricky problem that we don't have a complete solution to yet, even planned, and nobody is on your level of understanding yet (myself included), but I do think when I get there I will have something to offer in terms of where we end up landing

1614214253
marler8997
I feel like I can explain it very simply, the messages I sent earlier should explain exactly why @tryImport is necessary

1614214294
marler8997
@tryImport isn't an off the cuff idea I had, I came up to it by logically reducing the problem

1614214331
marler8997
so the question I would first ask you is, are we agreed that projects should be able to use some logic to change their dependencies?

1614214372
marler8997
as opposed to a project's dependencies always being a static non-changing list regardless of the options passed to build.zig

1614214390
andrewrk
for the build artifacts, certainly, but for what build.zig is able to @import, I think we're not quite ready to take that as a shared premise

1614214405
marler8997
gotcha

1614214416
marler8997
so what do you think about the android example then?

1614214436
andrewrk
I need a bit more time to think it through

1614214445
marler8997
ok, then that's probably a good place to leave it

1614214447
marler8997
for now

1614214474
marler8997
but also make sure to consider that dependencies are recursive

1614214482
andrewrk
ok

1614214563
marler8997
and just to be clear, I'm totally happy with alternative solutions, but it is quite frustrating to discuss this with people who don't even seem to be willing to admit it's a problem, nor make a good faith effort to understand the problem

1614214682
marler8997
but I'm telling you right now, I'm pretty confident your package manager idea of a static configuration file is not going to work, and will eventually need to become more complex, and you'll realize it should have been done in Zig, then you're going to want to support packages in your dependencie.zig file, and then you're back to the exact same problem we have today

1614214685
andrewrk
I promise you SpexGuy is making a good faith effort. I think it's a tricky problem to wrap one's head around

1614214719
marler8997
Yeah I definitely agree

1614214744
marler8997
I'm more qualifying what I'm saying in case I say something nasty because my emotions were starting to run high there

1614214764
andrewrk
let's come up with some degenerate example use cases for this problem, and create gists with various projects with interdependencies, that way whatever solution we propose can be evaluated in that context, whether it be @tryImport (which I agree with you solves the stated problem btw) or something else

1614214795
andrewrk
gotta go, lang specs meeting

1614214804
marler8997
andrewrk, yeah that's a good idea because then people can actually understand the problem instead of constatly arguing about whether it is

1614214807
marler8997
I'll work on that

1614214981
mipri
Ada has something like this, f.e.

1614214999
noam
andrewrk: given that everything except for cache misses is improving, what's the point in using cache misses as a metric?

1614215005
mipri
.gpr files that resemble code (not sure how much code is possible there) for configuration, that handle FFI and other languages and such.

1614215006
noam
Clearly, they're not actually important

1614215022
noam
Or, rather, the change isn't itself important

1614215033
mipri
aaand here's

1614215104
g-w1
it may be helpful to post how the ziget build.zig works with the git prompt and an example of it on the cli so the users fully understand it

1614215123
g-w1
s/users/people on issue

1614215471
marler8997
g-w1, what's your take on this?

1614216710
g-w1
this is a very complex problem (i may not fully understand yet), your solution looks like reloader with re-execing the binary based on the config

1614216755
marler8997
yeah I mean, that's one solution, but @tryImport can be applied to that idea, or the package-manager idea if we want to separate our dependencies into another file

1614216805
g-w1
My take is that if the compiler, build system, and pm are so intertwined why not have a @needsPackage(comptime name: []const u8, comptime error: []const u8) type that makes a compile error with error if the package is not found, but otherwise returns the package and does all the nessacary reloading for you

1614216815
g-w1
would that solve your usecase?

1614216834
g-w1
basically tryimport but in the language so its less powerful

1614216901
g-w1
imo a ?type is SUPER powerful

1614216909
marler8997
yeah that's true

1614216920
g-w1
would that hypothetical builtin solve the use case?

1614216925
marler8997
thinking...

1614216991
marler8997
so basically with @needsPackage, it's exactly the same as @import except it lets you provide a custom error message?

1614217001
g-w1
yes

1614217019
g-w1
for example git clone ../ziget ...

1614217034
marler8997
ok, then it doesn't solve the problem becuase we need a way to not get a compile error

1614217058
g-w1
hmm, what if openssl is not found at all, then you need a compile error

1614217071
g-w1
it will do the reloading for you too

1614217090
marler8997
if (androidEnabled) {    if (@tryImport("androidbuildlib")) |abl| { ... } else { ... } }

1614217106
g-w1
what goes in the else? thats what im confused about?

1614217116
marler8997
anything can go there

1614217120
marler8997
it can be a compile error

1614217131
marler8997
but what's important is that this is all wrapped in the if (androidEnabled)

1614217137
g-w1
whats an other usecase for the else?

1614217143
g-w1
besides compileerror

1614217157
marler8997
the else is not the point of it

1614217166
marler8997
the "if (androidEnabled)" is the point

1614217195
g-w1
ok I dont understand it :D, I will try again tommorow

1614217196
marler8997
we only ever enter this block if android is enabled, if android is disabled, our build still works so long as they don't enable android

1614217214
marler8997
and androidEnabled is a runtime known-value

1614217225
g-w1
oh, so tryimport is runtime known?

1614217227
marler8997
come on, I know you can get it

1614217251
g-w1
or comptime but embedded in the binary so it can be known at runtime?

1614217261
marler8997
nope, @tryImport is comptime-known, but we won't know if we actually need it until runtime, which is why we have to handle it being there and not being there

1614217302
marler8997
once you wrap your mind around it, it all makes sense, but it takes a minute

1614217334
g-w1
I think this is a problem that needs a solution. Im not sure if ?type is the best approach, let me come back to you

1614217343
marler8997
?type is the only approach :)

1614217359
marler8997
it has to be ?type because whether or not we need the import depends on a runtime value

1614217386
marler8997
let's compare it to your @needsPackage

1614217391
marler8997
what happens in this example?

1614217402
marler8997
when android is missing, what happens?

1614217473
marler8997
if (androidEnabled) { const abl = @needsPackage("androidbuidlib"); ... }

1614217581
marler8997
stay with me, I feel like you're close to getting this, what happens to this code when androidbuildlib is missing?

1614218247
g-w1
i iok      /quiti

1614218290
g-w1
oops, my ssh session got borked

1614218299
marler8997
you back now?

1614218304
g-w1
yes

1614218316
g-w1
I understand it now

1614218327
g-w1
i took a break and now get it

1614218343
g-w1
so the ?type seems necessary

1614218351
marler8997
yup

1614218376
marler8997
we need to be able to build `build.zig` even when androidbuildlib is missing

1614218379
g-w1
unless the error for @needsPackage is triggered on runtime instead of comptime

1614218391
marler8997
g-w1, yes that coud work

1614218408
g-w1
I would like that better since it is less open ended

1614218418
g-w1
are there usecases in which that wouldn't work?

1614218431
marler8997
I'm trying to think if it could even work like that

1614218435
g-w1
if not, ill add it to the github issue

1614218457
marler8997
so when androidbuildlib is missing, what type does @needsPackage return?

1614218490
g-w1
a dummy type that allows anything to be called on it

1614218512
marler8997
you would need some way to know whether it actually failed or not, so you can do if (needsPackageFailed) { // dont call anything from androidbuildlib or you'll get a compile error }

1614218522
marler8997
g-w1, in that case, it's just as powerful as @tryImport

1614218530
marler8997
just a little more convuluted, @tryImport with more steps

1614218535
g-w1
ok yeah

1614218547
g-w1
you seem to have put a lot of thought into this

1614218549
noam
but...

1614218562
noam
if androidEnabled is a comptime value - which it is, since build.zig - then that import will never happen

1614218567
noam
Or the needsPackage, rather

1614218574
noam
Ahhh wait, no, I see

1614218578
g-w1
its runtime, yeah

1614218582
noam
Hm.

1614218592
noam
@needsPackage... is a builtin??

1614218596
noam
Not a build.zig *function*?

1614218602
g-w1
see

1614218602
noam
That makes no sense, IMO

1614218615
g-w1
yeah @tryImport is the way to go

1614218622
noam
I have, but...

1614218632
marler8997
noam, if it makes no sense then you're on the right track :)

1614218643
marler8997
it shouldn't make sense when you first look at it and think about it

1614218677
noam
Wait. that's a built-time dependency, right?

1614218694
marler8997
androidbuildlib is a comptime import

1614218705
marler8997
in build.zig

1614218706
noam
build.zig needs it to build for android, right. Hm.

1614218711
g-w1
to make people understand this better, I think you should put front and center that this allows stuff to compile with missing deps and that it is used at runtime

1614218718
noam
I don't like this, at all. This means if you build with it not installed, you can't target android

1614218725
noam
Even if you install it afterwards!

1614218736
noam
You'd need runtime import resolution, which is horrendous

1614218741
marler8997
nope

1614218750
noam
You'd have to rebuild build.zig

1614218755
marler8997
yup

1614218779
noam
Which it won't know to do without trying to build anyways

1614218788
marler8997
nope

1614218790
noam
Personally, I think the better solution is to stop caching the result of building build.zig

1614218801
marler8997
that's not a solution

1614218811
noam
With stage2, building a build.zig file should be so blazing fast - even before incremental compilation - that invoking it as a script makes more sense IMO

1614218826
noam
Then, you turn android_enabled into a comptime value.

1614218839
g-w1
so build.zig is like config.h?

1614218846
noam
`zig run`, basically.

1614218860
noam
You rebuild it every time, and the cache catches it if the current config has already been built.

1614218869
marler8997
interpreting build.zig instead of compiling it...that is an interesting idea, thinking...

1614218872
noam
Make arguments available at comptime and voila.

1614218886
noam
I don't think we should twist the language when we can just change how we run the file, instead.

1614218894
g-w1
OMG, thats cool. a comptime script

1614218895
noam
There's no reason to add concepts to the language that only need to exist for a single use case

1614218902
noam
g-w1: exactly!

1614218903
marler8997
so does this mean you wouldn't analyze the @import("androidbuildlib") if the user doesn't enable android with their command-line ?

1614218907
noam
Yep

1614218915
marler8997
yes that would also work

1614218922
noam
Basically, it'd mean tweaking zig run - a

1614218931
marler8997
making all the configuration available at comptime is another solution

1614218935
noam
I think this is better, because it adds options for a whole load of other use cases

1614218946
marler8997
it does mean you'll have to re-compile build.zig every for every possible set of command-line options

1614218946
g-w1
I like it better too, since it was already suggested!

1614218954
noam
It means that you can use "dynamic zig" - the comptime language - for scripts!

1614218960
g-w1
no, run it at comptime

1614218963
noam
marler8997: no, only for the currently given one ;)

1614218977
noam
in theory, if we do a finer-grained cache - as zyg will - it won't matter

1614218984
noam
anywho, I'm headed on a run, cya

1614218995
g-w1
this was suggested here

1614219043
g-w1
imo this is a much cleaner solution

1614219055
marler8997
what is this dynamic zig?

1614219059
g-w1
comptime!

1614219061
marler8997
is this a thing?

1614219082
g-w1
not yet, but why not just make pub fn build invoked at comptime by build_runner.zig?

1614219107
g-w1
comptime { @import("build.zig").build(b) } then you just do what b says

1614219124
marler8997
interesting, I'd have to think on this a bit but this could be a viable solution

1614219124
noam
It is a thing, actually

1614219128
g-w1
all you have to do is support comptime cli args

1614219131
noam
Comptime zig is already fully dynamic

1614219135
noam
Yep

1614219146
noam
Comptime cli args seem like a much more elegant solution to me

1614219168
marler8997
I need to know enough to make a PR

1614219202
g-w1
pr? why not just another proposal? I can make if you dont want to

1614219206
marler8997
it could be more elegant, but I need to understand it more

1614219249
marler8997
so how would build.zig work if it executed at comptime?

1614219269
marler8997
what would need to change?

1614219272
marler8997
with build.zig specifically

1614219301
g-w1
everything is declarative

1614219350
marler8997
are you saying we can't implement any logic to select our build configuration?

1614219419
g-w1
these 2 solutions are congruent, they both take cli args and do imports based on it. #2 works at comptime therefore not requiring a builtin, #1 runs at runtime therefore requiring a builtin. all that needs to change in the language is a way to pass args at comptime

1614219458
g-w1
which I think would be good because the way build.zig does it anyways is not possible (I dont think) without using the build.zig api (ex. build-exe)

1614219459
marler8997
andrewrk, if/when you see this, have you thought about making build.zig comptime only?  Doing this would also be a solution to the build.zig bootsrap problem because it would get recompiled with every set of command-line arguments given to it.

1614219469
g-w1
and it would be a solution to the securty problem

1614219482
g-w1
3 birds with 1 stone!

1614219508
marler8997
what 2 solutions?

1614219526
g-w1
tryimport and comptime build.zig

1614219535
marler8997
oh right, yes

1614219546
marler8997
well, it wouldn't be tryImport anymore

1614219554
g-w1
?

1614219562
marler8997
it would be if (androidEnabled) { const al = @import("androidbuildlib"); }

1614219570
marler8997
this would not compile because androidEnabled is comptime known

1614219576
marler8997
*this would now compile

1614219608
g-w1
the 2 solutions are either 1 or the other; you can ignore that

1614219657
marler8997
ah, is that what congruent is supposed to mean?

1614219675
g-w1
they do the same thing; ==

1614219688
marler8997
they both solve the bootstrap problem

1614219692
marler8997
but are both quite different

1614219710
marler8997
@tryImport allows build.zig to make use of runtime

1614219735
marler8997
so that's the crucial question, do we want build.zig to be able to use runtime or not

1614219745
g-w1
for securty no

1614219761
marler8997
I'm still fuzzy on the details for a comptime build.zig

1614219764
noam
Hm. It's not really a security thing though

1614219792
g-w1
why? now bulid scripts cant execute arbitrary commands

1614219821
marler8997
yeah, comptime build.zig would be more sandboxed, though, I'm not intimately familair with all the restrictions on comptime

1614219852
noam
Only if it runs fully at comptime, which isn't what I was saying and also isn't really possible.

1614219853
marler8997
if it's viable, I do like the idea of comptime build.zig

1614219854
g-w1
it

1614219860
noam
It fundamentally needs to be able to execute child processes.

1614219862
noam
Well, hm

1614219868
marler8997
noam, that's actually a good point

1614219873
marler8997
you're right

1614219875
noam
We could make a whitelist

1614219890
noam
Disable inline asm, make sure it can't use syscalls, and give it a whitelist of functions to use at runtime

1614219902
noam
but security is orthognal to this

1614219921
marler8997
I'm still trying to figure out how comptime build.zig looks

1614219927
g-w1
why childprocess? just add a Builder field called commands: [][]const u8

1614219930
marler8997
so we don't have a build entry point anymore right?

1614219951
g-w1
we have a build_runner that takes all the things declared in build.zig and actually executes it

1614219967
marler8997
what are "all the things" exactly?

1614219989
g-w1
exes, subprocess, packages, libs, c files, etc

1614220007
marler8997
right, but how do I write this build.zig, what are these things? types?

1614220015
marler8997
give me an example

1614220075
marler8997
pub const MyApp = std.build.Exe("myapp", "myapp.zig"); ??? and then build_running uses reflection to get all the pub decls?

1614220087
marler8997
*build_runner, not build_running

1614220137
marler8997
I think a path forward here might be to add support for a comptimebuild.zig, and prototype this idea

1614220152
mikdusan
marler8997: does this use-case correctly capture the happenings of tryImport?

1614220184
g-w1
const Builder = struct { exes: []Exe, } const Exe = struct { source_path: []const u8, packages: []Pkg } fn execute(b: Builder) { for (b.exes) |exe| exe.build() } fn build(e: Exe) { os.system("zig build-exe {}", .{e.source_path}); } marler8997 this is how I would do it. then pub fn build in comptimebuild would modify Builder

1614220193
marler8997
mikdusan, looking

1614220207
noam
g-w1: ahhhh, so you modify the builder, and only the builder is allowed to generate runtime code?

1614220214
g-w1
exactly

1614220218
noam
I likey.

1614220256
g-w1
it is b = Builder{}; comptime { @import("build.zig").build(&b) } b.execute();

1614220259
noam
Zig build would basically be a specialized zig run, which detects runtime code from the build script (NOT the root source file) and errors out if detected

1614220264
marler8997
mikdusan, you're missing and if (b.option("enable-llvm")) around your block that uses @tryPackage("llvm").  The key here being that the block is surrounded by a runtime value

1614220283
marler8997
*surrounded by an if that uses a runtime value

1614220306
mikdusan
ah right.

1614220330
mikdusan
well it's a comptime value to build.zig is it not?

1614220340
marler8997
no, it's a runtime value

1614220356
marler8997
-Denable-llvm is a an option passed to the compiled build.zig executable

1614220375
mikdusan
ah yes. whups

1614220414
g-w1
marler8997: does my explanation make sense? build.zig modifies a Builder at comptime and then build_runnner.zig runs it at runtime

1614220423
marler8997
g-w1, I'm still groking your example

1614220527
marler8997
now I'm the one who isn't understanding :)

1614220540
g-w1
its exactly the same as it is now just comptime

1614220578
marler8997
so build is now executed at comptime instead of runtime?

1614220634
marler8997
I don't understand, what's "execute" and "build" functions for?

1614220641
g-w1
/ build_runner.zig: comptime var b = Builder {}; comptime { @import("build.zig").build(&b); } b.execute(); // <- runtime

1614220667
marler8997
I thought Builder was defined in build.zig?

1614220673
marler8997
@import("build.zig").Builder?

1614220681
g-w1
no, its still in std

1614220695
marler8997
so then what was the code you pasted earlier? I thought it was the content of build.zig?

1614220709
g-w1
thats the content of build_runner lol

1614220730
marler8997
well that clears up one part of my confusion

1614220735
marler8997
so what does build.zig look like?

1614220742
marler8997
oh, it looks exactly the same as it does today?

1614220746
g-w1
yes exactly

1614220769
marler8997
Would that work?

1614220774
g-w1
to do subcommands you just call b.subCommand and build_runner executes it after (maybe let the user vet it)

1614220791
g-w1
Idk, i dont see why it would not

1614220806
marler8997
we need to create a simple build_running.zig and see if it works

1614220817
marler8997
I'm just not familair enough with comptime to know

1614220841
marler8997
we can try the ziget build

1614220847
andrewrk
oh baby is that a green CI I see?

1614220850
mikdusan
marler8997: updated gist. take a peek when u have chance. afk for 10 mins.

1614220867
mikdusan
confirmation bias!

1614220878
g-w1
ok, its getting late for me, but I will put that on my TODO list and try tommorow. the only thing we need is comptime args now

1614220890
g-w1
it should be possible though

1614220898
marler8997
if you're off, then I'll be trying it before then :)

1614220927
marler8997
mikdusan, taht won't compile when llvm is missing because llvm won't have the methods like getLibrariesToLink

1614220949
marler8997
unless, is exec noreturn?

1614220951
g-w1
beware, you might need to modify builder. I was thinking of just creating a builder type that resembles std.build just that works at comptime if the current one doesn't

1614220971
mikdusan
marler8997: yes some kind of replace-existing-process

1614220987
marler8997
ok, then the compiler shouldn't analyze the lines below if llvm is missing

1614221007
marler8997
but it's not immediately clear, I would an if { .. } else { ... } to make it very clear

1614221013
mikdusan
k

1614221015
g-w1
OMG green ci

1614221026
marler8997
flao, you can remove a level of nesting if you just put your (enable_llvm) around the block above it

1614221042
marler8997
congrats on green CI, that's awesome!

1614221122
marler8997
time to see if DOD is all it's cracked up to be

1614221206
g-w1
marler8997: heck this can be even simpler. all we need to do is support comptime args to build.zig; thats it!

1614221211
g-w1
thats super ez

1614221251
marler8997
yeah I think you're right, though I'm not sure how different that is

1614221279
marler8997
I suppose it's actually different because the logic now executes at runtime

1614221310
marler8997
the big downside here is that we need to recompile build.zig with every combination of command-line arguments

1614221333
g-w1
yes, but that should be fast; that is what noam was saying all along; weve gone full circle

1614221382
marler8997
I don't think it's a big deal, but I'm not sure yet

1614221387
noam
or full klein bottle. You can't prove we're only 2d!

1614221408
marler8997
would the target name also be comptime?

1614221423
marler8997
or with "zig build run ARGS", ARGS would be runtime correct?

1614221461
g-w1
actually this can be implimented with the language right now. all we need is a build_build.zig which takes any args it has and passes them to build.zig at comptime

1614221549
marler8997
need more context for that one

1614221591
g-w1
build_build.zig gets executed at runtime with cli args. then it passes all its args to build.zig in a way that it can access them at comptime. this is a hack, but a good way to explore this

1614221601
g-w1
and to show that it is possible

1614221647
marler8997
so build_build.zig is the one that actually builds build.zig

1614221678
marler8997
and how does it pass comptime args to it?

1614221686
mikdusan
don't you still need a place to action code when pkg is not found? where does that go?

1614221696
g-w1
the same way build.zig passes to main.zig

1614221706
g-w1
mikdusan: presumably just an @compileError

1614221730
marler8997
mikdusan, that's where your "exec" function is called

1614221741
marler8997
g-w1, build.zig passes comptime parameters to main.zig?

1614221759
g-w1
as build options

1614221767
mikdusan
no I mean with build_build. is the point of build_build

1614221792
marler8997
mikdusan, pretty much yeah, but it's based off another proposal to make build.zig comptime only so it is sandboxed

1614221795
g-w1
it is hypothetical. it would just be the compiler that collects the args and passes to build.zig at comptime

1614221798
noam
and to test whether comptime CLI args are a good idea

1614221800
marler8997
now we're exploring something in between the 2

1614221805
noam
Yeah the compiler would have to do it

1614221816
noam
not a build_build.zig file; it'd have to be part of `build.zig`

1614221830
noam
Basically, invoke the comptime engine with the given args

1614221836
marler8997
yeah we're talking about the details of a proof-of-concept

1614221881
mikdusan
just build.zig --target wasm sandboxed :P

1614221894
marler8997
the problem of missing imports goes away if all out build-configuration is provided at comptime, because now we can put our @imports inside if blocks that are known at comptime

1614221954
marler8997
Unfortunately I don't know enough about comptime to really know whether limiting build.zig to comptime for it's configuration would even be viable, or a good idea, but seems like it could be

1614221979
marler8997
so the best I can do is try to implement it and see what happens

1614222079
g-w1
ill try to get build_build.zig working tmrw as a proof of concept too

1614222137
g-w1
hmm theres no documentation on how to add a builtin comptime option as a build-exe flag? how do you do it

1614222137
andrewrk
#7920 merged 🎉🎉

1614222161
g-w1
yay 🎉🎉

1614222214
andrewrk
big thank you to ifreund and vexu

1614222338
marler8997
g-w1, yeah I'm not familiar with any concept like that

1614222348
g-w1
build.zig must do it somehow with the -Doptions

1614222355
noam
andrewrk: nice work! ☺

1614222356
marler8997
those aren't comptime, their runtime

1614222379
g-w1
they are comptime for main.zig, im thinking the same thing but for build.zig; its probably a hidden compiler flag

1614222380
noam
g-w1: it generates a build_options.zig file

1614222387
g-w1
ahhhhhhhhhhhhhhh, makes sense

1614222390
noam
Which you import

1614222396
marler8997
they don't get passed to main.zig

1614222407
noam
You could have zig build generate a build_args package

1614222420
g-w1
yep, will do a prototype like that

1614222422
marler8997
noam, yeah generating something like that is what I hthought of

1614222422
noam
Then you get args as a tuple-shaped structure in build_args

1614222469
marler8997
so in `build.zig` @import("buildoptions")

1614222477
noam
Yeah

1614222484
g-w1
yep, then you can conditionaly import based on that

1614222490
marler8997
I mean, I don't think we need a proof of concept for this

1614222493
marler8997
I know it will work

1614222504
marler8997
the question is whether this would be accepted

1614222516
marler8997
and the bigger question is, whether build.zig could be executed entirely at comptime

1614222528
marler8997
I'll be back in like 30

1614222530
g-w1
imo its way more likeley than @tryImport for the buildoptions

1614222562
noam
I agree - this is also based on something we

1614222570
noam
We're just changing it a bit

1614222583
marler8997
andrewrk, do you think making build options available at comptime for build.zig is likely to be accepted?

1614222602
marler8997
be back

1614222616
g-w1
the reason for this is to allow the same kind of conditional import that tryImport allows just in a more ziggy way

1614223095
andrewrk
I'm expecting 90% of zig packages to not even have a build.zig

1614223106
andrewrk
especially "leaf nodes" in the global dependency tree

1614223655
g-w1


1614223668
noam
...

1614223671
g-w1
i tried to emulate the js version as much as possible

1614223788
marler8997
there's no question that this feature is a corner case

1614223817
marler8997
not only does not only apply to non-leaf nodes, it also only applies to nodes that have dynamic dependencies

1614223846
g-w1
how do you test leafs without a build.zig?

1614223888
marler8997
it sounds like your answer is, "I don't know I need to think about it"  from your first impression, do you have an inkling about whether you would be more likely to accept @tryImport or comptime build options?

1614223921
g-w1
i think the comptime build options would need to replace runtime ones for consistency but that is fine imo

1614223942
marler8997
g-w1 huh?

1614223973
g-w1
b.option and buildoptions.get(x) seem redundant

1614223992
marler8997
we could make b.option return a comptime value, so we'd still be using the exact same API

1614224000
g-w1
makes sense

1614224015
marler8997
build.zig wouldn't actually import buildoptions, build_runner.zig would

1614224029
g-w1
std.build right?

1614224035
marler8997
oh right, yes

1614224156
marler8997
ooo wait a second

1614224164
marler8997
why don't we let build.zig say what options are comptime?

1614224202
g-w1
so it doesn't have to rebuild every time? in that case why not just cache the combinations of options used?

1614224205
marler8997
comptime options would need a special syntax in "zig build"

1614224207
marler8997
right

1614224223
g-w1
why special syntax? just do -Dthing the same way

1614224233
marler8997
how would zig build know if it was a comptime or runtime option?

1614224276
g-w1
oh, in your case where it specifies then idk, but if all r comptime it still allows caching of the args passed

1614224342
g-w1
what is the benifit of runtime args in that case?

1614224354
marler8997
means you don't need to rebuild build.zig

1614224368
g-w1
see my above point about caching individual combinations of args

1614224389
marler8997
sure, but we're talking about a corner case

1614224399
marler8997
why should every project pay the cost of comptime args when only a few need it?

1614224419
marler8997
you're going to recompile build.zig N exact duplicates of build.zig

1614224459
g-w1
I guess

1614224500
marler8997
we already need to distinguish between comptime and runtime options, it would be crazy to make "zig build run ARGS" comptime

1614224534
g-w1
then just a b.comptime_option ig

1614224540
marler8997
right

1614224546
marler8997
but how to expose them on the command-line?

1614224560
g-w1
the user doesn't have to know ;)

1614224561
marler8997
zig build needs to know which options the user has given are comptime

1614224575
marler8997
because that's how it knows it needs to rebuild build.zig

1614224612
g-w1
can't it just look at b's comptime_options and see if it matches?

1614224621
g-w1
or is that too much compiler+std integratino?

1614224631
marler8997
b's comptime_options? what's b?

1614224641
marler8997
oh, builder

1614224645
marler8997
that' doesn't run until runtime

1614224655
g-w1
yeah

1614224667
marler8997
zig build does not even know the options until after it executes the "build" function from build.zig at runtime

1614224917
marler8997
we could use a different prefix like "zig build -Efoo=bar"

1614224945
marler8997
but, it doesn't seem like something that should be exposed to the end-user

1614224999
g-w1
now if comptime_options is a comptime field, then the compiler could know what they are, not sure if that would work though

1614225099
marler8997
it needs to know what options are comptime before it compiles build.zig

1614225150
marler8997
we could possibly do something clever

1614225155
g-w1
ah, i guess one solution is - stage2 is fast enough

1614225158
marler8997
pre_build_runner.zig

1614225171
marler8997
it imports build.zig but doesn't call "build"

1614225189
marler8997
it relys on Zig being lazy, and it looks for a special symbol like "comptime_options" inside build.zig

1614225221
marler8997
that's pretty clever if I do say so myself

1614225228
g-w1
clever, but complicated

1614225233
marler8997
it's convuluted and complicated

1614225298
marler8997
it adds this extra compilation before build.zig is compiled

1614225323
marler8997
but it should work

1614225339
g-w1
probably same amount of time to just cache every arg

1614225344
marler8997
ok I think I have enough to create a PR with a proof-of-concept in Zig

1614225359
marler8997
nah, caching every arg is completely different

1614225377
g-w1
👍ok, ill be on the look out for pr

1614225385
marler8997
that's 1 compilation per argument permutation

1614225402
marler8997
this is 1 extra compilation, that's it end of story

1614225404
marler8997
that can be cached

1614225427
g-w1
yes, but stage2 is fast. with yours it has 1 compilation every time with pre_build_runner.zig right? so 2 if it changes vs 1 constant

1614225438
marler8997
it's not just about speed, but storage as well

1614225468
marler8997
not 1 compliation every time

1614225476
marler8997
only 1 compilation ever

1614225488
marler8997
you only need to recompile pre_build_runner.zig when build.zig changes

1614225498
g-w1
ah, makes sense

1614225504
marler8997
you don't need to rebuild it, even if the user provides different comptime options

1614225677
g-w1
yep, this is pretty nice to poc and seems much more ziggy

1614225748
marler8997
it's a solution that works with the existing language, so that's definitely a plus

1614225793
marler8997
this means we don't use b.comptime_option

1614225806
g-w1
at the very least if this didn't get accepted, you could probably emulate this somehow in userspace

1614225836
marler8997
you can do this with a tool that runs before Zig's package/manager and "zig build"

1614225858
marler8997
that's always an option, but is ugly, and will make my project not work as a dependency for other projects

1614225873
marler8997
every project that uses my project will also need to run this "pre-package-manager-build-tool"

1614225916
marler8997
and Zig's package manager probably won't have a way to hook into a dependency to run a pre-build step like this, so it actually probably isn't even a viable solution

1614225939
g-w1
or just provide another fn build(b: *Builder, sslBackend: enum { ... }) that projs can hook into

1614225956
g-w1
*comptime sslBackend: enum { ... }

1614225989
g-w1
but i agree its not the best solution

1614226000
marler8997
I'm not sure it's even a solution yet

1614226020
g-w1
exactly :)

1614226334
andrewrk
marler8997, yes my answer is, "I don't know, I need to think about it."

1614226370
marler8997
andrewrk, ok thanks, knowing where you stand saves me alot of time and effort, even knowing you're not sure

1614226373
andrewrk
I didn't catch the conversation about comptime build options. to be clear, @imports are available to comptime code

1614226403
marler8997
the current idea is to allow build.zig to specify some options as comptime

1614226419
marler8997
this solves the @tryImport problem because now we can use those comptime_options to know whether or not we need certain imports

1614226457
andrewrk
if you just put `pub const foo = 1234;` in a .zig file and @import() it, it will be comptime known

1614226464
andrewrk
I think I'm missing something

1614226482
g-w1
known to

1614226490
marler8997
if (comptimeOptionAndroidEnabled) { const androidbuild = @import("androidbuild"); ... }

1614226508
g-w1
from the cli

1614226519
marler8997
whears today we have if (b.option(bool, "androidEnabled")) { const androidbuild = @import("androidbuild"); ... }

1614226534
marler8997
this will always fail because b.option is known at runtime, so the @import must always pass

1614226548
marler8997
(this is why @tryImport can get around this)

1614226578
marler8997
but allowing some options to be comptime is another solution, with no language changes required

1614226630
marler8997
g-w1, instead of pre_build_running.zig, we probably want something like extract_comptime_options.zig

1614226648
g-w1
same idea right?

1614226653
marler8997
yup

1614226943
andrewrk
I see

1614227012
andrewrk
I think the degenerate use cases that are driving these ideas are so far just slightly bigger than I can fit in my head at this time (with other stuff on my mind) and I'll need to dedicate some full, undivided attention to it

1614227068
marler8997
sure thing, let me know if you want to discuss sometime as well, if you want to discuss soon I'll hold off on prototyping the comptime options idea and wait instead

1614227087
marler8997
I know it will work so no proof-of-concept needed

1614227119
andrewrk
will do

1614227169
g-w1
note if we wanted to go full-comptime with build.zig for securty, this would be a byproduct of that and not be needed

1614227209
marler8997
yeah true, I don't know if you've considered full comptime build.zig

1614227243
daurnimator
I've mentioned it before

1614227265
g-w1
yep thats where I got the idea :D

1614227413
marler8997
here's what comptime build options would look like in a build.zig:

1614227457
andrewrk
I don't think comptime build.zig is feasible

1614227459
daurnimator
marler8997: why like that?

1614227469
andrewrk
we want to touch the filesystem and other stuff like that

1614227471
g-w1
its for build.zig caching

1614227477
daurnimator
marler8997: use the field name as the option name; and make the help come from a doc-comment?

1614227490
marler8997
I was just copying the Builder.option function

1614227505
daurnimator
andrewrk: I think build.zig should (comptime) create a dependency of commands to run; from a known set of available commands.

1614227527
daurnimator
andrewrk: uh, DAG of commands to run

1614227548
g-w1
andrewrk: that could be in a declarative api. we can mutate builder to touch all the stuff. b.exec(cmd) b.writeFile(name, string) then this would make a TODO in the runner to do that

1614227558
daurnimator
for security reasons, I'd like to be able to run `zig build` without fully reviewing it first

1614227561
andrewrk
it's an idea worth exploring

1614227586
daurnimator
--> I want to be able to run `zig build` and trust it hasn't stolen some credentials on my machine

1614227592
mikdusan
marler8997: what happens when @import("opensslbuild") fails because not found?

1614227593
daurnimator
(or that it hasn't installed a rootkit)

1614227605
marler8997
it's just a compile error

1614227618
daurnimator
as it is: I have to run `zig build` in a sandbox that gets thrown away every time

1614227625
marler8997
with this solution, I'm not sure how a package would know which packages need to be retrieved

1614227637
mikdusan
marler8997: the solutions are thus not even remotely equal

1614227650
marler8997
yea definitely not equal

1614227661
marler8997
this one doesn't give build.zig any opportunity to try to handle a missing package

1614227668
daurnimator
marler8997: that's good IMO

1614227675
daurnimator
I would never want build.zig to download packages for me

1614227685
marler8997
but it does allow build.zig to change what it needs to import based on the build configuration

1614227686
daurnimator
infact I don't want build.zig to be even

1614227714
andrewrk
I agree that build.zig logic should create a DAG only and the build runner should interpret this DAG and do the package downloading if necessary

1614227722
g-w1
what is DAG?

1614227727
mikdusan
giving comptime config to .zig is easy. in alternative solutions to @tryImport, if we dont have opportunity to codify not-found logic, then I don't know the point

1614227730
andrewrk
Directed Acyclic Graph

1614227734
g-w1
thx

1614227741
andrewrk
never mind that though, I think that's not quite the right term

1614227753
andrewrk
point is build.zig is declarative and the build runner takes that info and does the actual work

1614227806
daurnimator
yep

1614227815
marler8997
with the current package manager design, this would require the package manager to have some way to interact with build.zig to know which packages it is importing for any given comptime-configuration set

1614227841
daurnimator
marler8997: my proposal to g-w1 the other week was that `pub fn build()` would be evaluated at comptime

1614227863
marler8997
how does that tell the package manager which package it needs?

1614227890
daurnimator
then

1614227913
marler8997
just for clarification, this would mean the packages that build.zig uses would be in packages.json, but we wouldn't necessarily download them unless we determine that build.zig needs them

1614227951
marler8997
groking...

1614227991
marler8997
are you sure that's correct?

1614228023
marler8997
I guess the point you're saying it, builder is the result of running build from build.zig

1614228027
daurnimator
marler8997: if build.zig can be evaluated at comptime, then there's no reason you couldn't call it from any comptime code/context.

1614228060
marler8997
but how does evaluating it at comptime help the package manager know what packages it needs?

1614228068
daurnimator
and if the `build()` set up dependencies it wants in some field of the builder, then you would be able to interact with it

1614228097
g-w1
imo a comptime build.zig would solve a bunch of problems and is worth a prototype

1614228125
marler8997
I'm trying to picture how the package manager and "zig build" would be using build.zig at comptime

1614228160
marler8997
like, when is the compiler running, how does the flow work here?

1614228194
marler8997
today the flow is, compile build.zig, then run the exe to get inputs and outputs and run various build actions

1614228230
marler8997
how does the zig build flow work if build.zig is invoked at comptime?

1614228280
marler8997
Does it work the same way?  you still compile a build exe and run it the same way?

1614228289
g-w1
build_runner is still runtime

1614228302
marler8997
ok, so then how does the package manager use build.zig?

1614228325
marler8997
is it interacting with the resulting build exe, or is package-manager re-evaluating the comptime build function?

1614228392
marler8997
if it interacts with the build exe function, I wonder if there's a way build_runner could output the packages it needs?

1614228407
marler8997
build --zig-internal-list-packages

1614228433
marler8997
wait no that doesn't work, because the @imports will fail

1614228436
mikdusan
I think both altnernatives to tryImport discussed here need to show a use-case in enough detail to answer these questions and state what they do when an import is not found

1614228460
marler8997
yeah definitely, I'm trying to work through a potential solution

1614228482
marler8997
this means that the package manager MUST evaluate build.zig at compile time

1614228490
marler8997
but then the imports will still fail

1614228499
marler8997
yeah I don't think this works

1614228564
marler8997
with @tryImport, what would happen is package-manger would compile build.zig, then it would run it to get the package list it needs

1614228618
marler8997
in build.zig  if (b.option(bool, "android")) { if (@tryImport("androidbuild")) |ab| { ... } else { b.needPackage("android"); } }

1614228647
mikdusan
btw, s/tryImport/maybeImport/ to denote that it's an option? do we have any idiom fn naming for such things?

1614228653
mikdusan
optional.

1614228676
marler8997
that's fine with me

1614228687
marler8997
I was also considering optionalImport

1614228725
marler8997
try kinda  means "error if this fails" so it doesn't really match

1614228755
marler8997
but shoot, I don't think comptime build options solves this, that's freakin lame

1614228795
g-w1
yeah, thats super lame

1614228937
mikdusan
and counter-point (oops). `std.thread.Mutex.tryAcquire()` vs `Mutex.acquire()`

1614228958
mikdusan
forget I brought it up

1614229045
mikdusan
marler8997: yeah I was staring at my gist thinking `if (enable_llvm)` is comptime, I don't see how to handle missing package:

1614229073
mikdusan
sorry (updating gist I had tryPackage, should be tryImport)

1614229074
marler8997
mikdusan, yeah I hadn't gotten that far in the comptime build options yet, but I got there eventually :)

1614229112
lukeholder
Is there a http server/client library for zig yet?

1614229394
marler8997
what kind of server/client, for what purpose?

1614229811
marler8997
ok, here's a realistic example, with a step-by-step of what's going on:

1614229838
marler8997
so long as we agree this use case is valid, if we can solve this without @tryImport I'd love to hear ideas

1614230267
mikdusan
ooh here's a thought. package_manager

1614230283
geemili
lukeholder: There is apple_pie for the server side:

1614230305
marler8997
IPCs?

1614230313
g-w1
intner process communication

1614230330
mikdusan
oh right doesn't need to be IPC if embedded zig.exe . so callbacks or wahtever

1614230333
marler8997
oh right, well that's what the --get-package-needs is

1614230336
marler8997
poor mans IPC

1614230363
mikdusan
if done that way, wouldn't need a new builtin

1614230389
daurnimator
mikdusan: I really

1614230396
marler8997
how do we hook into the compiler to report missing imports, and not also cause other compile errors from the resulting type not being valid?

1614230414
marler8997
and how do we know which imports we need?  We only know this at runtime

1614230433
marler8997
if (b.option(bool, "android")) { @import("android"); }

1614230453
daurnimator
mikdusan: and by that I mean: I want

1614230497
mikdusan
daurnimator: notwithstanding the runtime thing marler8997  just mentioned, none of what I said precludes user-interaction required if we setup package manager defaults that way

1614230523
marler8997
"the runtime thing" is kinda the whole thing :)

1614230528
mikdusan
heh i know

1614230532
mikdusan
slow.. on the ... grok

1614230534
marler8997
lol

1614230552
marler8997
you did the same thing to me when I was talking about comptime build options so now we're even

1614230573
mikdusan
dude you got a looooong memory dontcha ? :P

1614230592
marler8997
lol, actually I think my memory is pretty shit

1614230605
marler8997
I'm just laser focused at the moment

1614230616
marler8997
everyone's input on this has actually been very helpful

1614230639
marler8997
people have been bringing new and interesting ideas and we've really made some progress

1614230766
marler8997
I have this theory that I have a horrible memory, and I constantly have to relearn/revaluate everything I know. It makes me very detail oriented and I get lost if I don't understand everything.

1614230831
marler8997
normals don't seem to relate, maybe some fellow programmers feel the same way?

1614230840
daurnimator
marler8997: IMO a build/package system needs the following 'phases': `download` -> `unpack` -> `build` -> `package`

1614230858
mikdusan
so let's say pkgmgr is available as some kind of service, be it in another proc, same proc, whatever, run `zig build -Denable-androidstuff` and pkgmgr ready to intercept @import(),

1614230870
daurnimator
where the `download` step

1614230873
marler8997
daurnimator, you could be right, I'm not sure, but my example allows for that flow

1614230891
daurnimator
the `unpack` step (and all others) are

1614230906
daurnimator
the `build` step is where most configuring happens

1614230933
daurnimator
the `package` step should do nothing but `cp` from a temporary directory to the "installed" layout

1614230942
marler8997
it might be confusing because zig's build.zig doesn't actually just do the build step

1614230946
daurnimator
yeah

1614230962
daurnimator
but for each of those steps, what you can do should be limited

1614230969
daurnimator
e.g. in unpack step, no knowing the final locations

1614230987
daurnimator
in package, the only thing you can see is output of build step; no network; no source files.

1614230992
marler8997
daurnimator, like I said you could be right but I'd have to think about it

1614231053
marler8997
with my example, compiling and querying build.zig could all be done in the download setp

1614231066
mikdusan
daurnimator: some of today's processes are quite sophisticated for "building". and they necessarily include running a native binary.

1614231081
daurnimator
mikdusan: I think we should explicitly

1614231108
daurnimator
for zig, we should say that any code that needs to run at build time must be comptime

1614231142
mikdusan
to what end? if security is a concern, I ask you to consider the plethora of autotool shenanigans that are executed every single time for many package builds. and no one goes through them with a security comb

1614231145
marler8997
daurnimator, you're probably more familair with comptime restrictions, what benefit would be get by limiting build.zig to comptime?

1614231153
daurnimator
mikdusan: that's exactly why

1614231175
marler8997
give me an example of what we can't do at comptime

1614231187
marler8997
like touch the filesystem (aside from imports)

1614231189
mikdusan
and then we have qt which builds it's own compiler to compile some wacky interfaces

1614231190
daurnimator
mikdusan: to run a autotools based build I have to spin up a whole VM; its time consuming and awkward.

1614231226
marler8997
so you don't want build.zig to be able to read/process non-zig files to generate it's DAG?

1614231241
daurnimator
marler8997: sure it can, `@embedFile` is a thing

1614231250
marler8997
oh true

1614231253
marler8997
so what can't we do then?

1614231265
mikdusan
daurnimator: I think ruling out all builds that execute anything supplied by their sources would be huge

1614231277
mikdusan
huge as in the number of things that would not be supported

1614231282
daurnimator
marler8997: 1. can't reach the network. 2. can't read anything outside of build/src dir (e.g. my /etc/passwd file)

1614231305
marler8997
can't run subprocesses?

1614231332
daurnimator
marler8997: subprocesses should be from a predefined list (essentially only `zig build-*` commands)

1614231361
marler8997
yeah I definitely think that's worth consideration

1614231373
daurnimator
and then the `package` step able to create files in the passed destination directory/prefix

1614231412
marler8997
it makes the DAG more pure

1614231431
daurnimator
makes it parallelisable too

1614231455
marler8997
which is good, except if someone has a valid use case that doesn't allow this, would have to think if there is one

1614231477
daurnimator
I have a few in mind that I want to solve

1614231486
marler8997
like?

1614231487
daurnimator
e.g. for building a linux kernel module, I need to invoke the orc tool

1614231500
daurnimator
(orc is an alternative to dwarf)

1614231533
marler8997
but that doesn't require DAG modification right?

1614231540
marler8997
you can still run subprocesses during the actual build

1614231560
daurnimator
as I said above: I wanted a whitelist of subprocesses permitte

1614231576
marler8997
how do you restrict runtime like that?

1614231589
daurnimator
marler8997: what do you mean?

1614231609
marler8997
you have a custom build step to call the orc tool, how to you prevent it from calling anything else?

1614231613
mikdusan
I think these are policy decisions and build.zig/package_manager.zig features should make that policy an option or default, but shouldn't make it impossible to do more

1614231615
daurnimator
marler8997: you create the DAG, and each DAG step has an action in it, e.g. "run zig build-obj" or "run zig build-lib"

1614231647
marler8997
we're at runtime now, so anything is free to use the network/full filesystem/whatever

1614231668
daurnimator
marler8997: so I haven't figured this out yet, but I imagine you can add to the white list, so e.g. `zig build --allow-build-subprocess orc=/path/to/orc`

1614231700
marler8997
oh wait a second, does this pure Dag have no ability to add runtime code to it?

1614231710
daurnimator
marler8997: correct.

1614231712
marler8997
ah

1614231739
marler8997
so at no point can you pass a function to the Builder that gets executed at runtime, interesting

1614231747
daurnimator
yeah that's the idea

1614231762
mikdusan
set daurnimator.lockdown=true

1614231858
marler8997
It's an interesting idea.  You're sort of forcing people to make their build logic more correct

1614231873
daurnimator
we've got a blank-ish slate here... lets do it right

1614231893
marler8997
I'm still unsure whether it would be too restrictive

1614231933
g-w1
also it might be akward getting the output of cmds? how would you do it?

1614231935
marler8997
for your orc idea, would this whitelist be a list in the zig standard library?

1614231939
daurnimator
I think the most annoying thing would be that people have to write that whitelist every time: but that pain is intentional, its to force you to accept what the build system might run

1614231969
daurnimator
g-w1: we already have files passing from one step to another in build.zig, see .addArtifactArg I think it is?

1614231994
g-w1
getting the output of a cmd at comptime?

1614232037
daurnimator
g-w1: you don't: you can get the output of a command during build and have it written to a file; then you can pass that file to another command

1614232048
daurnimator
of course all commands would need to be on the whitelist

1614232069
marler8997
is this whitelist in the standard lib, or in the project's build.zig file?

1614232082
g-w1
ok, so like cmd("ls").pipe("file.txt") then read file.txt?

1614232084
daurnimator
marler8997: project's build.zig

1614232104
daurnimator
marler8997: or what do you mean?

1614232112
marler8997
yeah that's what I meant

1614232134
daurnimator
marler8997: the std libraries build.zig would have the default whitelist; then a build.zig would specify which (if any) additional commands it needs

1614232139
marler8997
daurnimator you don't have an example of what such a build.zig would look like do you?

1614232166
daurnimator
marler8997: uh, no different to what build.zig looks like today, except that build() would be called as `comptime build()`

1614232245
mikdusan
how do you define what is allowed on the project whitelist?

1614232273
daurnimator
mikdusan: I'm proposing that we would add it from the build special runner; and then check against it in RunStep

1614232328
mikdusan
but there has to be something that says "ls" or "/usr/bin/ls" is allowed

1614232381
daurnimator
mikdusan: `zig build --allow-build-subprocess ls=/usr/bin/ls`

1614232410
mikdusan
how about "cc"

1614232427
mikdusan
are we supposed to add each thing to command line? I must not be seeing something here

1614232451
g-w1
i think yes

1614232467
g-w1
maybe it could be cached?

1614232469
mikdusan
I have 10 different Xcode compilers on my system. and freely select between them.

1614232513
mikdusan
each Xcode toolchain has many executables. It's not unheard of in complex projects do use different versions of compilers to overcome stupid compiler bugs building the same executable

1614232534
daurnimator
mikdusan: in this scheme: yes you are. but... why would you be using `cc` and not zig's builtin supported `zig cc`

1614232667
mikdusan
today, and for the foreseeable future, `zig cc` is not going to get the job done for UI and ios/tvos/watchos apps

1614232731
mikdusan
It should be stated a closed build.zig would have the consequence of: "zig cc/c++" or bust.

1614232834
mikdusan
I mean maybe that's ok. But let's just be CLEAR about it so when issues open up it's straight to "not supported".

1614232929
marler8997
there can always be --ignore-whitelist

1614233066
mikdusan
to be clear, that would mean it

1614239048
daurnimator
mikdusan: do you need more than `cc`? in which case it might be `zig build --allow-build-subprocess cc=$(xcode some thing to get cc)`

1614240422
ifreund
andrewrk: woot! \o/

1614240595
ifreund
that diff on formatting src/ looks good

1614241229
ikskuh
hellau!

1614243234
marler8997
ikskuh have a look at the @tryImport example I put together:

1614243277
marler8997
I made the "optional dependency" "opt-in"

1614248535
ikskuh
marler8997: doesn't look too bad, even though im still opposed. no technical critique :D

1614268792
marler8997
ikskuh I'm all ears if you have alternative solutions :)

1614269212
ed_t
why does ...print("{s}",.{if (i>0) "a" else "b"}) not work?

1614269242
Gliptic
what does it tell you?

1614269276
ikskuh
marler8997: not sure yet

1614269297
fengb
ed_t: literals with logic are buggy

1614269302
marler8997
well if you get any ideas let me know and we can discuss

1614269305
ed_t
it compliles but always shows "a".  I looks like the test is ignored

1614269328
ikskuh
sure!

1614269334
ikskuh
ed_t: compiler bug

1614269338
ikskuh
just do

1614269347
ikskuh
var temp = if(i>0) ...

1614269353
marler8997
we spent a bunch of time on it yesterday and almost had a solution but it ultimately fell through and we still needed @tryImport

1614269355
ikskuh
print("{s}", .{temp})

1614269368
fengb


1614269389
ikskuh
marler8997: have you seen andrews proposal on using string literals instead of comptime strings for @import() ?

1614269468
ed_t
I figured the workaround would work, I just could not see why the if was not working.  compiler bug is an answer that makes sense

1614269487
ed_t
thanks guys

1614269494
ikskuh
"will be fixed in stage2" (tm)

1614269529
ed_t
I gather that means "eventually"

1614269569
ikskuh
yep

1614269575
ikskuh
in the rewrite of the zig compiler

1614269580
ed_t
<grin>

1614269664
ed_t
I have been playing with zig for a month now, and its making a lot of sense.

1614269689
fengb
Is there a way to create a tagged union with @Type?

1614269712
fengb
Doing `.layout = Auto, .tag_type = TagType` does not give me a usable tag :(

1614270123
fengb


1614270964
karchnu
Hello guys, the french translation is almost here \o/ I'm reading it one more time, checking for spelling mistakes and maybe a few rewordings.

1614271015
g-w1
fengb: ir.cpp:26806 and ir.cpp:26847 seems to get it. not sure why its not working

1614271101
fengb
It works if I forward an existing @typeInfo, but not when I try to build it manually

1614271132
g-w1
probably a subtle bug

1614271249
g-w1
i have some time, so ill try to debug

1614271327
ikskuh
karchnu: whooot? sweet!

1614271378
karchnu
ikskuh: thanks! ^^

1614271423
karchnu
Will try to push it in a few hours.

1614271437
ikskuh
a lot of languages already :)

1614271678
marler8997
ikskuh I'm not familiar with that proposal

1614271703
marler8997
was that something you think might help with this problem?

1614272249
g-w1
fengb: found the issue it checks the

1614272259
g-w1
lmao: if (decl_node->data.container_decl.auto_enum || decl_node->data.container_decl.init_arg_expr != nullptr) {

1614272279
g-w1
it should check the type, not the ast note XD. ive seen this bug b4 in stage2

1614272294
fengb
I wish I understood the compiler :/

1614272303
g-w1
ir.cpp:14138 check that out

1614272313
g-w1
the @Type works fine, its the switch thats the problem

1614272327
g-w1
ill try to fix

1614272872
g-w1
fengb: does this look good?

1614272884
g-w1
i feel like that is just some legacy code from when zig analyzed the ast

1614272982
g-w1
andrewrk: should it even check the ast now that we have an ir? ^^

1614273537
g-w1
i feel like that pattern of checking the ast is used a lot in stage1

1614274594
fengb
I don't know what I'm looking at >_>

1614274640
fengb
Worthwhile to add a test case though 🙃

1614274677
g-w1
basically from my understanding, to see if a type had a tag, it checked the ast where it came from instead of the actual type which only works when you dont use @Type

1614274851
fengb
Oh

1614275577
g-w1
fengb:

1614275835
fengb
:o thanks!

1614278826
ikskuh
<marler8997> was that something you think might help with this problem?

1614278847
ikskuh
yeah i think so. with this proposal you can scan for all

1614278871
marler8997
what do you mean by scan?

1614278877
ikskuh
"grep"

1614278888
marler8997
and can these

1614278892
ikskuh
as yep

1614278895
marler8997
i.e. can -Dandroid enable/disable an import?

1614278915
ikskuh
and in case of build.zig we could make the "build runner builder" (what) scan for all imports and pass in as comptime known values which imports are available

1614278943
marler8997
this doesn't seem possible, where's this proposal?

1614279019
ikskuh


1614279056
marler8997
just by the title I don't see how we can use logic inside Zig to enable/disable the @import

1614279058
marler8997
how would that work?

1614279079
ikskuh
tokenize build.zig and find all @import tokens

1614279096
marler8997
the problem isn't finding all possible imports

1614279103
ikskuh
let me continue, please :D

1614279104
ikskuh
now you know which packages are required

1614279111
marler8997
it's running the logic inside build.zig that tells us which ones it needs based on the command-line options

1614279132
marler8997
knowing all the @import tokens doesn't tell us which packages are required

1614279135
marler8997
look at the example I sent

1614279143
ikskuh
but allows us to know which are available ;)

1614279152
ikskuh
and we can then pass this information into build.zig

1614279158
g-w1
noam: if this is accepted then you could lex imports in parrallel ^^

1614279167
ikskuh
const available_build_packages = @import("build-deps");

1614279186
ikskuh
if(available_build_packages.bearssl) { } else { print("requires bearssl to be used!"); }

1614279201
marler8997
thinking...

1614279227
ikskuh
same as your proposal, but with existing language features :)

1614279233
marler8997
loading...buffering...

1614279260
ikskuh
andrewrk: can i convince you of @import(.std) ?

1614279275
g-w1
function overloading?

1614279289
marler8997
you might be onto something here

1614279317
marler8997
so let me make sure I have this right

1614279348
marler8997
before compiling build.zig, we scan it for all the imports it makes (we can limit it to package imports as that's the only ones I have a use case for)

1614279354
ikskuh
g-w1: it's a builtin. they are magic anyways

1614279382
marler8997
then we take those imports and create a module with comptime values for each import that indicates whether or not it has been included

1614279388
g-w1
they behave like functions though with the definition. maybe @importStd(); would be better

1614279408
ikskuh
g-w1: also @importRoot, @importSelf, @importPkg ?

1614279422
g-w1
actually nvm, it can just take anytype :)

1614279423
marler8997
this is actually functionally equivalent to @tryImport, it's just implemented through a dynamic module rather than supported in the general case

1614279440
marler8997
I find this solution acceptable

1614279446
marler8997
because it would work

1614279449
ikskuh
g-w1: builtins take AST nodes though ;)

1614279468
ikskuh
and it wouldn't make the the language more complex :)

1614279477
g-w1
yeah, its fine

1614279489
marler8997
we are making the build process quite a bit more compelx

1614279527
ikskuh
i'm going to break every build file soon anyways :D

1614279558
marler8997
although, I suppose my proposed solution isn't much better

1614279560
marler8997
yeah, I'm totally fine with this solution as well

1614279582
marler8997
if andrewrk, approves, then I'll be happy to make a PR for this

1614279598
ikskuh
we first need the issue implemented though :D

1614279613
marler8997
the "issue implemented"?

1614279621
g-w1
its pretty easy to impliment import taking a string literal

1614279622
ikskuh
#2206

1614279655
g-w1
i can do it in stage2

1614279701
marler8997
yeah that sounds easy

1614280547
marler8997
oh wait no, this mechanism still needs to print the needed packages back to the package manager

1614280554
marler8997
so it's just extra steps to do @tryImport

1614280622
marler8997
oh wait a second

1614280627
marler8997
we don't need to scan build.zig

1614280674
ikskuh
hm?

1614280696
marler8997
all we do is provide a function that takes a comptime string with the package name and it only returns true for the packages is has

1614280696
marler8997
So we don't even need #2206 to implement this!

1614280706
marler8997
I'm putting together a gist

1614280712
marler8997
link in a bit

1614280875
marler8997


1614280918
marler8997
should rename buildimports to buildpkgs, since this only works for packages

1614280927
g-w1
the solution is so simple, yet took so long to come to!

1614281041
marler8997
this stuff is so tricky for our humans brains to think about

1614281151
ikskuh
yep

1614281153
ikskuh
100% status quo

1614281154
ikskuh
sweet

1614281171
marler8997
thanks for the help ikskuh

1614281187
ikskuh
sure

1614281190
ikskuh
always!

1614281214
marler8997
everyone else as well, mikdusan, g-w1, ifruend, noam

1614281401
marler8997
ikskuh what are you working on that's going to break build.zig? (out of curiosity)

1614281427
ikskuh


1614281429
ikskuh
this one :)

1614281442
marler8997
oh right, I remember that one

1614281651
mikdusan
as build.zig becomes more feature rich I'm going to invest in ram because we're going to need it to hold the bloody error-stack :P

1614281684
fengb
Until stage2 lands right? 🙃

1614281700
ikskuh
mikdusan: can you explain?

1614281715
ikskuh
my changes make build.zig use less memory

1614281848
mikdusan
I'll try to drum up a case

1614281894
ikskuh
sure

1614284087
marler8997
noam what's ur github name?

1614284151
g-w1
its pixelherodev

1614284565
marler8997
here's the proposal of our design:

1614285269
g-w1
how does this test pass?

1614285269
g-w1
doesn't foo expect a pointer and a is a value?

1614285347
andrewrk
g-w1, the test harness for those only checks that the set of errors includes the listed ones

1614285372
andrewrk
probably the test harness should be more strict. I think it already is for stage2 tests

1614285482
g-w1
hmm, yeah I was very confused

1614285652
earnestly
Is there any example of zig using linux's drm/kms directly?

1614285687
marler8997
daurnimator, maybe we could try out your idea by supporting a comptimeBuild entry point

1614290819
braket
if I want to modify a struct instance passed into a function, I take it by pointer right?

1614290839
g-w1
yes

1614290933
braket
thanksss

1614291257
mikdusan1
andrewrk: when we emit cpu-features, is LLVM doing arm cpu feature detection or does zig have it's own code (asm?) to probe/detect?

1614291266
mikdusan1
specifically arm

1614291327
andrewrk
mikdusan1,

1614291361
andrewrk
mikdusan1, also

1614291405
mikdusan1
ah ok. thanks. I thought arm features looked barely baked

1614291503
andrewrk
arm cpu detection is ripe for contribution

1614292347
ed_t
should inline work for fn that return instances of structures?

1614292987
kbd
I'm struggling with some basic syntax. I want to make a list of tuples and then iterate over that. I'm converting this Nim code to Zig:

1614293017
kbd
I tried `var format = .{.{Color.green, "↑", Status.ahead}, ... }`, but I suppose that's not right, and `for (format) |f| {...}` to iterate over it, but that gives "error: unable to evaluate constant expression" on the for.

1614293033
g-w1
use inline for

1614293037
g-w1
because it is comptime

1614293096
kbd
oh, that works.

1614293098
kbd
Thanks!

1614293233
kbd
oh, here's why that didn't work in the main code. What do I do about a `continue` in the loop, which gives "error: comptime control flow inside runtime block" on the continue?

1614293320
g-w1
iirc thats a bug

1614293334
kbd
oh, good to know

1614293385
g-w1
might be this?

1614293407
kbd
It's this line, except in the Zig:

1614293425
kbd
I'll try to figure out how to write it differently.

1614293457
g-w1
you may be able to do a regular for if you make it an array of structs instead of tuples because that is runtime i think

1614293573
kbd
Is there any way to do destructuring in Zig, like what I did in the Nim? `for (color, token, code) in format:...`

1614293593
g-w1
no

1614293640
g-w1
the most you can do is add an enumeration with it `for (arr) |i, val| { }

1614293857
kbd
looks like converting it to structs worked! I always try to avoid bothering y'all but I never would have known that I was running into a bug vs something I was doing wrong, or that structs vs tuples would make it runtime vs comptime. Thanks again for your help.

1614293972
andrewrk
kbd, it's always ok to ask for help in here :) you just might not get an answer if people are distracted, or nobody knows the answer

1614294238
ed_t
Is there a roadmap for zig someplace?  not looking for date but rather milestones.

1614294293
mipri
there's

1614294299
ifreund
ed_t: you might be interested in this video:

1614294323
ed_t
thanks guys

1614294768
andrewrk
ed_t,

