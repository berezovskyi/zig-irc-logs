1610331414
andrewrk
is it possible to pass a wasm-allocated string to javascript? or does the js have to supply the buffer if you want this?

1610331509
fengb
You need to copy the bytes into the wasm memory

1610331521
fengb
Oh wait... the opposite

1610331531
fengb
Yeah you need to look it up

1610331701
fengb
Need to create a Uint8Array from wasm.memory.buffer, pointer, and length

1610331708
fengb


1610331722
fengb


1610331752
fengb
wasm = the module instance

1610331773
andrewrk
what does it looks like on the zig side/

1610331805
fengb
Returning a pointer and length

1610331823
fengb
Pointer is implicitly the offset to the memory buffer

1610331843
fengb
I have a dumb hack to kludge both into a f64

1610331858
fengb
Because JS doesn’t support u64 yet

1610331867
andrewrk
but how do you write the bytes into the buffer on the zig side

1610331918
fengb
Hmm, on the Zig side, you can return an allocated buffer or global buffer

1610331981
fengb
In fundude, I pass in the byte buffer from JS, but that’s manually allocated via a shim

1610332007
andrewrk
extern fn stderr(msg_ptr: [*]const u8, msg_len: usize) void;  this prints some integers to the console on the js side but there doesn't appear to be a way to access the wasm memory buffer

1610332029
fengb
Yeah that’s a raw pointer

1610332047
fengb
You need to fetch the wasm instance and grab the memory off it

1610332097
fengb
I remember having problems trying to reference the instance before it’s created hmmm

1610332176
andrewrk
I don't think the wasm instance has a memory property

1610332183
fengb
It does

1610332206
andrewrk
`memory` property is undefined

1610332228
andrewrk
oh there's extra stuff inside exports

1610332350
andrewrk
thanks

1610332366
fengb
np

1610333114
leeward
I have a construct that's not behaving the way I expect. Am I being an idiot, or is this a bug in Zig? `var on = false; while (true) { light(on); on = !on; delay(500) }`

1610333144
leeward
I expect this to alternate between on and off, but when I set a breakpoint inside the loop, the debugger tells me that on is always false.

1610333163
leeward
And when I look at the assembler output, I see nothing that suggests it's changing on's value.

1610333445
andrewrk
leeward, looks like the value gets changed to me:

1610335927
andrewrk
fengb, if you hit unreachable in a debug wasm build is there a way to find out which one it hit?

1610336129
andrewrk
oh snap chromium supports stack traces from webassembly

1610336653
leeward
andrewrk: Yeah, it works fine on my desktop too. This is on an msp430, and I'm still digging at it.

1610336740
andrewrk
leeward, I see an xor in there:

1610336792
leeward
Yeah, I don't in my actual code. It could be that my light function is doing something unexpected.

1610337269
leeward
ok, this is special: `const mask = ~(various() | functions()) & old;` and my debugger says old is 0x0. What's mask? 0x3b

1610338178
vesim
is the debug info generated by zig compiler valid?

1610338187
daurnimator
vesim: should be.

1610338204
leeward
Yep, I use it all the time.

1610338226
vesim
I tried to set breakpoint at codegen.c.genHeader and it is never hit, but the file was generated

1610338304
vesim
setting it at c.zig:394 doesnt work either

1610338315
vesim
or the -femit-h is using different code path? O_o

1610338319
leeward
And you're running stage2?

1610338363
vesim
yep

1610338392
leeward
head scratchy

1610338468
vesim
i built it using ./zig build -Dstage1=false and after that running it like this ./zig-cache/bin/zig test lib/std/child_process.zig -fno-emit-bin -femit-h=foo.h

1610338557
vesim
and also for me -fno-emit-bin is still hitting the linker, so i had to modify the allocateDeclIndexes function to do nothing for .elf, otherwise it was crashing the compiler

1610339385
leeward
Well, my problem was indeed something going on in the function.

1610339400
leeward
Not sure why it's doing what it's doing though.

1610340838
vesim
hmmm, is -femit-h even supossed to work? O_o

1610341554
leeward
oh, hey, I think it's not

1610341564
leeward
I vaguely remember something about that...

1610341628
leeward
It might be in release notes. I don't see it in bugs.

1610347051
mikdusan
does zig0 have any dependency-file generator?

1610362669
kbd
I didn't see `unsetenv` exposed within Zig stdlib. Is there a better way than @cImport(@cInclude("stdlib.h")).unsetenv()?

1610362733
ifreund
kbd: I believe andrewrk's stance is that setenv/unsetenv are inherently racy and don't belong in the zig std

1610362758
ifreund
though in single threaded programs they are totally fine IMO

1610362797
ifreund
intstead of using the cImport() you could also define the extern function manually:

1610362817
ifreund
extern unsetenv(name: [*:0]const u8) c_int;

1610362919
kbd
🤔

1610363170
kbd


1610363198
kbd
thanks ifreund!

1610364069
ifreund
heh, no problem

1610367457
daurnimator
kbd: why do you need unsetenv?

1610367494
daurnimator
I think only valid reason would be other libc-using things in-process that you want to have fail a `getenv`...

1610367530
kbd
a program called by my zig program looks for an env var, and I want to unset it.

1610367552
ifreund
you can modify the environment map passed to your child process

1610368532
kbd
ok switched to that. Bit more cumbersome in my case but it works:

1610368597
ifreund
Yeah, I'm also really not a fan of that API

1610368617
ifreund
still using setenv in river myself as I don't use childprocess

1610368663
ifreund
and I haven't had time to improve std.ChildProcess or relace it with something nicer yet

1610368719
mikdusan
"don't use childprocess" <-- what are you using?

1610368756
ifreund
fork and exec

1610368762
kbd
I'd still prefer unsetenv here, since it happens once at the beginning of the program and not in every call to `run` (+ getEnvMap, + .delete).

1610368790
mikdusan
execve ?

1610368794
ifreund
yes, that

1610368857
mikdusan
🍴💣

1610368871
ifreund
well, it's a little more complicated in one case as I double fork and do some cleanup to get the child process inherited by pid 1

1610369109
daurnimator
ifreund: but why? that's so 90s

1610369221
ifreund
river has a command that lets you run arbitrary programs. I don't want to need to wait(2) all of them

1610369238
ifreund
that's the job of pid 1

1610369424
daurnimator
I guess...

1610369643
ifreund
if there's some other way that's better I'd be open to it, but I don't know of any /shrug

1610370122
daurnimator
ifreund: more that I like my processes to.... be in a tree. if I started a program from river I usually would want it to stay in the tree under river

1610372080
xyproto
when calling a C library that expects a pointer to a struct, and has it's own "init" function, how can that be done from Zig? I have a failed attempt at finding the right type for gmp.mpz_init here:

1610372342
daurnimator
xyproto: mpz_init takes a pointer-to MP_INT

1610372489
daurnimator
xyproto: you're going to want to do: `var x: MP_INT = undefined; gmp.mpz_init(&x);`

1610372534
xyproto
daurnimator: thanks! I'll try that.

1610372536
daurnimator
and don't forget `defer gmp.mpz_clear(&x);`

1610372570
xyproto
cool, thanks. I'm trying to port the one benchmark program from the Benchmark Game where C is faster than Rust, to Zig, to compare the performance.

1610372605
xyproto
There are probably faster ways than using gmp, but I want to try that first.

1610372738
daurnimator
xyproto: go for it :)

1610372773
daurnimator
xyproto: your 2nd version could try zig std libraries built in bignum support. but it probably isn't as fast as gmp... but maybe it is

1610372991
xyproto
daurnimator: I'll compare them both, if I can make the gmp version work :)

1610373300
olabaz
Is there a way to redirect std.log.info to a file?

1610373343
daurnimator
olabaz: declare a `pub fn log` in your root file

1610373420
olabaz
hmm, and then what?

1610373465
daurnimator
write to the file you want?

1610373481
xyproto
then use the log function, where the body of the function writes to the file you want?

1610373499
daurnimator
olabaz: see the big doc-comment in std/log.zig

1610373716
olabaz
ok thanks I'll take a look

1610373886
daurnimator
xyproto: okay now I'm looking closer... which benchmark is this?

1610374055
xyproto
daurnimator: pidigits, here:

1610376329
daurnimator
xyproto:

1610376616
daurnimator
need to use a buffered stdout.... more time spent in printing than anything else :P

1610376787
olabaz
How can I check if an array is undefined?

1610376817
daurnimator
olabaz: you don't

1610377029
olabaz
daurnimator: hmm, what's the approach if I want to do something like: var input = read_line() catch undefined; if (input == undefined) { a();} else { b();}?

1610377066
daurnimator
olabaz: undefined isn't what you're looking for, try `null`

1610377479
daurnimator
xyproto:

1610377526
daurnimator
(I'm getting 0.5 seconds for gmp vs 2.5 seconds for pure-zig)

1610377737
olabaz
once I have checked that input != null, how can I change it from optional to its child type?

1610377797
daurnimator
olabaz: `if (optional) |not_optional|` or just `.?`

1610377885
olabaz
daurnimator: passing in input.? to a function I'm getting an error about acessing union field 'Pointer'  while field 'Optional' is set

1610377949
olabaz
oh wait nvm

1610377963
olabaz
I was freeing input instead of input.?

1610390503
olabaz
what is a `[]const []const u8`?

1610390609
justin_smith
a const slice of const slices of 8 bit unsigned values - eg. if you split stdin by lines where each line is a slice

1610390686
olabaz
ah ok makes sense

1610397066
marijnfs
I'm using a c-library with aio callbacks, but they are in callconv(.C). Is there a way to still use async there?

1610397224
andrewrk
marijnfs, no, C does not support zig's async calling convention

1610398557
marijnfs
:(

1610398568
marijnfs
yeah i figured, but is there maybe a pattern

1610398707
marijnfs
i guess i could hand over the resources in the c callback, into my own event loop

1610398714
marijnfs
there i can use async

1610398924
andrewrk
there is a pattern you can do

1610399015
andrewrk
you'll have your function suspend, put its frame pointer into some data structure, then in the callconv(.C) callback, you have it mark the frame pointer as "ready" in the data structure, then you wake up the event loop so that it gets looked at and the event loop calls resume

1610399036
andrewrk
zig's async/await semantics are extremely flexible, I promise you can accomplish what you want to

1610399344
marijnfs
ah that's cool

1610399360
marijnfs
yeah you can store the anyframe anywhere, seems very flexible

1610399370
marijnfs
it's hard for your brain though

1610399386
marijnfs
is my whole callstack stored in there or something?

1610399434
marijnfs
even loris said he didn't quite understand it fully, and he wrote the main tutorial:P

1610399733
fengb
I can grok the low levels of where the frame is and how the suspend/resume works, and the high level of awaiting for data

1610399744
fengb
My brain gets fried whenever I try connecting the two

1610399803
andrewrk
marijnfs, just the 1 call frame is stored in that function's frame

1610399819
andrewrk
but the callsite probably is storing the callee's frame in its own, and so on

1610399849
andrewrk
at every call site though, it is obvious where the frame memory is stored

1610400519
marijnfs
but how is the memory of all these frames handled

1610400563
andrewrk
marijnfs, pick any async function. where its local variables are stored is decided by the callsite

1610400587
andrewrk
if you do `var x = async foo();` then the frame of foo is stored in x

1610400602
marijnfs
and whats exactly in the frame

1610400644
marijnfs
return address and local variables/

1610400646
marijnfs
?

1610400847
andrewrk
local variables only

1610401500
marijnfs
that's actually not so complicated

1610401536
marijnfs
but also it needs to know where in the code to continue?

1610401547
marijnfs
or is that comptime

1610401625
andrewrk
yeah it stores that in there too, so that when you resume it, it goes to the correct place

1610401643
companion_cube
but can you suspend from a function inside?

1610401665
andrewrk
can you refrase that?

1610401669
andrewrk
*rephrase

1610401680
andrewrk
I don't understand the question

1610401681
companion_cube
as in, could a "frame" contain several stack frames, where the yield/suspend is from an inner function

1610401684
companion_cube
not the outer one

1610401724
andrewrk
calling an async function is a suspend point

1610401750
andrewrk
an async function suspends itself in order to call an async function. then when the function returns it resumes the callee

1610401773
companion_cube
hmm so by construction, each async function has its own separate frame?

1610401787
companion_cube
(psosibly allocated in a different place)

1610401808
marijnfs
i think this is the main confusion

1610402366
andrewrk
yes exactly

1610402381
andrewrk
this is also known as "stackless coroutines"

1610402407
companion_cube
interesting

1610402419
companion_cube
it's a bit more manual than stackfull ones, but also easier I guess

1610402964
andrewrk
they play more nicely with manual memory management

1610403012
companion_cube
and yet, I suppose it'd work well with a local allocator

1610403079
andrewrk
or a statically allocated global variable

1610403110
marijnfs


1610403119
marijnfs
this might be a good talk?

1610403554
companion_cube
andrewrk: personally I'd avoid ever using global variables…

1610403562
companion_cube
I imagine it's ok in embedded contexts

1610403668
marijnfs
i guess what you resume is always some code that simply ends, or some code that returns a value that goes into the await

1610403715
marijnfs
but you are free to put in the return what you want

1610403831
andrewrk
marijnfs, yes all those concepts apply to zig's async functions as well, with some asterisks here and there

1610405305
ugla
Is there a fixed-point Zig lib?

